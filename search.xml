<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/blog/2017/03/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>retrofit中的设计模式</title>
    <url>/blog/2020/06/retrofit-design-patern.html</url>
    <content><![CDATA[<p>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装.</p>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p1.webp" alt></p>
<p>一般网络请求框架做的工作如上图所示</p>
<ol>
<li>build request(API参数配置)</li>
<li>executor(这里可以有很多变体，比如有无队列，进出顺序，线程管理)</li>
<li>parse callback(解析数据，返回T给上层)</li>
</ol>
<p>retrofit所做的主要分为以下3部分：</p>
<ol>
<li>通过注解配置API参数,将resultful api拼接成真正的请求url</li>
<li><code>CallAdapter</code>(你可以把它理解成executor)，指定真正的网络请求</li>
<li><code>Converter</code>(解析数据并转换成T)</li>
</ol>
<h4 id="面向对象六大原则"><a href="#面向对象六大原则" class="headerlink" title="面向对象六大原则"></a>面向对象六大原则</h4><ul>
<li><p>单一职责原则(Single Responsibility Principle)——SRP</p>
<p>单一职责原则很好理解，就是一个类尽量只做一件事。</p>
</li>
<li><p>开闭原则(Open Close Principle)——OCP</p>
<p>开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。<br>即当需求发生改变的时候，我们需要对代码进行修改，这个时候我们应该尽量去扩展原来的代码，而不是去修改原来的代码，因为这样可能会引起更多的问题。</p>
</li>
<li><p>里式替换原则(Liskov Substitution Principle)——LSP</p>
<p>里式替换原则简单说来就是：所有引用基类的地方必须能够透明地使用其子类的对象。<br>里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能</p>
<p>里氏替换和开闭原则是比较相近的，通过里式替换来达到对扩展开放，对修改关闭的效果</p>
</li>
<li><p>依赖倒置原则(Dependence Inversion Principle)——DIP</p>
<p>这个原则从名字根本看不出什么意思。高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。简单的说就是尽量面向接口编程.</p>
<p>依赖倒置原则在java语言中的表现就是：模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。</p>
</li>
<li><p>接口隔离原则(InterfacesSergregation Principle)——ISP</p>
<p>接口隔离原则的定义是：客户端不应该依赖它不需要的接口；<br>一个类对另一个类的依赖应该建立在最小的接口上。接口最小化,过于臃肿的接口依据功能,可以将其拆分为多个接口</p>
<p>以上这些设计思想用英文的第一个字母可以组成SOLID ，满足这个5个原则的程序也被称为满足了SOLID准则。</p>
</li>
<li><p>迪米特原则(Law of Demeter)——LOD</p>
<p>迪米特原则也被称为最小知识原则，他的定义：一个对象应该对其他对象保持最小的了解。<br>因为类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大，所以这也是我们提倡的软件编程的总的原则：低耦合，高内聚。</p>
</li>
</ul>
<h4 id="retrofit中用到的设计模式"><a href="#retrofit中用到的设计模式" class="headerlink" title="retrofit中用到的设计模式"></a>retrofit中用到的设计模式</h4><ul>
<li><p>构造者模式(通过builder构建)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit =<span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(server1.url(<span class="string">"/"</span>))</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<p>1.良好的封装性，使用建造者模式可以使客户端不必知道产品内部细节，更加安全</p>
<p>2.链式调用 ，更加简洁，易懂</p>
</li>
<li><p>外观模式（门面模式）</p>
<p>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p>
<p>Retrofit给我们暴露的方法和类不多。核心类就是Retrofit，我们只管配置Retrofit，然后做请求。剩下的事情就跟上层无关了，只需要等待回调。这样大大降低了系统的耦合度。对于这种写法，我们叫外观模式(门面模式)。</p>
<p>几乎所有优秀的开源library都有一个门面。比如<code>Glide.with()</code> <code>ImageLoader.load()</code> 。有个门面方便记忆，学习成本低，利于推广品牌。 Retrofit的门面就是<code>retrofit.create()</code></p>
<p>优点：</p>
<p>1.对客户程序隐藏子系统细节，减少了客户对于子系统的藕合，能够拥抱变化</p>
<p>2.外观类对子系统的接口封装，使得系统更加易用。</p>
<p>缺点：</p>
<p>1.外观类接口膨胀。有时子系统过多，使得外观类API较多，一定程度上增加了用户使用成本</p>
<p>2.外观类没有遵循开闭原则，当业务变更时，可能需要直接修改外观类。</p>
</li>
</ul>
<ul>
<li><p>动态代理</p>
<p>代理模式即为其他对象提供一种代理以控制对这个对象的访问<br>再来说动态代理。以往的动态代理和静态代理使用的场景是类似的。都想在delegate调用方法前后做一些操作。如果我的代理类有很多方法，那我得额外写很多代码，所以这时候就引入了动态代理。<br>通过动态设置delegate，可以处理不同代理的不同方法<br>动态代理则利用反射机制在运行时创建代理类。<br>动态代理常被用于在真正的操作之前或之后做一些操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before invoke "</span>  + method.getName());</span><br><span class="line">        method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">"After invoke "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Retrofit里的动态代理比较巧妙。实际上它根本就没有delegate。因为这个方法没有真正的实现。使用动态代理，只是单纯的为了拿到这个method上所有的注解。所有的工作都是由proxy做了</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    validateServiceInterface(service);</span><br><span class="line">    <span class="keyword">return</span> (T)</span><br><span class="line">        Proxy.newProxyInstance(</span><br><span class="line">            service.getClassLoader(),</span><br><span class="line">            <span class="keyword">new</span> Class&lt;?&gt;[] &#123;service&#125;,</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">final</span> Object[] emptyArgs = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">                  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">                <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">                &#125;</span><br><span class="line">                args = args != <span class="keyword">null</span> ? args : emptyArgs;</span><br><span class="line">                <span class="keyword">return</span> platform.isDefaultMethod(method)</span><br><span class="line">                    ? platform.invokeDefaultMethod(method, service, proxy, args)</span><br><span class="line">                    : loadServiceMethod(method).invoke(args);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>装饰模式</p>
<p>装饰模式又称包装模式，即动态地给一个对象添加一些额外的职责。</p>
<p>装饰模式与代理模式的共同点在于增强功能，但是代理的特点是添加逻辑控制，而装饰则是动态地添加功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      Objects.requireNonNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;...&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>你可以将<code>ExecutorCallbackCall</code>当作是Wrapper，而真正去执行请求的源Source是<code>OkHttpCall</code>。之所以要有个Wrapper类，是希望在源Source操作时去做一些额外操作。这里的操作就是线程转换，将子线程切换到主线程上去。</p>
<p>enqueue()方法是异步的，也就是说，当你调用<code>OkHttpCall</code>的enqueue方法，回调的callback是在子线程中的，如果你希望在主线程接受回调，那需要通过Handler转换到主线程上去。<code>ExecutorCallbackCall</code>就是用来干这个事。当然以上是原生retrofit使用的切换线程方式。如果你用rxjava，那就不会用到这个<code>ExecutorCallbackCall</code>而是<code>RxJava</code>的Call了</p>
</li>
</ul>
<ul>
<li><p>适配器模式</p>
<p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起的两个类能够在一起工作(类似转接头)</p>
<p>再回来看看Retrofit，为什么我们需要转接头呢。那个被转换的是谁？我们看看<code>CallAdapter</code>的定义。<code>Adapts a {@link Call} into the type of {@code T}.</code> 这个Call是OkHttpCall，它不能被我们直接使用吗？被转换后要去实现什么特殊的功能吗？</p>
<p>我们假设下。一开始，retrofit只打算在android上使用，那就通过静态代理<code>ExecutorCallbackCall</code>来切换线程。但是后来发现rxjava挺好用啊，这样就不需要Handler来切换线程了嘛。想要实现，那得转换一下。将<code>OkHttpCall</code>转换成rxjava(<code>Scheduler</code>)的写法。再后来又支持了java8(<code>CompletableFuture</code>)。大概就是这样一个套路。</p>
<p>适配器模式就是，已经存在的<code>OkHttpCall</code>，要被不同的标准，平台来调用。设计了一个接口<code>CallAdapter</code>，让其他平台都是做不同的实现来转换，这样不花很大的代价就能再兼容一个平台</p>
</li>
<li><p>策略模式</p>
<p>策略模式定义了一系列算法，并将每一个算法封装起来，而且使他们还可以互相替换。策略模式让算法独立于使用它的客户而独立变化。</p>
<p>使用场景：</p>
<p>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- <span class="keyword">private</span> CallAdapter&lt;Observable&lt;?&gt;&gt; getCallAdapter(Type returnType, Scheduler scheduler) &#123;  </span><br><span class="line">  Type observableType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType) returnType);  </span><br><span class="line">  Class&lt;?&gt; rawObservableType = getRawType(observableType);</span><br><span class="line">  <span class="keyword">if</span> (rawObservableType == Response<span class="class">.<span class="keyword">class</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (!(observableType <span class="keyword">instanceof</span> ParameterizedType)) &#123;  </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Response must be parameterized"</span>     </span><br><span class="line">           + <span class="string">" as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;"</span>); </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">Type responseType=getParameterUpperBound(<span class="number">0</span>,(ParameterizedType)observableType);   </span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ResponseCallAdapter(responseType, scheduler);  </span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">if</span> (rawObservableType == Result<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(observableType <span class="keyword">instanceof</span> ParameterizedType))</span><br><span class="line">   &#123;      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Result must be parameterized"</span>     </span><br><span class="line">    + <span class="string">" as Result&lt;Foo&gt; or Result&lt;? extends Foo&gt;"</span>);    </span><br><span class="line">   &#125;    </span><br><span class="line">      Type responseType = getParameterUpperBound(<span class="number">0</span>, (ParameterizedType)observableType); </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultCallAdapter(responseType, scheduler);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SimpleCallAdapter(observableType, scheduler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>看看retrofit中的CallAdapter是如何确立的？</p>
<p>它是根据api方法声明的returnType来创建具体的<code>CallAdapter</code>实例的</p>
<p>根据不同的策略使用不同的算法，不同的returnType声明就是set不同的Strategy</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/bog2/p2.webp" alt></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客安装配置</title>
    <url>/blog/2017/04/hexo-learn-start.html</url>
    <content><![CDATA[<p><strong>Hexo博客安装配置总结</strong>              </p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul>
<li><p>安装Hexo          </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mkdir hexo  <span class="comment">#创建一个文件夹</span></span><br><span class="line">cd hexo</span><br><span class="line">npm <span class="keyword">install</span> -g hexo-cli</span><br><span class="line">npm <span class="keyword">install</span> hexo <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部署Hexo：在Git shell 中输入         </p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Hexo 插件：自动生成sitemap,Rss，部署到git等，建议安装      </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">index</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">archive</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-<span class="keyword">category</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-tag <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-<span class="keyword">server</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-heroku <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-rsync <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-openshift <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-marked@<span class="number">0.2</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-renderer-stylus@<span class="number">0.2</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-feed@<span class="number">1</span> <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap@<span class="number">1</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Hexo常用的几个命令"><a href="#Hexo常用的几个命令" class="headerlink" title="Hexo常用的几个命令"></a>Hexo常用的几个命令</h3><h4 id="创建新博文"><a href="#创建新博文" class="headerlink" title="创建新博文"></a>创建新博文</h4><p>执行new命令，生成指定名称的文章至hexo\source_posts\postName.md。<br><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type"></span>[layout] <span class="string">"postName"</span> <span class="meta">#新建文章</span></span><br></pre></td></tr></table></figure></p>
<h4 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<h4 id="生成静态站点文件"><a href="#生成静态站点文件" class="headerlink" title="生成静态站点文件"></a>生成静态站点文件</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure>
<h4 id="部署到Git"><a href="#部署到Git" class="headerlink" title="部署到Git"></a>部署到Git</h4><p>部署到Github前需要配置_config.yml文件</p>
<p>添加如下内容：<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">	<span class="attribute">type</span>: git</span><br><span class="line">	<span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:RicardoJiang/RicardoJiang.github.io.git</span><br><span class="line">	<span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>然后输入：<br><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>注意，在CMD中输入这个会报错，必须在git bash中输入。                   </p>
<h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cd</span> hexo目录</span><br><span class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<h4 id="应用Hexo主题"><a href="#应用Hexo主题" class="headerlink" title="应用Hexo主题"></a>应用Hexo主题</h4><p>在hexo目录下找到_config.yml配置文件，找到 theme 字段，并将其值更改为 next，如下所示：<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure></p>
<h4 id="添加标签tags页面"><a href="#添加标签tags页面" class="headerlink" title="添加标签tags页面"></a>添加标签tags页面</h4><p>定位到 Hexo 站点目录下，使用 hexo new page 新建一个页面，命名为 tags，布局格式为page：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ cd hexo目录</span><br><span class="line">$ hexo new<span class="built_in"> page </span>tags</span><br></pre></td></tr></table></figure></p>
<p>内容如下所示，如果要关闭tags页面的评论可以设置comments为false：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2014</span><span class="number">-12</span><span class="number">-22</span> <span class="number">12</span><span class="string">:39:04</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">"tags"</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p>
<p>这样以后tags页面在每次执行hexo generate后自动更新,注意要设置type为comments。</p>
<h4 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h4><p>你也可以更改代码高亮的主题，一共有五种，可选的值有 normal，night， night blue， night bright， night eighties，修改themes\next_config.yml文件，如下所示：<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">highlight_theme:</span> normal</span><br></pre></td></tr></table></figure></p>
<h4 id="一些常用主题设置"><a href="#一些常用主题设置" class="headerlink" title="一些常用主题设置"></a>一些常用主题设置</h4><p>添加介绍，Archive等标签<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure></p>
<p>首页只展示部分，不展示全文<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure></p>
<p>首页tab固定在顶部，样式修改<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">scheme:</span> Mist</span><br></pre></td></tr></table></figure></p>
<p>关闭侧边栏<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sidebar</span><br><span class="line">  <span class="keyword">display</span>: <span class="keyword">hide</span></span><br></pre></td></tr></table></figure></p>
<h4 id="统计访问量"><a href="#统计访问量" class="headerlink" title="统计访问量"></a>统计访问量</h4><p>可以在页面下方看到总的访问量与访问人数<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_pv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">page_pv_footer:</span></span><br></pre></td></tr></table></figure></p>
<h4 id="支持搜索"><a href="#支持搜索" class="headerlink" title="支持搜索"></a>支持搜索</h4><p>详情可见：<br><a href="https://www.cnblogs.com/fsong/p/11759136.html" target="_blank" rel="noopener">Hexo next主题添加站内搜索功能</a><br>我们在使用过程中可能会碰到搜索结果url host不对的问题，可以通过以下方法解决<br><a href="https://blog.csdn.net/ksws0292756/article/details/82714984" target="_blank" rel="noopener">hexo next主题 站内搜索出现异常，无法正常跳转，跳转时出现异常</a></p>
<h4 id="在新电脑上hexo-g生成空白的问题"><a href="#在新电脑上hexo-g生成空白的问题" class="headerlink" title="在新电脑上hexo g生成空白的问题"></a>在新电脑上hexo g生成空白的问题</h4><p>主要原因是node版本太高<br>详情可见：<a href="https://zhuanlan.zhihu.com/p/136552969" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/136552969</a></p>
<h4 id="next主题配置"><a href="#next主题配置" class="headerlink" title="next主题配置"></a>next主题配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># ========================= ATTENTION! ==========================</span></span><br><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># NexT repository is moving here: https://github.com/theme-next</span></span><br><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"><span class="comment"># It's rebase to v6.0.0 and future maintenance will resume there</span></span><br><span class="line"><span class="comment"># ===============================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Theme Core Configuration Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set to true, if you want to fully override the default configuration.</span></span><br><span class="line"><span class="comment"># Useful if you don't want to inherit the theme _config.yml configurations.</span></span><br><span class="line"><span class="attr">override:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To get or check favicons visit: https://realfavicongenerator.net</span></span><br><span class="line"><span class="comment"># Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"><span class="comment"># And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For example, you put your favicons into `hexo-site/source/images` directory.</span></span><br><span class="line"><span class="comment"># Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.</span></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set default keywords (Use a comma to separate)</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">"Hexo, NexT"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line"><span class="attr">rss:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup.</span></span><br><span class="line">  <span class="comment"># If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">user</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, will be used `author` from Hexo main config.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Any custom text can be defined here.</span></span><br><span class="line">  <span class="comment">#custom_text: Hosted by &lt;a target="_blank" href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.</span></span><br><span class="line"><span class="comment"># See: https://support.google.com/webmasters/answer/139066</span></span><br><span class="line"><span class="comment"># Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )</span></span><br><span class="line"><span class="attr">canonical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.</span></span><br><span class="line"><span class="attr">seo:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If true, will add site-subtitle to index page, added in main hexo config.</span></span><br><span class="line"><span class="comment"># subtitle: Subtitle</span></span><br><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target link.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Links.</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span></span><br><span class="line"><span class="comment">#social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">Links</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">block</span></span><br><span class="line"><span class="comment">#links_layout: inline</span></span><br><span class="line"><span class="comment">#links:</span></span><br><span class="line">  <span class="comment">#Title: http://example.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line"><span class="comment">#avatar: /images/avatar.gif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Table Of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># http://creativecommons.org/</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment">#creative_commons: by-nc-sa</span></span><br><span class="line"><span class="comment">#creative_commons:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display, available value (only for Muse | Mist):</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  Totally remove sidebar including sidebar toggle.</span></span><br><span class="line">  <span class="comment">#display: post</span></span><br><span class="line">  <span class="comment">#display: always</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">hide</span></span><br><span class="line">  <span class="comment">#display: remove</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Back to top in sidebar (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">b2t:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Post Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span></span><br><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically saving scroll position on each post/page in cookies.</span></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post meta display settings</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wechat Subscriber</span></span><br><span class="line"><span class="comment">#wechat_subscriber:</span></span><br><span class="line">  <span class="comment">#enabled: true</span></span><br><span class="line">  <span class="comment">#qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg</span></span><br><span class="line">  <span class="comment">#description: ex. subscribe to my blog by scanning my public wechat account</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reward</span></span><br><span class="line"><span class="comment">#reward_comment: Donate comment here</span></span><br><span class="line"><span class="comment">#wechatpay: /images/wechatpay.jpg</span></span><br><span class="line"><span class="comment">#alipay: /images/alipay.jpg</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">3.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/3.0/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Misc Theme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reduce padding / margin indents on devices with narrow width.</span></span><br><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Android Chrome header panel color ($black-deep).</span></span><br><span class="line"><span class="attr">android_chrome_color:</span> <span class="string">"#222"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Logo.</span></span><br><span class="line"><span class="comment"># !!Only available for Default Scheme currently.</span></span><br><span class="line"><span class="comment"># Options:</span></span><br><span class="line"><span class="comment">#   enabled: [true/false] - Replace with specific image</span></span><br><span class="line"><span class="comment">#   image: url-of-image   - Images's url</span></span><br><span class="line"><span class="attr">custom_logo:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">normal</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># - Find fonts on Google Fonts (https://www.google.com/fonts)</span></span><br><span class="line"><span class="comment"># - All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#     light, light italic, normal, normal italic, bold, bold italic</span></span><br><span class="line"><span class="comment"># - Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># - Introduce in 5.0.1</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># CAUTION! Safari Version 10.1.2 <span class="doctag">bug:</span> https://github.com/iissnan/hexo-theme-next/issues/1844</span></span><br><span class="line"><span class="comment"># To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host. E.g. //fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: xx`. Use `px` as unit.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used on &lt;body&gt; element.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Headlines (h1, h2, h3, h4, h5, h6).</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts.</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Logo.</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Services Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Han Support docs: https://hanzi.pro/</span></span><br><span class="line"><span class="attr">han:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Swiftype Search API Key</span></span><br><span class="line"><span class="comment">#swiftype_key:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Analytics ID</span></span><br><span class="line"><span class="comment">#baidu_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Duoshuo ShortName</span></span><br><span class="line"><span class="comment">#duoshuo_shortname:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">shortname:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hypercomments</span></span><br><span class="line"><span class="comment">#hypercomments_id:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># changyan</span></span><br><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appid:</span></span><br><span class="line">  <span class="attr">appkey:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Support for youyan comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from http://www.uyan.cc</span></span><br><span class="line"><span class="comment">#youyan_uid: your uid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Support for LiveRe comments system.</span></span><br><span class="line"><span class="comment"># You can get your uid from https://livere.com/insight/myCode (General web site)</span></span><br><span class="line"><span class="comment">#livere_uid: your uid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Gitment</span></span><br><span class="line"><span class="comment"># Introduction: https://imsun.net/posts/gitment-introduction/</span></span><br><span class="line"><span class="comment"># You can get your Github ID from https://api.github.com/users/&lt;Github username&gt;</span></span><br><span class="line"><span class="attr">gitment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">mint:</span> <span class="literal">true</span> <span class="comment"># RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Show comments count in post meta area</span></span><br><span class="line">  <span class="attr">lazy:</span> <span class="literal">false</span> <span class="comment"># Comments lazy loading with a button</span></span><br><span class="line">  <span class="attr">cleanly:</span> <span class="literal">false</span> <span class="comment"># Hide 'Powered by ...' on footer, and more</span></span><br><span class="line">  <span class="attr">language:</span> <span class="comment"># Force language, or auto switch by theme</span></span><br><span class="line">  <span class="attr">github_user:</span> <span class="comment"># MUST HAVE, Your Github ID</span></span><br><span class="line">  <span class="attr">github_repo:</span> <span class="comment"># MUST HAVE, The repo you use to store Gitment comments</span></span><br><span class="line">  <span class="attr">client_id:</span> <span class="comment"># MUST HAVE, Github client id for the Gitment</span></span><br><span class="line">  <span class="attr">client_secret:</span> <span class="comment"># EITHER this or proxy_gateway, Github access secret token for the Gitment</span></span><br><span class="line">  <span class="attr">proxy_gateway:</span> <span class="comment"># Address of api proxy, See: https://github.com/aimingoo/intersect</span></span><br><span class="line">  <span class="attr">redirect_protocol:</span> <span class="comment"># Protocol of redirect_uri with force_redirect_protocol when mint enabled</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Share</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    button | slide</span></span><br><span class="line"><span class="comment"># Warning: Baidu Share does not support https.</span></span><br><span class="line"><span class="comment">#baidushare:</span></span><br><span class="line"><span class="comment">##  type: button</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="comment"># This plugin is more useful in China, make sure you known how to use it.</span></span><br><span class="line"><span class="comment"># And you can find the use guide at official webiste: http://www.jiathis.com/.</span></span><br><span class="line"><span class="comment"># Warning: JiaThis does not support https.</span></span><br><span class="line"><span class="comment">#jiathis:</span></span><br><span class="line">  <span class="comment">##uid: Get this uid from http://www.jiathis.com/</span></span><br><span class="line"><span class="comment">#add_this_id:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="comment">#duoshuo_share: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NeedMoreShare2</span></span><br><span class="line"><span class="comment"># This plugin is a pure javascript sharing lib which is useful in China.</span></span><br><span class="line"><span class="comment"># See: https://github.com/revir/need-more-share2</span></span><br><span class="line"><span class="comment"># Also see: https://github.com/DzmVasileusky/needShareButton</span></span><br><span class="line"><span class="comment"># iconStyle: default | box</span></span><br><span class="line"><span class="comment"># boxForm: horizontal | vertical</span></span><br><span class="line"><span class="comment"># position: top / middle / bottom + Left / Center / Right</span></span><br><span class="line"><span class="comment"># networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,</span></span><br><span class="line"><span class="comment">#           Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,</span></span><br><span class="line"><span class="comment">#           Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,</span></span><br><span class="line"><span class="comment">#           Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailru</span></span><br><span class="line"><span class="attr">needmoreshare2:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">postbottom:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">iconStyle:</span> <span class="string">box</span></span><br><span class="line">      <span class="attr">boxForm:</span> <span class="string">horizontal</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">bottomCenter</span></span><br><span class="line">      <span class="attr">networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line">  <span class="attr">float:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="attr">iconStyle:</span> <span class="string">box</span></span><br><span class="line">      <span class="attr">boxForm:</span> <span class="string">horizontal</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">middleRight</span></span><br><span class="line">      <span class="attr">networks:</span> <span class="string">Weibo,Wechat,Douban,QQZone,Twitter,Facebook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters/</span></span><br><span class="line"><span class="comment">#google_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="comment">#google_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bing Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.bing.com/webmaster/</span></span><br><span class="line"><span class="comment">#bing_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yandex Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://webmaster.yandex.ru/</span></span><br><span class="line"><span class="comment">#yandex_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CNZZ count</span></span><br><span class="line"><span class="comment">#cnzz_siteid:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Insights</span></span><br><span class="line"><span class="comment"># See https://azure.microsoft.com/en-us/services/application-insights/</span></span><br><span class="line"><span class="comment"># application_insights:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make duoshuo show UA</span></span><br><span class="line"><span class="comment"># user_id must NOT be null when admin_enable is true!</span></span><br><span class="line"><span class="comment"># you can visit http://dev.duoshuo.com get duoshuo user id.</span></span><br><span class="line"><span class="attr">duoshuo_info:</span></span><br><span class="line">  <span class="attr">ua_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">admin_enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">user_id:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">#admin_nickname: Author</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post widgets &amp; FB/VK comments settings.</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Facebook SDK Support.</span></span><br><span class="line"><span class="comment"># https://github.com/iissnan/hexo-theme-next/pull/410</span></span><br><span class="line"><span class="attr">facebook_sdk:</span></span><br><span class="line">  <span class="attr">enable:</span>       <span class="literal">false</span></span><br><span class="line">  <span class="attr">app_id:</span>       <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">fb_admin:</span>     <span class="comment">#&lt;user_id&gt;</span></span><br><span class="line">  <span class="attr">like_button:</span>  <span class="comment">#true</span></span><br><span class="line">  <span class="attr">webmaster:</span>    <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Facebook comments plugin</span></span><br><span class="line"><span class="comment"># This plugin depends on Facebook SDK.</span></span><br><span class="line"><span class="comment"># If facebook_sdk.enable is false, Facebook comments plugin is unavailable.</span></span><br><span class="line"><span class="attr">facebook_comments_plugin:</span></span><br><span class="line">  <span class="attr">enable:</span>       <span class="literal">false</span></span><br><span class="line">  <span class="attr">num_of_posts:</span> <span class="number">10</span>    <span class="comment"># min posts num is 1</span></span><br><span class="line">  <span class="attr">width:</span>        <span class="number">100</span><span class="string">%</span>  <span class="comment"># default width is 550px</span></span><br><span class="line">  <span class="attr">scheme:</span>       <span class="string">light</span> <span class="comment"># default scheme is light (light or dark)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VKontakte API Support.</span></span><br><span class="line"><span class="comment"># To get your AppID visit https://vk.com/editapp?act=create</span></span><br><span class="line"><span class="attr">vkontakte_api:</span></span><br><span class="line">  <span class="attr">enable:</span>       <span class="literal">false</span></span><br><span class="line">  <span class="attr">app_id:</span>       <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">like:</span>         <span class="literal">true</span></span><br><span class="line">  <span class="attr">comments:</span>     <span class="literal">true</span></span><br><span class="line">  <span class="attr">num_of_posts:</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">id:</span>     <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">color:</span>  <span class="string">fc6423</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="comment">#&lt;app_key&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another tool to show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># visit https://console.firebase.google.com/u/0/ to get apiKey and projectId</span></span><br><span class="line"><span class="comment"># visit https://firebase.google.com/docs/firestore/ to get more information about firestore</span></span><br><span class="line"><span class="attr">firestore:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">collection:</span> <span class="string">articles</span> <span class="comment">#required, a string collection name to access firestore database</span></span><br><span class="line">  <span class="attr">apiKey:</span> <span class="comment">#required</span></span><br><span class="line">  <span class="attr">projectId:</span> <span class="comment">#required</span></span><br><span class="line">  <span class="attr">bluebird:</span> <span class="literal">false</span> <span class="comment">#enable this if you want to include bluebird 3.5.1(core version) Promise polyfill</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line">  <span class="attr">site_uv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_uv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-user"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_uv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line">  <span class="attr">site_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">site_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-eye"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">site_pv_footer:</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line">  <span class="attr">page_pv:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page_pv_header:</span> <span class="string">&lt;i</span> <span class="string">class="fa</span> <span class="string">fa-file-o"&gt;&lt;/i&gt;</span></span><br><span class="line">  <span class="attr">page_pv_footer:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tencent analytics ID</span></span><br><span class="line"><span class="comment"># tencent_analytics:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tencent MTA ID</span></span><br><span class="line"><span class="comment"># tencent_mta:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Calendar</span></span><br><span class="line"><span class="comment"># Share your recent schedule to others via calendar page</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># API Documentation:</span></span><br><span class="line"><span class="comment"># https://developers.google.com/google-apps/calendar/v3/reference/events/list</span></span><br><span class="line"><span class="attr">calendar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">calendar_id:</span> <span class="string">&lt;required&gt;</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">&lt;required&gt;</span></span><br><span class="line">  <span class="attr">orderBy:</span> <span class="string">startTime</span></span><br><span class="line">  <span class="attr">offsetMax:</span> <span class="number">24</span></span><br><span class="line">  <span class="attr">offsetMin:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">timeZone:</span></span><br><span class="line">  <span class="attr">showDeleted:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">singleEvents:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">maxResults:</span> <span class="number">250</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Algolia Search</span></span><br><span class="line"><span class="attr">algolia_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hits:</span></span><br><span class="line">    <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">input_placeholder:</span> <span class="string">Search</span> <span class="string">for</span> <span class="string">Posts</span></span><br><span class="line">    <span class="attr">hits_empty:</span> <span class="string">"We didn't find any results for the search: $&#123;query&#125;"</span></span><br><span class="line">    <span class="attr">hits_stats:</span> <span class="string">"$&#123;hits&#125; results found in $&#123;time&#125; ms"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Tags Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># External URL with BASE64 encrypt &amp; decrypt.</span></span><br><span class="line"><span class="comment"># Usage: &#123;% exturl text url "title" %&#125;</span></span><br><span class="line"><span class="comment"># Alias: &#123;% extlink text url "title" %&#125;</span></span><br><span class="line"><span class="attr">exturl:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note tag (bs-callout).</span></span><br><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Label tag.</span></span><br><span class="line"><span class="attr">label:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tabs tag.</span></span><br><span class="line"><span class="attr">tabs:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">labels:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#! DO NOT EDIT THE FOLLOWING SETTINGS</span></span><br><span class="line"><span class="comment">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use velocity to animate everything.</span></span><br><span class="line"><span class="attr">motion:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">async:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span></span><br><span class="line">    <span class="comment"># Transition variants:</span></span><br><span class="line">    <span class="comment"># fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut</span></span><br><span class="line">    <span class="comment"># swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut</span></span><br><span class="line">    <span class="comment"># bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut</span></span><br><span class="line">    <span class="comment"># slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut</span></span><br><span class="line">    <span class="comment"># slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut</span></span><br><span class="line">    <span class="comment"># perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut</span></span><br><span class="line">    <span class="attr">post_block:</span> <span class="string">fadeIn</span></span><br><span class="line">    <span class="attr">post_header:</span> <span class="string">slideDownIn</span></span><br><span class="line">    <span class="attr">post_body:</span> <span class="string">slideDownIn</span></span><br><span class="line">    <span class="attr">coll_header:</span> <span class="string">slideLeftIn</span></span><br><span class="line">    <span class="comment"># Only for Pisces | Gemini.</span></span><br><span class="line">    <span class="attr">sidebar:</span> <span class="string">slideUpIn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fancybox</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-minimal</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># three_waves</span></span><br><span class="line"><span class="attr">three_waves:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_lines</span></span><br><span class="line"><span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># canvas_sphere</span></span><br><span class="line"><span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Only fit scheme Pisces</span></span><br><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="comment"># size: The width of the ribbon.</span></span><br><span class="line"><span class="comment"># alpha: The transparency of the ribbon.</span></span><br><span class="line"><span class="comment"># zIndex: The display level of the ribbon.</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Script Vendors.</span></span><br><span class="line"><span class="comment"># Set a CDN address for the vendor you want to customize.</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment">#    jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js</span></span><br><span class="line"><span class="comment"># Be aware that you should use the same version as internal ones to avoid potential problems.</span></span><br><span class="line"><span class="comment"># Please use the https protocol of CDN files when you enable https on your site.</span></span><br><span class="line"><span class="attr">vendors:</span></span><br><span class="line">  <span class="comment"># Internal path prefix. Please do not edit it.</span></span><br><span class="line">  <span class="attr">_internal:</span> <span class="string">lib</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 2.1.3</span></span><br><span class="line">  <span class="attr">jquery:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 2.1.5</span></span><br><span class="line">  <span class="comment"># See: http://fancyapps.com/fancybox/</span></span><br><span class="line">  <span class="attr">fancybox:</span></span><br><span class="line">  <span class="attr">fancybox_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.6</span></span><br><span class="line">  <span class="comment"># See: https://github.com/ftlabs/fastclick</span></span><br><span class="line">  <span class="attr">fastclick:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.9.7</span></span><br><span class="line">  <span class="comment"># See: https://github.com/tuupola/jquery_lazyload</span></span><br><span class="line">  <span class="attr">lazyload:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line">  <span class="attr">velocity:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.2.1</span></span><br><span class="line">  <span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line">  <span class="attr">velocity_ui:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 0.7.9</span></span><br><span class="line">  <span class="comment"># See: https://faisalman.github.io/ua-parser-js/</span></span><br><span class="line">  <span class="attr">ua_parser:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 4.6.2</span></span><br><span class="line">  <span class="comment"># See: http://fontawesome.io/</span></span><br><span class="line">  <span class="attr">fontawesome:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1</span></span><br><span class="line">  <span class="comment"># https://www.algolia.com</span></span><br><span class="line">  <span class="attr">algolia_instant_js:</span></span><br><span class="line">  <span class="attr">algolia_instant_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.2</span></span><br><span class="line">  <span class="comment"># See: https://github.com/HubSpot/pace</span></span><br><span class="line">  <span class="comment"># Or use direct links below:</span></span><br><span class="line">  <span class="comment"># pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line">  <span class="comment"># pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line">  <span class="attr">pace:</span></span><br><span class="line">  <span class="attr">pace_css:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># https://github.com/hustcc/canvas-nest.js</span></span><br><span class="line">  <span class="attr">canvas_nest:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three</span></span><br><span class="line">  <span class="attr">three:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/three_waves</span></span><br><span class="line">  <span class="attr">three_waves:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/canvas_lines</span></span><br><span class="line">  <span class="attr">canvas_lines:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># three_waves</span></span><br><span class="line">  <span class="comment"># https://github.com/jjandxa/canvas_sphere</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">  <span class="comment"># https://github.com/zproo/canvas-ribbon</span></span><br><span class="line">  <span class="attr">canvas_ribbon:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Internal version: 3.3.0</span></span><br><span class="line">  <span class="comment"># https://github.com/ethantw/Han</span></span><br><span class="line">  <span class="attr">han:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># needMoreShare2</span></span><br><span class="line">  <span class="comment"># https://github.com/revir/need-more-share2</span></span><br><span class="line">  <span class="attr">needMoreShare2:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assets</span></span><br><span class="line"><span class="attr">css:</span> <span class="string">css</span></span><br><span class="line"><span class="attr">js:</span> <span class="string">js</span></span><br><span class="line"><span class="attr">images:</span> <span class="string">images</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme version</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">5.1</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://www.ezlippi.com//blog/2016/02/jekyll-to-hexo.html" target="_blank" rel="noopener">Jekyll迁移到Hexo搭建个人博客</a><br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next主题配置</a></p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】取代Android的LiveData:StateFlow还是SharedFlow？</title>
    <url>/blog/2020/12/translate-substituing-liveData.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>原标题: Substituting Android’s LiveData: StateFlow or SharedFlow?<br>原文地址: <a href="https://proandroiddev.com/should-we-choose-kotlins-stateflow-or-sharedflow-to-substitute-for-android-s-livedata-2d69f2bd6fa5" target="_blank" rel="noopener">Substituting Android’s LiveData: StateFlow or SharedFlow?</a><br>原文作者：Patrick Steiger</p>
</blockquote>
<p>Kotlin Coroutines最近推出了两种Flow类型，SharedFlow和StateFlow，Android社区开始考虑使用用这些新类型去替代LiveData的可能性。<br>这样做的两个主要原因是：    </p>
<ul>
<li>1.LiveData与UI紧密绑定（没有自然的方式将工作卸载到工作线程）    </li>
<li>2.LiveData与Android平台紧密绑定。    </li>
</ul>
<p>我们可以从这两个事实得出结论，就Clean Architecture而言，尽管LiveData在展示层上运行良好，但它并不能很好地集成到域层中，后者应该独立于平台（意味着一个纯粹的Kotlin / Java模块）；   而且它也不太适合数据层（存储库实现和数据源），因为我们通常应该将数据访问工作分担给工作线程。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.png" alt><br>但是，我们不能仅用纯Flow代替LiveData。使用纯Flow作为LiveData替代品的主要问题是：   </p>
<ul>
<li>1.Flow是无状态的（并且不能通过.value访问）。</li>
<li>2.Flow是声明性的,一个Flow Builder仅描述Flow是什么，并且仅在收集时才具体化。 并且将为每个收集器有效地实例化新的Flow，这意味着将为每个收集器冗余且重复地运行上游昂贵的数据库访问。</li>
<li>3.Flow本身对Android生命周期一无所知，并且不会在Android生命周期状态发生变化时自动暂停和恢复收集器。</li>
</ul>
<blockquote>
<p>这些不应被视为Flow固有缺陷：这些只是使其无法很好地替代LiveData，而在其他情况下却可能很实用。</p>
</blockquote>
<p>对于（3），我们已经可以使用LifecycleCoroutineScope扩展（例如launchWhenStarted）来启动协程以收集我们的flows-这些收集器将自动暂停并与组件的Lifecycle同步恢复。  </p>
<blockquote>
<p>注意：在本文中，我们将收集和观察用作同义词概念。 收集是Kotlin Flows（我们收集一个Flow）的首选术语，观察是Android LiveData（我们观察一个LiveData）的首选术语。  </p>
</blockquote>
<p>但是关于（1）访问当前状态，（2）对于N&gt; = 1个收集器仅实现一次，而对于0个收集器则消失，我们该如何实现呢？</p>
<p>现在，SharedFlow和StateFlow为这两个问题提供了解决方案。     </p>
<h2 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h2><p>我们举一个例子。我们的用例正在获取附近的位置。我们假设将Firebase实时数据库与GeoFire库一起使用，该库允许查询附近的位置。   </p>
<h3 id="使用LiveData端到端"><a href="#使用LiveData端到端" class="headerlink" title="使用LiveData端到端"></a>使用LiveData端到端</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p2.png" alt></p>
<p>让我们首先展示从数据源一直到视图的LiveData用法。<br>数据源负责通过GeoQuery连接到Firebase实时数据库。<br>当我们收到onGeoQueryReady或onGeoQueryError时，将使用自上一个onGeoQueryReady以来输入，退出或移动的位置的总和来更新LiveData值。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Listener for receiving GeoLocations</span></span><br><span class="line">    <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">            map[key] = location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">            map.remove(key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">            map[key] = location</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _locations.value = State.Ready(map.toMap())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">            _locations.value = State.Error(map.toMap(), e.toException())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Listen for changes only while observed</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _locations = <span class="keyword">object</span> : MutableLiveData&lt;State&gt;() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActive</span><span class="params">()</span></span> &#123;</span><br><span class="line">            geoQuery.addGeoQueryEventListener(listener)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onInactive</span><span class="params">()</span></span> &#123;</span><br><span class="line">            geoQuery.removeGeoQueryEventListener(listener)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Expose read-only LiveData</span></span><br><span class="line">    <span class="keyword">val</span> locations: LiveData&lt;State&gt; <span class="keyword">by</span> <span class="keyword">this</span>::_locations</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们的Repository，ViewModel和Activity应该很简单：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersRepository</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    nearbyUsersDataSource: NearbyUsersDataSource</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> locations <span class="keyword">get</span>() = nearbyUsersDataSource.locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersViewModel</span> <span class="meta">@ViewModelInject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    nearbyUsersRepository: NearbyUsersRepository</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations <span class="keyword">get</span>() = nearbyUsersRepository.locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        viewModel.locations.observe(<span class="keyword">this</span>) &#123; state: State -&gt;</span><br><span class="line">            <span class="comment">// Update views with the data.   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在您决定使包含存储库接口的域层（独立于平台）之前，这种尝试可能不错。 同样，一旦需要将工作分担到数据源上的工作线程上，您将发现LiveData没有简单，惯用的方法。</p>
<h3 id="在数据源和Repository上使用Flow"><a href="#在数据源和Repository上使用Flow" class="headerlink" title="在数据源和Repository上使用Flow"></a>在数据源和Repository上使用Flow</h3><p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p3.png" alt><br>让我们将数据源转换为使用Flow。 我们有一个Flow生成器callbackFlow，它将回调转换为Flow。<br>收集此Flow后，它将运行传递给Flow构建器的代码块，添加GeoQuery侦听器并到达awaitClose，在该处暂停直到Flow被关闭（即直到没有人收集或因为异常被取消为止).<br>关闭时，它将删除监听器，并且Flow将取消实现。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> GeoQuery.<span class="title">asFlow</span><span class="params">()</span></span> = callbackFlow &#123;</span><br><span class="line">        <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">            <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                map.remove(key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">                emit(State.Ready(locations.toMap()))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                emit(State.Error(map.toMap(), e.toException()))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addGeoQueryEventListener(listener)</span><br><span class="line">        </span><br><span class="line">        awaitClose &#123; removeGeoQueryEventListener(listener) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations: Flow&lt;State&gt; = geoQuery.asFlow()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们的Repository和ViewModel不做任何更改，但是我们的Activity现在接收到Flow而不是LiveData，因此它需要进行调整：我们将收集Flow而不是观察LiveData。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        lifecycleScope.launchWhenStarted &#123;</span><br><span class="line">            viewModel.locations.collect &#123;</span><br><span class="line">                <span class="comment">// Update views with the data.   </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们使用launchWhenStarted {}来收集Flow，因此协程仅在Activity达到onStart（）生命周期状态时才自动启动，而当它达到onStop（）生命周期状态时将自动暂停。 这类似于LiveData给我们的生命周期自动处理。 </p>
<blockquote>
<p>注意：您可以选择在展示层中继续使用LiveData。 在这种情况下，您可以使用Flow <t>.asLiveData扩展函数轻松地在ViewModel中将Flow从Flow转换为LiveData。<br>这个决定将带来后果，我们将继续进行讨论，并且将证明端到端使用SharedFlow和StateFlow更加通用，并且可能更适合您的体系结构。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p4.png" alt>  </t></p>
</blockquote>
<h3 id="在View层中使用Flow有什么问题？"><a href="#在View层中使用Flow有什么问题？" class="headerlink" title="在View层中使用Flow有什么问题？"></a>在View层中使用Flow有什么问题？</h3><p>这种方法的第一个问题是生命周期的处理，LiveData会自动为我们处理。 在上面的示例中，我们通过使用launchWhenStarted {}实现了类似的行为。    </p>
<p>但是还有另一个问题：由于Flow是声明性的，并且仅在收集时运行（实例化），因此，如果我们有多个收集器，则将为每个收集器运行一个新的Flow，彼此完全独立。<br>根据完成的操作（例如数据库或网络操作），这可能会非常无效。<br>如果我们期望操作只进行一次以确保正确性，则甚至可能导致错误的状态。<br>在我们的实际示例中，我们将为每个收集器添加一个新的GeoQuery监听器-可能不是关键问题，但肯定会浪费内存和CPU周期。   </p>
<blockquote>
<p>注意：如果通过在ViewModel中使用Flow <t> .asLiveData（）将存储库流转换为LiveData，则LiveData将成为Flow的唯一收集器，无论展示层中有多少观察者，都将只有一个Flow 集。<br>但是，为了使该架构正常工作，您需要确保自己的所有其他组件都可以从ViewModel访问LiveData，而绝不能直接从存储库访问Flow。<br>这可能是一个挑战，具体取决于应用程序的分离程度：所有需要存储库的组件现在都将依赖Activity实例来获取ViewModel实例，以及这些组件的范围 需要相应地加以限制。</t></p>
</blockquote>
<p>无论我们在View层中有多少个收集器，我们都只需要一个GeoQuery监听器。 我们可以通过共享所有收集器之间的流来实现此目的。     </p>
<h3 id="SharedFlow"><a href="#SharedFlow" class="headerlink" title="SharedFlow"></a>SharedFlow</h3><p>SharedFlow是一种流，它允许在多个收集器之间共享自己，因此对于所有同时收集器，只有一个流有效地运行（实现）。<br>如果定义访问数据库的SharedFlow并且由多个收集器收集，则数据库访问将仅运行一次，并且所得到的数据将共享给所有收集器。    </p>
<p>StateFlow也可以用于实现相同的行为：它是具有.value（其当前状态）和特定SharedFlow配置（约束）的专用SharedFlow。 稍后我们将讨论这些限制。<br>我们有一个运算符，用于将任何Flow转换为SharedFlow<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">shareIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scope: <span class="type">CoroutineScope</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    started: <span class="type">SharingStarted</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    replay: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: SharedFlow&lt;T&gt; (source)</span><br></pre></td></tr></table></figure></p>
<p>让我们将其应用于我们的数据源。     </p>
<p>scope是完成实现该流程的所有计算的地方。<br>由于我们的数据源是@Singleton，因此我们可以使用应用程序进程的LifecycleScope，它是一个LifecycleCoroutineScope，它是在进程创建时创建的，仅在进程销毁时才销毁。    </p>
<p>对于started参数，我们可以使用SharingStarted.WhileSubscribed（），这使Flow仅在订阅者数量从0变为1时才开始共享（实现），并在订阅者数量从1变为0时停止共享。     与我们之前通过在onActive（）回调中添加GeoQuery侦听器并在onInactive（）回调中删除侦听器实现的LiveData行为类似。      我们还可以将其配置为立即启动（立即实现，而不再取消实现）或懒启动（在首次收集时实现，而从未取消实现），但是我们希望它在下游不再收集时停止上游数据库的收集。    </p>
<blockquote>
<p>关于术语的注意事项：正如我们将术语“观察者”用于LiveData，将“收集器”用于Flow一样，我们将术语“订阅”用于SharedFlow。</p>
</blockquote>
<p>对于replay参数,我们可以设置为1，新订阅者将在订阅时立即获得最后发出的值。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersDataSource</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Ideally, those should be constructor-injected.</span></span><br><span class="line">    <span class="keyword">val</span> geoFire = GeoFire(FirebaseDatabase.getInstance().getReference(<span class="string">"geofire"</span>))</span><br><span class="line">    <span class="keyword">val</span> geoLocation = GeoLocation(<span class="number">0.0</span>, <span class="number">0.0</span>)</span><br><span class="line">    <span class="keyword">val</span> radius = <span class="number">100.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> geoQuery = geoFire.queryAtLocation(geoLocation, radius)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> GeoQuery.<span class="title">asFlow</span><span class="params">()</span></span> = callbackFlow &#123;</span><br><span class="line">        <span class="keyword">val</span> listener: GeoQueryEventListener = <span class="keyword">object</span> : GeoQueryEventListener &#123;</span><br><span class="line">            <span class="keyword">val</span> map = mutableMapOf&lt;Key, GeoLocation&gt;()</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyEntered</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyExited</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">                map.remove(key)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onKeyMoved</span><span class="params">(key: <span class="type">String</span>, location: <span class="type">GeoLocation</span>)</span></span> &#123;</span><br><span class="line">                map[key] = location</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryReady</span><span class="params">()</span></span> &#123;</span><br><span class="line">                emit(State.Ready(map.toMap())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGeoQueryError</span><span class="params">(e: <span class="type">DatabaseError</span>)</span></span> &#123;</span><br><span class="line">                emit(State.Error(map.toMap(), e.toException())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        addGeoQueryEventListener(listener)</span><br><span class="line">        </span><br><span class="line">        awaitClose &#123; removeGeoQueryEventListener(listener) &#125;</span><br><span class="line">    &#125;.shareIn(</span><br><span class="line">         ProcessLifecycleOwner.<span class="keyword">get</span>().lifecycleScope,</span><br><span class="line">         SharingStarted.WhileSubscribed(),</span><br><span class="line">         <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locations: Flow&lt;State&gt; = geoQuery.asFlow()</span><br><span class="line">                     </span><br><span class="line">    <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span></span>(<span class="keyword">open</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;) &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Ready</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;</span><br><span class="line">        ) : State(value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span></span>(</span><br><span class="line">            <span class="keyword">override</span> <span class="keyword">val</span> value: Map&lt;Key, GeoLocation&gt;,</span><br><span class="line">            <span class="keyword">val</span> exception: Exception</span><br><span class="line">        ) : State(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将SharedFlow本身视为Flow收集器可能会有所帮助，它会将上游的冷流变为热流，并在下游的许多收集器之间共享收集的值。 在冷的上游水流和多个下游收集器之间的中间位置有一个人。  </p>
<p>现在，我们可能会以为Activity不需要调整。<br>错误！ 有一个陷阱：在使用launchWhenStarted {}启动的协程中收集流时，协程将在onStop（）上暂停，并在onStart（）上恢复，但仍将订阅该流。<br>对于MutableSharedFlow <t>，这意味着MutableSharedFlow <t> .subscriptionCount对于暂停的协程不会更改。 为了利用SharingStarted.WhileSubscribed（）的功能，我们实际上需要在onStop（）上退订，然后在onStart（）上再次订阅。 这意味着取消收集协程并重新创建它。</t></t></p>
<p>让我们为此目的创建一个类：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PublishedApi</span></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverImpl</span>&lt;<span class="type">T</span>&gt; </span>(</span><br><span class="line">    lifecycleOwner: LifecycleOwner,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> flow: Flow&lt;T&gt;,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> collector: <span class="keyword">suspend</span> (T) -&gt; <span class="built_in">Unit</span></span><br><span class="line">) : DefaultLifecycleObserver &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> job: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        job = owner.lifecycleScope.launch &#123;</span><br><span class="line">            flow.collect &#123;</span><br><span class="line">                collector(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">(owner: <span class="type">LifecycleOwner</span>)</span></span> &#123;</span><br><span class="line">        job?.cancel()</span><br><span class="line">        job = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        lifecycleOwner.lifecycle.addObserver(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">observe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">noinline</span> collector: <span class="type">suspend</span> (<span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ObserverImpl(lifecycleOwner, <span class="keyword">this</span>, collector)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">observeIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    ObserverImpl(lifecycleOwner, <span class="keyword">this</span>, &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们可以调整Activity以使用刚刚创建的.observeIn（LifecycleOwner）扩展功能：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AndroidEntryPoint</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NearbyUsersActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: NearbyUsersViewModel <span class="keyword">by</span> viewModels()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        viewModel</span><br><span class="line">            .locations</span><br><span class="line">            .onEach &#123; <span class="comment">/* new locations received */</span> &#125;</span><br><span class="line">            .observeIn(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当LifecycleOwner的生命周期达到CREATED状态（恰好在onStop（）调用之前）时，使用observeIn（LifecycleOwner）创建的收集器协程将被销毁，并且一旦达到STARTED状态（在onStart（）调用之后）将被重新创建。</p>
<blockquote>
<p>注意：为什么是CREATED状态？ 不应该是STOPED状态吗？ 乍一看听起来有点违反直觉，但确实很合理。 Lifecycle.State仅具有以下状态：CREATED, DESTROYED, INITIALIZED, RESUMED, STARTED。<br>没有STOPPED和PAUSED状态。 当生命周期达到onPause（）时，它不会返回新状态，而是返回到STARTED状态。 当到达onStop（）时，它返回到CREATED状态。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p5.png" alt><br>现在，我们有了一个数据源，该数据源一次实现，但将其数据共享给所有订阅者。<br>一旦没有订阅者，它的上游收集将停止，并在第一个订阅者重新出现时重新启动。<br>它不依赖于Android平台，也不与主线程绑定（仅通过应用.flowOn（）运算符即可在其他线程中进行流转换：<br>flowOn（Dispatchers.IO）或.flowOn（Dispatchers.Default） ）。</p>
<h3 id="但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？"><a href="#但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？" class="headerlink" title="但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？"></a>但是，如果我最终需要访问Flow的当前状态而不收集它怎么办？</h3><p>如果确实需要像使用LiveData一样使用.value访问Flow的状态，则我们可以使用StateFlow，它是一种专用的受限SharedFlow。    </p>
<p>ShareFlow使用shareIn来实现<br>StateFlow使用stateIn实现</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">stateIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scope: <span class="type">CoroutineScope</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    started: <span class="type">SharingStarted</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">    initialValue: <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: StateFlow&lt;T&gt; (source)</span><br></pre></td></tr></table></figure>
<p>从方法参数可以看出，sharedIn（）和stateIn（）之间有两个基本区别：</p>
<p>1.stateIn（）不支持replay自定义。 StateFlow是具有固定replay=1的SharedFlow。 这意味着新订阅者将在订阅后立即获得当前状态。<br>2.stateIn（）需要一个初始值。 这意味着如果您当时没有初始值，则需要使StateFlow <t>类型T为可为空，或使用密封类来表示空的初始值。    </t></p>
<h3 id="选择哪个，StateFlow或SharedFlow？"><a href="#选择哪个，StateFlow或SharedFlow？" class="headerlink" title="选择哪个，StateFlow或SharedFlow？"></a>选择哪个，StateFlow或SharedFlow？</h3><p>回答此问题的简单方法是尝试回答其他一些问题：   </p>
<p><strong>“我真的需要在任何给定时间使用myFlow.value访问Flow的当前状态吗？”</strong><br>如果此问题的答案为“否”，则可以考虑使用SharedFlow。 </p>
<p><strong>“我需要支持发出和收集重复值吗？”</strong><br>如果对这个问题的回答是“是”，则需要SharedFlow。  </p>
<p><strong>“对于新订户，我是否需要重播超过最新值的内容？”</strong><br>如果对这个问题的回答是“是”，则需要SharedFlow。    </p>
<p>正如我们所看到的，对于所有内容，StateFlow并不是自动的正确答案。  </p>
<p>1.它忽略（合并）重复的值，并且这是不可配置的。 有时您不需要忽略重复的值，例如：连接尝试将尝试的结果存储在流中，并且每次失败后都需要重试。   </p>
<p>2.另外，它需要一个初始值。 由于SharedFlow没有.value，因此不需要使用初始值实例化-收集器将暂停直到第一个值出现，并且没有人会尝试在任何值到达之前访问.value。 如果您没有StateFlow的初始值，则必须将StateFlow类型设为可为null的T？ 并使用null作为初始值（或使用密封类来表示空的初始值）。</p>
<p>3.另外，您可能需要调整重播值。 SharedFlow可以为新订户重播最后n个值。 StateFlow的固定重播值为1-它仅共享当前状态值</p>
<p>两者都支持SharingStarted（立刻，懒加载或WhileSubscribed（））配置。我通常使用SharingStarted.WhileSubscribed（）<br>并在Activity onStart（）/ onStop（）时，销毁/重新创建所有收集器，<br>因此，当用户不积极使用该应用程序时，数据源上游收集将停止    </p>
<p>StateFlow施加在SharedFlow上的约束可能不是最适合您，您可能需要调整行为并选择使用SharedFlow。就个人而言，我很少需要访问myFlow.value，并且享受SharedFlow的灵活性，因此我通常选择SharedFlow。  </p>
<h3 id="一个使用SharedFlow的实例"><a href="#一个使用SharedFlow的实例" class="headerlink" title="一个使用SharedFlow的实例"></a>一个使用SharedFlow的实例</h3><p>考虑以下围绕Google Billing Client库的包装。我们有一个MutableSharedFlow billingClientStatus，用于存储当前到计费服务的连接状态。<br>我们将其初始值设置为SERVICE_DISCONNECTED。我们收集billingClientStatus，当它不正常时，我们尝试将startConnection（）连接到计费服务。<br>如果连接尝试失败，我们将发出SERVICE_DISCONNECTED。</p>
<p>在该示例中，如果billingClientStatus是MutableStateFlow而不是MutableSharedFlow，则当其值已经为SERVICE_DISCONNECTED且我们尝试将其设置为相同（连接重试失败）时，它将忽略更新，因此，它将不会尝试重新连接再次。   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Biller</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="meta">@ApplicationContext</span> <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">) : PurchasesUpdatedListener, BillingClientStateListener &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> billingClient: BillingClient =</span><br><span class="line">        BillingClient.newBuilder(context)</span><br><span class="line">            .setListener(<span class="keyword">this</span>)</span><br><span class="line">            .enablePendingPurchases()</span><br><span class="line">            .build()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> billingClientStatus = MutableSharedFlow&lt;<span class="built_in">Int</span>&gt;(</span><br><span class="line">        replay = <span class="number">1</span>,</span><br><span class="line">        onBufferOverflow = BufferOverflow.DROP_OLDEST</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBillingSetupFinished</span><span class="params">(result: <span class="type">BillingResult</span>)</span></span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(result.responseCode)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBillingServiceDisconnected</span><span class="params">()</span></span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(BillingClient.BillingResponseCode.SERVICE_DISCONNECTED)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Suspend until billingClientStatus == BillingClient.BillingResponseCode.OK</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requireBillingClientSetup</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> =</span><br><span class="line">        withTimeoutOrNull(TIMEOUT_MILLIS) &#123;</span><br><span class="line">            billingClientStatus.first &#123; it == BillingClient.BillingResponseCode.OK &#125;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125; ?: <span class="literal">false</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        billingClientStatus.tryEmit(BillingClient.BillingResponseCode.SERVICE_DISCONNECTED)</span><br><span class="line">        billingClientStatus.observe(ProcessLifecycleOwner.<span class="keyword">get</span>()) &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                BillingClient.BillingResponseCode.OK -&gt; with (billingClient) &#123;</span><br><span class="line">                    updateSkuPrices()</span><br><span class="line">                    handlePurchases()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                    delay(RETRY_MILLIS)</span><br><span class="line">                    billingClient.startConnection(<span class="keyword">this</span><span class="symbol">@Biller</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TIMEOUT_MILLIS = <span class="number">2000L</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> RETRY_MILLIS = <span class="number">3000L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们需要使用SharedFlow，它支持发出连续的重复值。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是关于SharedFlow与StateFlow的一些介绍及使用他们代替LiveData的一些尝试<br>这是在下翻译的第一篇文章，还有很多不足之处，请各位读者结合原文观看，如果有什么总量，欢迎提出指正。    </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>利用MotionLayout实现RecyclerView折叠展开动画</title>
    <url>/blog/2020/12/motionlayout-recyclerview-animation.html</url>
    <content><![CDATA[<p>RecyclerView的展开与折叠是一种常见的动画<br>主要有两种方式可以实现<br><strong>1.通过添加与移除元素</strong><br>notifyInsert,notifyRemoved，这种方式涉及到元素的加减，动画效果不太流畅<br><strong>2.通过给RecyclerView的item添加动画</strong><br>这种情况需要考虑一个item添加动画时，对其他的item的影响。而利用MotionLayout可以方便的实现这一点。    </p>
<p><strong>先来看看效果</strong><br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.gif" alt><br>1.支持流畅的展开折叠<br>2.支持多类型item<br>3.支持只能同时展开一个    </p>
<p>下面来看下具体实现  </p>
<h2 id="1-引入MotionLayout库"><a href="#1-引入MotionLayout库" class="headerlink" title="1.引入MotionLayout库"></a>1.引入MotionLayout库</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">dependencies</span> &#123; <span class="attribute">implementation</span> <span class="string">'com.android.support.constraint:constraint-layout:2.0.0-beta2'</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-在布局文件中使用"><a href="#2-在布局文件中使用" class="headerlink" title="2.在布局文件中使用"></a>2.在布局文件中使用</h2><p>MotionLayout 想要使用 MotionLayout，只需要在布局文件中作如下声明即可：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;androidx<span class="selector-class">.constraintlayout</span><span class="selector-class">.motion</span><span class="selector-class">.widget</span><span class="selector-class">.MotionLayout</span> xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    xmlns:app=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span><br><span class="line">    xmlns:tools=<span class="string">"http://schemas.android.com/tools"</span></span><br><span class="line">    android:id=<span class="string">"@+id/motionContainer"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:<span class="attribute">background</span>=<span class="string">"@color/white"</span></span><br><span class="line">    app:layoutDescription=<span class="string">"@xml/motion_list_rv_item_scene"</span>&gt;</span><br><span class="line">.....</span><br><span class="line">&lt;/android<span class="selector-class">.support</span><span class="selector-class">.constraint</span><span class="selector-class">.motion</span>.MotionLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>由于 MotionLayout 作为 ConstraintLayout 的子类，那么就自然而然地可以像 ConstraintLayout 那样使用去“约束”子视图了，不过这可就有点“大材小用了”，MotionLayout 的用处可远不止这些。我们先来看看 MotionLayout 的构成：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p1.webp" alt></p>
<p>由上图可知，MotionLayout 可分为 <view> 和 <helper> 两个部分。<view> 部分可简单理解为一个 ConstraintLayout，至于 <helper> 其实就是我们的“动画层”了。MotionLayout 为我们提供了 layoutDescription 属性，我们需要为它传入一个 MotionScene 包裹的 XML 文件，想要实现动画交互，就必须通过这个“媒介”来连接。</helper></view></helper></view></p>
<h2 id="MotionScene"><a href="#MotionScene" class="headerlink" title="MotionScene"></a>MotionScene</h2><p>什么是 MotionScene？结合上图 MotionScene 主要由三部分组成：StateSet、ConstraintSet 和 Transition<br>实现RecyclerView展开折叠效果，主要用到了 ConstarintSet 和 Transition     </p>
<h3 id="首先来看看布局文件"><a href="#首先来看看布局文件" class="headerlink" title="首先来看看布局文件"></a>首先来看看布局文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/motionContainer"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"@color/white"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layoutDescription</span>=<span class="string">"@xml/motion_list_rv_item_scene"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/box_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"86dp"</span>&gt;</span></span><br><span class="line">            ....</span><br><span class="line">            <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:background</span>=<span class="string">"@color/blue_magic"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/view2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"1dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#eaeaef"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.motion.widget.MotionLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>布局文件很简单，只不过你可能会注意到，我们对 LinearLayout并没有添加任何约束，原因在于：我们会在 MotionScene 中声明 ConstraintSet，里面将包含该 LinearLayout 的“运动”起始点和终点的约束信息。</p>
<p>当然你也可以在布局文件中对其加以约束，但 MotionScene 中对于控件约束的优先级会高于布局文件中的设定。这里我们通过 layoutDescription 来为 MotionLayout 设置它的 MotionScene 为 motion_list_rv_item_scene，接下来就让我们一睹 MotionScene 的芳容：</p>
<h3 id="动画文件"><a href="#动画文件" class="headerlink" title="动画文件"></a>动画文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MotionScene</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span> <span class="attr">android:id</span>=<span class="string">"@+id/start"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"86dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ConstraintSet</span> <span class="attr">android:id</span>=<span class="string">"@+id/end"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Constraint</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@id/box_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"186dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ConstraintSet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Transition</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetEnd</span>=<span class="string">"@id/end"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:constraintSetStart</span>=<span class="string">"@+id/start"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:duration</span>=<span class="string">"500"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:motionInterpolator</span>=<span class="string">"easeInOut"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MotionScene</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先，可以发现我们定义了两个 <constraintset>   分别描述了RecyclerView中的item的动画起始位置以及结束位置的约束信息（仅包含少量必要信息，如：width、height、margin以及位置属性等）。<br>显而易见，itemView起始高度为86dp，结束高度186dp.    </constraintset></p>
<p><strong>那么问题来了，如何让它动起来呢？</strong><br>这就要依靠我们的 <transition> 元素了。     </transition></p>
<p>事实上，我们都知道，动画都是有开始位置和结束位置的，而 MotionLayout 正是利用这一客观事实，将首尾位置和动画过程分离，两个点位置和距离虽然是固定的，但是它们之间的 Path 是无限的，可以是“一马平川”，也可以是”蜿蜒曲折”的。</p>
<p>我们只需要为 Transition 设置起始位置和结束位置的 ConstraintSet 并设置动画时间即可，剩下的都交给 MotionLayout 自动去帮我们完成。</p>
<p>当然你也可以通过 onClick 点击事件来触发动画，绑定目标控件的 id 以及通过 clickAction 属性来设置点击事件的类型。</p>
<h3 id="OnClick有多种类型"><a href="#OnClick有多种类型" class="headerlink" title="OnClick有多种类型"></a>OnClick有多种类型</h3><ul>
<li>1.toggle，如果布局当前处于开始状态，请将动画效果切换为结束状态；否则，请将动画效果切换为开始状态。</li>
<li>2.transitionToStart,为从当前布局到 <transition> 元素的 motion::constraintSetStart 属性指定的布局添加动画效果。</transition></li>
<li>3.transitionToEnd,为从当前布局到 <transition> 元素的 motion:constraintSetEnd 属性指定的布局添加动画效果。</transition></li>
</ul>
<h2 id="只能同时展开一个item实现"><a href="#只能同时展开一个item实现" class="headerlink" title="只能同时展开一个item实现"></a>只能同时展开一个item实现</h2><p>因为我们需要在展开一个item时，折叠其他item,因此不在xml中指定点击事件，去adapter中指定<br>实现展开一个时折叠其他item 我们可以通过MotionLayout的progress判断当前是在start状态还是end状态。   </p>
<p>下面的代码主要有几点需要注意的<br>1.如果是start状态则展开，否则则折叠<br>2.利用payload局部刷新达到折叠其他itemView的效果。<br>3.在RecyclerView滚动时会复用，所以需要在onBindViewHolder时初始化item的状态，即progress，不然会发生错位现象</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (holder <span class="keyword">is</span> MotionViewHolder) &#123;</span><br><span class="line">            <span class="keyword">val</span> motionBox = holder.itemView.findViewById&lt;MotionLayout&gt;(R.id.motionContainer)</span><br><span class="line">            <span class="keyword">if</span> (expandList[position])&#123;</span><br><span class="line">                motionBox.progress = <span class="number">1.0f</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                motionBox.progress = <span class="number">0f</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            holder.itemView.setOnClickListener &#123;</span><br><span class="line">                expandList.fill(<span class="literal">false</span>)</span><br><span class="line">                <span class="keyword">if</span> (motionBox.progress == <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    motionBox.transitionToStart()</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (motionBox.progress == <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    motionBox.transitionToEnd()</span><br><span class="line">                    expandList[position] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until itemCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != position) &#123;</span><br><span class="line">                        notifyItemChanged(i, <span class="string">"collapse"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        holder: <span class="type">RecyclerView</span>.<span class="type">ViewHolder</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        position: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        payloads: <span class="type">MutableList</span>&lt;<span class="type">Any</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (payloads.isNullOrEmpty()) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onBindViewHolder(holder, position, payloads)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (holder <span class="keyword">is</span> MotionViewHolder) &#123;</span><br><span class="line">                <span class="keyword">val</span> motionBox = holder.itemView.findViewById&lt;MotionLayout&gt;(R.id.motionContainer)</span><br><span class="line">                motionBox.transitionToStart()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，即利用MotionLayout比较简单的实现了RecyclerView的item展开折叠效果<br>1.支持流畅的展开折叠<br>2.支持多类型item<br>3.支持只能同时展开一个    </p>
<p>MotionLayout还有很多更强大的功能，比如与AppBarLayout联动，与Lottie联动，实现复杂动画等。<br>读者如有兴趣可阅读下方的参考链接，及本文的所有代码</p>
<h3 id="本文的所有相关代码"><a href="#本文的所有相关代码" class="headerlink" title="本文的所有相关代码"></a>本文的所有相关代码</h3><p><a href="https://github.com/shenzhen2017/MotionLayoutRecyclerView" target="_blank" rel="noopener">MotionLayoutRecyclerView实现</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844903918598635534" target="_blank" rel="noopener">MotionLayout：打开动画新世界大门 (part I)</a><br><a href="https://juejin.cn/post/6854573206653812743" target="_blank" rel="noopener">Android MotionLayout动画：续写ConstraintLayout新篇章</a>     </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>kotlin实用技巧总结</title>
    <url>/blog/2021/01/kotlin-tips-sum.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，kotlin是google力推的用以取代java的android开发语言<br>kotlin使用起来比较方便，同时有许多语法糖<br>本文主要讲解了一些比较实用的kotlin技巧</p>
<h2 id="自定义圆角矩形"><a href="#自定义圆角矩形" class="headerlink" title="自定义圆角矩形"></a>自定义圆角矩形</h2><p>在项目中，我们常常要定义圆角矩形背景，一般是用自定义drawable实现的<br>但是圆角矩形的背景与圆角常常会有细微的变化，而一旦变化我们又要新创建一个drawable文件<br>这样就会导致文件爆炸的问题  </p>
<p>我们可以利用kotlin的扩展函数，来实现简单方便的圆角矩形背景<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> View.<span class="title">setRoundRectBg</span><span class="params">(color: <span class="type">Int</span> = Color.WHITE, cornerRadius: <span class="type">Int</span> = <span class="number">15.</span>dp)</span></span> &#123;</span><br><span class="line">    background = GradientDrawable().apply &#123;</span><br><span class="line">        setColor(color)</span><br><span class="line">        setCornerRadius(cornerRadius.toFloat())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于需要自定义背景的View,直接调用setRoundRectBg即可，简单方便</p>
<h2 id="reified使用"><a href="#reified使用" class="headerlink" title="reified使用"></a>reified使用</h2><p>reified,kotlin中的泛型实化关键字，使抽象的东西更加具体或真实。<br>我们举两个例子来看看怎么使用reified</p>
<h3 id="startActivity例子"><a href="#startActivity例子" class="headerlink" title="startActivity例子"></a>startActivity例子</h3><p>我们一般startActivity是这样写的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">startActivity(context, NewActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>我们利用reified定义一个扩展函数<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T : Activity&gt;</span> Activity.<span class="title">startActivity</span><span class="params">(context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">    startActivity(Intent(context, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Caller</span></span><br><span class="line">startActivity&lt;NewActivity&gt;(context)</span><br></pre></td></tr></table></figure></p>
<p>使用 reified，通过添加类型传递简化泛型参数<br>这样就不用手动传泛型的类型过去了 </p>
<h3 id="Gson解析例子"><a href="#Gson解析例子" class="headerlink" title="Gson解析例子"></a>Gson解析例子</h3><p>我们首先看下一般我们使用gson解析json是怎么做的<br>在Java序列化库（如Gson）中，当您想要反序列化该JSON字符串时，您最终必须将Class对象作为参数传递，以便Gson知道您想要的类型。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> Gson().fromJson(getJson(), User<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>现在，让我们一起展示reified类型实化参数的魔法 我们将创建一个非常轻量级的扩展函数来包装Gson方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> Gson.<span class="title">fromJson</span><span class="params">(json: <span class="type">String</span>)</span></span> = </span><br><span class="line">        fromJson(json, T::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>现在，在我们的Kotlin代码中，我们可以反序列化JSON字符串，甚至根本不需要传递类型信息！<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> user: User = Gson().fromJson(json)</span><br></pre></td></tr></table></figure></p>
<p>Kotlin根据它的用法推断出类型 - 因为我们将它分配给User类型的变量，Kotlin使用它作为fromJson（）的类型参数</p>
<h2 id="kotin接口支持SAM转换"><a href="#kotin接口支持SAM转换" class="headerlink" title="kotin接口支持SAM转换"></a>kotin接口支持SAM转换</h2><p>什么是SAM转换？可能有的同学还不太了解，这里先科普一下：</p>
<p>SAM 转换，即 Single Abstract Method Conversions，就是对于只有单个非默认抽象方法接口的转换 —— 对于符合这个条件的接口（称之为 SAM Type ），在 Kotlin 中可以直接用 Lambda 来表示 —— 当然前提是 Lambda 的所表示函数类型能够跟接口的中方法相匹配。</p>
<p>在Kotlin1.4之前，Kotlin是不支持Kotlin的SAM转换的，只支持Java SAM转换，官方给出的的解释是：是 Kotlin 本身已经有了函数类型和高阶函数，不需要在去SAM转化。 这个解释开发者并不买账，如果你用过Java Lambda和Fuction Interface。当你切换到Kotlin时，就会很懵逼。看来Kotlin是意识到了这个，或者是看到开发者的反馈，终于支持了。</p>
<p>在1.4之前，只能传递一个对象，是不支持Kotlin SAM的，而在1.4之后，可以支持Kotlin SAM,但是用法有一丢丢变化。interface需要使用fun关键字声明。使用fun关键字标记接口后，只要将此类接口作为参数，就可以将lambda作为参数传递。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意需用fun 关键字声明</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> Action &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">runAction</span><span class="params">(a: <span class="type">Action</span>)</span></span> = a.run()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 1.4之前，只能使用object</span></span><br><span class="line">    runAction(<span class="keyword">object</span> : Action&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">            println(<span class="string">"run action"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">     <span class="comment">// 1.4-M1支持SAM,OK</span></span><br><span class="line">    runAction &#123;</span><br><span class="line">        println(<span class="string">"Hello, Kotlin 1.4!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>有时候，完成一些工作的方法是将它们委托给别人。这里不是在建议您将自己的工作委托给朋友去做，而是在说将一个对象的工作委托给另一个对象。</p>
<p>当然，委托在软件行业不是什么新鲜名词。委托 (Delegation) 是一种设计模式，在该模式中，对象会委托一个助手 (helper) 对象来处理请求，这个助手对象被称为代理。代理负责代表原始对象处理请求，并使结果可用于原始对象。</p>
<h3 id="类委托"><a href="#类委托" class="headerlink" title="类委托"></a>类委托</h3><p>举个例子，当我们要实现一个增强版的ArrayList,支持恢复最后一次删除的item   </p>
<p>实现这个用例的一种方式，是继承 ArrayList 类。由于新的类继承了具体的 ArrayList 类而不是实现 MutableList 接口，因此它与 ArrayList 的实现高度耦合。<br>如果只需要覆盖 remove() 函数来保持对已删除项目的引用，并将 MutableList 的其余空实现委托给其他对象，那该有多好啊。为了实现这一目标，Kotlin 提供了一种将大部分工作委托给一个内部 ArrayList 实例并且可以自定义其行为的方式，并为此引入了一个新的关键字: by。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;!-- Copyright <span class="number">2019</span> Google LLC.</span><br><span class="line">SPDX-License-Identifier: Apache-<span class="number">2.0</span> --&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListWithTrash</span> &lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> innerList: MutableList&lt;T&gt; = ArrayList&lt;T&gt;()) : MutableCollection&lt;T&gt; <span class="keyword">by</span> innerList &#123;</span><br><span class="line">	<span class="keyword">var</span> deletedItem : T? = <span class="literal">null</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(element: <span class="type">T</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">	       deletedItem = element</span><br><span class="line">			<span class="keyword">return</span> innerList.remove(element)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">recover</span><span class="params">()</span></span>: T? &#123;</span><br><span class="line">		<span class="keyword">return</span> deletedItem</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>by 关键字告诉 Kotlin 将 MutableList 接口的功能委托给一个名为 innerList 的内部 ArrayList。通过桥接到内部 ArrayList 对象方法的方式，ListWithTrash 仍然支持 MutableList 接口中的所有函数。与此同时，现在您可以添加自己的行为了。</p>
<h3 id="属性委托"><a href="#属性委托" class="headerlink" title="属性委托"></a>属性委托</h3><p>除了类代理，您还可以使用 by 关键字进行属性代理。通过使用属性代理，代理类会负责处理对应属性 get 与 set 函数的调用。这一特性在您需要在其他对象间复用 getter/setter 逻辑时十分有用，同时也能让您可以轻松地对简单支持字段的功能进行扩展</p>
<p>举个例子，利用委托属性可以封装SharedPreference<br>将数据存储操作委托给代理类有几个好处<br>1.则精简了代码，方便了存储与读取调用<br>2.与SP进行了解耦，后续如果要替换存储库，只需要修改代理类即可   </p>
<p>调用如下:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Pref: PreferenceHolder() &#123;</span><br><span class="line">    <span class="keyword">var</span> isFirstInstall: <span class="built_in">Boolean</span> <span class="keyword">by</span> bindToPreferenceField(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">var</span> time: <span class="built_in">Long</span>? <span class="keyword">by</span> bindToPreferenceFieldNullable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体实现可见:<a href="https://juejin.cn/post/6857432013424001038" target="_blank" rel="noopener">SharedPreferences用Kotlin应该这样写</a></p>
<h2 id="带状态的LiveData"><a href="#带状态的LiveData" class="headerlink" title="带状态的LiveData"></a>带状态的LiveData</h2><p>目前我们在开发的过程中越来越多的使用MVVM模式与ViewModel<br>我们也常常用LiveData来标识网络请求状态<br>我们需要定义请求开始，请求成功，请求失败，三个LiveData    </p>
<p>这其实也是很冗余重复的代码，因此我们可以进行一定的封装，封装一个带状态的LiveData</p>
<p>定义如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> StatefulLiveData&lt;T&gt; = LiveData&lt;RequestState&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">typealias</span> StatefulMutableLiveData&lt;T&gt; = MutableLiveData&lt;RequestState&lt;T&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> StatefulLiveData<span class="type">&lt;T&gt;</span>.<span class="title">observeState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    owner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">init</span>: <span class="type">ResultBuilder</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = ResultBuilder&lt;T&gt;().apply(<span class="keyword">init</span>)</span><br><span class="line"></span><br><span class="line">    observe(owner) &#123; state -&gt;</span><br><span class="line">        <span class="keyword">when</span> (state) &#123;</span><br><span class="line">            <span class="keyword">is</span> RequestState.Loading -&gt; result.onLading.invoke()</span><br><span class="line">            <span class="keyword">is</span> RequestState.Success -&gt; result.onSuccess(state.<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">is</span> RequestState.Error -&gt; result.onError(state.error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用如下<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = StatefulMutableLiveData&lt;String&gt;()</span><br><span class="line">viewModel.<span class="keyword">data</span>.observeState(viewLifecycleOwner) &#123;</span><br><span class="line">            onLading = &#123;</span><br><span class="line">                <span class="comment">//loading</span></span><br><span class="line">            &#125;</span><br><span class="line">            onSuccess = &#123; <span class="keyword">data</span> -&gt;</span><br><span class="line">                <span class="comment">//success</span></span><br><span class="line">            &#125;</span><br><span class="line">            onError = &#123; exception -&gt;</span><br><span class="line">                <span class="comment">//error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上封装，可以比较优雅简洁的封装网络请求的loading,success,error状态，精简了代码，结构也比较清晰    </p>
<h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>DSL（domain specific language），即领域专用语言：专门解决某一特定问题的计算机语言，比如大家耳熟能详的 SQL 和正则表达式。<br>但是，如果为解决某一特定领域问题就创建一套独立的语言，开发成本和学习成本都很高，因此便有了内部 DSL 的概念。所谓内部 DSL，便是使用通用编程语言来构建 DSL。比如，本文提到的 Kotlin DSL，我们为 Kotlin DSL 做一个简单的定义：</p>
<p>“使用 Kotlin 语言开发的，解决特定领域问题，具备独特代码结构的 API 。”</p>
<p>举个例子，我们使用TabLayout时，如果要为他添加监听，需要实现以下3个方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实我们一般只会用到onTabSelected方法，其余两个一般是空实现<br>我们利用DSL对OnTabSelectedListener进行封装，即可避免写不必要的空实现代码   </p>
<p>具体实现如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">typealias</span> OnTabCallback = (tab: TabLayout.Tab?) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnTabSelectedListenerBuilder</span> : <span class="type">TabLayout.OnTabSelectedListener &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabReselectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabUnselectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> onTabSelectedCallback: OnTabCallback? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabReselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabUnselectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(tab: <span class="type">TabLayout</span>.<span class="type">Tab</span>?)</span></span> =</span><br><span class="line">            onTabSelectedCallback?.invoke(tab) ?: <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabReselected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabReselectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabUnselected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabUnselectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onTabSelected</span><span class="params">(callback: <span class="type">OnTabCallback</span>)</span></span> &#123;</span><br><span class="line">        onTabSelectedCallback = callback</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">registerOnTabSelectedListener</span><span class="params">(function: <span class="type">OnTabSelectedListenerBuilder</span>.() -&gt; <span class="type">Unit</span>)</span></span> =</span><br><span class="line">        OnTabSelectedListenerBuilder().also(function)</span><br></pre></td></tr></table></figure></p>
<p>定义DSL的一般步骤：    </p>
<ul>
<li>1.先定义一个类去实现回调接口，并且实现它的回调方法。</li>
<li>2.观察回调方法的参数，提取成一个函数类型（function type)，并且按照需要使用类型别名给函数类型起一个别称，并且用私有修饰。</li>
<li>3.在类里面声明一些可空的函数类型的可变（var）私有成员变量，并且在回调函数中拿到对应的变量实现它的invoke函数，传入对应的参数。</li>
<li>4.在类中定义一些跟回调接口一样名字，但是参数是对应的函数类型的函数，并且将函数类型赋值给当前类的对应的成员变量。</li>
<li>5.定义一个成员函数，参数是一个带有我们定好那个类的接受者对象并且返回Unit的Lambda表达式，在函数里创建相应的对象，并且使用also函数把Lambda表达式传进去。</li>
</ul>
<p>调用如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">tabLayout.addOnTabSelectedListener(registerOnTabSelectedListener &#123;</span><br><span class="line">    onTabSelected &#123; vpOrder.currentItem = it?.position ?: <span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>如上，就可以避免写一些不必要的空实现代码了  </p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Paging3你应该知道的知识点</title>
    <url>/blog/2021/01/paging-source-learn.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Paging库是Google新推出的jetPack组件，主要方便封装分页逻辑。<br>使用Paging库后，我们不需要再考虑加载下一页的逻辑，可以做到自动加载，同时可以方便的观察加载下一页的状态，是成功还是失败</p>
<p>本文主要包括Paging3的基本使用与部分源码解析，具体如下：<br>1.Paging3的基本使用<br>2.Paging3自动加载更多原理    </p>
<h2 id="Paging3的基本使用"><a href="#Paging3的基本使用" class="headerlink" title="Paging3的基本使用"></a>Paging3的基本使用</h2><h3 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h3><p>Paging 库包含以下功能：</p>
<ul>
<li>分页数据的内存中缓存。这可确保您的应用在处理分页数据时高效利用系统资源。</li>
<li>内置的请求重复信息删除功能，可确保您的应用高效地利用网络带宽和系统资源。</li>
<li>可配置的 RecyclerView 适配器，它们会在用户滚动到已加载数据的末尾时自动请求数据。</li>
<li>对 Kotlin 协程和流程以及 LiveData 和 RxJava 的一流支持。</li>
<li>内置对错误处理功能的支持，包括刷新和重试功能。</li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="https://github.com/shenzhen2017/newImage/blob/master/blog9/p6.jpg?raw=true" alt><br>里面几个类的作用：</p>
<ul>
<li><code>PagingSource</code> ：单一的数据源。</li>
<li><code>RemoteMediator</code> ：其实 <code>RemoteMediator</code> 也是单一的数据源，它会在 <code>PagingSource</code>  没有数据的时候，再使用 <code>RemoteMediator</code>  提供的数据，如果既存在数据库请求，又存在网络请求，通常 <code>PagingSource</code>  用于进行数据库请求，<code>RemoteMediator</code>  进行网络请求。</li>
<li><code>PagingData</code> ：单次分页数据的容器。</li>
<li><code>Pager</code>：用来构建 <code>Flow&lt;PagingData&gt;</code> 的类，实现数据加载完成的回调。</li>
<li><code>PagingDataAdapter</code> ：分页加载数据的 <code>RecyclerView</code> 的适配器。</li>
</ul>
<p>简述一下就是 <code>PagingSource</code> 和 <code>RemoteMediator</code> 充当数据源的角色，<code>ViewModel</code> 使用 <code>Pager</code> 中提供的 <code>Flow&lt;PagingData&gt;</code> 监听数据刷新.<br>每当 <code>RecyclerView</code> 即将滚动到底部的时候，就会有新的数据的到来，最后，<code>PagingAdapter</code> 展示数据。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="1-配置数据源"><a href="#1-配置数据源" class="headerlink" title="1.配置数据源"></a>1.配置数据源</h4><p>首先需要生成数据层，配置数据源<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> SHOE_START_INDEX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPageDataSource</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeRepository: ShoeRepository) : PagingSource&lt;<span class="built_in">Int</span>, Shoe&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">load</span><span class="params">(params: <span class="type">LoadParams</span>&lt;<span class="type">Int</span>&gt;)</span></span>: LoadResult&lt;<span class="built_in">Int</span>, Shoe&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> pos = params.key ?: SHOE_START_INDEX</span><br><span class="line">        <span class="keyword">val</span> startIndex = pos * params.loadSize + <span class="number">1</span></span><br><span class="line">        <span class="keyword">val</span> endIndex = (pos + <span class="number">1</span>) * params.loadSize</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从数据库拉去数据</span></span><br><span class="line">            <span class="keyword">val</span> shoes = shoeRepository.getPageShoes(startIndex.toLong(), endIndex.toLong())</span><br><span class="line">            <span class="comment">// 返回你的分页结果，并填入前一页的 key 和后一页的 key</span></span><br><span class="line">            LoadResult.Page(</span><br><span class="line">                shoes,</span><br><span class="line">                <span class="keyword">if</span> (pos &lt;= SHOE_START_INDEX) <span class="literal">null</span> <span class="keyword">else</span> pos - <span class="number">1</span>,</span><br><span class="line">                <span class="keyword">if</span> (shoes.isNullOrEmpty()) <span class="literal">null</span> <span class="keyword">else</span> pos + <span class="number">1</span></span><br><span class="line">            )</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:Exception)&#123;</span><br><span class="line">            LoadResult.Error(e)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-生成可观察的数据集"><a href="#2-生成可观察的数据集" class="headerlink" title="2. 生成可观察的数据集"></a>2. 生成可观察的数据集</h4><p>第二步则是在viewModel中生成可观察的数据集<br>这里可观察数据集包括 <code>LiveData</code> 、<code>Flow</code> 以及 <code>RxJava</code> 中的 <code>Observable</code> 和 <code>Flowable</code>，其中，RxJava 需要单独引入扩展库去支持的。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoeModel</span> <span class="keyword">constructor</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> shoeRepository: ShoeRepository) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 分页的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pagingSourceFactory 单一数据源的工厂，在闭包中提供一个PageSource即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> remoteMediator 同时支持网络请求和数据库请求的数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialKey 初始化使用的key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">var</span> shoes = Pager(config = PagingConfig(</span><br><span class="line">        pageSize = <span class="number">20</span></span><br><span class="line">        , enablePlaceholders = <span class="literal">false</span></span><br><span class="line">        , initialLoadSize = <span class="number">20</span></span><br><span class="line">    ), pagingSourceFactory = &#123; CustomPageDataSource(shoeRepository) &#125;).flow</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-创建Adapter"><a href="#3-创建Adapter" class="headerlink" title="3.创建Adapter"></a>3.创建Adapter</h4><p>和普通的 Adapter 没有特别大的区别，主要是：   </p>
<ul>
<li>提供 <code>DiffUtil.ItemCallback&lt;Shoe&gt;</code></li>
<li>继承 <code>PagingDataAdapter</code></li>
</ul>
<p>使用<code>PagingAdapter</code>需要实现<code>DiffUtil.ItemCallback</code>接口，因为后续提交数据时，会根据<code>DiffUtil</code>接口判断数据是否相同，从而做插入与删除操作<br>同时使用Paging需要继承<code>PagingDataAdapter</code>，这通常需要我们修改已有的基类，这也是Paging库的一个主要缺点</p>
<h4 id="4-在UI中使用"><a href="#4-在UI中使用" class="headerlink" title="4.在UI中使用"></a>4.在UI中使用</h4><p>如果只显示数据，我们要做的是：  </p>
<ul>
<li>创建和设置适配器。</li>
<li>开启一个协程</li>
<li>在协程中接收 Flow 提供的数据。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ShoeAdapter(context!!)</span><br><span class="line">binding.recyclerView.adapter = adapter</span><br><span class="line">job = viewModel.viewModelScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    viewModel.shoes.collect() &#123;</span><br><span class="line">        adapter.submitData(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-监听数据加载状态"><a href="#5-监听数据加载状态" class="headerlink" title="5.监听数据加载状态"></a>5.监听数据加载状态</h4><p>Paging可以监听数据的加载状态，状态对应的类是 LoadState，它有三种状态：</p>
<ul>
<li>Loading：数据加载中。</li>
<li>NotLoading：内存中有已经获取的数据，即使往下滑，Paging 也不需要请求更多的数据。</li>
<li>Error：请求数据时返回了一个错误。</li>
</ul>
<p>监听数据状态的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">adapter.addLoadStateListener &#123;state:CombinedLoadStates-&gt;</span><br><span class="line">    <span class="comment">//... 状态监听</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听方法就是这么简单，可以看到这个 <code>state</code> 并不是 <code>LoadState</code>，而是一个 <code>CombinedLoadStates</code>，顾名思义，就是多个 <code>LoadState</code> 组合而成的状态类，它里面有：</p>
<ul>
<li><code>refresh:LoadState</code>：刷新时的状态，因为可以调用 <code>PagingDataAdapter#refresh()</code> 方法进行数据刷新。</li>
<li><code>append:LoadState</code>：可以理解为 RecyclerView 向下滑时数据的请求状态。</li>
<li><code>prepend:LoadState</code>：可以理解为RecyclerView 向上滑时数据的请求状态。</li>
</ul>
<h2 id="Paging3如何实现自动加载更多？"><a href="#Paging3如何实现自动加载更多？" class="headerlink" title="Paging3如何实现自动加载更多？"></a>Paging3如何实现自动加载更多？</h2><p>当RecyclerView即将滚动到底部时，Paging库会自动加载更多，我们可以看下是怎样实现的</p>
<p>实际上，Paging的加载更多逻辑是通过<code>PagingDataAdapter</code>的<code>getItem()</code>方法触发的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> position: <span class="type">Int</span>)</span></span> = differ.getItem(position)</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>differ</code>是一个<code>AsyncPagingDataDiffer</code>对象：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(<span class="meta">@IntRange(from = 0)</span> index: <span class="type">Int</span>)</span></span>: T? &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inGetItem = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> differBase[index]</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inGetItem = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>接着看<code>differBase</code>的<code>get()</code>方法，<code>differBase</code>是一个<code>PagingDataDiffer</code>对象：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T? &#123;</span><br><span class="line">        lastAccessedIndex = index</span><br><span class="line">        receiver?.addHint(presenter.loadAround(index))</span><br><span class="line">        <span class="keyword">return</span> presenter.<span class="keyword">get</span>(index)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>receiver</code>是一个<code>UiReceiver</code>对象,在初始化时会初始化为<code>PagerUiReceiver</code>，下面看一下<code>addHint()</code>方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">PagerUiReceiver</span>&lt;<span class="type">Key : Any, Value : Any</span>&gt; <span class="keyword">constructor</span></span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> pageFetcherSnapshot: PageFetcherSnapshot&lt;Key, Value&gt;,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> retryChannel: SendChannel&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line">    ) : UiReceiver &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">addHint</span><span class="params">(hint: <span class="type">ViewportHint</span>)</span></span> = pageFetcherSnapshot.addHint(hint)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">retry</span><span class="params">()</span></span> &#123;</span><br><span class="line">            retryChannel.offer(<span class="built_in">Unit</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">refresh</span><span class="params">()</span></span> = <span class="keyword">this</span><span class="symbol">@PageFetcher</span>.refresh()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>pageFetcherSnapshot</code>是一个<code>PageFetcherSnapshot</code>对象<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addHint</span><span class="params">(hint: <span class="type">ViewportHint</span>)</span></span> &#123;</span><br><span class="line">        lastHint = hint</span><br><span class="line">        <span class="meta">@OptIn(ExperimentalCoroutinesApi::class)</span></span><br><span class="line">        hintChannel.offer(hint)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>hintChannel</code>是一个<code>BroadcastChannel</code>对象，只要该<code>channel</code>中有新值，它会广播给所有的订阅者，下面看一下订阅<code>hintChannel</code>的地方<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">hintChannel.asFlow()</span><br><span class="line">            <span class="comment">// Prevent infinite loop when competing PREPEND / APPEND cancel each other</span></span><br><span class="line">            .drop(<span class="keyword">if</span> (generationId == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">            .map &#123; hint -&gt; GenerationalViewportHint(generationId, hint) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// Prioritize new hints that would load the maximum number of items.</span></span><br><span class="line">        .runningReduce &#123; previous, next -&gt;</span><br><span class="line">            <span class="keyword">if</span> (next.shouldPrioritizeOver(previous, loadType)) next <span class="keyword">else</span> previous</span><br><span class="line">        &#125;</span><br><span class="line">        .conflate()</span><br><span class="line">        .collect &#123; generationalHint -&gt;</span><br><span class="line">            doLoad(loadType, generationalHint)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到上游hintChannel有值时，会构造一个<code>GenerationalViewportHint</code>对象，下游会调用<code>doLoad()</code>方法：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doLoad</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        loadType: <span class="type">LoadType</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        generationalHint: <span class="type">GenerationalViewportHint</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">    	.....</span><br><span class="line">    	 <span class="keyword">var</span> loadKey: Key? = stateHolder.withLock &#123; state -&gt;</span><br><span class="line">            state.nextLoadKeyOrNull(</span><br><span class="line">                loadType,</span><br><span class="line">                generationalHint.generationId,</span><br><span class="line">                generationalHint.presentedItemsBeyondAnchor(loadType) + itemsLoaded,</span><br><span class="line">            )?.also &#123; state.setLoading(loadType) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="symbol">loop@</span> <span class="keyword">while</span> (loadKey != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> params = loadParams(loadType, loadKey)</span><br><span class="line">            <span class="keyword">val</span> result: LoadResult&lt;Key, Value&gt; = pagingSource.load(params)</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出在<code>loadKey</code>不为<code>null</code>时，会调用<code>pagingSource</code>的<code>load</code>方法从而加载下一页,我们看看<code>nextLoadKeyOrNull</code>方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> PageFetcherSnapshotState<span class="type">&lt;Key, Value&gt;</span>.<span class="title">nextLoadKeyOrNull</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        loadType: <span class="type">LoadType</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        generationId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        presentedItemsBeyondAnchor: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Key? &#123;</span><br><span class="line">        <span class="keyword">if</span> (generationId != generationId(loadType)) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">// Skip load if in error state, unless retrying.</span></span><br><span class="line">        <span class="keyword">if</span> (sourceLoadStates.<span class="keyword">get</span>(loadType) <span class="keyword">is</span> Error) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip loading if prefetchDistance has been fulfilled.</span></span><br><span class="line">        <span class="keyword">if</span> (presentedItemsBeyondAnchor &gt;= config.prefetchDistance) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (loadType == PREPEND) &#123;</span><br><span class="line">            pages.first().prevKey</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pages.last().nextKey</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上可以看出,只有当加载状态为成功，且最后一个的距离小于预加载距离时，才会返回<code>nextKey</code>,即开始加载下一页  </p>
<p>以上就是Paing3自动加载下一页的源码分析，总结为时序图如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p6.png" alt></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6898133386218045453" target="_blank" rel="noopener">即学即用Android Jetpack - Paging 3</a><br><a href="https://blog.csdn.net/weixin_40888127/article/details/107392096" target="_blank" rel="noopener">Paging内部原理</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView相关知识点总结</title>
    <url>/blog/2021/02/recyclerview-sum-up.html</url>
    <content><![CDATA[<p>1.RecyclerView缓存机制<br><a href="https://mp.weixin.qq.com/s/VI68qPFr-iNa_-lwCh7fwA" target="_blank" rel="noopener">再也不用担心面试官问RecycleView了</a><br><a href="https://juejin.cn/post/6930412704578404360" target="_blank" rel="noopener">RecyclerView 面试题 | 哪些情况下表项会被回收到缓存池？</a><br><a href="https://mp.weixin.qq.com/s/Qm8HWRG0kwAkOvNibHsK6Q" target="_blank" rel="noopener">看完感觉我RecyclerView白学了！ | 刘望舒</a></p>
<p>2.RecyclerView吸顶</p>
<p>3.RecyclerView折叠展开</p>
<p>4.局部刷新<br>payload</p>
<p>5.预取</p>
<p>6.diffutils<br><a href="https://juejin.cn/post/6882531923537707015" target="_blank" rel="noopener">更高效地刷新 RecyclerView | DiffUtil二次封装</a></p>
<p>7.RecyclerView item点击<br><a href="https://juejin.cn/post/6881427923316768776/" target="_blank" rel="noopener">https://juejin.cn/post/6881427923316768776/</a></p>
<p>8.MultiType<br><a href="https://juejin.cn/post/6876967151975006221" target="_blank" rel="noopener">代理模式应用 | 每当为 RecyclerView 新增类型时就很抓狂</a></p>
<p>9.Paging<br><a href="https://juejin.cn/post/6893699877415436295" target="_blank" rel="noopener">超简单易用的使用Paging3封装的RecyclerView的列表适配器</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>SharedPreferences替换:MMKV集成与原理</title>
    <url>/blog/2021/02/sp-mmkv-learned.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SharedPreferences是谷歌提供的轻量级存储方案，使用起来比较方便，可以直接进行数据存储，不必另起线程<br>不过也带来很多问题，尤其是由SP引起的ANR问题，非常常见。<br>正因如此，后来也出现了一些SP的替代解决方案，比如MMKV  </p>
<p>本文主要包括以下内容<br>1.SharedPreferences存在的问题<br>2.MMKV的基本使用与介绍<br>3.MMKV的原理</p>
<h2 id="SharedPreferences存在的问题"><a href="#SharedPreferences存在的问题" class="headerlink" title="SharedPreferences存在的问题"></a>SharedPreferences存在的问题</h2><h3 id="SP的效率比较低"><a href="#SP的效率比较低" class="headerlink" title="SP的效率比较低"></a>SP的效率比较低</h3><p>1.读写方式：直接I/O<br>2.数据格式：xml<br>3.写入方式：全量更新<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p7.png" alt></p>
<p>由于SP使用的xml格式保存数据，所以每次更新数据只能全量替换更新数据<br>这意味着如果我们有100个数据，如果只更新一项数据，也需要将所有数据转化成xml格式，然后再通过io写入文件中<br>这也导致SP的写入效率比较低</p>
<h3 id="commit导致的ANR"><a href="#commit导致的ANR" class="headerlink" title="commit导致的ANR"></a>commit导致的ANR</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean commit() &#123;</span><br><span class="line">    <span class="comment">// 在当前线程将数据保存到mMap中</span></span><br><span class="line">    MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是在singleThreadPool中执行写入操作，通过await()暂停主线程，直到写入操作完成。</span></span><br><span class="line">        <span class="comment">// commit的同步性就是通过这里完成的。</span></span><br><span class="line">        mcr.writtenToDiskLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 回调的时机：</span></span><br><span class="line"><span class="comment">     * 1. commit是在内存和硬盘操作均结束时回调</span></span><br><span class="line"><span class="comment">     * 2. apply是内存操作结束时就进行回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    notifyListeners(mcr);</span><br><span class="line">    <span class="keyword">return</span> mcr.writeToDiskResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示<br>1.commit有返回值，表示修改是否提交成功<br>2.commit提交是同步的，直到磁盘操作成功后才会完成    </p>
<p>所以当数据量比较大时，使用commit很可能引起ANR</p>
<h3 id="Apply导致的ANR"><a href="#Apply导致的ANR" class="headerlink" title="Apply导致的ANR"></a>Apply导致的ANR</h3><p>commit是同步的，同时SP也提供了异步的apply<br>apply是将修改数据原子提交到内存, 而后异步真正提交到硬件磁盘, 而commit是同步的提交到硬件磁盘，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后在操作，从而降低了效率。而apply只是原子的提交到内容，后面有调用apply的函数的将会直接覆盖前面的内存数据，这样从一定程度上提高了很多效率    </p>
<p>但是apply同样会引起ANR的问题<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void apply() &#123;</span><br><span class="line">    <span class="keyword">final</span> long startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</span><br><span class="line">    <span class="keyword">final</span> Runnable awaitCommit = new Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void run() &#123;</span><br><span class="line">                mcr.writtenToDiskLatch.await(); <span class="comment">// 等待</span></span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="comment">// 将 awaitCommit 添加到队列 QueuedWork 中</span></span><br><span class="line">    QueuedWork.addFinisher(awaitCommit);</span><br><span class="line"></span><br><span class="line">    Runnable postWriteRunnable = new Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> void run() &#123;</span><br><span class="line">                awaitCommit.run();</span><br><span class="line">                QueuedWork.removeFinisher(awaitCommit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>将一个 awaitCommit 的  Runnable 任务，添加到队列 QueuedWork 中，在 awaitCommit 中会调用 await() 方法等待，在 handleStopService 、 handleStopActivity 等等生命周期会以这个作为判断条件，等待任务执行完毕</li>
<li>将一个 postWriteRunnable 的  Runnable 写任务，通过 enqueueDiskWrite 方法，将写入任务加入到队列中，而写入任务在一个线程中执行</li>
</ul>
<p>为了保证异步任务及时完成，当生命周期处于 <code>handleStopService()</code> 、 <code>handlePauseActivity()</code> 、 <code>handleStopActivity()</code> 的时候会调用 <code>QueuedWork.waitToFinish()</code> 会等待写入任务执行完毕</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; sPendingWorkFinishers =</span><br><span class="line">        new ConcurrentLinkedQueue&lt;Runnable&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">public</span> static void waitToFinish() &#123;</span><br><span class="line">    Runnable toFinish;</span><br><span class="line">    <span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        toFinish.run(); <span class="comment">// 相当于调用 `mcr.writtenToDiskLatch.await()` 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sPendingWorkFinishers</code> 是 <code>ConcurrentLinkedQueue</code> 实例，<code>apply</code> 方法会将写入任务添加到 <code>sPendingWorkFinishers</code>队列中，在单个线程的线程池中执行写入任务，线程的调度并不由程序来控制，也就是说当生命周期切换的时候，任务不一定处于执行状态</li>
<li><code>toFinish.run()</code> 方法，相当于调用 <code>mcr.writtenToDiskLatch.await()</code> 方法，会一直等待</li>
<li><code>waitToFinish()</code> 方法就做了一件事，会一直等待写入任务执行完毕，其它什么都不做，当有很多写入任务，会依次执行，当文件很大时，效率很低，造成 ANR 就不奇怪了</li>
</ul>
<p>所以当数据量比较大时，<code>apply</code>也会造成ANR</p>
<h3 id="getXXX-导致ANR"><a href="#getXXX-导致ANR" class="headerlink" title="getXXX() 导致ANR"></a>getXXX() 导致ANR</h3><p>不仅是写入操作，所有 getXXX() 方法都是同步的，在主线程调用 get 方法，必须等待 SP 加载完毕，也有可能导致ANR<br>调用 <code>getSharedPreferences()</code> 方法，最终会调用 <code>SharedPreferencesImpl#startLoadFromDisk()</code> 方法开启一个线程异步读取数据。  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object mLock = new Object();</span><br><span class="line"><span class="keyword">private</span> boolean mLoaded = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> void startLoadFromDisk() &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        mLoaded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    new Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            loadFromDisk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如你所看到的，开启一个线程异步读取数据，当我们正在读取一个比较大的数据，还没读取完，接着调用 <code>getXXX()</code> 方法。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String getString(String key, <span class="meta">@Nullable</span> String defValue) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        awaitLoadedLocked();</span><br><span class="line">        String v = (String)mMap.<span class="keyword">get</span>(key);</span><br><span class="line">        <span class="keyword">return</span> v != <span class="literal">null</span> ? v : defValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void awaitLoadedLocked() &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mLock.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在同步方法内调用了 <code>wait()</code> 方法，会一直等待 <code>getSharedPreferences()</code> 方法开启的线程读取完数据才能继续往下执行，如果读取几 KB 的数据还好，假设读取一个大的文件，势必会造成主线程阻塞。  </p>
<h2 id="MMKV的使用"><a href="#MMKV的使用" class="headerlink" title="MMKV的使用"></a>MMKV的使用</h2><p>MMKV 是基于 mmap 内存映射的 key-value 组件，底层序列化/反序列化使用 protobuf 实现，性能高，稳定性强。从 2015 年中至今在微信上使用，其性能和稳定性经过了时间的验证。近期也已移植到 Android / macOS / Win32 / POSIX 平台，一并开源。</p>
<h3 id="MMKV优点"><a href="#MMKV优点" class="headerlink" title="MMKV优点"></a>MMKV优点</h3><p>1.MMKV实现了SharedPreferences接口，可以无缝切换<br>2.通过 mmap 内存映射文件，提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统负责将内存回写到文件，不必担心 crash 导致数据丢失。<br>3.MMKV数据序列化方面选用 protobuf 协议，pb 在性能和空间占用上都有不错的表现<br>4.SP是全量更新，MMKV是增量更新，有性能优势  </p>
<p>详细的使用细节可以参考文档：<a href="https://github.com/Tencent/MMKV/wiki" target="_blank" rel="noopener">https://github.com/Tencent/MMKV/wiki</a></p>
<h2 id="MMKV原理"><a href="#MMKV原理" class="headerlink" title="MMKV原理"></a>MMKV原理</h2><h3 id="为什么MMKV写入速度更快"><a href="#为什么MMKV写入速度更快" class="headerlink" title="为什么MMKV写入速度更快"></a>为什么MMKV写入速度更快</h3><h4 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h4><p>我们知道，SP是写入是基于IO操作的，为了了解IO，我们需要先了解下用户空间与内核空间<br>虚拟内存被操作系统划分成两块：用户空间和内核空间，用户空间是用户程序代码运行的地方，内核空间是内核代码运行的地方。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p8.png" alt><br><strong>写文件流程:</strong><br>1、调用write，告诉内核需要写入数据的开始地址与长度<br>2、内核将数据拷贝到内核缓存<br>3、由操作系统调用，将数据拷贝到磁盘，完成写入    </p>
<h4 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h4><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p9.png" alt><br>对文件进行mmap，会在进程的虚拟内存分配地址空间，创建映射关系。<br>实现这样的映射关系后，就可以采用指针的方式读写操作这一段内存，而系统会自动回写到对应的文件磁盘上    </p>
<h4 id="MMAP优势"><a href="#MMAP优势" class="headerlink" title="MMAP优势"></a>MMAP优势</h4><ul>
<li>MMAP对文件的读写操作只需要从磁盘到用户主存的一次数据拷贝过程，减少了数据的拷贝次数，提高了文件读写效率。</li>
<li>MMAP使用逻辑内存对磁盘文件进行映射，操作内存就相当于操作文件，不需要开启线程，操作MMAP的速度和操作内存的速度一样快；</li>
<li>MMAP提供一段可供随时写入的内存块，App 只管往里面写数据，由操作系统如内存不足、进程退出等时候负责将内存回写到文件，不必担心 crash 导致数据丢失。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p10.png" alt><br>可以看出，MMAP的写入速度基本与内存写入速度一致，远高于SP，这就是MMKV写入速度更快的原因    </p>
<h3 id="MMKV写入方式"><a href="#MMKV写入方式" class="headerlink" title="MMKV写入方式"></a>MMKV写入方式</h3><h4 id="SP的数据结构"><a href="#SP的数据结构" class="headerlink" title="SP的数据结构"></a>SP的数据结构</h4><p>SP是使用XML格式存储数据的，如下所示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p11.png" alt><br>但是这也导致SP如果要更新数据的话，只能全量更新</p>
<h4 id="MMKV数据结构"><a href="#MMKV数据结构" class="headerlink" title="MMKV数据结构"></a>MMKV数据结构</h4><p>MMKV数据结构如下<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog9/p12.png" alt><br>MMKV使用Protobuf存储数据，冗余数据更少，更省空间，同时可以方便地在末尾追加数据   </p>
<h4 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h4><p><strong>增量写入</strong><br>不管key是否重复，直接将数据追加在前数据后。<br>这样效率更高，更新数据只需要插入一条数据即可。    </p>
<p>当然这样也会带来问题，如果不断增量追加内容，文件越来越大，怎么办？<br>当文件大小不够，这时候需要全量写入。将数据去掉重复key后，如果文件大小满足写入的数据大小，则可以直接更新全量写入，否则需要扩容。（在扩容时根据平均每个K-V大小计算未来可能需要的文件大小进行扩容，防止经常性的全量写入）   </p>
<h3 id="MMKV三大优势"><a href="#MMKV三大优势" class="headerlink" title="MMKV三大优势"></a>MMKV三大优势</h3><ul>
<li>mmap防止数据丢失，提高读写效率;</li>
<li>精简数据，以最少的数据量表示最多的信息，减少数据大小;</li>
<li>增量更新，避免每次进行相对增量来说大数据量的全量写入。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6881442312560803853" target="_blank" rel="noopener">[Google] 再见 SharedPreferences 拥抱 Jetpack DataStore</a><br><a href="https://juejin.cn/post/6844903729217404935" target="_blank" rel="noopener">浅析SharedPreferences</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>协程异常机制与优雅封装</title>
    <url>/blog/2021/02/corountine-handle-exeception.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要包括以下内容<br>1.协程的3种作用域以及异常的传播方式<br>2.协程异常的两种捕获方式及对比<br>3.协程异常的优雅封装  </p>
<p>如果觉得本文对您有所帮助，请帮忙点赞，谢谢~</p>
<h2 id="协程的异常是怎么传播的？"><a href="#协程的异常是怎么传播的？" class="headerlink" title="协程的异常是怎么传播的？"></a>协程的异常是怎么传播的？</h2><h3 id="首先了解下协程作用域"><a href="#首先了解下协程作用域" class="headerlink" title="首先了解下协程作用域"></a>首先了解下协程作用域</h3><p>协程作用域分为顶级作用域，协同作用域与主从作用域，分别对应GlobalScope,coroutineScope,supervisorScope<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c42668a11d4d7b9535d7927c9d020f~tplv-k3u1fbpfcp-watermark.image" alt><br>作用分析：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8389309dbcd440bb606ce1e33184112~tplv-k3u1fbpfcp-watermark.image" alt>   </p>
<p>说明：     </p>
<ul>
<li>C2-1发生异常的时候，C2-1-&gt;C2-&gt;C2-2-&gt;C2-&gt;C1-&gt;C3（包括里面的子协程）-&gt;C4</li>
<li>C3-1-1发生异常的时候,C3-1-1-&gt;C3-1-1-1，其他不受影响</li>
<li>C3-1-1-1发生异常的时候，C3-1-1-1-&gt;C3-1-1，其他不受影响</li>
</ul>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><h4 id="1、C1和C2没有关系"><a href="#1、C1和C2没有关系" class="headerlink" title="1、C1和C2没有关系"></a>1、C1和C2没有关系</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123; <span class="comment">//协程C1</span></span><br><span class="line">    GlobalScope.launch &#123;<span class="comment">//协程C2</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C1,C2不会互相影响，完全独立</p>
<h4 id="2-C2和C3是C1的子协程，C2和C3异常会取消C1"><a href="#2-C2和C3是C1的子协程，C2和C3异常会取消C1" class="headerlink" title="2.C2和C3是C1的子协程，C2和C3异常会取消C1"></a>2.C2和C3是C1的子协程，C2和C3异常会取消C1</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123; <span class="comment">//协程C1</span></span><br><span class="line">    coroutineScoope &#123;</span><br><span class="line">         launch&#123;&#125;<span class="comment">//协程C2</span></span><br><span class="line">         launch&#123;&#125;<span class="comment">//协程C3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-C2和C3是C1的子协程，C2和C3异常不会取消C1"><a href="#3-C2和C3是C1的子协程，C2和C3异常不会取消C1" class="headerlink" title="3.C2和C3是C1的子协程，C2和C3异常不会取消C1"></a>3.C2和C3是C1的子协程，C2和C3异常不会取消C1</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">GlobalScope.launch &#123; <span class="comment">//协程C1</span></span><br><span class="line">    supervisorScope &#123;</span><br><span class="line">         launch&#123;&#125;<span class="comment">//协程C2</span></span><br><span class="line">         launch&#123;&#125;<span class="comment">//协程C3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何捕获异常"><a href="#如何捕获异常" class="headerlink" title="如何捕获异常"></a>如何捕获异常</h2><h3 id="1-直接用Try-Catch会有什么问题？"><a href="#1-直接用Try-Catch会有什么问题？" class="headerlink" title="1.直接用Try,Catch会有什么问题？"></a>1.直接用Try,Catch会有什么问题？</h3><p>在java与Kotlin中，我们一般直接try,catch捕获异常<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in coroutine"</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">"Handle <span class="variable">$exception</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: RuntimeException in coroutine</span></span><br></pre></td></tr></table></figure></p>
<p>但是当我们在try模块中<code>launch</code>一个新的协程时，会有一个意外的发现   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            launch &#123;</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in nested coroutine"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">"Handle <span class="variable">$exception</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现捕获失效了，并且app crash了<br>我们发现try,catch无法catch住子协程的异常  </p>
<p><strong>发生了什么</strong><br>在协程中未捕获的异常会发生什么呢？ 协程最创新的功能之一就是<strong>结构化并发</strong>。 为了使结构化并发的所有功能成为可能，CoroutineScope的Job对象以及Coroutines和Child-Coroutines的Job对象形成了父子关系的层次结构。      未传播的异常（而不是重新抛出）是“在工作层次结构中传播”。 这种异常传播会导致父Job的失败，进而导致其子级所有Job的取消。</p>
<p>上面示例代码的job层次大概如下所示:<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p1.png" alt><br>子协程的异常传播到协程（1）的Job，然后传播到topLevelScope（2）的Job。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p2.png" alt>  </p>
<p>传播的异常可以通过CoroutineExceptionHandler来捕获，如果没有设置，则将调用线程的未捕获异常处理程序，可能会导致退出应用<br>我们看出，协程有两种异常处理机制，这也是协程的异常处理比较复杂的原因  </p>
<h4 id="小结1"><a href="#小结1" class="headerlink" title="小结1"></a>小结1</h4><p>如果协程本身不使用try-catch子句自行处理异常，则不会重新抛出该异常，因此无法通过外部try-catch子句进行处理。<br>异常会在“Job层次结构中传播”，可以由已设置的CoroutineExceptionHandler处理。 如果未设置，则调用该线程的未捕获异常处理程序。    </p>
<h3 id="2-CoroutineExceptionHandler"><a href="#2-CoroutineExceptionHandler" class="headerlink" title="2.CoroutineExceptionHandler"></a>2.CoroutineExceptionHandler</h3><p>现在我们知道，如果我们在try块中launch失败的协程，try-catch是没有用的。<br>因此，我们需要配置一个CoroutineExceptionHandler，我们可以将context传递给启动协程生成器。<br>由于CoroutineExceptionHandler是一个ContextElement，因此我们可以通过在启动子协程时将其传递给launch：     </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, exception -&gt;</span><br><span class="line">        println(<span class="string">"Handle <span class="variable">$exception</span> in CoroutineExceptionHandler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        launch(coroutineExceptionHandler) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in nested coroutine"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Exception in thread "DefaultDispatcher-worker-2" java.lang.RuntimeException: RuntimeException in nested coroutine</span></span><br></pre></td></tr></table></figure>
<p>可以发现程序还是crash了<br><strong>为什么不生效？</strong>    </p>
<p>这是因为给子协程设置CoroutineExceptionHandler是没有效果的，我们必须给顶级协程设置,或者初始化Scope时设置才有效<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">val</span> topLevelScope = CoroutineScope(Job() + coroutineExceptionHandler)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">topLevelScope.launch(coroutineExceptionHandler) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>
<h4 id="小结2"><a href="#小结2" class="headerlink" title="小结2"></a>小结2</h4><p>为了使CoroutineExceptionHandler起作用，必须将其设置在CoroutineScope或顶级协程中。</p>
<h3 id="3-Try-Catch与CoroutineExceptionHandler对比"><a href="#3-Try-Catch与CoroutineExceptionHandler对比" class="headerlink" title="3.Try,Catch与CoroutineExceptionHandler对比"></a>3.Try,Catch与CoroutineExceptionHandler对比</h3><p>如上面介绍的，协程支持两种异常处理机制，那么我们应该选择哪种呢？  </p>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/" target="_blank" rel="noopener">CoroutineExceptionHandler</a>的官方文档提供了一些很好的答案：   </p>
<blockquote>
<p>“ CoroutineExceptionHandler是用于全局“全部捕获”行为的最后手段。 您无法从CoroutineExceptionHandler中的异常中恢复。 当调用处理程序时，协程已经完成，并带有相应的异常。 通常，处理程序用于记录异常，显示某种错误消息，终止和/或重新启动应用程序。    </p>
</blockquote>
<blockquote>
<p>如果需要在代码的特定部分处理异常，建议在协程内部的相应代码周围使用try / catch。 这样，您可以防止协程异常完成（现在已捕获异常），重试该操作和/或采取其他任意操作：”</p>
</blockquote>
<h4 id="小结3"><a href="#小结3" class="headerlink" title="小结3"></a>小结3</h4><p>如果要在协程完成之前重试该操作或执行其他操作，请使用try / catch。<br>请记住，通过直接在协同程序中捕获异常，该异常不会在Job层次结构中传播，也不会利用结构化并发的取消功能。<br>而使用CoroutineExceptionHandler处理应该在协程完成后发生的逻辑。<br>可以看出，我们绝大多数时候应该使用CoroutineExceptionHandler   </p>
<h3 id="4-launch-vs-async"><a href="#4-launch-vs-async" class="headerlink" title="4.launch{} vs async{}"></a>4.launch{} vs async{}</h3><p>我们上面的例子都是使用launch启动协程的异常，但是launch与async的协常处理是完全不同的<br>下面看个例子<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(SupervisorJob())</span><br><span class="line"></span><br><span class="line">    topLevelScope.async &#123;</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in async coroutine"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有输出</span></span><br><span class="line">```   </span><br><span class="line">**为什么这里不会抛出异常？**     </span><br><span class="line">我们先要了解下launch与async的区别   </span><br><span class="line"></span><br><span class="line">从launch开始的协程的返回类型是Job，它只是协程的一种表示形式，没有返回值。    </span><br><span class="line">如果我们需要协程的某些结果，则必须使用async，它返回Deferred，这是一种特殊的Job，另外还保存一个结果值。    如果异步协程失败，则将该异常封装在Deferred返回类型中，并在我们调用<span class="keyword">suspend</span>函数.await（）来检索其结果值时将其重新抛出。     </span><br><span class="line"></span><br><span class="line">因此，我们可以使用<span class="keyword">try</span>-<span class="keyword">catch</span>子句将对.await（）的调用括起来。      </span><br><span class="line">```kotlin</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(SupervisorJob())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> deferredResult = topLevelScope.async &#123;</span><br><span class="line">        <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in async coroutine"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            deferredResult.await()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">"Handle <span class="variable">$exception</span> in try/catch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: RuntimeException in async coroutine in try/catch</span></span><br></pre></td></tr></table></figure></p>
<p>注意：如果async协程是顶级协程，则会将异常封装在Deferred中,等待调用await才会抛出异常。<br>否则，该异常将立即传播到Job层次结构中，并由CoroutineExceptionHandler处理，甚至传递给线程的未捕获异常处理程序，即使不对其调用.await（），如以下示例所示：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, exception -&gt;</span><br><span class="line">        println(<span class="string">"Handle <span class="variable">$exception</span> in CoroutineExceptionHandler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(SupervisorJob() + coroutineExceptionHandler)</span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in async coroutine"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: RuntimeException in async coroutine in CoroutineExceptionHandler</span></span><br></pre></td></tr></table></figure></p>
<h4 id="小结4"><a href="#小结4" class="headerlink" title="小结4"></a>小结4</h4><p><code>launch</code>和<code>async</code>协程中未捕获的异常会立即在作业层次结构中传播。<br>但是，如果顶层Coroutine是从launch启动的，则异常将由CoroutineExceptionHandler处理或传递给线程的未捕获异常处理程序。<br>如果顶级协程以async方式启动，则异常封装在Deferred返回类型中，并在调用.await（）时重新抛出。    </p>
<h3 id="5-coroutineScope异常处理特性"><a href="#5-coroutineScope异常处理特性" class="headerlink" title="5.coroutineScope异常处理特性"></a>5.coroutineScope异常处理特性</h3><p>文章开头我们举了个例子，失败的协程将其异常传播到<code>Job</code>层次结构中，而不是重新抛出该异常，因此，外部try-catch无效。<br>但是，当我们用<code>coroutineScope {}</code>作用域函数将失败的协程包围起来时，会发生一些有趣的事情：    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line">    </span><br><span class="line">  topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            coroutineScope &#123;</span><br><span class="line">                launch &#123;</span><br><span class="line">                    <span class="keyword">throw</span> RuntimeException(<span class="string">"RuntimeException in nested coroutine"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            println(<span class="string">"Handle <span class="variable">$exception</span> in try/catch"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: RuntimeException in nested coroutine in try/catch</span></span><br></pre></td></tr></table></figure>
<p>现在，我们可以使用<code>try-catch</code>子句处理异常。<br>可以看出，范围函数<code>coroutineScope {}</code>重新抛出其失败子项的异常，而不是将其传播到Job层次结构中。  </p>
<p><code>coroutineScope {}</code>主要用于<code>suspend</code>函数中以实现“并行分解”。 这些<code>suspend</code>函数将重新抛出其失败的协程的异常，因此我们可以相应地设置异常处理逻辑。  </p>
<h4 id="5-小结5"><a href="#5-小结5" class="headerlink" title="5.小结5"></a>5.小结5</h4><p>范围函数<code>coroutineScope {}</code>重新抛出其失败的子协程的异常，而不是将其传播到<code>Job</code>层次结构中，这使我们能够使用<code>try-catch</code>处理失败的协程的异常    </p>
<h3 id="6-supervisorScope异常处理特性"><a href="#6-supervisorScope异常处理特性" class="headerlink" title="6.supervisorScope异常处理特性"></a>6.supervisorScope异常处理特性</h3><p>通过使用作用域函数<code>supervisorScope {}</code>，我们将在Job层次结构中添加一个新的，独立的嵌套作用域，并将<code>SupervisorJob</code>作为其<code>Job</code>。   </p>
<p>代码如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">"starting Coroutine 1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch &#123;</span><br><span class="line">                println(<span class="string">"starting Coroutine 2"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">"starting Coroutine 3"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，在这里了解异常处理至关重要的一点是，supervisorScope是一个必须独立处理异常的新的独立子域。<br>它不会像coroutineScope那样重新抛出失败的协程的异常，也不会将异常传播到其父级– topLevelScope作业。    </p>
<p>要理解的另一件至关重要的事情是，异常只会向上传播，直到它们到达顶级范围或SupervisorJob。 这意味着job2和job3现在是顶级协程。<br>这也意味着我们可以为它们添加CoroutineExceptionHandler    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; coroutineContext, exception -&gt;</span><br><span class="line">        println(<span class="string">"Handle <span class="variable">$exception</span> in CoroutineExceptionHandler"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> topLevelScope = CoroutineScope(Job())</span><br><span class="line"></span><br><span class="line">    topLevelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> job1 = launch &#123;</span><br><span class="line">            println(<span class="string">"starting Coroutine 1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        supervisorScope &#123;</span><br><span class="line">            <span class="keyword">val</span> job2 = launch(coroutineExceptionHandler) &#123;</span><br><span class="line">                println(<span class="string">"starting Coroutine 2"</span>)</span><br><span class="line">                <span class="keyword">throw</span> RuntimeException(<span class="string">"Exception in Coroutine 2"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> job3 = launch &#123;</span><br><span class="line">                println(<span class="string">"starting Coroutine 3"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// starting Coroutine 1</span></span><br><span class="line"><span class="comment">// starting Coroutine 2</span></span><br><span class="line"><span class="comment">// Handle java.lang.RuntimeException: Exception in Coroutine 2 in CoroutineExceptionHandler</span></span><br><span class="line"><span class="comment">// starting Coroutine 3</span></span><br></pre></td></tr></table></figure>
<p>直接在<code>supervisorScope</code>中启动的协程是顶级协程，这也意味着<code>async</code>协程现在将其异常封装在其<code>Deferred</code>对象中,并且仅在调用<code>.await（）</code>时被重新抛出<br>这也是为什么<code>viewModelScope</code>中的<code>async</code>需要调用<code>await</code>才会抛出异常的原因    </p>
<h4 id="小结6"><a href="#小结6" class="headerlink" title="小结6"></a>小结6</h4><p>范围函数<code>supervisorScope {}</code>在<code>Job</code>层次结构中添加了一个新的独立子范围，并将<code>SupervisorJob</code>作为这个<code>scope</code>的’job’。<br>这个新作用域不会在“Job层次结构”中传播其异常，因此它必须自行处理其异常。<br>直接从<code>supervisorScope</code>启动的协程是顶级协程。<br>顶级协程与子协程在使用<code>launch（）</code>或<code>async（）</code>启动时的行为有所不同，此外，还可以在它们中安装<code>CoroutineExceptionHandlers</code>。</p>
<h2 id="协程异常处理封装"><a href="#协程异常处理封装" class="headerlink" title="协程异常处理封装"></a>协程异常处理封装</h2><p>如上文所说，在大多数时候，CoroutineExceptionHandler是一个更好的选择     </p>
<p>如我们所知，协程最大的优点是可以使用同步的方法写异步代码<br>但是CoroutineExceptionHandler将异常处理代码与协程代码分隔开了，感觉上并不是同步的<br>同时每次使用都要新建一个局部变量，不太优雅    </p>
<p>我们可以对CoroutineExceptionHandler进行封装，利用kotlin扩展函数，实现类似RxJava的调用效果<br>最后调用效果如下<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fetch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.rxLaunch&lt;String&gt; &#123;</span><br><span class="line">            onRequest = &#123;</span><br><span class="line">                <span class="comment">//网络请求</span></span><br><span class="line">                resposity.getData()</span><br><span class="line">            &#125;</span><br><span class="line">            onSuccess = &#123;</span><br><span class="line">                <span class="comment">//成功回调</span></span><br><span class="line">            &#125;</span><br><span class="line">            onError = &#123;</span><br><span class="line">                <span class="comment">//失败回调</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>主要利用kotlin扩展函数及DSL语法，封装协程异常处理，达到类似RxJava调用的效果<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> CoroutineScope.<span class="title">rxLaunch</span><span class="params">(<span class="keyword">init</span>: <span class="type">CoroutineBuilder</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> result = CoroutineBuilder&lt;T&gt;().apply(<span class="keyword">init</span>)</span><br><span class="line">    <span class="keyword">val</span> coroutineExceptionHandler = CoroutineExceptionHandler &#123; _, exception -&gt;</span><br><span class="line">        result.onError?.invoke(exception)</span><br><span class="line">    &#125;</span><br><span class="line">    launch(coroutineExceptionHandler) &#123;</span><br><span class="line">        <span class="keyword">val</span> res: T? = result.onRequest?.invoke()</span><br><span class="line">        res?.let &#123;</span><br><span class="line">            result.onSuccess?.invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineBuilder</span>&lt;<span class="type">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> onRequest: (<span class="keyword">suspend</span> () -&gt; T)? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> onSuccess: ((T) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> onError: ((Throwable) -&gt; <span class="built_in">Unit</span>)? = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上即是一个简单封装，可实现上面演示的目标效果<br>将请示，成功，失败分类展示，结构更加清晰，同时不需要写CoroutineExceptionHandler局部变量，更为优雅简洁   </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.cn/post/6922625944830083079" target="_blank" rel="noopener">[译] 关于 Kotlin Coroutines， 你可能会犯的 7 个错误</a><br><a href="https://juejin.cn/post/6930973078529720334" target="_blank" rel="noopener">安卓-kotlin协程的异常处理机制分析</a><br><a href="https://www.lukaslechner.com/why-exception-handling-with-kotlin-coroutines-is-so-hard-and-how-to-successfully-master-it/" target="_blank" rel="noopener">why-exception-handling-with-kotlin-coroutines-is-so-hard-and-how-to-successfully-master-it</a>    </p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Paging痛点：必须继承PagingDataAdapter吗？</title>
    <url>/blog/2021/03/paging-pain-points.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要包括以下内容<br>1.使用<code>Paging</code>必须继承<code>PagingDataAdapter</code>吗？<br>2.使用<code>AsyncPagingDataDiffer</code>实现<code>Paging</code>功能示例<br>3.更进一步，利用装饰模式实现<code>Paging</code>功能    </p>
<p>如果觉得本文对您有所帮助，请帮忙点赞，谢谢~</p>
<h2 id="使用Paging必须继承PagingDataAdapter吗？"><a href="#使用Paging必须继承PagingDataAdapter吗？" class="headerlink" title="使用Paging必须继承PagingDataAdapter吗？"></a>使用<code>Paging</code>必须继承<code>PagingDataAdapter</code>吗？</h2><p><code>Paging3</code>最近已经发布了beta版本，相信几个月内应该就会正式release了<br>使用<code>Paging3</code>可以比较方便地简化加载更多逻辑，可以更轻松的在<code>RecyclerView</code>中逐步妥善地加载数据    </p>
<p>最近在查阅关于<code>Paging3</code>的资料时，看到有不少文章说使用<code>Paging3</code>必须继承于<code>PagingAdapter</code>，这其实是错误的<br>如果我们点开<code>PagingDataAdapter</code>的源码，可以看到其实他的主要工作是由<code>AsyncPagingDataDiffer</code>完成的</p>
<blockquote>
<p>界面层中的主要 <code>Paging</code> 库组件是 <code>PagingDataAdapter</code>，它是一种处理分页数据的 <code>RecyclerView</code> 适配器。<br>此外，您也可以使用随附的 <code>AsyncPagingDataDiffer</code> 组件来构建自己的自定义适配器。</p>
</blockquote>
<p>由于在实际开发中，我们的<code>adapter</code>往往都已经有了自己的基类了，再继承<code>PagingDataAdapter</code>并不方便<br>所以实际开发中基于<code>AsyncPagingDataDiffer</code>来构建自己的自定义适配器是一个更加实用的选择     </p>
<h2 id="使用AsyncPagingDataDiffer自定义适配器"><a href="#使用AsyncPagingDataDiffer自定义适配器" class="headerlink" title="使用AsyncPagingDataDiffer自定义适配器"></a>使用<code>AsyncPagingDataDiffer</code>自定义适配器</h2><h3 id="1-首先看看原有的BaseAdapter"><a href="#1-首先看看原有的BaseAdapter" class="headerlink" title="1.首先看看原有的BaseAdapter"></a>1.首先看看原有的<code>BaseAdapter</code></h3><p>我们的项目中往往已经有了<code>Adapter</code>的基类，我们这里先定义一个简单的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseAdapter</span>&lt;<span class="type">T:DifferData,VH:RecyclerView.ViewHolder</span>&gt;:<span class="type">RecyclerView.Adapter</span>&lt;<span class="type">VH</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">var</span> mDataList = mutableListOf&lt;T&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setDataList</span><span class="params">(dataList:<span class="type">List</span>&lt;<span class="type">T</span>&gt;)</span></span>&#123;</span><br><span class="line">        mDataList = dataList.toMutableList()</span><br><span class="line">        notifyDataSetChanged()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mDataList.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">我们这里定义的`BaseAdapter`非常简单，只做模拟作用    </span><br><span class="line">主要就是支持`setDataList`功能，其他就没有什么了     </span><br><span class="line"></span><br><span class="line">### <span class="number">2</span>.自定义`PagingAdapter`</span><br><span class="line">我们可以通过我自定义`PagingAdapter`来实现`Paging`功能，同时继承于`BaseAdapter`,并不影响原有功能    </span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PagingAdapter</span>&lt;<span class="type">T:DifferData,VH:RecyclerView.ViewHolder</span>&gt; : <span class="type">BaseAdapter</span>&lt;<span class="type">T,VH</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> differ = AsyncPagingDataDiffer&lt;T&gt;(</span><br><span class="line">        diffCallback =DifferCallback(),</span><br><span class="line">        updateCallback = AdapterListUpdateCallback(<span class="keyword">this</span>),</span><br><span class="line">        mainDispatcher = Dispatchers.Main,</span><br><span class="line">        workerDispatcher = Dispatchers.Default</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">    	<span class="comment">//监听数据，加载成功后给BaseAdapter赋值</span></span><br><span class="line">        differ.addLoadStateListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.append <span class="keyword">is</span> LoadState.NotLoading) &#123;</span><br><span class="line">                <span class="keyword">val</span> items = differ.snapshot().items</span><br><span class="line">                setDataList(items)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">submitList</span><span class="params">(pagingData: <span class="type">PagingData</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        differ.submitData(pagingData)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">VH</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    	<span class="comment">//这一步必不可少，因为Paging就是通过getItem触发预加载的</span></span><br><span class="line">        differ.getItem(position)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>PagingAdapter</code>主要做了以下工作<br>1.定义<code>differ</code>，供后续<code>submitList</code>后更新数据使用<br>2.提供<code>submitList</code>方法更新数据<br>3.在<code>onBindViewHolder</code>中调用<code>getItem</code>，这一步是必不可少的，因为<code>Paging</code>预载下一页就是通过<code>getItem</code>触发的<br>4.监听加载状态，在加载成功后调用<code>setDataList</code>给BaseAdapter中赋值即可    </p>
<h3 id="3-使用自定义的PagingAdapter"><a href="#3-使用自定义的PagingAdapter" class="headerlink" title="3.使用自定义的PagingAdapter"></a>3.使用自定义的<code>PagingAdapter</code></h3><p>当我们要开发新的Adapter时，直接继承<code>PagingAdapter</code>即可<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoAdapter</span>:<span class="type">PagingAdapter</span>&lt;<span class="type">NewsBean.StoriesBean,DemoAdapter.ViewHolder</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>(itemView:View):RecyclerView.ViewHolder(itemView)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ViewHolder &#123;</span><br><span class="line">        <span class="keyword">return</span> ViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_news,parent,<span class="literal">false</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onBindViewHolder(holder, position)</span><br><span class="line">        holder.itemView.run &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = mDataList[position]</span><br><span class="line">            tv_title.text = <span class="keyword">data</span>.title</span><br><span class="line">            Glide.with(context).load(<span class="keyword">data</span>.images?.<span class="keyword">get</span>(<span class="number">0</span>)).into(iv_cover)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原本继承于<code>BaseAdapter</code>的<code>DemoAdapter</code>，几乎不用修改代码，改为继承于<code>PagingAdapter</code>,就实现了功能的增强，支持了自动预加载的功能  </p>
<h2 id="实现装饰模式实现Paging功能"><a href="#实现装饰模式实现Paging功能" class="headerlink" title="实现装饰模式实现Paging功能"></a>实现装饰模式实现Paging功能</h2><p>上文我们通过<code>AsyncPagingDataDiffer</code>自定义适配器，继承于<code>BaseAdapter</code>，实现了功能的增强，这样做有什么问题？    </p>
<h3 id="1-继承方式有什么问题？"><a href="#1-继承方式有什么问题？" class="headerlink" title="1.继承方式有什么问题？"></a>1.继承方式有什么问题？</h3><p>上文所用的方法，本质还是重重继承的方式   </p>
<ul>
<li>增加了继承层次，影响代码的可维护性<br>我们在<code>BaseAdapter</code>与<code>DemoAdapter</code>之间，又增加了一层<code>PagingAdapter</code>,如果我们以后要添加新功能时，可能又要增加新的<code>Adapter</code>基类，这是难以维护的       </li>
<li>子类的实现依赖于父类的实现，破坏了类的封装性<br>如果我们要搞清楚子类有哪些方法与属性，必须层层跟进阅读父类的代码，同时子类的实现依赖于父类的实现，如果父类修改会影响所有子类的逻辑，会带来不可预知的bug   </li>
</ul>
<h3 id="2-使用装饰方式实现"><a href="#2-使用装饰方式实现" class="headerlink" title="2.使用装饰方式实现"></a>2.使用装饰方式实现</h3><h4 id="1-首先定义一个PagingWrapAdapter"><a href="#1-首先定义一个PagingWrapAdapter" class="headerlink" title="1.首先定义一个PagingWrapAdapter"></a>1.首先定义一个<code>PagingWrapAdapter</code></h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PagingWrapAdapter</span>&lt;<span class="type">T : DifferData, VH : RecyclerView.ViewHolder</span>&gt;</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> innerAdapter: RecyclerView.Adapter&lt;VH&gt;,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> callback: ((List&lt;T&gt;) -&gt; <span class="built_in">Unit</span>)</span><br><span class="line">) : RecyclerView.Adapter&lt;VH&gt;() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> differ = AsyncPagingDataDiffer&lt;T&gt;(</span><br><span class="line">        diffCallback = DifferCallback(),</span><br><span class="line">        updateCallback = AdapterListUpdateCallback(<span class="keyword">this</span>),</span><br><span class="line">        mainDispatcher = Dispatchers.Main,</span><br><span class="line">        workerDispatcher = Dispatchers.Default</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        differ.addLoadStateListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.append <span class="keyword">is</span> LoadState.NotLoading) &#123;</span><br><span class="line">                <span class="keyword">val</span> items = differ.snapshot().items</span><br><span class="line">                callback.invoke(items)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">submitList</span><span class="params">(pagingData: <span class="type">PagingData</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        differ.submitData(pagingData)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: VH &#123;</span><br><span class="line">        <span class="keyword">return</span> innerAdapter.onCreateViewHolder(parent, viewType)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">VH</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        differ.getItem(position)</span><br><span class="line">        innerAdapter.onBindViewHolder(holder, position)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerAdapter.itemCount</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PagingWrapAdapter</code>主要做了以下工作<br>1.继承于<code>RecyclerView.Adapter</code>，并实现几个默认方法<br>2.构建’differ’，实现Paging功能<br>2.传入一个<code>innerAdapter</code>,将以上方法的实现由其代理实现   </p>
<p>UML图如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p3.png" alt></p>
<h4 id="2-调用方式"><a href="#2-调用方式" class="headerlink" title="2.调用方式"></a>2.调用方式</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> mAdapter <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    <span class="keyword">val</span> readAdapter = Demo2Adapter()</span><br><span class="line">    PagingWrapAdapter&lt;NewsBean.StoriesBean, Demo2Adapter.ViewHolder&gt;(readAdapter) &#123;</span><br><span class="line">        readAdapter.setDataList(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，原有的<code>adapter</code>不需要任何修改，只需要传入<code>PagingWrapAdapter</code>中，即可实现预加载功能   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于我们实际项目中的<code>adapter</code>常常已经有基类了，再去继承<code>PaginDataAdapter</code>并不方便<br>基于<code>AsyncPagingDataDiffer</code>构建自定义适配器是一个更好的选择    </p>
<p>使用继承方式也会带来可维护性等问题，更好的选择是使用装饰模式实现对功能的增强以达到:实现<code>Paging</code>功能并不修改原有代码的目标    </p>
<h3 id="Show-Me-The-Code"><a href="#Show-Me-The-Code" class="headerlink" title="Show Me The Code"></a>Show Me The Code</h3><p>本文所有代码可见：<a href="https://github.com/shenzhen2017/PagingAdapter" target="_blank" rel="noopener">PagingAdapter</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>MMKV缺陷：不支持getAll?</title>
    <url>/blog/2021/03/mmkv-disadvange-sum.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要包括以下内容<br>1.<code>MMKV</code>有什么缺陷？<br>2.使用<code>kotlin</code>委托优化<code>MMKV</code>调用的实用技巧</p>
<p>如果觉得本文对您有所帮助，请帮忙点赞，谢谢~</p>
<h2 id="MMKV有什么缺陷"><a href="#MMKV有什么缺陷" class="headerlink" title="MMKV有什么缺陷"></a><code>MMKV</code>有什么缺陷</h2><p>我们在之前介绍过，<code>MMKV</code>相比<code>SharedPreferences</code>有很多优点,比如<br>1.mmap防止数据丢失，提高读写效率;<br>2.精简数据，以最少的数据量表示最多的信息，减少数据大小;<br>3.增量更新，避免每次进行相对增量来说大数据量的全量写入。<br>详情可见：<a href="https://juejin.cn/post/6930168094983716877" target="_blank" rel="noopener">SharedPreferences替换:MMKV集成与原理</a>   </p>
<p><strong>那么MMKV有没有什么缺点？</strong><br>MMKV的主要缺点就在于它不支持<code>getAll</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, ?&gt; getAll() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"use allKeys() instead, getAll() not implement because type-erasure inside mmkv"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>MMKV</code>都是按字节进行存储的，实际写入文件把类型擦除了，这也是<code>MMKV</code>不支持<code>getAll</code>的原因   </p>
</blockquote>
<p>虽然说<code>getAll</code>用的不多问题不大，但是<code>MMKV</code>因此就不具备导出和迁移的能力了。<br>比如说，以后出了更优秀的存储框架，例如<code>DataStore</code>正式发布后，是没有办法直接从<code>MMKV</code>批量迁移到新框架的，除非代码里面写死一个个<code>key</code>迁移,这样是很麻烦的<br>所以在我们引入<code>MMKV</code>时，就应该考虑到将来可能的数据迁出   </p>
<h3 id="如何让MMKV支持getAll"><a href="#如何让MMKV支持getAll" class="headerlink" title="如何让MMKV支持getAll?"></a>如何让<code>MMKV</code>支持<code>getAll</code>?</h3><p>既然<code>MMKV</code>不支持<code>getAll</code>的原因是因为类型被擦除了，那最简单的思路就是加上类型<br><strong>我们可以在<code>key</code>上添加一个类型后缀</strong>   </p>
<p>但是如果我们强制规定写<code>key</code>时后面都添加上后缀是难以维护的，并且也很麻烦<br>一个更加优雅地方式是添加一个代理层，所有读写操作都代理给这个代理类，并在这里为<code>key</code>添加类型   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpProxy</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> mmkv: MMKV?) : SharedPreferences, SharedPreferences.Editor &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: MutableMap&lt;String, *&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> keys = mmkv?.allKeys()</span><br><span class="line">        <span class="keyword">val</span> map = mutableMapOf&lt;String, Any&gt;()</span><br><span class="line">        keys?.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (it.contains(<span class="string">"@"</span>)) &#123;</span><br><span class="line">                <span class="keyword">val</span> typeList = it.split(<span class="string">"@"</span>)</span><br><span class="line">                <span class="keyword">when</span> (typeList[typeList.size - <span class="number">1</span>]) &#123;</span><br><span class="line">                    String::<span class="class"><span class="keyword">class</span>.<span class="title">simpleName</span> -&gt; <span class="title">map</span>[<span class="title">it</span>] = <span class="title">getString</span></span>(it, <span class="string">""</span>) ?: <span class="string">""</span></span><br><span class="line">                    <span class="built_in">Int</span>::<span class="class"><span class="keyword">class</span>.<span class="title">simpleName</span> -&gt; <span class="title">map</span>[<span class="title">it</span>] = <span class="title">getInt</span></span>(it, <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">Long</span>::<span class="class"><span class="keyword">class</span>.<span class="title">simpleName</span> -&gt; <span class="title">map</span>[<span class="title">it</span>] = <span class="title">getLong</span></span>(it, <span class="number">0L</span>)</span><br><span class="line">                    <span class="built_in">Float</span>::<span class="class"><span class="keyword">class</span>.<span class="title">simpleName</span> -&gt; <span class="title">map</span>[<span class="title">it</span>] = <span class="title">getFloat</span></span>(it, <span class="number">0f</span>)</span><br><span class="line">                    <span class="built_in">Boolean</span>::<span class="class"><span class="keyword">class</span>.<span class="title">simpleName</span> -&gt; <span class="title">map</span>[<span class="title">it</span>] = <span class="title">getBoolean</span></span>(it, <span class="literal">false</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getString</span><span class="params">(key: <span class="type">String</span>?, defValue: <span class="type">String</span>?)</span></span>: String? &#123;</span><br><span class="line">        <span class="keyword">val</span> typeKey = getTypeKey&lt;String&gt;(key)</span><br><span class="line">        <span class="keyword">return</span> mmkv?.getString(typeKey, defValue)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getBoolean</span><span class="params">(key: <span class="type">String</span>?, defValue: <span class="type">Boolean</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> typeKey = getTypeKey&lt;<span class="built_in">Boolean</span>&gt;(key)</span><br><span class="line">        <span class="keyword">return</span> mmkv?.getBoolean(typeKey, defValue) ?: defValue</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">contains</span><span class="params">(key: <span class="type">String</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> realKey = getRealKey(key)</span><br><span class="line">        <span class="keyword">return</span> realKey.isNotEmpty()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">edit</span><span class="params">()</span></span>: SharedPreferences.Editor? &#123;</span><br><span class="line">        <span class="keyword">return</span> mmkv?.edit()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">putString</span><span class="params">(key: <span class="type">String</span>?, value: <span class="type">String</span>?)</span></span>: SharedPreferences.Editor? &#123;</span><br><span class="line">        <span class="keyword">val</span> typeKey = getTypeKey&lt;String&gt;(key)</span><br><span class="line">        <span class="keyword">return</span> mmkv?.putString(typeKey, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">putBoolean</span><span class="params">(key: <span class="type">String</span>?, value: <span class="type">Boolean</span>)</span></span>: SharedPreferences.Editor? &#123;</span><br><span class="line">        <span class="keyword">val</span> typeKey = getTypeKey&lt;<span class="built_in">Boolean</span>&gt;(key)</span><br><span class="line">        <span class="keyword">return</span> mmkv?.putBoolean(typeKey, value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(key: <span class="type">String</span>?)</span></span>: SharedPreferences.Editor? &#123;</span><br><span class="line">        <span class="keyword">val</span> realKey = getRealKey(key)</span><br><span class="line">        <span class="keyword">if</span> (realKey.isNotEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> mmkv?.remove(realKey)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span>: SharedPreferences.Editor? &#123;</span><br><span class="line">        <span class="keyword">return</span> mmkv?.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">getTypeKey</span><span class="params">(key: <span class="type">String</span>?)</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">val</span> type = <span class="string">"@"</span> + T::<span class="class"><span class="keyword">class</span>.<span class="title">simpleName</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (key?.contains(type) == <span class="literal">true</span>) &#123;</span><br><span class="line">            type</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key + type</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getRealKey</span><span class="params">(key: <span class="type">String</span>?)</span></span>:String&#123;</span><br><span class="line">        <span class="keyword">val</span> typeKys = listOf(getTypeKey&lt;String&gt;(key),getTypeKey&lt;<span class="built_in">Long</span>&gt;(key),getTypeKey&lt;<span class="built_in">Float</span>&gt;(key),getTypeKey&lt;<span class="built_in">Int</span>&gt;(key),getTypeKey&lt;<span class="built_in">Boolean</span>&gt;(key))</span><br><span class="line">        typeKys.forEach &#123;</span><br><span class="line">            <span class="keyword">if</span> (mmkv?.containsKey(it)==<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> it</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示：<br>1.所有读写操作都基于<code>SpProxy</code>来做<br>2.<code>key</code>尾部添加类型字段通过<code>getTypeKey</code>方法实现<br>3.支持<code>getAll</code>方法，方便后续迁移<br>4.<code>mmkv</code>的操作全都封装在<code>SpProxy</code>类里了，后续如果要迁移到其他类，修改<code>SpProxy</code>即可，外部可完全不用修改  </p>
<p>计算机软件中所有问题都可以通过添加一个中间层来解决，为<code>SharedPreferences</code>封装一个代理层，可以有效地拓展我们项目的扩展性      </p>
<h3 id="如何迁移老数据"><a href="#如何迁移老数据" class="headerlink" title="如何迁移老数据"></a>如何迁移老数据</h3><p><code>MMKV</code>为我们提供了<code>importFromSharedPreferences</code>方法来从<code>SharedPreferences</code>迁移到<code>MMKV</code><br>但如果直接调用这个方法迁移，那么数据类型就丢失了，下面提供一个新的迁移方法    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">migrate</span><span class="params">(migrateSp:<span class="type">SpProxy</span>,preferences: <span class="type">SharedPreferences</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> kvs = preferences.all</span><br><span class="line">   <span class="keyword">if</span> (kvs != <span class="literal">null</span> &amp;&amp; kvs.isNotEmpty()) &#123;</span><br><span class="line">       <span class="keyword">val</span> iterator = kvs.entries.iterator()</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">val</span> entry = iterator.next()</span><br><span class="line">            <span class="keyword">val</span> key = entry.key</span><br><span class="line">            <span class="keyword">val</span> value = entry.value</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; value != <span class="literal">null</span>) &#123;</span><br><span class="line">                migrateSp.run &#123;</span><br><span class="line">                    <span class="keyword">when</span> (value) &#123;</span><br><span class="line">                        <span class="keyword">is</span> <span class="built_in">Boolean</span> -&gt; <span class="keyword">this</span>.putBoolean(key, value)</span><br><span class="line">                        <span class="keyword">is</span> <span class="built_in">Int</span> -&gt;  <span class="keyword">this</span>.putInt(key,value)</span><br><span class="line">                        <span class="keyword">is</span> <span class="built_in">Long</span> -&gt; <span class="keyword">this</span>.putLong(key,value)</span><br><span class="line">                        <span class="keyword">is</span> <span class="built_in">Float</span> -&gt; <span class="keyword">this</span>.putFloat(key, value)</span><br><span class="line">                        <span class="keyword">is</span> String -&gt; <span class="keyword">this</span>.putString(key,value)</span><br><span class="line">                        <span class="keyword">else</span> -&gt; &#123;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kvs.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示：支持从<code>SharedPreferences</code>迁移数据到MMKV并保留类型</p>
<h2 id="利用委托优化存取操作"><a href="#利用委托优化存取操作" class="headerlink" title="利用委托优化存取操作"></a>利用委托优化存取操作</h2><p>我们一般利用<code>SharedPreferences</code>存取数据是这样写的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> KEY_DEMO_STR = <span class="string">"key_demo_STR"</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setDemoStr</span><span class="params">(str: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    edit.putString(KEY_DEMO_STR, str).apply()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getDemoStr</span><span class="params">()</span></span>: String? &#123;</span><br><span class="line">    <span class="keyword">return</span> preferences.getString(KEY_DEMO_STR, <span class="string">""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们需要定义一个<code>key</code>，然后再定义<code>set</code>与<code>get</code>方法<br>这样一个简单的操作就需要8行代码了，但如果我们利用委托机制可以实现一行搞定    </p>
<h3 id="一行搞定数据存取"><a href="#一行搞定数据存取" class="headerlink" title="一行搞定数据存取"></a>一行搞定数据存取</h3><p>优化后的代码实现数据存取可以一行搞定<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> TestSP : PreferenceHolder() &#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="built_in">Long</span> <span class="keyword">by</span> bindToPreferenceField(<span class="number">0L</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取sp</span></span><br><span class="line"><span class="keyword">val</span> value = TestSP.value</span><br><span class="line">println(value) <span class="comment">// 0 or 100</span></span><br><span class="line"><span class="comment">//存入sp</span></span><br><span class="line">TestSP.value = <span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<p>如上所示，通过变量<code>value</code>的读取与赋值即可实现数据的存取<br>这背后的原理是根据变量名生成<code>key</code>，然后将数据地存取操作委托给了<code>ReadWriteProperty</code><br>然后在其中的<code>getValue</code>与<code>setValue</code>中调用<code>mmkv</code>或<code>SharedPreferences</code>相关方法来实现真正的存储与读取    </p>
<p>这样做的优点在于<br>1.避免定义大量字符串key和出现重复key<br>2.简洁的委托模式不用再书写get(..) set(..)<br>3.后续如果需要修改代码，修改委托类即可，项目中的其他代码不需要变动，增强了扩展性    </p>
<p>详情可见：<a href="https://github.com/shenzhen2017/Preferences" target="_blank" rel="noopener">Preferences委托优化</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要讲述了<code>MMKV</code>的缺陷：即不支持<code>getAll</code>导致后续迁移困难及解决方案<br>同时介绍了利用委托优化数据存取API调用的经验     </p>
<h3 id="Show-Me-The-Code"><a href="#Show-Me-The-Code" class="headerlink" title="Show Me The Code"></a>Show Me The Code</h3><p>本文代码可见：<a href="https://github.com/shenzhen2017/Preferences/blob/master/preferences/src/main/java/com/forjrking/preferences/kt/SpProxy.kt" target="_blank" rel="noopener">SpProxy</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6857432013424001038" target="_blank" rel="noopener">SharedPreferences用Kotlin应该这样写</a><br><a href="https://juejin.cn/post/6887800985272451086" target="_blank" rel="noopener">来聊一聊MMKV的不足以及线下调试工具</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>7个你应该知道的Gradle实用技巧</title>
    <url>/blog/2021/04/gradle-sum-up.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Gradle</code>在<code>android</code>开发中应用地十分广泛，但相信有很多同学并不很了解<code>gradle</code><br>本文主要介绍了使用<code>gradle</code>的一些实用技巧，帮助读者增进对这个熟悉的陌生人的了解<br>主要包括以下内容   </p>
<ul>
<li>1.<code>Gradle</code>依赖树查询</li>
<li>2.使用循环优化<code>Gradle</code>依赖管理</li>
<li>3.支持代码提示的<code>Gradle</code>依赖管理</li>
<li>4.<code>Gradle</code>模块化</li>
<li>5.<code>Library</code>模块<code>Gradle</code>代码复用</li>
<li>6.资源文件分包</li>
<li>7.<code>AAR</code>依赖与源码依赖快速切换</li>
</ul>
<h2 id="1-Gradle依赖树查询"><a href="#1-Gradle依赖树查询" class="headerlink" title="1.Gradle依赖树查询"></a>1.<code>Gradle</code>依赖树查询</h2><p>有时我们在分析依赖冲突时，需要查看依赖树，我们常用的查看依赖树的命令为<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">gradlew <span class="string">app:</span>dependencies</span><br></pre></td></tr></table></figure></p>
<p>不过这种命令行方式查看依赖树出来的信息太多，看的有些费劲<br>所以官方又推出了<code>Scan</code>工具来帮助我们更加方便地查看依赖树<br>在项目根目录位置下运行<code>gradle build --scan</code>即可，然后会生成 <code>HTML</code> 格式的分析文件的分析文件  </p>
<p>分析文件会直接上传到<code>Scan</code>官网，命令行最后会给出远程地址<br>第一次跑会让你在 <code>Scan</code> 官网注册一下，邮件确认后就能看了<br><code>scan</code> 工具是按照依赖变体挨个分类的，<code>debugCompileClassPath</code> 就是 <code>dedug</code> 打包中的依赖包了<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559c9e60f6604600958f09cd16420229~tplv-k3u1fbpfcp-watermark.image" alt><br>如上，使用这种方式分析依赖树更加方便简洁   </p>
<h2 id="2-使用循环优化Gradle依赖管理"><a href="#2-使用循环优化Gradle依赖管理" class="headerlink" title="2.使用循环优化Gradle依赖管理"></a>2.使用循环优化<code>Gradle</code>依赖管理</h2><p>如下所示，我们常常使用<code>ext</code>来管理依赖<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">include:</span> [<span class="string">'*.jar'</span>], <span class="string">dir:</span> <span class="string">'libs'</span>)</span><br><span class="line">    implementation rootProject.ext.dependencies[<span class="string">"appcompat-v7"</span>]</span><br><span class="line">    implementation rootProject.ext.dependencies[<span class="string">"cardview-v7"</span>]</span><br><span class="line">    implementation rootProject.ext.dependencies[<span class="string">"design"</span>]</span><br><span class="line">    implementation rootProject.ext.dependencies[<span class="string">"constraint-layout"</span>]</span><br><span class="line">    annotationProcessor rootProject.ext.dependencies[<span class="string">"glide_compiler"</span>]</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样虽然实现了依赖的统一管理，但是随着项目越来越大，依赖也会越来越多，常常会有几十甚至上百行，导致<code>build.gradle</code>越来越长     </p>
<p>有没有一种好的方式不在 <code>build.gradle</code> 中写这么多的依赖配置？<br>有，就是使用循环遍历依赖。<br>示例如下，首先添加<code>config.gradle</code><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">ext&#123;</span><br><span class="line">	dependencies = [</span><br><span class="line">            <span class="comment">// base</span></span><br><span class="line">            <span class="string">"appcompat-v7"</span>                      : <span class="string">"com.android.support:appcompat-v7:$&#123;version["</span>supportLibraryVersion<span class="string">"]&#125;"</span>，</span><br><span class="line">            ...</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    annotationProcessor = [</span><br><span class="line">            <span class="string">"glide_compiler"</span>                    : <span class="string">"com.github.bumptech.glide:compiler:$&#123;version["</span>glideVersion<span class="string">"]&#125;"</span>,</span><br><span class="line">            ...</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    apiFileDependencies = [</span><br><span class="line">            <span class="string">"launchstarter"</span>                                   :<span class="string">"libs/launchstarter-release-1.0.0.aar"</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    debugImplementationDependencies = [</span><br><span class="line">            <span class="string">"MethodTraceMan"</span>                                  : <span class="string">"com.github.zhengcx:MethodTraceMan:1.0.7"</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    implementationExcludes = [</span><br><span class="line">            <span class="string">"com.android.support.test.espresso:espresso-idling-resource:3.0.2"</span> : [</span><br><span class="line">                    <span class="string">'com.android.support'</span> : <span class="string">'support-annotations'</span></span><br><span class="line">            ]</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在<code>build.gradle</code>中配置如下：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply from config.gradle</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> implementationDependencies = project.ext.dependencies</span><br><span class="line"><span class="keyword">def</span> processors = project.ext.annotationProcesso</span><br><span class="line"><span class="keyword">def</span> implementationExcludes = project.ext.implementationExcludes</span><br><span class="line">dependencies&#123;</span><br><span class="line">    <span class="comment">// 处理所有的 xxximplementation 依赖</span></span><br><span class="line">    implementationDependencies.each &#123; k, v -&gt; implementation v &#125;   </span><br><span class="line">    <span class="comment">// 处理 annotationProcessor 依赖</span></span><br><span class="line">    processors.each &#123; k, v -&gt; annotationProcessor v &#125;</span><br><span class="line">    <span class="comment">// 处理所有包含 exclude 的依赖</span></span><br><span class="line">    implementationExcludes.each &#123; entry -&gt;</span><br><span class="line">        implementation(entry.key) &#123;</span><br><span class="line">            entry.value.each &#123; childEntry -&gt;</span><br><span class="line">                exclude(<span class="string">group:</span> childEntry)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做的优点在于<br>1.后续添加依赖不需要改动<code>build.gradle</code>,直接在<code>config.gradle</code>中添加即可<br>2.精简了<code>build.gradle</code>的长度   </p>
<h2 id="3-支持代码提示的Gradle依赖管理"><a href="#3-支持代码提示的Gradle依赖管理" class="headerlink" title="3.支持代码提示的Gradle依赖管理"></a>3.支持代码提示的<code>Gradle</code>依赖管理</h2><p>上面介绍了通过<code>config.gradle</code>管理依赖的方法<br>在我们添加<code>Gradle</code>依赖时，还有一些痛点<br>1.不支持代码提示<br>2.不支持单击跳转<br>3.多模块开发时，不现模块相同的依赖需要复制粘贴   </p>
<p>使用<code>buildSrc</code>+<code>kotlin</code>可以解决这个问题<br>效果如下：<br><img src="https://user-gold-cdn.xitu.io/2020/5/27/172543b2eb81973a?imageslim" alt><br>由于<code>buildSrc</code>是对全局的所有<code>module</code>的配置,所以可以在所有<code>module</code>中直接使用   </p>
<p>这里就不多介绍了，详细开发及引入<code>buildSrc</code>的过程可见:<br><a href="https://juejin.cn/post/6844903615346245646#heading-0" target="_blank" rel="noopener">[译]Kotlin + buildSrc：更好的管理Gadle依赖</a>   </p>
<h3 id="buildSrc-vs-includeBuild"><a href="#buildSrc-vs-includeBuild" class="headerlink" title="buildSrc vs includeBuild"></a><code>buildSrc</code> vs <code>includeBuild</code></h3><p>上面介绍的方法使用的是<code>buildSrc</code>,使用起来比较方便<br>不过它的缺点在于构建速度上会慢一些，使用<code>includeBuild</code>可以实现同样的效果<br>两者实现的最终效果是差不多的，详细实现可见:<a href="https://juejin.cn/post/6844904169833234439" target="_blank" rel="noopener">【奇技淫巧】除了 buildSrc 还能这样统一配置依赖版本？巧用 includeBuild</a></p>
<h2 id="4-Gradle模块化"><a href="#4-Gradle模块化" class="headerlink" title="4.Gradle模块化"></a>4.<code>Gradle</code>模块化</h2><p>我们在开发中，引入一些插件时，有时需要在<code>build.gradle</code>中引入一些配置，比如<code>greendao</code>,推送,<code>tinker</code>等<br>这些其实是可以封装在相应<code>gradle</code>文件中，然后通过<code>apply from</code>引入<br>举个例子，例如在我们使用<code>greendao</code>数据库时，需要在<code>build.gradle</code>中指定版本     </p>
<p>这种时候应该新建一个<code>greendao-config.gradle</code><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'org.greenrobot.greendao'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//greenDao指定版本和路劲等</span></span><br><span class="line">greendao &#123;</span><br><span class="line">    <span class="comment">//数据库的schema版本，也可以理解为数据库版本号</span></span><br><span class="line">    schemaVersion <span class="number">1</span></span><br><span class="line">    <span class="comment">//设置DaoMaster、DaoSession、Dao包名，也就是要放置这些类的包的全路径。</span></span><br><span class="line">    daoPackage <span class="string">'com.example.ausu.big_progect.dao'</span></span><br><span class="line">    <span class="comment">//设置DaoMaster、DaoSession、Dao目录</span></span><br><span class="line">    targetGenDir <span class="string">'src/main/java'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后再在<code>build.gradle</code>中引入<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply from <span class="string">'greendao-config.gradle'</span></span><br></pre></td></tr></table></figure></p>
<p>这样做主要有2个优点<br>1.单一职责原则，将<code>greendao</code>的相关配置封装在一个文件里，不与其他文件混淆<br>2.精简了<code>build.gradle</code>的代码，同时后续修改数据库相关时不需要修改<code>build.gradle</code>的代码</p>
<h2 id="5-Library模块Gradle代码复用"><a href="#5-Library模块Gradle代码复用" class="headerlink" title="5.Library模块Gradle代码复用"></a>5.<code>Library</code>模块<code>Gradle</code>代码复用</h2><p>随着我们项目的越来越大，<code>Library Module</code>也越建越多，每个<code>Module</code>都有自己的<code>build.gradle</code><br>但其实每个<code>build.gradle</code>的内容都差不多，我们能不能将重复的部分封装起来复用？   </p>
<p>我们可以做一个 <code>basic</code> 抽取，同样将共有参数/信息提取到 <code>basic.gradle</code> 中，每个 <code>module</code> <code>apply</code>，这样就是减少了不少代码量    </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-android-extensions'</span></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'kotlin-kapt'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// 指定用于编译项目的 API 级别</span></span><br><span class="line">    compileSdkVersion Versions.compileSDK</span><br><span class="line">    <span class="comment">// 指定在生成项目时要使用的 SDK 工具的版本，Android Studio 3.0 后不需要手动配置。</span></span><br><span class="line">    buildToolsVersion Versions.buildTools</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定 Android 插件适用于所有构建版本的版本属性的默认值</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion Versions.minSDK</span><br><span class="line">        targetSdkVersion Versions.targetSDK</span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">"1.0"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 Java 编译(编码格式、编译级别、生成字节码版本)</span></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        encoding = <span class="string">'utf-8'</span></span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = JavaVersion.VERSION_1_8.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        <span class="comment">// lint 异常后继续执行</span></span><br><span class="line">        abortOnError <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(<span class="string">dir:</span> <span class="string">'libs'</span>, <span class="string">include:</span> [<span class="string">'*.jar'</span>])</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在相应的模块的<code>build.gradle</code>中引入即可<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">from:</span><span class="string">"../basic.gradle"</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    api Deps.constraintLayout</span><br><span class="line">    api Deps.retrofit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样是不是简洁很多？读者可根据项目实际情况判断是否适合抽取<code>basic.gradle</code>使用    </p>
<h2 id="6-资源文件分包"><a href="#6-资源文件分包" class="headerlink" title="6.资源文件分包"></a>6.资源文件分包</h2><p>随着项目越来越大，项目中的资源文件也越来越大，比如<code>layout</code>与<code>drawable</code>文件夹下的文件数量常常可达几百甚至上千个<br>我们能不能像代码一样，对资源文件进行分包呢？    </p>
<p>答案是可以的，主要是利用<code>gradle</code>的<code>sourceSets</code>属性<br>我们可以将资源文件像代码一样按业务分包,具体操作如下    </p>
<p>1.新建res_xxx目录<br><img src="https://user-gold-cdn.xitu.io/2019/2/21/1690ef7f0ab38477?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>在 <code>main</code> 目录下新建 <code>res_core</code>, <code>res_feed</code>（根据业务模块命名）等目录，在<code>res_core</code>中新建<code>res</code>目录中相同的文件夹如：<code>layout</code>、<code>drawable-xxhdpi</code>、<code>values</code>等。   </p>
<p>2.在<code>gradle</code>中配置<code>res_xx</code>目录<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            res.srcDirs(</span><br><span class="line">                    <span class="string">'src/main/res'</span>,</span><br><span class="line">                    <span class="string">'src/main/res_core'</span>,</span><br><span class="line">                    <span class="string">'src/main/res_feed'</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就完成了资源文件分包,这样做主要有几点好处<br>1.按业务分包查找方便，结构清晰<br>2.<code>strings.xml</code>等<code>key-value</code>型文件多人修改可以减少冲突<br>3.当删除模块或做组件化改造时资源文件删除或迁移方便，不必像以前一样一个个去找    </p>
<h2 id="7-AAR依赖与源码依赖快速切换"><a href="#7-AAR依赖与源码依赖快速切换" class="headerlink" title="7.AAR依赖与源码依赖快速切换"></a>7.<code>AAR</code>依赖与源码依赖快速切换</h2><p>当我们的项目中<code>Module</code>越来越多，为了加快编译速度，常常把<code>Module</code>发布成<code>AAR</code>，然后在项目中直接依赖<code>AAR</code><br>但是我们有时候又需要修改<code>AAR</code>，就需要依赖于源码<br>所以我们需要一个可以快速地切换依赖<code>AAR</code>与依赖源码的方式    </p>
<p>我们下面举个例子，以<code>retrofit</code>为例<br>假如我们要修改<code>retrofit</code>的源码，修改步骤如下：<br>1.首先下载<code>retrofit</code>，可以放到和项目同级的目录,并修改目录名为<code>retrofit-source</code>,以便区分<br>2.在<code>settings.gradle</code>文件中添加需要修改的<code>aar</code>库的源码<code>project</code><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include <span class="string">':retrofit-source'</span></span><br><span class="line">project(<span class="string">':retrofit-source'</span>).projectDir = <span class="keyword">new</span> File(<span class="string">"../retrofit-source"</span>)</span><br></pre></td></tr></table></figure></p>
<p>3.替换<code>aar</code>为源码<br><code>build.gradle(android)</code> 脚本中添加替换策略<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    configurations.all &#123;</span><br><span class="line">        resolutionStrategy &#123;</span><br><span class="line">            dependencySubstitution &#123;</span><br><span class="line">                substitute module( <span class="string">"com.squareup.retrofit2:retrofit"</span>) with project(<span class="string">':retofit-source'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上几步，就可以比较方便地实现<code>aar</code>依赖与源码依赖间的互换了<br>这样做的主要优点在于<br>1.不需要修改原有的依赖配置，而是通过全局的配置，利用本地的源码替换掉<code>aar</code>，侵入性低<br>2.如果有多个<code>Module</code>依赖于同一个<code>aar</code>，不需要重复修改，只需在根目录<code>build.gradle</code>中修改一处   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了几个实用的<code>Gradle</code>技巧，如果觉得有所帮助，可以帮忙点赞<br>如果发现本文还有什么不足，欢迎在评论区指出~   </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6895299152226615309#heading-3" target="_blank" rel="noopener">Gradle Scan使用介绍</a><br><a href="https://juejin.cn/post/6844904122492125198#heading-24" target="_blank" rel="noopener">使用循环进行依赖优化</a><br><a href="https://juejin.cn/post/6872721978898743310#heading-11" target="_blank" rel="noopener">Android 重构 ｜ 持续优化统一管理 Gradle</a><br><a href="https://juejin.cn/post/6844903780547297288" target="_blank" rel="noopener">Android res 资源 分包</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【从入门到放弃】android布局优化深入解析</title>
    <url>/blog/2021/04/android-ui-monitor.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android的绘制优化其实可以分为两个部分，即布局(UI)优化和卡顿优化，而布局优化的核心问题就是要解决因布局渲染性能不佳而导致应用卡顿的问题，所以它可以认为是卡顿优化的一个子集。<br>本文主要包括以下内容<br>1.为什么要进行布局优化及android绘制，布局加载原理<br>2.获取布局文件加载耗时的方法<br>3.介绍一些布局优化的手段与方法<br>4.为什么放弃使用这些优化方法?</p>
<h2 id="1-为什么要进行布局优化？"><a href="#1-为什么要进行布局优化？" class="headerlink" title="1.为什么要进行布局优化？"></a>1.为什么要进行布局优化？</h2><p>为什么要进行布局优化？<br>答案是显而易见的，如果布局嵌套过深，或者其他原因导致布局渲染性能不佳，可能会导致应用卡顿<br>那么布局到底是如何导致渲染性能不佳的呢？首先我们应该了解下<code>android</code>绘制原理与布局加载原理         </p>
<h3 id="android绘制原理"><a href="#android绘制原理" class="headerlink" title="android绘制原理"></a><code>android</code>绘制原理</h3><p><code>Android</code>的屏幕刷新中涉及到最重要的三个概念（为便于理解，这里先做简单介绍）     </p>
<ul>
<li><code>CPU</code>：执行应用层的<code>measure</code>、<code>layout</code>、<code>draw</code>等操作，绘制完成后将数据提交给<code>GPU</code></li>
<li><code>GPU</code>：进一步处理数据，并将数据缓存起来</li>
<li>屏幕：由一个个像素点组成，以固定的频率（16.6ms，即1秒60帧）从缓冲区中取出数据来填充像素点</li>
</ul>
<p>总结一句话就是：<code>CPU</code> 绘制后提交数据、<code>GPU</code> 进一步处理和缓存数据、最后屏幕从缓冲区中读取数据并显示<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p11.webp" alt>  </p>
<h3 id="双缓冲机制"><a href="#双缓冲机制" class="headerlink" title="双缓冲机制"></a>双缓冲机制</h3><p>看完上面的流程图，我们很容易想到一个问题，屏幕是以16.6ms的固定频率进行刷新的，但是我们应用层触发绘制的时机是完全随机的（比如我们随时都可以触摸屏幕触发绘制）.<br>如果在<code>GPU</code>向缓冲区写入数据的同时，屏幕也在向缓冲区读取数据，会发生什么情况呢？<br>有可能屏幕上就会出现一部分是前一帧的画面，一部分是另一帧的画面，这显然是无法接受的，那怎么解决这个问题呢？</p>
<p>所以，在屏幕刷新中，<strong><code>Android</code>系统引入了双缓冲机制</strong>    </p>
<p><code>GPU</code>只向<code>Back Buffer</code>中写入绘制数据，且<code>GPU</code>会定期交换<code>Back Buffer</code>和<code>Frame Buffer</code>，交换的频率也是60次/秒，这就与屏幕的刷新频率保持了同步。<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p12.webp" alt><br>虽然我们引入了双缓冲机制，但是我们知道，当布局比较复杂，或设备性能较差的时候，<code>CPU</code>并不能保证在16.6ms内就完成绘制数据的计算，所以这里系统又做了一个处理。<br>当你的应用正在往<code>Back Buffer</code>中填充数据时，系统会将<code>Back Buffer</code>锁定。<br>如果到了<code>GPU</code>交换两个<code>Buffer</code>的时间点，你的应用还在往<code>Back Buffer</code>中填充数据，<code>GPU</code>会发现<code>Back Buffer</code>被锁定了，它会放弃这次交换。     </p>
<p>这样做的后果就是手机屏幕仍然显示原先的图像，这就是我们常常说的掉帧   </p>
<h3 id="布局加载原理"><a href="#布局加载原理" class="headerlink" title="布局加载原理"></a>布局加载原理</h3><p>由上面可知，导致掉帧的原因是<code>CPU</code>无法在16.6ms内完成绘制数据的计算。<br>而之所以布局加载可能会导致掉帧，正是因为它在主线程上进行了耗时操作，可能导致<code>CPU</code>无法按时完成数据计算    </p>
<p>布局加载主要通过<code>setContentView</code>来实现，我们就不在这里贴源码了，一起来看看它的时序图<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p1.webp" alt><br>我们可以看到，在<code>setContentView</code>中主要有两个耗时操作     </p>
<ul>
<li>1.解析<code>xml</code>,获取<code>XmlResourceParser</code>,这是IO过程</li>
<li>2.通过<code>createViewFromTag</code>,创建<code>View</code>对象，用到了反射</li>
</ul>
<p>以上两点就是布局加载可能导致卡顿的原因，也是布局的性能瓶颈    </p>
<h2 id="2-获取布局文件加载耗时的方法"><a href="#2-获取布局文件加载耗时的方法" class="headerlink" title="2.获取布局文件加载耗时的方法"></a>2.获取布局文件加载耗时的方法</h2><p>我们如果需要优化布局卡顿问题，首先最重要的就是：<strong>确定定量标准</strong><br>所以我们首先介绍几种获取布局文件加载耗时的方法    </p>
<h3 id="常规获取"><a href="#常规获取" class="headerlink" title="常规获取"></a>常规获取</h3><p>首先介绍一下常规方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> start = System.currentTimeMillis()</span><br><span class="line">setContentView(R.layout.activity_layout_optimize)</span><br><span class="line"><span class="keyword">val</span> inflateTime = System.currentTimeMillis() - start</span><br></pre></td></tr></table></figure></p>
<p>这种方法很简单，因为<code>setContentView</code>是同步方法，如果想要计算耗时，直接将前后时间计算相减即可得到结果了     </p>
<h3 id="AOP-Aspectj-ASM"><a href="#AOP-Aspectj-ASM" class="headerlink" title="AOP(Aspectj,ASM)"></a><code>AOP</code>(<code>Aspectj</code>,<code>ASM</code>)</h3><p>上面的方式虽然简单，但是却不够优雅，同时代码有侵入性，如果要对所有Activity测量时，就需要在基类中复写相关方法了，比较麻烦了<br>下面介绍一种<code>AOP</code>的方式计算耗时<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* android.app.Activity.setContentView(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSetContentViewTime</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    Signature signature = joinPoint.getSignature();</span><br><span class="line">    String name = signature.toShortString();</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(<span class="string">"aop inflate"</span>,name + <span class="string">" cost "</span> + (System.currentTimeMillis() - time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面用的<code>Aspectj</code>，比较简单，上面的注解的意思是在<code>setContentView</code>方法执行内部去调用我们写好的<code>getSetContentViewTime</code>方法<br>这样就可以获取相应的耗时<br>我们可以看下打印的日志<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">I/aop</span> <span class="attr">inflate:</span> <span class="string">AppCompatActivity.setContentView(..)</span> <span class="string">cost</span> <span class="number">69</span></span><br><span class="line"><span class="string">I/aop</span> <span class="attr">inflate:</span> <span class="string">AppCompatActivity.setContentView(..)</span> <span class="string">cost</span> <span class="number">25</span></span><br></pre></td></tr></table></figure></p>
<p>这样就可以实现无侵入的监控每个页面布局加载的耗时<br>具体源码可见文末     </p>
<h3 id="获取任一控件耗时"><a href="#获取任一控件耗时" class="headerlink" title="获取任一控件耗时"></a>获取任一控件耗时</h3><p>有时为了更精确的知道到底是哪个控件加载耗时，比如我们新添加了自定义<code>View</code>,需要监控它的性能<br>我们可以利用<code>setFactory2</code>来监听每个控件的加载耗时<br>首先我们来回顾下<code>setContentView</code>方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">tryCreateView</span><span class="params">(@Nullable View parent, @NonNull String name,</span></span></span><br><span class="line"><span class="function"><span class="params">  	...</span></span></span><br><span class="line"><span class="function"><span class="params">    View view;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">        view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        view = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在真正进行反射实例化<code>xml</code>结点前，会调用<code>mFactory2</code>的<code>onCreateView</code>方法<br>这样如果我们重写<code>onCreateView</code>方法，在其前后加上耗时统计，即可获取每个控件的加载耗时<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initItemInflateListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LayoutInflaterCompat.setFactory2(layoutInflater, <span class="keyword">object</span> : Factory2 &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            parent: <span class="type">View</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">            name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            context: <span class="type">Context</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            attrs: <span class="type">AttributeSet</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span>: View? &#123;</span><br><span class="line">            <span class="keyword">val</span> time = System.currentTimeMillis()</span><br><span class="line">            <span class="keyword">val</span> view = delegate.createView(parent, name, context, attrs)</span><br><span class="line">            Log.i(<span class="string">"inflate Item"</span>,name + <span class="string">" cost "</span> + (System.currentTimeMillis() - time))</span><br><span class="line">            <span class="keyword">return</span> view</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(name: <span class="type">String</span>, context: <span class="type">Context</span>, attrs: <span class="type">AttributeSet</span>)</span></span>: View? &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示：真正的创建<code>View</code>的方法，仍然是调用<code>delegate.createView</code>,我们只是其之前与之后做了埋点<br>注意，<code>initItemInflateListener</code>需要在<code>onCreate</code>之前调用<br>这样就可以比较方便地实现监听每个控件的加载耗时    </p>
<h2 id="3-布局加载优化的一些方法介绍"><a href="#3-布局加载优化的一些方法介绍" class="headerlink" title="3.布局加载优化的一些方法介绍"></a>3.布局加载优化的一些方法介绍</h2><p>布局加载慢的主要原因有两个,一个是<code>IO</code>,一个是反射<br>所以我们的优化思路一般有两个<br>1.侧面缓解(异步加载)<br>2.根本解决(不需要IO,反射过程,如X2C,anko,compose等)</p>
<h3 id="AsyncLayoutInflater方案"><a href="#AsyncLayoutInflater方案" class="headerlink" title="AsyncLayoutInflater方案"></a><code>AsyncLayoutInflater</code>方案</h3><blockquote>
<p><code>AsyncLayoutInflater</code> 是来帮助做异步加载 <code>layout</code> 的，<code>inflate(int, ViewGroup, OnInflateFinishedListener)</code> 方法运行结束之后 <code>OnInflateFinishedListener</code> 会在主线程回调返回 <code>View</code>；这样做旨在 <code>UI</code> 的懒加载或者对用户操作的高响应。</p>
</blockquote>
<p>简单的说我们知道默认情况下 <code>setContentView</code> 函数是在 <code>UI</code> 线程执行的，其中有一系列的耗时动作：<code>Xml</code>的解析、<code>View</code>的反射创建等过程同样是在<code>UI</code>线程执行的，<code>AsyncLayoutInflater</code> 就是来帮我们把这些过程以异步的方式执行，保持<code>UI</code>线程的高响应。</p>
<p>使用如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="keyword">new</span> AsyncLayoutInflater(AsyncLayoutActivity.<span class="keyword">this</span>)</span><br><span class="line">            .inflate(R.layout.async_layout, <span class="keyword">null</span>, <span class="keyword">new</span> AsyncLayoutInflater.OnInflateFinishedListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInflateFinished</span><span class="params">(View view, <span class="keyword">int</span> resid, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">                    setContentView(view);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    <span class="comment">// 别的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做的优点在于将<code>UI</code>加载过程迁移到了子线程，保证了<code>UI</code>线程的高响应<br>缺点在于牺牲了易用性，同时如果在初始化过程中调用了<code>UI</code>可能会导致崩溃     </p>
<h3 id="X2C方案"><a href="#X2C方案" class="headerlink" title="X2C方案"></a><code>X2C</code>方案</h3><p><code>X2C</code>是掌阅开源的一套布局加载框架<br>它的主要是思路是在编译期，将需要翻译的layout翻译生成对应的java文件，这样对于开发人员来说写布局还是写原来的xml，但对于程序来说，运行时加载的是对应的java文件。<br>这就将运行时的开销转移到了编译时<br>如下所示,原始xml文件：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:paddingLeft</span>=<span class="string">"10dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">"@+id/head"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">layout</span>=<span class="string">"@layout/head"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_centerHorizontal</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">"@+id/ccc"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">"@style/bb"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_below</span>=<span class="string">"@id/head"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>X2C</code> 生成的 <code>Java</code> 文件<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">X2C_2131296281_Activity_Main</span> <span class="keyword">implements</span> <span class="title">IViewCreator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> View <span class="title">createView</span><span class="params">(Context ctx, <span class="keyword">int</span> layoutId)</span> </span>&#123;</span><br><span class="line">    	Resources res = ctx.getResources();</span><br><span class="line"></span><br><span class="line">        RelativeLayout relativeLayout0 = <span class="keyword">new</span> RelativeLayout(ctx);</span><br><span class="line">        relativeLayout0.setPadding((<span class="keyword">int</span>)(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,<span class="number">10</span>,res.getDisplayMetrics())),<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        View view1 =(View) <span class="keyword">new</span> X2C_2131296283_Head().createView(ctx,<span class="number">0</span>);</span><br><span class="line">        RelativeLayout.LayoutParams layoutParam1 = <span class="keyword">new</span> RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">        view1.setLayoutParams(layoutParam1);</span><br><span class="line">        relativeLayout0.addView(view1);</span><br><span class="line">        view1.setId(R.id.head);</span><br><span class="line">        layoutParam1.addRule(RelativeLayout.CENTER_HORIZONTAL,RelativeLayout.TRUE);</span><br><span class="line"></span><br><span class="line">        ImageView imageView2 = <span class="keyword">new</span> ImageView(ctx);</span><br><span class="line">        RelativeLayout.LayoutParams layoutParam2 = <span class="keyword">new</span> RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,(<span class="keyword">int</span>)(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,<span class="number">1</span>,res.getDisplayMetrics())));</span><br><span class="line">        imageView2.setLayoutParams(layoutParam2);</span><br><span class="line">        relativeLayout0.addView(imageView2);</span><br><span class="line">        imageView2.setId(R.id.ccc);</span><br><span class="line">        layoutParam2.addRule(RelativeLayout.BELOW,R.id.head);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> relativeLayout0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用时如下所示,使用<code>X2C.setContentView</code>替代原始的<code>setContentView即可</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this.setContentView(R.layout.activity_main);</span></span><br><span class="line">X2C.setContentView(<span class="keyword">this</span>, R.layout.activity_main);</span><br></pre></td></tr></table></figure></p>
<p><strong><code>X2C</code>优点</strong><br>1.在保留<code>xml</code>的同时，又解决了它带来的性能问题<br>2.据<code>X2C</code>统计，加载耗时可以缩小到原来的1/3    </p>
<p><strong><code>X2C</code>问题</strong><br>1.部分属性不能通过代码设置,<code>Java</code>不兼容<br>2.将加载时间转移到了编译期，增加了编译期耗时<br>3.不支持<code>kotlin-android-extensions</code>插件，牺牲了部分易用性   </p>
<h3 id="Anko方案"><a href="#Anko方案" class="headerlink" title="Anko方案"></a><code>Anko</code>方案</h3><p><code>Anko</code>是<code>JetBrains</code>开发的一个强大的库,支持使用<code>kotlin DSL</code>的方式来写<code>UI</code>,如下所示<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?, persistentState: <span class="type">PersistableBundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState, persistentState)</span><br><span class="line">        MyActivityUI().setContentView(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivityUI</span> : <span class="type">AnkoComponent</span>&lt;<span class="type">MyActivity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createView</span><span class="params">(ui: <span class="type">AnkoContext</span>&lt;<span class="type">MyActivity</span>&gt;)</span></span> = with(ui) &#123;</span><br><span class="line">        verticalLayout &#123;</span><br><span class="line">            <span class="keyword">val</span> name = editText()</span><br><span class="line">            button(<span class="string">"Say Hello"</span>) &#123;</span><br><span class="line">                onClick &#123; ctx.toast(<span class="string">"Hello, <span class="subst">$&#123;name.text&#125;</span>!"</span>) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，<code>Anko</code>使用<code>kotlin DSL</code>实现布局，它比我们使用<code>Java</code>动态创建布局方便很多，主要是更简洁，它和拥有<code>xml</code>创建布局的层级关系，能让我们更容易阅读<br>同时，它去除了<code>IO</code>与反射过程,性能更好，以下是<code>Anko</code>与<code>XML</code>的性能对比<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p5.png" alt>    </p>
<blockquote>
<p>以上数据来源于:<a href="https://android.jlelse.eu/400-faster-layouts-with-anko-da17f32c45dd" target="_blank" rel="noopener">https://android.jlelse.eu/400-faster-layouts-with-anko-da17f32c45dd</a></p>
</blockquote>
<p>不过由于<code>AnKo</code>已经停止维护了，这里不建议大家使用，了解原理即可<br><code>AnKo</code>建议大家使用<code>Jetpack Compose</code>来替代使用   </p>
<h3 id="Compose方案"><a href="#Compose方案" class="headerlink" title="Compose方案"></a><code>Compose</code>方案</h3><p><code>Compose</code> 是 <code>Jetpack</code> 中的一个新成员，是 <code>Android</code> 团队在2019年<code>I/O</code>大会上公布的新的<code>UI</code>库,目前处于<code>Beta</code>阶段<br><code>Compose</code>使用纯<code>kotlin</code>开发，使用简洁方便，但它并不是像<code>Anko</code>一样对<code>ViewGroup</code>的封装<br><code>Compose</code> 并不是对 <code>View</code> 和 <code>ViewGroup</code> 这套系统做了个上层包装来让写法更简单，而是完全抛弃了这套系统，自己把整个的渲染机制从里到外做了个全新的。</p>
<p>可以确定的是,<strong><code>Compose</code>是取代<code>XML</code>的官方方案</strong>      </p>
<p><code>Compose</code>的主要优点就在于它的简单好用，具体来说就是两点<br>1.它的声明式 <code>UI</code><br>2.去掉了 <code>xml</code>，只使用 <code>Kotlin</code> 一种语言   </p>
<p>由于本文并不是介绍<code>Compose</code>的，所以就不继续介绍<code>Compose</code>了，总得来说，<code>Compose</code>是未来<code>android UI</code>开发的方向,读者可以自行查阅相关资料</p>
<h2 id="4-为什么放弃使用这些优化方法"><a href="#4-为什么放弃使用这些优化方法" class="headerlink" title="4.为什么放弃使用这些优化方法?"></a>4.为什么放弃使用这些优化方法?</h2><p>上面介绍了不少布局加载优化方法，而我最后在项目中最后都没有使用，这就是从真<strong>从入门到放弃</strong><br>总得来说有以下几个原因<br>1.有些方式(如<code>AsyncLayoutInflater</code>,<code>X2C</code>)牺牲了易用性，虽然性能提升了，但是开发变得麻烦了<br>2.<code>Anko</code>使用上比较方便同时性能较高，但是比起<code>XML</code>方式改动很大，同时<code>Anko</code>已经放弃维护了，在团队中推动难度大<br>3.<code>Compose</code>是未来<code>android UI</code>开发的方向，但目前仍处于<code>Beta</code>阶段，相信在<code>Release</code>后，会成为我们替换<code>XML</code>的有效手段<br>4.还有最主要的一点是，针对我们的项目，布局加载耗时并不是主要耗时的地方，所以优化收益不大，可以将精力投入到其他地方    </p>
<p>如下所示，我们将<code>setConteView</code>前后时间相减，得到布局加载时间<br>而<code>onWindowFocusChanged</code>是<code>Activity</code>真正可见时间，将其与<code>onCreate</code>时间相减，可得页面显示时间<br>在我们的项目中测试效果如下：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android <span class="number">5.0</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">inflateTime:</span><span class="number">33</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">activityShowTime:</span><span class="number">252</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">inflateTime:</span><span class="number">11</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">activityShowTime:</span><span class="number">642</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">inflateTime:</span><span class="number">83</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">activityShowTime:</span><span class="number">637</span></span><br><span class="line"></span><br><span class="line">android <span class="number">10.0</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">inflateTime:</span><span class="number">11</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">activityShowTime:</span><span class="number">88</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">inflateTime:</span><span class="number">5</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">activityShowTime:</span><span class="number">217</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">inflateTime:</span><span class="number">27</span></span><br><span class="line">I/<span class="string">Log:</span> <span class="string">activityShowTime:</span><span class="number">221</span></span><br></pre></td></tr></table></figure></p>
<p>我在<code>android</code>5.0手机与10.0手机上分别做了测试，在我们的项目中布局加载耗时并不很长，同时它们在整个页面可见过程中，占得比例也并不高<br>所以得出结论：<strong>针对我们项目，布局加载耗时并不是主要耗时的地方，优化收益不大</strong><br>这就是从入门到放弃的原因    </p>
<h3 id="一些常规优化手段"><a href="#一些常规优化手段" class="headerlink" title="一些常规优化手段"></a>一些常规优化手段</h3><p>上面介绍了一些改动比较大的方案，其实我们在实际开发中也有些常规的方法可以优化布局加载<br>比如优化布局层级，避免过度绘制等，这些简单的手段可能正是可以应用到项目中的     </p>
<h4 id="优化布局层级及复杂度"><a href="#优化布局层级及复杂度" class="headerlink" title="优化布局层级及复杂度"></a>优化布局层级及复杂度</h4><p>1.使用<code>ConstraintLayout</code>,可以实现完全扁平化的布局，减少层级<br>2.<code>RelativeLayout</code>本身尽量不要嵌套使用<br>3.嵌套的<code>LinearLayout</code>中，尽量不要使用<code>weight</code>，因为<code>weight</code>会重新测量两次<br>4.推荐使用<code>merge</code>标签，可以减少一个层级<br>5.使用<code>ViewStub</code>延迟加载    </p>
<h4 id="避免过度绘制"><a href="#避免过度绘制" class="headerlink" title="避免过度绘制"></a>避免过度绘制</h4><p>1.去掉多余背景色,减少复杂<code>shape</code>的使用<br>2.避免层级叠加<br>3.自定义<code>View</code>使用<code>clipRect</code>屏蔽被遮盖<code>View</code>绘制    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了以下内容<br>1.<code>andrid</code>绘制原理与布局加载原理<br>2.如何定量的获取<code>android</code>布局加载耗时<br>3.介绍了一些布局加载优化的方法与手段(<code>AsyncLayoutInflater</code>,<code>X2C</code>,<code>Anko</code>,<code>Compose</code>等)<br>4.介绍了因为在我们在项目中布局加载耗时优化收益不大，所以没有引入上述优化手段   </p>
<h3 id="Show-Me-The-Code"><a href="#Show-Me-The-Code" class="headerlink" title="Show Me The Code"></a>Show Me The Code</h3><p><a href="https://github.com/shenzhen2017/android-apm/tree/main/app/src/main/java/com/zj/android_apm/layout" target="_blank" rel="noopener">本文相关源码</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844904047355363341" target="_blank" rel="noopener">深入探索Android布局优化（上）</a><br><a href="https://juejin.cn/post/6844904179048120334" target="_blank" rel="noopener">Android “退一步”的布局加载优化</a>     </p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【从入门到实用】android启动优化深入解析</title>
    <url>/blog/2021/04/android-start-optimize.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>性能优化的方案不少，但能落地应用到项目中的却不多<br>前段时间学习布局优化时，总结了不少布局优化的方案，但最后却无法在项目中应用：<a href="https://juejin.cn/post/6950791235413999652" target="_blank" rel="noopener">【从入门到放弃】android布局优化深入解析</a><br>今天一如既往，不做标题党，给大家介绍一些可以实用的启动优化方案~</p>
<p>对于<code>android APP</code>来说，启动时间是用户的第一体验，如果启动时间过长，很可能会流失用户，所以启动优化也是我们做性能优化的一个重要方向<br>本文主要包括以下内容<br>1.启动优化有哪些优化方向？<br>2.如何精准测量启动时间？<br>3.有哪些实用的优化手段？    </p>
<h2 id="启动优化有哪些优化方向？"><a href="#启动优化有哪些优化方向？" class="headerlink" title="启动优化有哪些优化方向？"></a>启动优化有哪些优化方向？</h2><p>应用有三种启动状态，每种状态都会影响应用向用户显示所需的时间：冷启动、温启动或热启动。在冷启动中，应用从头开始启动。在另外两种状态中，系统需要将后台运行的应用带入前台。<br>本文所说的启动优化都是指冷启动优化    </p>
<p>要优化应用以实现快速启动，了解系统和应用层面的情况以及它们在各个状态中的互动方式很有帮助。   </p>
<h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>冷启动是指应用从头开始启动：系统进程在冷启动后才创建应用进程。<br>发生冷启动的情况包括应用自设备启动后或系统终止应用后首次启动。<br>这种启动给最大限度地减少启动时间带来了最大的挑战，因为系统和应用要做的工作比在另外两种启动状态中更多。</p>
<p>在冷启动开始时，系统有三个任务，它们是：<br>1.加载并启动应用。<br>2.在启动后立即显示应用的空白启动窗口。<br>3.创建应用进程。    </p>
<p>系统一创建应用进程，应用进程就负责后续阶段：<br>1.创建应用对象。<br>2.启动主线程。<br>3.创建主 <code>Activity</code>。<br>4.填充视图。<br>5.布局屏幕。<br>6.执行初始绘制。    </p>
<p>一旦应用进程完成第一次绘制，系统进程就会换掉当前显示的后台窗口，替换为主 <code>Activity</code>。此时，用户可以开始使用应用。<br><img src="https://developer.android.com/topic/performance/images/cold-launch.png?hl=zh-cn" alt><br>如上所示，<code>Application</code>与<code>Activity</code>的生命周期就是我们的优化方向<br>一般为<code>Application onCreate</code>方法与首个<code>Activity</code>加载耗时   </p>
<h2 id="如何测量启动时间？"><a href="#如何测量启动时间？" class="headerlink" title="如何测量启动时间？"></a>如何测量启动时间？</h2><h3 id="最简单方法"><a href="#最简单方法" class="headerlink" title="最简单方法"></a>最简单方法</h3><p>通过查看<code>logcat</code>可以快速了解启动时间<br>在<code>Android Studio Logcat</code>中过滤关键字<code>Displayed</code>，可以看到对应的冷启动耗时日志。     </p>
<h3 id="命令测量"><a href="#命令测量" class="headerlink" title="命令测量"></a>命令测量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in `seq 1 10`</span><br><span class="line">do</span><br><span class="line">  adb shell am force-stop com.xx.xx</span><br><span class="line">  sleep 2</span><br><span class="line">  adb shell am start-activity -W -n 包名/activity名称 | grep "TotalTime" | cut -d ' ' -f 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>有时候我们需要统计app的冷启动性能，单次结果往往不准确 还需要多次统计以后做平均值<br>如上，使用脚本启动10次首页<code>Activity</code>,可以比较准确的获取冷启动性能   </p>
<p>命令测量方式线下使用方便，可以测试竞品<br>但是不能带到线上,不能精准控制测量时间<br>所以我们通常还需要手动埋点    </p>
<h3 id="埋点测量"><a href="#埋点测量" class="headerlink" title="埋点测量"></a>埋点测量</h3><p>埋点测量关键点在于合适的开始与结束时间<br>我们一般使用<code>Application attachBaseContext</code>作为开始时间<br>而启动结束时间则有很多选择   </p>
<h4 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h4><p><code>IdleHandler</code>在<code>MessageQueue</code>空闲时会回调,也就是所在线程任务已经执行完时，线程处于空闲状态时才会执行<code>Idle</code>列表中的任务。<br>正常情况下，当主线程程处于空闲状态时，可以认为冷启动已经完成，是一个比较不错的打点时机<br>但有个问题，如果<code>UI</code>线程的任务一直不执行完呢？如果有其他任务加入了<code>MessageQueue</code>但是页面已经可见了呢？<br><code>IdleHandler</code>具有一定的不可控特性，读者可根据项目特性判断是否使用   </p>
<h4 id="onWindowFocusChanged"><a href="#onWindowFocusChanged" class="headerlink" title="onWindowFocusChanged"></a>onWindowFocusChanged</h4><p>当<code>Activity</code>回调<code>onWindowFocusChanged</code>时，我们可以认为<code>Activity</code>已经可见了，所以可以在此时打点<br>不过<code>onWindowFocusChanged</code> 方法只是 <code>Activity</code> 的首帧时间，是 <code>Activity</code> 首次进行绘制的时间，首帧时间和界面完整展示出来还有一段时间差，不能真正代表界面已经展现出来了。    </p>
<p>但是<code>onWindowFocusChanged</code>方式与业务耦合少，侵入性低，使用起来比较方便<br>在我们的项目中回调时间与界面展示时间相差很少，可以作为一种可选方案，根据实际情况使用   </p>
<h4 id="onPrewDrawListener"><a href="#onPrewDrawListener" class="headerlink" title="onPrewDrawListener"></a>onPrewDrawListener</h4><p>如上面所说，正确的计算启动耗时的时机是要等真实的数据展示出来，比如在列表第一项的展示时再计算启动耗时。<br>我们可以在给列表的第一项添加<code>onPreDrawListener</code>监听，这种方式比较准确<br>不过这种方式与业务代码强相关，侵入性较大。读者也可根据实际情况使用   </p>
<h3 id="AOP测量方法耗时"><a href="#AOP测量方法耗时" class="headerlink" title="AOP测量方法耗时"></a>AOP测量方法耗时</h3><p>我们的<code>Application</code>中初始化了很多第三方库，有时我们需要统计每个方法的耗时，确定是哪个方法比较耗时，如果一个一个添加是很麻烦的<br>这种时候就可以使用<code>AOP</code>面向切面编程<br>如果想了解详情，请参阅<a href="https://juejin.cn/post/6844904093786308622#heading-34" target="_blank" rel="noopener">使用AOP测量方法耗时</a></p>
<h3 id="TraceView与SystraceView使用"><a href="#TraceView与SystraceView使用" class="headerlink" title="TraceView与SystraceView使用"></a>TraceView与SystraceView使用</h3><h4 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h4><p><code>TraceView</code>可以跟踪 <code>App</code> 某段时间内所有调用过的方法，这是测量应用执行性能常用的方式之一.<br>通过它我们可以查出 <code>App</code> 启动时具体都调用了方法，都花了多长时间。<br>这个功能是 <code>Android</code> 系统提供的，我们可以通过在代码里手动调用 <code>android.os.Debug.startMethodTracing()</code> 和 <code>stopMethodTracing()</code> 方法来开始和结束 <code>Tracing</code>，然后系统会把 <code>Tracing</code> 的结果保存到手机的 <code>.trace</code> 文件里。</p>
<p>此外，除了通过写代码来 <code>Trace</code>，我们也有更方便的方式。例如也可以通过 <code>Android Studio Profiler</code> 里的 <code>Method Tracer</code> 来 <code>Trace</code>。但是，针对 <code>App</code> 的冷启动，我们则通常会用 <code>Android</code> 系统自带的 <code>Am</code> 命令来跟踪，因为它能准确的在 <code>App</code> 启动的时候就开始 <code>Trace</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动指定 Activity，并同时进行采样跟踪,-P在app进入idle状态时profiler结束</span></span><br><span class="line">adb shell am start -n com.xxx.android/com.xxx.android.app.ui.activity.MainActivity -P /data/local/tmp/xxx-startup.trace --sampling 1000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取 .trace 文件到本机当前目录</span></span><br><span class="line">adb pull /data/local/tmp/xx-startup.trace .</span><br></pre></td></tr></table></figure>
<p>如上所示：-P参数表示在<code>app</code>进入<code>idle</code>状态时会自动结束，这样就不必手动打点了<br>在启动结束后，通过<code>adb pull</code>拉取<code>trace</code>文件后，直接拖到<code>android studio</code>中打开就可以查找耗时方法了<br><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca87e78817bbbb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt>    </p>
<p>更多关于<code>TraceView</code>定位启动优化问题的实例，读者可参阅:<br><a href="https://juejin.cn/post/6844903919580086280#heading-19" target="_blank" rel="noopener">TraceView使用</a><br><a href="https://www.jianshu.com/p/bcc3dddf0b36" target="_blank" rel="noopener">知乎 Android 客户端启动优化 - Retrofit 代理</a>   </p>
<h4 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h4><p><code>TraceView</code> 虽然是找出耗时方法的利器，但是执行 <code>TraceView</code> 时的运行环境和用户最终运行的环境会有极大的差距，因为 <code>TraceView</code> 会严重拖慢 <code>App</code> 的执行速度。<br>即使使用采样跟踪，测量得到的结果和实际结果肯定还是有很大偏差，只能作为参考。<br>而且 <code>TraceView</code> 更偏向于追查应用的内因，对于运行环境等外因（锁、<code>GC</code>、资源匮乏等）的追查显得很无力。<br>所以，我们可以借助另一个 <code>Google</code> 官方极力推荐的工具 - 「<code>Systrace</code>」来跟踪 App 实际运行时的情况    </p>
<p>运行<code>app</code>后，手动杀掉。然后<code>cd</code> 到<code>SDK</code> 目录下的 <code>platform-tools/systrace</code> 下，使用命令：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">python systrace<span class="selector-class">.py</span> -t <span class="number">10</span> -o /Users/xxx/trace<span class="selector-class">.html</span> -<span class="selector-tag">a</span> com<span class="selector-class">.xx</span>.xxx</span><br></pre></td></tr></table></figure></p>
<p>其中：<code>-t</code> 10是指跟踪10秒，<code>-o</code> 表示把文件输出到指定目录下，<code>-a</code> 是指定应用包名。<br>输入完这行命令后，可以看到开始跟踪的提示。看到 <code>Starting tracing</code>后，手动打开我们的应用。   </p>
<p>等到运行结束后打开输出的<code>trace.html</code><br><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca87e7b1bc5c28?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt>    </p>
<p>除了以上外，我们也可以通过<code>TraceCompact.beginSection</code>来指定关注的时间段<br>更多关于<code>Systrace</code>使用的实例，读者可以参阅:<br><a href="https://juejin.cn/post/6844903919580086280#heading-22" target="_blank" rel="noopener">systrace使用</a><br><a href="https://www.jianshu.com/p/bcc3dddf0b36" target="_blank" rel="noopener">知乎 Android 客户端启动优化 - Retrofit 代理-Systrace</a>  </p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1.<code>TraceView</code>可以用来定位具体耗时的方法<br>2.<code>TraceView</code>运行时开销严重，导致整体性能变慢，可能会带偏优化方向<br>3.<code>Systrace</code>开销小，可以直观反映<code>Cpu</code>使用率，便于查找运行环境等外因(锁,<code>GC</code>)等引起的问题<br>4.<code>TraceView</code>与<code>Systrace</code>都可以埋点，指定关心的区域   </p>
<h2 id="常规优化手段"><a href="#常规优化手段" class="headerlink" title="常规优化手段"></a>常规优化手段</h2><h3 id="1-Theme切换"><a href="#1-Theme切换" class="headerlink" title="1.Theme切换"></a>1.Theme切换</h3><p><code>Theme</code>设置可以说是启动优化的一个必备手段了<br>启动<code>Activity</code>的<code>windowBackground</code>主题属性预先设置一个启动图片（<code>layer-list</code>实现），在启动后，在<code>Activity</code>的<code>onCreate()</code>方法中的<code>super.onCreate()</code>前再<code>setTheme(R.style.AppTheme)</code>。</p>
<p><strong>优点</strong><br>1.使用简单。<br>2.避免了启动白屏和点击启动图标不响应的情况。    </p>
<p><strong>缺点</strong><br>治标不治本，表面上产生一种快的感觉。</p>
<h3 id="2-异步方案"><a href="#2-异步方案" class="headerlink" title="2.异步方案"></a>2.异步方案</h3><p>我们通常会在<code>Application</code>的<code>onCreate</code>中初始化很多任务，比如第三方库初始化，而且是串行的<br>这些初始化任务的耗时通常还不小，所以一个优化思路就是并行的初始化<br>这样就将初始化耗时从加法变成了求最大值   </p>
<p>核心思路：子线程分担主线程任务，并行减少时间</p>
<h4 id="常规异步方案的问题"><a href="#常规异步方案的问题" class="headerlink" title="常规异步方案的问题"></a>常规异步方案的问题</h4><p>1.代码不够优雅<br>假如我们有 100 个初始化任务，那我们就需要提交 100 次任务。     </p>
<p>2.无法限制在 <code>onCreate</code> 中完成<br>有的第三方库的初始化任务需要在 <code>Application</code> 的 <code>onCreate</code> 方法中执行完成，虽然可以用 <code>CountDownLatch</code> 实现等待，但是还是有点繁琐。    </p>
<p>3.无法实现存在依赖关系<br>有的初始化任务之间存在依赖关系，比如极光推送需要设备<code>ID</code>，而 <code>initDeviceId()</code> 这个方法也是一个初始化任务。</p>
<h2 id="异步启动器方案"><a href="#异步启动器方案" class="headerlink" title="异步启动器方案"></a>异步启动器方案</h2><p>上面介绍了常规异步方案的几个问题，我们可以通过启动器来解决<br>启动器的核心思想是充分利用多核 <code>CPU</code> ，自动梳理任务顺序。   </p>
<p>1.第一步是我们要对代码进行任务化，任务化是一个简称，比如把启动逻辑抽象成一个任务。</p>
<p>2.第二步是根据所有任务的依赖关系排序生成一个有向无环图，这个图是自动生成的，也就是对所有任务进行排序。<br>比如我们有个任务 <code>A</code> 和任务 <code>B</code>，任务 <code>B</code> 执行前需要任务 <code>A</code> 执行完，这样才能拿到特定的数据，比如上面提到的 <code>initDeviceId</code>。 </p>
<p>3.第三步是多线程根据排序后的优先级依次执行，比如我们现在有三个任务 <code>A</code>、<code>B</code>、<code>C</code>。<br>假如任务 <code>B</code> 依赖于任务 <code>A</code>，这时候生成的有向无环图就是 <code>ACB</code>，<code>A</code> 和 <code>C</code> 可以提前执行，<code>B</code> 一定要排在 <code>A</code> 之后执行。    </p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/19/16ca87e7f95fcdcd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt>   </p>
<p>启动器的大致流程如上所示，我们下面介绍几种开源的启动器方案，供读者参考    </p>
<h3 id="JetPack-App-Startup"><a href="#JetPack-App-Startup" class="headerlink" title="JetPack App Startup"></a>JetPack App Startup</h3><p>1.<code>App Startup</code> 这个库提供了一个组件，可以在应用程序启动的时候初始化。<br>2.开发人员可以使用这个组件精简启动序列和显式地设置初始化的顺序。 　<br>3.我们不需要为每个组件定义单独的 <code>ContentProvider</code>,<code>App Startup</code> 允许您定义的所有组件化共享一个内容提供者。    </p>
<p>这样可以极大地减少高应用程序的启动时间,但是<code>App Startup</code>只是支持将多个<code>ContentProvider</code>合并到一个<code>ContentProvider</code>中，并指定一定依赖顺序<br>它的推出的目的，是管理第三方库使用<code>ContentProvider</code>过多，导致启动速度变慢的问题<br>不支持异步与异步任务管理，所以并不符合我们的要求     </p>
<h3 id="阿里-alpha"><a href="#阿里-alpha" class="headerlink" title="阿里-alpha"></a>阿里-alpha</h3><blockquote>
<p><code>Alpha</code>是一个基于<code>PERT</code>图构建的<code>Android</code>异步启动框架，它简单，高效，功能完善。 在应用启动的时候，我们通常会有很多工作需要做，为了提高启动速度，我们会尽可能让这些工作并发进行。但这些工作之间可能存在前后依赖的关系，所以我们又需要想办法保证他们执行顺序的正确性。<code>Alpha</code>就是为此而设计的，使用者只需定义好自己的<code>task</code>，并描述它依赖的<code>task</code>，将它添加到<code>Project</code>中。框架会自动并发有序地执行这些<code>task</code>，并将执行的结果抛出来。 由于<code>Android</code>应用支持多进程，所以<code>Alpha</code>支持为不同进程配置不同的启动模式。</p>
</blockquote>
<p><code>alpha</code>已经基本满足我们的使用，不过它不支持任务是否需要等待，同时它的代码比较旧，感觉已经很久不维护了，所以最后决定使用<code>AnchorTask</code>框架    </p>
<h3 id="AnchorTask"><a href="#AnchorTask" class="headerlink" title="AnchorTask"></a><code>AnchorTask</code></h3><p>AnchorTask与Alpha类似<br>1.支持多任务并发执行<br>2.支持任务间依赖与拓扑排序<br>3.支持任务监听与耗时统计<br>4.支持指定任务优先级<br>5.支持指定是否在主线程运行与是否等待   </p>
<p>最主要的一点在于<code>AnchorTask</code>文档比较强大，从数据结构到拓扑排序，到设计到详细的说清楚了,有一系列文章，这也是我最后决定使用它的原因<br><a href="https://github.com/gdutxiaoxu/AnchorTask" target="_blank" rel="noopener">AnchorTask</a> by <a href="https://juejin.im/user/2207475076966584" target="_blank" rel="noopener">程序员徐公</a>    </p>
<p>简单使用如下，可以通过链式调用灵活的配置任务与依赖：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> project =  AnchorProject.Builder().setContext(context).setLogLevel(LogUtils.LogLevel.DEBUG)</span><br><span class="line">                .setAnchorTaskCreator(ApplicationAnchorTaskCreator())</span><br><span class="line">                .addTask(TASK_NAME_ZERO)</span><br><span class="line">                .addTask(TASK_NAME_ONE)</span><br><span class="line">                .addTask(TASK_NAME_TWO)</span><br><span class="line">                .addTask(TASK_NAME_THREE).afterTask(</span><br><span class="line">                    TASK_NAME_ZERO,</span><br><span class="line">                    TASK_NAME_ONE</span><br><span class="line">                )</span><br><span class="line">                .addTask(TASK_NAME_FOUR).afterTask(</span><br><span class="line">                    TASK_NAME_ONE,</span><br><span class="line">                    TASK_NAME_TWO</span><br><span class="line">                )</span><br><span class="line">                .addTask(TASK_NAME_FIVE).afterTask(</span><br><span class="line">                    TASK_NAME_THREE,</span><br><span class="line">                    TASK_NAME_FOUR</span><br><span class="line">                )</span><br><span class="line">                .setThreadPoolExecutor(TaskExecutorManager.instance.cpuThreadPoolExecutor)</span><br><span class="line">                .build()</span><br><span class="line">project.start().await()</span><br></pre></td></tr></table></figure></p>
<h2 id="延迟初始化方案"><a href="#延迟初始化方案" class="headerlink" title="延迟初始化方案"></a>延迟初始化方案</h2><h3 id="常规方案"><a href="#常规方案" class="headerlink" title="常规方案"></a>常规方案</h3><p>有些任务我们需要延迟加载，常规方法是通过<code>Handler.postDelayed</code>方法发送一个延迟消息，比如延迟到 100 毫秒后执行。    </p>
<h4 id="常规方案的问题"><a href="#常规方案的问题" class="headerlink" title="常规方案的问题"></a>常规方案的问题</h4><p>这种方法有以下几个问题<br>1.时机不便控制,无法确定一个合适的延迟时间<br>2.代码不够优雅，维护成本高,如果有多个任务，需要添加多次<br>3.可能造成主线程卡顿，假如把任务延迟 200 毫秒后执行，而 200 后用户还在滑动列表，那还是会发生卡顿。     </p>
<h3 id="更优方案"><a href="#更优方案" class="headerlink" title="更优方案"></a>更优方案</h3><p>核心思想：对延迟任务进行分批初始化<br>利用<code>IdleHandler</code>在当前消息队列空闲时执行的特性，实现一个延迟启动器<br><code>IdleHandler</code>在返回<code>true</code>时会继续监听，返回<code>false</code>结束监听<br>因此在任务全部完成后返回<code>false</code>即可,实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayInitDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Task&gt; mDelayTasks = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageQueue.IdleHandler mIdleHandler = <span class="keyword">new</span> MessageQueue.IdleHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(mDelayTasks.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Task task = mDelayTasks.poll();</span><br><span class="line">                <span class="keyword">new</span> DispatchRunnable(task).run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> !mDelayTasks.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DelayInitDispatcher <span class="title">addTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">        mDelayTasks.add(task);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Looper.myQueue().addIdleHandler(mIdleHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">DelayInitDispatcher delayInitDispatcher = <span class="keyword">new</span> DelayInitDispatcher();</span><br><span class="line">delayInitDispatcher.addTask(<span class="keyword">new</span> DelayInitTaskA())</span><br><span class="line">        .addTask(<span class="keyword">new</span> DelayInitTaskB())</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure>
<h2 id="极致懒加载与提前加载"><a href="#极致懒加载与提前加载" class="headerlink" title="极致懒加载与提前加载"></a>极致懒加载与提前加载</h2><h3 id="首页极致懒加载"><a href="#首页极致懒加载" class="headerlink" title="首页极致懒加载"></a>首页极致懒加载</h3><p>我们的首页通常有多个<code>tab</code>,而当我们启动时，只需要初始化一个<code>tab</code>即可<br>我们通常会利用<code>ViewPager</code>来实现简单的懒加载，比如只有当<code>Fragment</code>可见时才去进行网络请示   </p>
<p>这样有一定效果，但是<code>View</code>的<code>inflate</code>,<code>measure</code>,<code>layout</code>也需要一定时间<br>更加极致的懒加载方案如下：<br>1.首屏加载时，只往<code>ViewPager</code>中塞入默认要展示的<code>tab</code>，剩余的<code>tab</code>用空的占位<code>Fragment</code>代替<br>2.占位<code>Fragment</code>中只有一个空白的<code>FrameLayout</code><br>3.当占位<code>Fragment</code>可见时，将真正要展示的<code>Fragment</code>添加到空白<code>FrameLayout</code>，进行真正的初始化   </p>
<p>通过这种方案，可以做到在启动时，只<code>inflate</code>,<code>measure</code>,<code>layout</code>首页<code>Fragment</code>的<code>View</code>,其他<code>Tab</code>只有可见时才会填充<br>如果你的<code>Layout</code>比较复杂的话，通过这种方式可以较大的改善启动性能   </p>
<h3 id="布局预加载"><a href="#布局预加载" class="headerlink" title="布局预加载"></a>布局预加载</h3><p>官方提供了一个类，可以来进行异步的<code>inflate</code>，但是有两个缺点：<br>1.每次都要现场<code>new</code>一个出来<br>2.异步加载的<code>view</code>只能通过<code>callback</code>回调才能获得，使用不方便（死穴）<br>3.如果在<code>Activity</code>中进行初始化，通过<code>callback</code>回调时，并没有减少加载时间，仍然需要等待    </p>
<p>由于以上问题，一个思考方向就是，能不能提前在子线程<code>inflate</code>布局，然后在<code>Activity</code>中通过<code>id</code>取出来<br>核心思想如下<br>1.初始化时在子线程中<code>inflate</code>布局，存储在缓存中<br>2.<code>Activity</code>初始化时，先从缓存结果里面拿 <code>View</code>，拿到了<code>view</code>直接返回<br>3.没拿到<code>view</code>，但是子线程在<code>inflate</code>中，等待返回<br>4.如果还没开始<code>inflate</code>，由<code>UI</code>线程进行<code>inflate</code>     </p>
<p><strong>这种方案的优点:</strong><br>可以大大减少 <code>View</code> 创建的时间，使用这种方案之后，获取 <code>View</code> 的时候基本在 10ms 之内的。</p>
<p><strong>缺点</strong><br>1.由于 <code>View</code> 是提前创建的，并且会存在在一个 <code>map</code>，需要根据自己的业务场景将 <code>View</code> 从 <code>map</code> 中移除，不然会发生内存泄露<br>2.<code>View</code> 如果缓存起来，记得在合适的时候重置 <code>view</code> 的状态，不然有时候会发生奇奇怪怪的现象。     </p>
<p>总得来说，优缺点都很明显，读者可根据实际情况(主要是项目中<code>inflate</code>的时间长不长，改用提前加载后收益明不明显？),根据实际情况决定是否使用<br>具体实现可参阅：<a href="https://juejin.cn/post/6844903924965572615#heading-10" target="_blank" rel="noopener">神奇的的预加载（预加载View，而不是data）</a>   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要总结了启动优化的方向，与精准测量启动时间的方式<br>重点讲解了几种可以实用的启动优化方案：<br>1.异步启动器加快初始化速度<br>2.延迟加载器减少卡顿，代码更加优雅<br>3.首页极致懒加载，减少首页<code>inflate</code>,<code>measure</code>,<code>layout</code>时间<br>4.布局预加载方案大大减少<code>View</code>创建时间，读者可根据实际情况使用    </p>
<p>这些方案都比较实用，读者可以尝试在项目中应用，看看有多少提升~    </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://developer.android.com/topic/performance/vitals/launch-time?hl=zh-cn" target="_blank" rel="noopener">应用启动时间</a><br><a href="https://juejin.cn/post/6953221575860568077" target="_blank" rel="noopener">几种获取android 界面性能数据的快捷方法</a><br><a href="https://juejin.cn/post/6844903879931330567" target="_blank" rel="noopener">【性能优化】Android冷启动优化</a><br><a href="https://www.jianshu.com/p/bcc3dddf0b36" target="_blank" rel="noopener">知乎 Android 客户端启动优化 - Retrofit 代理</a><br><a href="https://juejin.cn/post/6844903919580086280" target="_blank" rel="noopener">探索 Android 启动优化方法</a><br><a href="https://juejin.cn/post/6844904093786308622" target="_blank" rel="noopener">深入探索Android启动速度优化（上）</a>   </p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【开源项目】不需要权限的悬浮窗方案了解一下~</title>
    <url>/blog/2021/05/no-permission-float.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>全局悬浮窗是项目中的一个常见需求,目前比较常见的实现是将要悬浮的<code>View</code>添加到<code>WindowManager</code>中<br>这种方案的主要痛点在于需要用户申请<code>TYPE_SYSTEM_ALERT</code>权限，并且需要用户去设置中手动打开,使用起来很不方便，同时需要申请权限可能会劝退用户.<br>针对这种情况下面介绍一种不需要权限的悬浮窗方案    </p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先看下最终的效果图<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p1.gif" alt>   </p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>1.不需要申请权限，可以直接打开悬浮窗，使用便捷          </li>
<li>2.支持自定义布局，自定义显示样式,自定义初始显示位置    </li>
<li>3.支持拖拽，可自动吸附到屏幕边缘   </li>
<li>4.可过滤不需要显示悬浮窗的黑名单界面    </li>
<li>5.支持自定义点击事件，可支持展开折叠等功能   </li>
<li>6.<code>API</code>链式调用，使用简洁优雅   </li>
</ul>
<h2 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h2><p>第 1 步:在工程的 <code>build.gradle</code> 中添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		...</span><br><span class="line">		mavenCentral()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第2步：在应用的 <code>build.gradle</code> 中添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        implementation <span class="string">'io.github.shenzhen2017:easyfloat:1.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>API</code>链式调用，使用起来非常方便     </p>
<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EasyFloat</span><br><span class="line">    .layout(R.layout.layout_float_view)</span><br><span class="line">    .blackList(mutableListOf(ThirdActivity::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">    .layoutParams(initLayoutParams())</span><br><span class="line">    .listener &#123;</span><br><span class="line">        initListener(it)</span><br><span class="line">    &#125;</span><br><span class="line">    .show(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>如上所示：<br>1.通过<code>layout</code>指定自定义布局<br>2.通过<code>blackList</code>指定不展示悬浮窗界面<br>3.通过<code>layoutParams</code>指定初始展示位置<br>4.通过<code>listener</code>处理自定义点击事件    </p>
<h3 id="2-销毁悬浮窗"><a href="#2-销毁悬浮窗" class="headerlink" title="2.销毁悬浮窗"></a>2.销毁悬浮窗</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">EasyFloat.dismiss(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<p>直接调用<code>dismiss</code>销毁即可   </p>
<h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><p>我们都知道，当我们需要设置布局的时候，是通过<code>setContentView</code>设置的<br>而<code>setContentView</code>实际上是将我们的布局添加到了<code>DecoreView</code>上,布局层级如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog4/p1.gif" alt>    </p>
<p>1.<code>Activity</code> 类似于一个框架，负责容器生命周期及活动，窗口通过 <code>Window</code> 来管理；<br>2.<code>Window</code> 负责窗口管理（实际是子类 <code>PhoneWindow</code>），窗口的绘制和渲染交给 <code>DecorView</code>完成；<br>3.<code>DecorView</code> 是 <code>View</code> 树的根，开发人员为 <code>Activity</code> 定义的 <code>layout</code> 将成为 <code>DecorView</code> 的子视图 <code>ContentParent</code> 的子视图；<br>4.<code>layout.xml</code> 是开发人员定义的布局文件，最终 <code>inflate</code> 为 <code>DecorView</code> 的子组件；   </p>
<p>由上我们可以想到一个方案：<br><strong>我们在<code>Activity onStart</code>时，将要悬浮的<code>View</code>添加到<code>ContentParent</code>上就可以实现不需要权限的悬浮窗了</strong>    </p>
<p>当然我们还需要注意以下几点<br>1.因为我们需要在多个页面展示悬浮窗，可以通过<code>ActivityLifecycleCallbacks</code>监听所有<code>Activity</code>的生命周期,<code>onStart</code>时添加，<code>onStop</code>时移除<br>2.因为要在多个页面共享状态，所以应该有一个单例类管理<code>View</code>，做到只创建一个<code>View</code>，页面切换时只做添加与移除<br>3.因为要添加到<code>ContentParent</code>中，持有了<code>Activity</code>的引用，所以要注意处理内存泄漏的问题，在项目中我们使用了弱引用来防止内存泄漏    </p>
<p>部分代码如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> EasyFloat : Application.ActivityLifecycleCallbacks &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStarted</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">         FloatingView.<span class="keyword">get</span>().attach(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        FloatingView.<span class="keyword">get</span>().detach(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        initShow(activity)</span><br><span class="line">        activity.application.registerActivityLifecycleCallbacks(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dismiss</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        FloatingView.<span class="keyword">get</span>().remove()</span><br><span class="line">        FloatingView.<span class="keyword">get</span>().detach(activity)</span><br><span class="line">        activity.application.unregisterActivityLifecycleCallbacks(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h3><p>在实现这个开源框架的过程中，主要借鉴了<a href="https://github.com/leotyndale/EnFloatingView" target="_blank" rel="noopener">EnFloatingView</a>的一些思路<br>并在其基础上进行了一定的封装，优化了<code>API</code>调用并解决了滑动冲突等一些问题     </p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shenzhen2017/EasyFloat" target="_blank" rel="noopener">EasyFloat</a><br>开源不易，如果项目对你有所帮助，欢迎点赞,<code>Star</code>,收藏~</p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【从入门到实用】android内存优化深入解析</title>
    <url>/blog/2021/05/memory-sum-up.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内存问题是一个普遍问题，但是却普遍缺少关注度，具体有以下几个原因<br>1.内存问题相对比较隐蔽，表现并不明显<br>2.同时<code>android</code>使用<code>Jvm</code>语言开发，垃圾回收是自动的，所以一般没有特别关注<br>3.内存问题难以定位，出现问题的地方往往只是表现的地方，真正的原因难以收集   </p>
<p>内存优化的内容其实非常多而复杂，我们可以尝试从以下思路去了解<br>1.要了解内存问题，我们首先要了解为什么要做内存优化？<br>2.同时需要了解一些内存优化的背景知识，如垃圾回收机制<br>3.我们需要了解一些内存优化的常用工具与手段<br>4.图片是内存优化的重点，我们需要重点了解下图片优化的知识点<br>5.内存问题的一个直接体现是<code>OOM</code>,我们还需要了解下<code>OOM</code>治理的一些手段     </p>
<p>所以我们可以轻松得出本文的主要内容：<br>1.为什么要做内存优化?<br>2.<code>android</code>内存优化的一些背景知识<br>3.<code>android</code>内存优化的常用工具与手段<br>4.怎么做图片内存优化？<br>5.怎么做<code>OOM</code>线上监控?       </p>
<p>本文主要内容思维导图如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog11/p5.png" alt>    </p>
<h2 id="1-为什么要做内存优化"><a href="#1-为什么要做内存优化" class="headerlink" title="1. 为什么要做内存优化?"></a>1. 为什么要做内存优化?</h2><p>要回答这个问题，我们首先应该明确需求，当我们去做内存优化时是为了什么<br>做内存优化的目的是降低<code>OOM</code>率、减少卡顿、增加应用存活时间。       </p>
<h3 id="1-1-降低OOM率"><a href="#1-1-降低OOM率" class="headerlink" title="1.1 降低OOM率"></a>1.1 降低<code>OOM</code>率</h3><p>做内存优化的一个常见原因是为了降低<code>OOM</code>率<br>申请内存过多而没有及时释放，常常就会导致<code>OOM</code><br>引起<code>OOM</code>的原因有多种，在后面我们再细谈    </p>
<h3 id="1-2-减少卡顿"><a href="#1-2-减少卡顿" class="headerlink" title="1.2 减少卡顿"></a>1.2 减少卡顿</h3><p><code>Android</code>中造成界面卡顿的原因有很多种，其中一种就是由内存问题引起的.<br>内存问题之所以会影响到界面流畅度，是因为垃圾回收.<br>在<code>GC</code>时，所有线程都要停止，包括主线程.当<code>GC</code>和绘制界面的操作同时触发时，绘制的执行就会被搁置，导致掉帧，也就是界面卡顿。</p>
<h3 id="1-3-增加应用存活时间"><a href="#1-3-增加应用存活时间" class="headerlink" title="1.3 增加应用存活时间"></a>1.3 增加应用存活时间</h3><p><code>Android</code>会按照特定的机制清理进程，清理进程时优先会考虑清理后台进程，如果某个应用在后台运行并且占用的内存更多，就会被优先清理掉<br>我们通常希望<code>App</code>能尽量存活的久一点，所以内存不再使用时应该尽快释放         </p>
<h2 id="2-android内存优化的一些背景知识"><a href="#2-android内存优化的一些背景知识" class="headerlink" title="2. android内存优化的一些背景知识"></a>2. <code>android</code>内存优化的一些背景知识</h2><h3 id="2-1-Java垃圾回收机制"><a href="#2-1-Java垃圾回收机制" class="headerlink" title="2.1 Java垃圾回收机制"></a>2.1 <code>Java</code>垃圾回收机制</h3><p><code>Java</code>内存回收主要包括以下内容<br>1.判断对象是否回收的可达性分析算法<br>2.强软弱虚4种引用类型<br>3.用于<code>GC</code>回收的垃圾回收算法<br>这些都是很常见的知识点了，这里也就不缀述了，如果想要了解更多细节的同学可参考：<a href="https://juejin.cn/post/6844903897958449166#heading-14" target="_blank" rel="noopener">Java 垃圾回收机制</a></p>
<h3 id="2-2-什么是内存泄漏"><a href="#2-2-什么是内存泄漏" class="headerlink" title="2.2 什么是内存泄漏?"></a>2.2 什么是内存泄漏?</h3><p>内存泄漏指的是一块内存没有被使用且无法被<code>GC</code>回收，从而造成了内存的浪费，比如<code>Handler</code>匿名内部类持有<code>Activity</code>的引用，<code>Activity</code> 需要销毁时，<code>GC</code> 就无法回收它。<br>内存泄漏的表现就是可用内存逐渐减少，无法被回收的内存逐渐累积，直到应用无更多可用内存可申请时，就会导致内存溢出<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9285ae8a857945fb95a47527c162ae68~tplv-k3u1fbpfcp-zoom-1.image" alt><br>内存泄漏的直接原因是长生命周期的对象引用了短生命周期的对象，导致短生命周期对象无法回收<br>常见的引起内存泄漏的原因有：<br>1.非静态内部类持有了外部引用<br>2.静态变量持有了<code>context</code>的引用<br>3.资源没有及时释放     </p>
<p>我们一般使用<code>LeakCanary</code>或者<code>Profile</code>检测内存泄漏，后面会详细介绍      </p>
<h3 id="2-3-什么是内存抖动"><a href="#2-3-什么是内存抖动" class="headerlink" title="2.3 什么是内存抖动?"></a>2.3 什么是内存抖动?</h3><p>当我们在短时间内频繁创建大量临时对象时，就会引起内存抖动，比如在一个<code>for</code>循环中创建临时对象实例，下面这张图就是内存抖动时的一个内存图表现，它的形状是锯齿形的，而中间的垃圾桶代表着一次<code>GC</code>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26ba4f5fd59e47c0982bcd54b9be12d8~tplv-k3u1fbpfcp-zoom-1.image" alt>        </p>
<p>内存抖动意味着频繁的创建对象与回收，容易触发<code>GC</code>，而当<code>GC</code>时所有线程都会停止，因此可能导致卡顿<br>为了避免内存抖动，我们应该避免以下操作<br>1.尽量避免在循环体中创建对象<br>2.尽量不要在自定义<code>View</code>的<code>onDraw()</code>方法中创建对象，因为这个方法会被频繁调用<br>3.对于能够复用的对象，可以考虑使用对象池把它们缓存起来      </p>
<h3 id="2-4-什么是内存溢出"><a href="#2-4-什么是内存溢出" class="headerlink" title="2.4 什么是内存溢出?"></a>2.4 什么是内存溢出?</h3><p>内存溢出即申请的内存超出可用的内存，即<code>OOM</code>，这会导致我们的程序异常退出,这也是我们重点关注的指标<br>引起<code>OOM</code>的原因可能有多种，主要可以分为以下几类<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1e939370db5400384bf1b8fe92b748c~tplv-k3u1fbpfcp-watermark.image" alt><br>关于<code>OOM</code>治理及线上监控等，后面会详细介绍    </p>
<h2 id="3-android内存优化的常用工具与手段"><a href="#3-android内存优化的常用工具与手段" class="headerlink" title="3. android内存优化的常用工具与手段"></a>3. <code>android</code>内存优化的常用工具与手段</h2><h3 id="3-1-Memory-Profiler"><a href="#3-1-Memory-Profiler" class="headerlink" title="3.1 Memory Profiler"></a>3.1 <code>Memory Profiler</code></h3><p><code>Memory Profiler</code>是<code>Profiler</code> 中的其中一个版块，<code>Profiler</code> 是 <code>Android Studio</code> 为我们提供的性能分析工具，使用 <code>Profiler</code> 能分析应用的 <code>CPU</code>、内存、网络以及电量的使用情况。<br>使用<code>Memory</code>可以检测以下功能<br>1.查看内存曲线及内存占用情况<br>2.可以定位是否存在内存抖动问题<br>3.堆转储（<code>Dump Java Heap</code>）可检测出内存泄漏的对象<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/934cf04e29a24055971ebaf7ce3af279~tplv-k3u1fbpfcp-zoom-1.image" alt><br>关于<code>Memory Profiler</code>的具体使用就不在此缀述了，想要了解的可参考：<a href="https://juejin.cn/post/6844903897958449166#heading-48" target="_blank" rel="noopener">什么是 Memory Profiler？</a></p>
<h3 id="3-2-Memory-Analyzer-Tool"><a href="#3-2-Memory-Analyzer-Tool" class="headerlink" title="3.2 Memory Analyzer Tool"></a>3.2 <code>Memory Analyzer Tool</code></h3><p><code>MAT</code>工具可以帮助开发者定位导致内存泄漏的对象，以及发现大的内存对象，然后解决内存泄漏并通过优化内存对象，以达到减少内存消耗的目的。<br>比起<code>Memory Profiler</code>，<code>MAT</code>使用起来更加麻烦，同时现在<code>Memory Profiler</code>功能也越来越强大了，所以我现在已经很少使用<code>MAT</code>了<br>如果想要更多地了解<code>MAT</code>，也可以参考:<a href="https://juejin.cn/post/6844903897958449166#heading-52" target="_blank" rel="noopener">什么是Memory Analyzer Tool</a></p>
<h3 id="3-3-LeakCanary检测内存泄漏"><a href="#3-3-LeakCanary检测内存泄漏" class="headerlink" title="3.3 LeakCanary检测内存泄漏"></a>3.3 <code>LeakCanary</code>检测内存泄漏</h3><p>相比<code>Memory Profiler</code>与<code>MAT</code>,<code>LeakCanary</code>在使用上更加简便<br>只需要在项目中添加依赖，即可自动地检测内存泄漏并报警，使用起来非常方便<br>当发生泄漏时，引用链如下：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d59f1b5a1424f91bbb49c8ca03189f3~tplv-k3u1fbpfcp-zoom-1.image" alt>         </p>
<p><code>LeakCanary</code>有以下几个特点：<br>1.不需要手动初始化<br>2.可自动检测内存泄漏并通过通知报警<br>3.不能用于线上<br><code>LeakCanary</code>检测流程如下：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/251424c1d8a14b97ba4a40795ab4bb46~tplv-k3u1fbpfcp-watermark.image" alt>          </p>
<p>关于<code>LeakCanary</code>的原理，我之前曾经总结过一篇文章，有兴趣的同学也可以参考:<a href="https://juejin.cn/post/6968084138125590541" target="_blank" rel="noopener">【带着问题学】关于LeakCanary2.0你应该知道的知识点</a></p>
<h3 id="3-4-内存优化的一些常规手段"><a href="#3-4-内存优化的一些常规手段" class="headerlink" title="3.4 内存优化的一些常规手段"></a>3.4 内存优化的一些常规手段</h3><p>内存优化的一些细节问题可以在开发时避免，下面介绍一些常规的内存优化手段<br>1）、使用<code>LargeHeap</code>属性增加最大可用内存<br>2）、在系统触发资源紧张回调时，主动删除缓存<br>3）、使用优化过后的集合：如<code>SparseArray</code>类等<br>4）、谨慎使用 <code>SharedPreference</code>,<code>SP</code>会在应用初始化时将所有内容加载到内存中，所以不应该存放比较大的内容<br>5）、谨慎使用外部库，引入时需要明确不会对应用性能造成大的影响<br>6）、业务架构设计要合理,抽象可以优化代码的灵活性和可维护性，但是抽象也会带来其他成本,应权衡使用    </p>
<p>这些细节问题其实都很普通，如果平时注意到了，相信对应用的内存一定有所帮助</p>
<h2 id="4-怎么做图片内存优化？"><a href="#4-怎么做图片内存优化？" class="headerlink" title="4. 怎么做图片内存优化？"></a>4. 怎么做图片内存优化？</h2><p>内存优化应该优先去做见效快的地方，图片内存优化是内存优化的重点，可能一张图片没有回收就会造成几M内存的浪费          </p>
<h3 id="4-1-常规的图片内存优化方法"><a href="#4-1-常规的图片内存优化方法" class="headerlink" title="4.1 常规的图片内存优化方法"></a>4.1 常规的图片内存优化方法</h3><p>我们都知道，图片所占内存=宽<em>高</em>一像素占用内存<br>所以优化图片内存主要有以下几个思路<br>1.缩放减小宽高<br>2.减少每个像素所占用的内存<br>3.内存复用，避免重复分配内存<br>4.对于大图，可以采取局部加载的策略      </p>
<h4 id="4-1-1-减少图片宽高"><a href="#4-1-1-减少图片宽高" class="headerlink" title="4.1.1 减少图片宽高"></a>4.1.1 减少图片宽高</h4><p>有时图片宽高为<code>200*200</code>,而<code>View</code>宽高为<code>100*100</code>,这种时候如果展示<code>200*200</code>的图片没有意义，应该对图片进行缩放<br>这种情况一般通过<code>inSampleSize</code>实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitampFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line"><span class="comment">// 设置为4就是宽和高都变为原来1/4大小的图片</span></span><br><span class="line">options.inSampleSize = <span class="number">4</span>;</span><br><span class="line">BitmapFactory.decodeSream(is, <span class="keyword">null</span>, options);</span><br></pre></td></tr></table></figure></p>
<h4 id="4-1-2-减少每个像素所占用的内存"><a href="#4-1-2-减少每个像素所占用的内存" class="headerlink" title="4.1.2 减少每个像素所占用的内存"></a>4.1.2 减少每个像素所占用的内存</h4><p>在<code>API29</code>中，将<code>Bitmap</code>分为<code>ALPHA_8</code>, <code>RGB_565</code>, <code>ARGB_4444</code>, <code>ARGB_8888</code>, <code>RGBA_F16</code>, <code>HARDWARE</code>六个等级。</p>
<ul>
<li><code>ALPHA_8</code>：不存储颜色信息，每个像素占1个字节；</li>
<li><code>RGB_565</code>：仅存储<code>RGB</code>通道，每个像素占2个字节，对<code>Bitmap</code>色彩没有高要求，可以使用该模式；</li>
<li><code>ARGB_4444</code>：已弃用，用<code>ARGB_8888</code>代替；</li>
<li><code>ARGB_8888</code>：每个像素占用4个字节，保持高质量的色彩保真度，默认使用该模式；</li>
<li><code>RGBA_F16</code>：每个像素占用8个字节，适合宽色域和<code>HDR</code>；</li>
<li><code>HARDWARE</code>：一种特殊的配置，减少了内存占用同时也加快了<code>Bitmap</code>的绘制。</li>
</ul>
<p>每个等级每个像素所占用的字节也都不一样，所存储的色彩信息也不同。同一张100像素的图片，<code>ARGB_8888</code>就占了400字节，<code>RGB_565</code>才占200字节<br>所以在某些场景中，修改图片格式可以达到减少一半内存的效果         </p>
<h4 id="4-1-3-内存复用，避免重复分配内存"><a href="#4-1-3-内存复用，避免重复分配内存" class="headerlink" title="4.1.3 内存复用，避免重复分配内存"></a>4.1.3 内存复用，避免重复分配内存</h4><p><code>Bitmap</code>所占内存比较大，如果我们频繁创建与回收<code>Bitmap</code>，那么很容易造成内存抖动,所以我们应该尽量复用<code>Bitmap</code>内存     </p>
<p>在 <code>Android 3.0（API 级别 11）</code>开始，系统引入了 <code>BitmapFactory.Options.inBitmap</code> 字段。如果设置了此选项，那么采用 <code>Options</code> 对象的解码方法会在生成目标 <code>Bitmap</code> 时尝试复用 <code>inBitmap</code>，这意味着 <code>inBitmap</code> 的内存得到了重复使用，从而提高了性能，同时移除了内存分配和取消分配。不过 <code>inBitmap</code> 的使用方式存在某些限制，在 <code>Android 4.4（API 级别 19）</code>之前系统仅支持复用大小相同的位图，4.4 之后只要 <code>inBitmap</code> 的大小比目标 <code>Bitmap</code> 大即可</p>
<h4 id="4-1-4-大图局部加载策略"><a href="#4-1-4-大图局部加载策略" class="headerlink" title="4.1.4 大图局部加载策略"></a>4.1.4 大图局部加载策略</h4><p>对于图片加载还有种情况，就是单个图片非常巨大，并且还不允许压缩。比如显示：世界地图、清明上河图、微博长图等<br>首先不压缩，按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中<br>所以这种情况的优化思路一般是局部加载，通过<code>BitmapRegionDecoder</code>来实现<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置显示图片的中心区域</span></span><br><span class="line">BitmapRegionDecoder bitmapRegionDecoder = BitmapRegionDecoder.newInstance(inputStream, <span class="keyword">false</span>);</span><br><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">Bitmap bitmap = bitmapRegionDecoder.decodeRegion(<span class="keyword">new</span> Rect(width / <span class="number">2</span> - <span class="number">100</span>, height / <span class="number">2</span> - <span class="number">100</span>, width / <span class="number">2</span> + <span class="number">100</span>, height / <span class="number">2</span> + <span class="number">100</span>), options);</span><br><span class="line">mImageView.setImageBitmap(bitmap);</span><br></pre></td></tr></table></figure></p>
<h4 id="4-1-5-小结"><a href="#4-1-5-小结" class="headerlink" title="4.1.5 小结"></a>4.1.5 小结</h4><p>上面所说的这些关于<code>Bitmap</code>的内存优化策略其实都比较简单，而且我们在开发中可能很少用到<br>因为我们常用的图片框架比如<code>Glide</code>已经将这些都封装在里面了，所以一般情况下我们加载图片时不需要做这些特殊操作<br>关于<code>Glide</code>对于加载图片都做了哪些优化，有兴趣的同学可以参考:<a href="https://juejin.cn/post/6970683481127043085" target="_blank" rel="noopener">【带着问题学】Glide做了哪些优化?</a>      </p>
<h3 id="4-2-图片兜底策略"><a href="#4-2-图片兜底策略" class="headerlink" title="4.2 图片兜底策略"></a>4.2 图片兜底策略</h3><p>针对因<code>activity</code>、<code>fragment</code>泄漏导致的图片泄漏，我们可以在<code>onDetachedFromWindow</code>时机进行了监控和兜底，具体流程如下：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a851196e2f5439fa05070ac0c37eb90~tplv-k3u1fbpfcp-watermark.image" alt><br>通过这种方式可以方便地解决因<code>Activity</code>导致的图片泄漏问题         </p>
<h3 id="4-3-线上大图监控方案"><a href="#4-3-线上大图监控方案" class="headerlink" title="4.3 线上大图监控方案"></a>4.3 线上大图监控方案</h3><p>当运营在线上配置了不合理大小的图片时，如果我们及时发现，也会带来内存问题<br>如果图片本身大小就不合理，我们在这个基础上谈图片优化也没有什么意义，因此大图监控这也是个比较常见的需求<br>下面介绍几种大图监控的方案：     </p>
<h4 id="4-3-1-ArtHook-方案"><a href="#4-3-1-ArtHook-方案" class="headerlink" title="4.3.1 ArtHook 方案"></a>4.3.1 <code>ArtHook</code> 方案</h4><p>该方案采用<code>weishu</code>大佬写的<code>epic</code>库实现，通过对<code>ART</code>虚拟机的<code>hook</code>，<code>hook ImageView</code>的 <code>setImageBitmap</code> 等方法<br>解析对比方法参数中的 <code>bitmap</code> 宽高和 <code>ImageView</code> 实例的宽高，也可以获得<code>bitmap</code>的实际大小<br>如果图片宽高比<code>ImageView</code>宽高大，或者图片大小超出了阈值，就可以把相关信息上报         </p>
<p>这种方案的优点在于：<br>1.侵入性极低，一次初始化配置即可<code>hook</code>全局的目标<code>View</code>控件<br>2.可以获取代码调用堆栈，方便开发者快速定位       </p>
<p>而缺点则在于:<br>兼容性存在问题，使用了<code>hook</code>系统<code>API</code> ,不能用于线上      </p>
<h4 id="4-3-2-BaseActivity-方案"><a href="#4-3-2-BaseActivity-方案" class="headerlink" title="4.3.2 BaseActivity 方案"></a>4.3.2 <code>BaseActivity</code> 方案</h4><p>大部分应用工程在业务发展的过程中都会沉淀封装自己的<code>BaseActivity</code> ，通过在<code>BaseActivity onDestroy</code>中动态地检测各个<code>View</code>控件，从而获知图片加载情况<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span> : <span class="type">Activity</span></span>()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onDestory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isOpenCheckBitmap)&#123;</span><br><span class="line">            checkBitmapFromView()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">checkBitmapFromView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、遍历activity中的各个View控件</span></span><br><span class="line">        <span class="comment">//2、获取View控件加载的Bitmap</span></span><br><span class="line">        <span class="comment">//3、对比Bitmap宽高与View宽高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方案的优点在于：<br>1.兼容性强，无任何反射<br>2.加入简单，没有什么复杂逻辑     </p>
<p>缺点在于：<br>1.侵入性太强，需要修改<code>BaseActivity</code><br>2.<code>BaseActivity.onDestory</code>本身可能被重写,并不安全       </p>
<h4 id="4-3-3-ASM方案"><a href="#4-3-3-ASM方案" class="headerlink" title="4.3.3 ASM方案"></a>4.3.3 <code>ASM</code>方案</h4><p>该方案在编译流程进行插桩，通过匹配<code>setImageBitmap</code> 、 <code>setBackground</code> 等关键方法，插入<code>Bitmap</code>大小检测逻辑<br>这种方案优点在于：<br>1.编译时期插桩，对开发过程无侵入性       </p>
<p>缺点在于：<br>1.通过插桩的方式打点，可能会增加编译期耗时<br>2.<code>ASM</code>代码维护成本较高，使用起来不是那么方便        </p>
<h4 id="4-3-4-registerActivityLifecycleCallback方案"><a href="#4-3-4-registerActivityLifecycleCallback方案" class="headerlink" title="4.3.4 registerActivityLifecycleCallback方案"></a>4.3.4 <code>registerActivityLifecycleCallback</code>方案</h4><p>通过<code>registerActivityLifecycleCallback</code>监听<code>Activity</code>生命周期,在<code>onStop</code>时进行<code>Bitmap</code>大小检测的逻辑<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerActivityLifecycleCallback</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    application.registerActivityLifecycleCallbacks(<span class="keyword">object</span> :</span><br><span class="line">        Application.ActivityLifecycleCallbacks &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityStopped</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">            checkBitmapIsTooBig(childViews)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方案对原始代码无侵入性，同时使用起来比较简单，也没有兼容性问题，应该属于比较良好的方案<br>详细实现可见：<a href="https://juejin.cn/post/6956138531789996040#heading-14" target="_blank" rel="noopener">BitmapCanary 诞生</a></p>
<h2 id="5-怎么做OOM线上监控"><a href="#5-怎么做OOM线上监控" class="headerlink" title="5.怎么做OOM线上监控?"></a>5.怎么做<code>OOM</code>线上监控?</h2><p>上文我们介绍了，可以使用<code>LeakCanary</code>在线下监测内存泄漏，但是<code>LeakCanary</code>只能在线下使用,有以下问题<br>1.线下场景能跑到的场景有限，很难把所有用户场景穷尽.碰到线上问题难以定位<br>2.检测过程需要主动触发<code>GC</code>,<code>Dump</code>内存镜像造成<code>app</code>冻结，造成测试过程中体验不好<br>3.适用范围有限，只能定位<code>Activity</code>&amp;<code>Fragment</code>泄漏，无法定位大对象、频繁分配等问题<br>4.<code>hprof</code>文件过大，如果整体上传的话需要耗费很多资源         </p>
<p>下面我们就介绍一下快手开源的线上<code>OOM</code>监控框架<code>KOOM</code></p>
<h3 id="5-1-线上OOM监控框架KOOM介绍"><a href="#5-1-线上OOM监控框架KOOM介绍" class="headerlink" title="5.1 线上OOM监控框架KOOM介绍"></a>5.1 线上<code>OOM</code>监控框架<code>KOOM</code>介绍</h3><p>上面我们介绍了<code>LeakCanary</code>不能用于线上监控的原因，所以要实现线上监控功能，就需要解决以下问题          </p>
<ul>
<li>监控<ul>
<li>主动触发<code>GC</code>，会造成卡顿</li>
</ul>
</li>
<li>采集<ul>
<li><code>Dump hprof</code>，会造成<code>app</code>冻结</li>
<li><code>Hprof</code>文件过大</li>
</ul>
</li>
<li>解析<ul>
<li>解析耗时过长</li>
<li>解析本身有<code>OOM</code>风险</li>
</ul>
</li>
</ul>
<p>其核心流程为三部分：<br>1.监控<code>OOM</code>，发生问题时触发内存镜像的采集，以便进一步分析问题<br>2.采集内存镜像，学名堆转储，将内存数据拷贝到文件中，以下简称<code>dump hprof</code><br>3.解析镜像文件，对泄漏、超大对象等我们关注的对象进行可达性分析，解析出其到<code>GC root</code>的引用链以解决问题<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5e9651d7bd943c4afb211591e994475~tplv-k3u1fbpfcp-zoom-1.image" alt></p>
<h3 id="5-2-KOOM解决GC卡顿"><a href="#5-2-KOOM解决GC卡顿" class="headerlink" title="5.2 KOOM解决GC卡顿"></a>5.2 <code>KOOM</code>解决<code>GC</code>卡顿</h3><p><code>LeakCanary</code>通过多次<code>GC</code>的方式来判断对象是否被回收，所以会造成性能损耗<br><code>koom</code>通过无性能损耗的内存阈值监控来触发镜像采集，具体策略如下：       </p>
<ul>
<li><code>Java</code>堆内存/线程数/文件描述符数突破阈值触发采集</li>
<li><code>Java</code>堆上涨速度突破阈值触发采集</li>
<li>发生<code>OOM</code>时如果策略1、2未命中 触发采集</li>
<li>泄漏判定延迟至解析时</li>
</ul>
<p>我们并不需要在运行时判定对象是否泄漏，以<code>Activity</code>为例，我们并不需要在运行时判定其是否泄漏，<code>Activity</code>有一个成员变<code>mDestroyed</code>，在<code>onDestory</code>时会被置为<code>true</code>，只要解析时发现有可达且<code>mDestroyed</code>为<code>true</code>的<code>Activity</code>，即可判定为泄漏<br>通过将泄漏判断延迟至解析时，即可解决<code>GC</code>卡顿的问题<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd2f54d13770470289b9518957639f69~tplv-k3u1fbpfcp-zoom-1.image" alt>               </p>
<h3 id="5-3-KOOM解决Dump-hprof冻结app"><a href="#5-3-KOOM解决Dump-hprof冻结app" class="headerlink" title="5.3 KOOM解决Dump hprof冻结app"></a>5.3 <code>KOOM</code>解决<code>Dump hprof</code>冻结<code>app</code></h3><p><code>Dump hprof</code>即采集内存镜像需要暂停虚拟机，以确保在内存数据拷贝到磁盘的过程中，引用关系不会发生变化，暂停时间通常长达10秒以上，对用户来讲是难以接受的，这也是<code>LeakCanary</code>官方不推荐线上使用的重要原因之一。<br>利用<code>Copy-on-write</code>机制，<code>fork</code>子进程<code>dump</code>内存镜像，可以完美解决这一问题，<code>fork</code>成功以后，父进程立刻恢复虚拟机运行，子进程<code>dump</code>内存镜像期间不会受到父进程数据变动的影响。<br>流程如下图所示：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8271f1c2b5ce4e3181d507ed2c4d732c~tplv-k3u1fbpfcp-zoom-1.image" alt><br><code>KOOM</code>随机采集线上真实用户的内存镜像，普通<code>dump</code>和<code>fork</code>子进程<code>dump</code>阻塞用户使用的耗时如下：<br><img src="https://github.com/KwaiAppTeam/KOOM/wiki/images/android_benchmark_cn.png" alt><br>可以看出，基本可以做到无感知的采集内存镜像        </p>
<h3 id="5-4-KOOM解决hprof文件过大"><a href="#5-4-KOOM解决hprof文件过大" class="headerlink" title="5.4 KOOM解决hprof文件过大"></a>5.4 <code>KOOM</code>解决<code>hprof</code>文件过大</h3><p><code>Hprof</code>文件通常比较大，分析<code>OOM</code>时遇到500M以上的<code>hprof</code>文件并不稀奇，文件的大小，与<code>dump</code>成功率、<code>dump</code>速度、上传成功率负相关，且大文件额外浪费用户大量的磁盘空间和流量。<br>因此需要对<code>hprof</code>进行裁剪，只保留分析<code>OOM</code>必须的数据，另外，裁剪还有数据脱敏的好处，只上传内存中类与对象的组织结构，并不上传真实的业务数据（诸如字符串、<code>byte</code>数组等含有具体数据的内容），保护用户隐私。<br>裁剪<code>hprof</code>文件涉及到对<code>hprof</code>文件格式的了解，这里就不缀述了<br>下面看一下裁剪过程的流程图：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3fd3422bb5b4f7689c25fd554f5c88f~tplv-k3u1fbpfcp-zoom-1.image" alt>          </p>
<h3 id="5-5-KOOM解决hprof解析的耗时与OOM"><a href="#5-5-KOOM解决hprof解析的耗时与OOM" class="headerlink" title="5.5 KOOM解决hprof解析的耗时与OOM"></a>5.5 <code>KOOM</code>解决<code>hprof</code>解析的耗时与<code>OOM</code></h3><p>解析<code>hprof</code>文件，对关键对象进行可达性分析，得到引用链，是解决<code>OOM</code>最核心的一步，之前的监控和<code>dump</code>都是为解析做铺垫。<br>解析分两种，一种是上传<code>hprof</code>文件由<code>server</code>解析，另一种是在客户端解析后上传报告(通常只有几<code>KB</code>)。<br><code>KOOM</code>选择了端上解析，这样做有两个好处：        </p>
<ul>
<li>1.节省用户流量           </li>
<li>2.利用用户闲时算力，降低<code>server</code>压力，这样也符合分布式计算理念。      </li>
</ul>
<p>这样就可以把解析过程拆解成以下两个问题       </p>
<ul>
<li>哪些对象需要分析，全部分析性能开销太大，很难在端上完成，并且问题没有重点也不利于解决。</li>
<li>性能优化，作为一个<code>debug</code>组件，要在不影响用户体验的情况下完成解析，对性能有非常高的要求。</li>
</ul>
<h4 id="5-5-1-关键对象判定"><a href="#5-5-1-关键对象判定" class="headerlink" title="5.5.1 关键对象判定"></a>5.5.1 关键对象判定</h4><p><code>KOOM</code>只解析关键的对象，关键对象分为两类，一类是根据规则可以判断出对象已经泄露，且持有大量资源的，另外一类是对象<code>shallow / retained size</code> 超过阈值<br><code>Activity/fragment</code>泄露判定即为第一种:<br>对于强可达的<code>activity</code>对象，其<code>mDestroyed</code>值为<code>true</code>时(<code>onDestroy</code>时赋值)，判定已经泄露。<br>类似的，对于<code>fragment</code>，当<code>mCalled</code>值为<code>true</code>且<code>mFragmentManager</code>为<code>null</code>时，判定已经泄露 。       </p>
<p><code>Bitmap/window/array/sufacetexture</code>判定为第二种<br>检查<code>bitmap/texture</code>的数量、宽高、<code>window</code>数量、<code>array</code>长度等等是否超过阈值，再结合<code>hprof</code>中的相关业务信息，比如屏幕大小，<code>view</code>大小等进行判定。            </p>
<h4 id="5-5-2-性能优化"><a href="#5-5-2-性能优化" class="headerlink" title="5.5.2 性能优化"></a>5.5.2 性能优化</h4><p><code>KOOM</code>在<code>LeakCanary</code>解析引擎<code>shark</code>的基础上做了一些优化，将解析时间在<code>shark</code>的基础上优化了2倍以上，内存峰值控制在100M以内。 用一张图总结解析的流程：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/627840a253884469847989453ccb14d7~tplv-k3u1fbpfcp-zoom-1.image" alt><br>详细流程就不在这里缀述了，详情可见：<a href="https://juejin.cn/post/6860014199973871624#heading-13" target="_blank" rel="noopener">KOOM解析性能优化</a>        </p>
<h3 id="5-6-KOOM使用"><a href="#5-6-KOOM使用" class="headerlink" title="5.6 KOOM使用"></a>5.6 <code>KOOM</code>使用</h3><p><code>KOOM</code>目前已经开源，开源地址：<a href="https://github.com/KwaiAppTeam/KOOM" target="_blank" rel="noopener">https://github.com/KwaiAppTeam/KOOM</a><br>直接参照接入指南接入即可，当发现内存超过阈值或者发生<code>OOM</code>时，就会触发采集内存快照，对<code>hprof</code>文件进行裁剪并分析后得到报告<br><code>KOOM</code>的报告是<code>json</code>格式，并且大小在<code>KB</code>级别，样式如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog11/p3.png" alt><br>大概包括以下信息<br>1.一些可能泄漏的类信息<br>2.泄漏原因,<code>gcRoot</code>,泄漏实例数量等<br>3.泄漏对象的引用链，方便定位问题         </p>
<p>可见<code>KOOM</code>上传的数据量并不太大，但相对准确，非常便于我们分析线上数据           </p>
<h3 id="5-7-小结"><a href="#5-7-小结" class="headerlink" title="5.7 小结"></a>5.7 小结</h3><p>本章主要介绍了线上监控<code>OOM</code>的开源框架<code>KOOM</code><br>其实线上监控<code>OOM</code>的框架各大厂都有开发，比如美团的<a href="https://tech.meituan.com/2019/11/14/crash-oom-probe-practice.html" target="_blank" rel="noopener">Probe</a>,字节的<a href="https://juejin.cn/post/6908517174667804680#heading-7" target="_blank" rel="noopener">Liko</a><br>不过大部分都没有正式开源，只是一些文章介绍原理，有兴趣的同学也可以都了解下      </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于优化的大方向，我们应该优先去做见效快的地方，主要有以下几个部分：<br>1.内存泄漏<br>2.内存抖动<br>3.<code>Bitmap</code>大图监控<br>4.<code>OOM</code>线上监控       </p>
<p>我们还介绍了内存优化的多种实用工具<br>1.可以使用<code>Profile</code>,<code>MAT</code>在开发时定位内存抖动内存泄漏问题<br>2.线下开发、回归、<code>Monkey</code>、压测等环节可以自动集成<code>LeakCanary</code>检测内存泄漏；<br>3.图片加载是内存优化的重点，我们可以结合图片兜底策略与线上大图监控，优化图片内存问题<br>4.线上<code>OOM</code>时通过<code>KOOM</code>监测，内存超出阈值时主动<code>dump</code>内存快照，通过上传分析结果精准分析<code>OOM</code>问题。       </p>
<p>内存优化是个复杂的过程，我们在做内存优化的过程中，需要结合多种工具，线上线下结合，系统化地配合来定位与解决问题    </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844903897958449166" target="_blank" rel="noopener">探索 Android 内存优化方法</a><br><a href="https://juejin.cn/post/6872919545728729095#heading-70" target="_blank" rel="noopener">深入探索 Android 内存优化（炼狱级别-下）</a><br><a href="https://juejin.cn/post/6956138531789996040" target="_blank" rel="noopener">更优雅地检测android应用中的大图</a><br><a href="https://juejin.cn/post/6860014199973871624" target="_blank" rel="noopener">快手客户端稳定性体系建设</a><br><a href="https://tech.meituan.com/2019/11/14/crash-oom-probe-practice.html" target="_blank" rel="noopener">Probe：Android线上OOM问题定位组件</a><br><a href="https://juejin.cn/post/6908517174667804680" target="_blank" rel="noopener">抖音 Android 性能优化系列: Java 内存优化篇</a>       </p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【带着问题学】 android事件分发8连问</title>
    <url>/blog/2021/05/dispatch-sum-up.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>android</code>事件分发是我们开发中的必备技能，但是关于事件分发的的知识点也有些繁杂。<br>如果我们从头开始阅读源码，往往千头万绪，抓不住要领。<br>我们可以从以下几个问题出发，提纲契领地掌握这个知识点。<br>读者最后也可以通过判断自己的问题是否得到解决，来判断自己是否真的掌握了这个知识点      </p>
<p>首先我们可以思考下，<strong>从我们触摸屏幕到<code>App</code>响应事件，都发生了什么，可以分为哪几个部分？</strong><br>我们将整个<code>Touch</code>事件可以分解为以下几个部分      </p>
<ul>
<li>1.<code>Touch</code>事件如何从屏幕到我们的<code>App</code>    </li>
<li>2.<code>Touch</code>事件到达<code>App</code>后怎么传递到对应页面    </li>
<li>3.<code>Touch</code>事件到达对应页面后内部怎样分发     </li>
</ul>
<p>其中与上层软件开发息息相关的就是第3条，也是我们最关注的，它也可以拆解为以下几个问题     </p>
<ul>
<li><code>ViewGroup</code>是否拦截事件,拦截与不拦截后分别怎么处理？</li>
<li>子<code>View</code>是否拦截事件，拦截与不拦截后分别怎么处理？</li>
<li><code>ViewGroup</code>与子<code>View</code>都不拦截，最终事件如何处理？</li>
<li>如何处理事件冲突？</li>
</ul>
<p>以上问题总结为思维导图如下:<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog10/p7.png" alt><br>接下来就具体分析分析</p>
<h2 id="1-Touch事件如何从屏幕到我们的App"><a href="#1-Touch事件如何从屏幕到我们的App" class="headerlink" title="1.Touch事件如何从屏幕到我们的App"></a>1.<code>Touch</code>事件如何从屏幕到我们的<code>App</code></h2><h3 id="1-1-硬件与内核部分"><a href="#1-1-硬件与内核部分" class="headerlink" title="1.1 硬件与内核部分"></a>1.1 硬件与内核部分</h3><p>当我们触摸屏幕或者按键操作时，首先触发的是硬件驱动<br>驱动收到事件后，将相应事件写入到输入设备节点，这便产生了最原生态的内核事件<br>当屏幕被触摸，<code>Linux</code>内核会将硬件产生的触摸事件包装为<code>Event</code>存到<code>/dev/input/event[x]</code>目录下     </p>
<p>这样做的目的是将输入事件封装为通用的<code>Event</code>，供后续处理   </p>
<h3 id="1-2-SystemServer部分"><a href="#1-2-SystemServer部分" class="headerlink" title="1.2 SystemServer部分"></a>1.2 <code>SystemServer</code>部分</h3><p>我们知道，当系统启动时，在<code>SystemServer</code>进程会启动一系列系统服务，如<code>AMS</code>,<code>WMS</code>等<br>其中还有一个就是我们管理事件输入的<code>InputManagerService</code>     </p>
<p>这个服务就是用来负责与硬件通信，接受屏幕输入事件。<br>在其内部，会启动一个读线程，也就是<code>InputReader</code>，它会从系统也就是<code>/dev/input/</code>目录拿到任务，并且分发给<code>InputDispatcher</code>线程，然后进行统一的事件分发调度。     </p>
<h3 id="1-3-跨进程通信传递给App"><a href="#1-3-跨进程通信传递给App" class="headerlink" title="1.3 跨进程通信传递给App"></a>1.3 跨进程通信传递给<code>App</code></h3><p>现在系统进程已经拿到输入事件了，但还需要传递给<code>App</code>进程，这就涉及到跨进程通信的部分<br>我们的<code>App</code>中的<code>Window</code>与<code>InputManagerService</code>之间的通信实际上使用的<code>InputChannel</code><br><code>InputChannel</code>是一个<code>pipe</code>，底层实际是通过<code>socket</code>进行通信。<br>我们知道在<code>Activity</code>启动时会调用<code>ViewRootImpl.setView()</code><br>在<code>ViewRootImpl.setView()</code>过程中，也会同时注册<code>InputChannel</code>：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">      requestLayout();</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 创建InputChannel</span></span><br><span class="line">      mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">      <span class="comment">// 通过Binder在SystemServer进程中完成InputChannel的注册</span></span><br><span class="line">      mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到了<code>WindowManagerService</code>和<code>Binder</code>跨进程通信，读者不需要纠结于详细的细节<br>只需了解最终在<code>SystemServer</code>进程中，<code>WindowManagerService</code>根据当前的<code>Window</code>创建了<code>SocketPair</code>用于跨进程通信，同时并对<code>App</code>进程中传过来的<code>InputChannel</code>进行了注册<br>这之后，<code>ViewRootImpl</code>里的<code>InputChannel</code>就指向了正确的<code>InputChannel</code>, 作为<code>Client</code>端，其<code>fd</code>与<code>SystemServer</code>进程中<code>Server</code>端的<code>fd</code>组成<code>SocketPair</code>, 它们就可以双向通信了。<br><img src="https://user-gold-cdn.xitu.io/2019/8/28/16cd7c108212f2aa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt>     </p>
<p>然后我们<code>App</code>进程的主线程就会监听<code>socket</code>客户端，当收到消息（输入事件）后，回调<code>NativeInputEventReceiver.handleEvent()</code>方法，最终会走到<code>InputEventReceiver.dispachInputEvent</code>方法。     </p>
<p>经过以上操作<code>App</code>终于拿到输入事件了，接下来就是传递到对应页面        </p>
<h3 id="1-4小结"><a href="#1-4小结" class="headerlink" title="1.4小结"></a>1.4小结</h3><p>关于内核处理输入事件与跨进程通信的部分一般来说不是应用开发者最关注的部分，也不是本文的重点，所以只做了概述<br>想要了解细节的同学可参考：<a href="http://gityuan.com/2016/12/31/input-ipc/" target="_blank" rel="noopener">Input系统—事件处理全过程</a></p>
<h2 id="2-Touch事件到达App后怎么传递到对应页面"><a href="#2-Touch事件到达App后怎么传递到对应页面" class="headerlink" title="2.Touch事件到达App后怎么传递到对应页面"></a>2.<code>Touch</code>事件到达<code>App</code>后怎么传递到对应页面</h2><p>现在我们已经在<code>App</code>进程中拿到输入事件了，接下来看看事件如何分发到页面<br>我们接下来跟一下源码    </p>
<h3 id="2-1-事件回传到ViewRootImpl"><a href="#2-1-事件回传到ViewRootImpl" class="headerlink" title="2.1 事件回传到ViewRootImpl"></a>2.1 事件回传到<code>ViewRootImpl</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InputEventReceiver.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event)</span> </span>&#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewRootImpl.java ::WindowInputEventReceiver</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title">InputEventReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span> </span>&#123;</span><br><span class="line">       enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueInputEvent</span><span class="params">(InputEvent event,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputEventReceiver receiver, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> processImmediately)</span> </span>&#123;</span><br><span class="line">    adjustInputEventForCompatibility(event);</span><br><span class="line">    QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);</span><br><span class="line"></span><br><span class="line">    QueuedInputEvent last = mPendingInputEventTail;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingInputEventHead = q;</span><br><span class="line">        mPendingInputEventTail = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        last.mNext = q;</span><br><span class="line">        mPendingInputEventTail = q;</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingInputEventCount += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">        doProcessInputEvents(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduleProcessInputEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到事件还是回到了<code>ViewRootImpl</code>中，可见<code>ViewRootImpl</code>不仅负责界面的绘制，同时负责事件的传递    </p>
<h3 id="2-2-第一次责任链分发"><a href="#2-2-第一次责任链分发" class="headerlink" title="2.2 第一次责任链分发"></a>2.2 第一次责任链分发</h3><p>接下来走到<code>doProcessInputEvents</code>中，其中涉及到事件分发中的第一次责任链分发<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessInputEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">     <span class="comment">// Deliver all pending input events in the queue.</span></span><br><span class="line">     <span class="keyword">while</span> (mPendingInputEventHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">         QueuedInputEvent q = mPendingInputEventHead;</span><br><span class="line">         mPendingInputEventHead = q.mNext;</span><br><span class="line">         deliverInputEvent(q);</span><br><span class="line">     &#125;</span><br><span class="line">     ....</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">     InputStage stage;</span><br><span class="line">     ....</span><br><span class="line">     <span class="comment">//stage赋值操作</span></span><br><span class="line">     ....</span><br><span class="line">     <span class="keyword">if</span> (stage != <span class="keyword">null</span>) &#123;</span><br><span class="line">         stage.deliver(q);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         finishInputEvent(q);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStage</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> InputStage mNext;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">InputStage</span><span class="params">(InputStage next)</span> </span>&#123;</span><br><span class="line">         mNext = next;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">deliver</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> ((q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED) != <span class="number">0</span>) &#123;</span><br><span class="line">             forward(q);</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldDropInputEvent(q)) &#123;</span><br><span class="line">             finish(q, <span class="keyword">false</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             traceEvent(q, Trace.TRACE_TAG_VIEW);</span><br><span class="line">             <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 result = onProcess(q);</span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">             &#125;</span><br><span class="line">             apply(q, result);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示：<br>1.<code>QueuedInputEvent</code>是一种输入事件，链表结构，遍历传递给<code>InputStage</code><br>2.<code>InputStage</code>是处理输入的责任链，在调用<code>deliver</code>时会遍历责任链传递事件<br>3.事件分发完成后会调用<code>finishInputEvent</code>，告知<code>SystemServer</code>进程的<code>InputDispatcher</code>线程，最终将该事件移除，完成此次事件的分发消费。</p>
<p>那么问题来了,<code>InputStage</code>的责任链是什么时候组件的呢？</p>
<h3 id="2-3-组装责任链"><a href="#2-3-组装责任链" class="headerlink" title="2.3 组装责任链"></a>2.3 组装责任链</h3><p>我们得回到<code>ViewRootImpl.setView</code>方法中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">       	...</span><br><span class="line">        <span class="comment">// Set up the input pipeline.</span></span><br><span class="line">        mSyntheticInputStage = <span class="keyword">new</span> SyntheticInputStage();</span><br><span class="line">        InputStage viewPostImeStage = <span class="keyword">new</span> ViewPostImeInputStage(mSyntheticInputStage);</span><br><span class="line">        InputStage nativePostImeStage = <span class="keyword">new</span> NativePostImeInputStage(viewPostImeStage,</span><br><span class="line">                 <span class="string">"aq:native-post-ime:"</span> + counterSuffix);</span><br><span class="line">        InputStage earlyPostImeStage = <span class="keyword">new</span> EarlyPostImeInputStage(nativePostImeStage);</span><br><span class="line">        InputStage imeStage = <span class="keyword">new</span> ImeInputStage(earlyPostImeStage,</span><br><span class="line">                <span class="string">"aq:ime:"</span> + counterSuffix);</span><br><span class="line">        InputStage viewPreImeStage = <span class="keyword">new</span> ViewPreImeInputStage(imeStage);</span><br><span class="line">        InputStage nativePreImeStage = <span class="keyword">new</span> NativePreImeInputStage(viewPreImeStage,</span><br><span class="line">                        <span class="string">"aq:native-pre-ime:"</span> + counterSuffix);</span><br><span class="line"></span><br><span class="line">        mFirstInputStage = nativePreImeStage;</span><br><span class="line">        mFirstPostImeInputStage = earlyPostImeStage;</span><br><span class="line">        ....</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在<code>setView</code>方法中，就把这条输入事件处理的责任链拼接完成了，不同的<code>InputStage</code>子类，通过构造方法一个个串联起来了，那这些<code>InputStage</code>到底干了啥呢？      </p>
<ul>
<li><code>SyntheticInputStage</code>。综合处理事件阶段，比如处理导航面板、操作杆等事件。</li>
<li><code>ViewPostImeInputStage</code>。视图输入处理阶段，比如按键、手指触摸等运动事件，我们熟知的<code>view</code>事件分发就发生在这个阶段。</li>
<li><code>NativePostImeInputStage</code>。本地方法处理阶段，主要构建了可延迟的队列。</li>
<li><code>EarlyPostImeInputStage</code>。输入法早期处理阶段。</li>
<li><code>ImeInputStage</code>。输入法事件处理阶段，处理输入法字符。</li>
<li><code>ViewPreImeInputStage</code>。视图预处理输入法事件阶段，调用视图<code>view</code>的<code>dispatchKeyEventPreIme</code>方法。</li>
<li><code>NativePreImeInputStage</code>。本地方法预处理输入法事件阶段。</li>
</ul>
<p>小结一下，事件到达应用端的主线程，会通过<code>ViewRootImpl</code>进行一系列<code>InputStage</code>来处理事件。这个阶段其实是对事件进行一些简单的分类处理，比如视图输入事件，输入法事件，导航面板事件等等。<br>我们的<code>View</code>触摸事件就发生在<code>ViewPostImeInputStage</code>阶段<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPostImeInputStage</span> <span class="keyword">extends</span> <span class="title">InputStage</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">onProcess</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">                <span class="keyword">return</span> processKeyEvent(q);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> source = q.mEvent.getSource();</span><br><span class="line">                <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> processPointerEvent(q);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processPointerEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> MotionEvent event = (MotionEvent)q.mEvent;</span><br><span class="line">            <span class="keyword">boolean</span> handled = mView.dispatchPointerEvent(event)</span><br><span class="line">            <span class="keyword">return</span> handled ? FINISH_HANDLED : FORWARD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchPointerEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (event.isTouchEvent()) &#123;</span><br><span class="line">                <span class="keyword">return</span> dispatchTouchEvent(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> dispatchGenericMotionEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>1.经过层层回调会调用到<code>mView.dispatchPointerEvent</code><br>2.我们知道<code>ViewRootImpl</code>中的<code>mView</code>就是<code>DecorView</code>   </p>
<p>现在事件已经传递到了<code>DecorView</code>，也就是我们界面的根布局<br>接下来是事件在<code>Activity</code>,<code>Window</code>,<code>DecorView</code>中的传递   </p>
<h3 id="2-4-事件在Activity-Window-DecorView中的传递"><a href="#2-4-事件在Activity-Window-DecorView中的传递" class="headerlink" title="2.4 事件在Activity,Window,DecorView中的传递"></a>2.4 事件在<code>Activity</code>,<code>Window</code>,<code>DecorView</code>中的传递</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DecorView.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//cb其实就是对应的Activity/Dialog</span></span><br><span class="line">        <span class="keyword">final</span> Window.Callback cb = mWindow.getCallback();</span><br><span class="line">        <span class="keyword">return</span> cb != <span class="keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span></span><br><span class="line">                ? cb.dispatchTouchEvent(ev) : <span class="keyword">super</span>.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//PhoneWindow.java</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DecorView.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到事件分发经过了:<strong><code>DecorView</code> -&gt; <code>Activity</code> -&gt; <code>PhoneWindow</code> -&gt; <code>DecorView</code></strong><br>看起来是一个很奇怪的事件流转，事件从<code>DecorView</code>出发，最后又回到了<code>DecorView</code>，为什么这样做呢？    </p>
<h4 id="2-4-1-为什么ViewRootImpl不直接把事件交给Activity？"><a href="#2-4-1-为什么ViewRootImpl不直接把事件交给Activity？" class="headerlink" title="2.4.1 为什么ViewRootImpl不直接把事件交给Activity？"></a>2.4.1 为什么<code>ViewRootImpl</code>不直接把事件交给<code>Activity</code>？</h4><p>主要是为了解藕<br><code>ViewRootImpl</code>并不知道有<code>Activity</code>这种东西存在！它只是持有了<code>DecorView</code>。所以，不能直接把触摸事件送到<code>Activity.dispatchTouchEvent()</code>    </p>
<h4 id="2-4-2-交给Acitivity后，为什么不直接交给DecorView开始分发事件呢"><a href="#2-4-2-交给Acitivity后，为什么不直接交给DecorView开始分发事件呢" class="headerlink" title="2.4.2 交给Acitivity后，为什么不直接交给DecorView开始分发事件呢?"></a>2.4.2 交给<code>Acitivity</code>后，为什么不直接交给<code>DecorView</code>开始分发事件呢?</h4><p>因为<code>Activity</code>不知道有<code>DecorView</code>！<br>但是，<code>Activity</code>持有<code>PhoneWindow</code> ，而<code>PhoneWindow</code>当然知道自己的窗口里有些什么了，所以能够把事件派发给<code>DecorView</code>。<br>在<code>Android</code>中，<code>Activity</code>并不知道自己的<code>Window</code>中有些什么，这样耦合性就很低了,<code>Activity</code>不需要知道<code>Window</code>中的具体内容    </p>
<h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>经过上述过程，事件终于到了我们熟悉的<code>ViewGroup.dispatchTouchEvent</code><br>流程图如下所示：<br><img src="https://gitee.com/pgm250/blog_img_bed/raw/master/wanan/%E4%BB%8ENative%E5%B1%82%E5%88%B0Framework%E5%B1%82Touch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.png" alt></p>
<h2 id="3-Touch事件到达页面后内部怎样分发"><a href="#3-Touch事件到达页面后内部怎样分发" class="headerlink" title="3.Touch事件到达页面后内部怎样分发"></a>3.<code>Touch</code>事件到达页面后内部怎样分发</h2><p>下面就是我们最常用也是最常见的事件分发部分了</p>
<h3 id="3-1-ViewGroup是否拦截事件"><a href="#3-1-ViewGroup是否拦截事件" class="headerlink" title="3.1 ViewGroup是否拦截事件"></a>3.1 <code>ViewGroup</code>是否拦截事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">    <span class="comment">//只有ActionDown或者mFirstTouchTarget为空时才会判断是否拦截</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">            intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">        <span class="comment">//事件传递给子view</span></span><br><span class="line">        ....</span><br><span class="line">        <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        	...</span><br><span class="line">        	<span class="comment">//如果子View消耗了则给mFirstTouchTarget赋值</span></span><br><span class="line">        	newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        	...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mFirstTouchTarget不为空时会调用dispatchTransformendTouchEvent</span></span><br><span class="line">    <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上可以看出<br>1.只有当<code>Action_Down</code>或者<code>mFirstTouchTarget</code>不为空时才判断是否拦截<br>2.<code>mFirstTouchTarget</code>是个链表结构，代表某个子<code>View</code>消费了事件，为<code>null</code>则表示没有子<code>View</code>消费事件<br>3.在判断是否拦截前有个<code>disallowIntercept</code>字段，这个在后面事件冲突内部拦截法时会用到<br>4.接下来就到了<code>onInterceptTouchEvent</code>,<code>ViewGroup</code>是否拦截事件正是由这个方法控制的     </p>
<h4 id="3-1-2-ViewGroup拦截后会发生什么？"><a href="#3-1-2-ViewGroup拦截后会发生什么？" class="headerlink" title="3.1.2 ViewGroup拦截后会发生什么？"></a>3.1.2 <code>ViewGroup</code>拦截后会发生什么？</h4><p>1.拦截之后，事件自然就不会再下发给子<code>View</code><br>2.接下来如果<code>mFirstTouchTarget</code>为<code>null</code>,则会调用到<code>dispatchTransformedTouchEvent</code>,然后调用到<code>super.dispatchTouchEvent</code>,最终到<code>ViewGroup.onTouchEvent</code><br>3.为什么使用<code>mFirstTouchTarget==null</code>来判断是否是<code>ViewGroup</code>处理，是因为<code>mFirstTouchTarget==null</code>有两种情况，一是<code>ViewGroup</code>拦截，二是子<code>View</code>没有处理事件,两种情况最后都回调到<code>ViewGroup.onTouchEvent</code></p>
<p>通过上面的分析，我们可以得出ViewGroup拦截的伪代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isConsume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isViewGroup) &#123;</span><br><span class="line">        <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;</span><br><span class="line">            isConsume = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> isConsume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是<code>ViewGroup</code>，会先执行到<code>onInterceptTouchEvent</code>方法判断是否拦截，如果拦截，则执行父类<code>View</code>的<code>dispatchTouchEvent</code>方法。    </p>
<h4 id="3-1-3-ViewGroup不拦截会发生什么"><a href="#3-1-3-ViewGroup不拦截会发生什么" class="headerlink" title="3.1.3 ViewGroup不拦截会发生什么?"></a>3.1.3 <code>ViewGroup</code>不拦截会发生什么?</h4><p>如果<code>ViewGroup</code>不拦截，则会传递到子<code>View</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    	<span class="comment">//遍历子View</span></span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                        childrenCount, i, customOrder);</span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                        preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.判断事件坐标</span></span><br><span class="line">                <span class="keyword">if</span> (!child.canReceivePointerEvents()</span><br><span class="line">                        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//3.传递事件</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不拦截，<code>ViewGroup</code>内主要做以下几件事<br>1.遍历当前<code>ViewGroup</code>的所有子<code>View</code><br>2.判断当前<code>View</code>是否在当前子<code>View</code>的坐标范围内，不在范围内不能接收事件，直接跳过<br>3.利用<code>dispatchTransformedTouchEvent</code>,如果返回<code>true</code>,则通过<code>addTouchTarget</code>对<code>mFirstTouchTarget</code>赋值<br>4.<code>dispatchTransformedTouchEvent</code>做的主要就是两个事，如果<code>child</code>不为<code>null</code>，则事件分发到<code>child</code>,否则调用<code>super.dispatchTouchEvent</code>,并最终返回结果<br>5.<code>mFirstTouchTarget</code>是单链表结构，记录消费链，但是在单点触控的时候这个特性没有用上，只是一个普通的<code>TouchTarget</code>对象</p>
<h3 id="3-2-子View是否拦截"><a href="#3-2-子View是否拦截" class="headerlink" title="3.2 子View是否拦截"></a>3.2 子<code>View</code>是否拦截</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            </span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>子<code>View</code>的<code>diapatchTouchEvent</code>逻辑比较简单<br>1.如果设置了<code>setOnTouchListener</code>并且返回为<code>true</code>，那么<code>onTouchEvent</code>就不再执行<br>2.否则执行<code>onTouchEvent</code>，我们常用的<code>OnClickListenr</code>就是在<code>onTouchEvent</code>里触发的    </p>
<p>所以默认情况下会直接执行<code>onTouchEvent</code>，如果我们设置了<code>setOnClickListener</code>或者<code>setLongClickListener</code>，都会正常触发   </p>
<h4 id="3-2-1-如果子View消费事件会怎么样？"><a href="#3-2-1-如果子View消费事件会怎么样？" class="headerlink" title="3.2.1 如果子View消费事件会怎么样？"></a>3.2.1 如果子<code>View</code>消费事件会怎么样？</h4><p>上面说了，如果子<code>View</code>消费事件，即<code>dispatchTouchEvent</code>方法返回<code>true</code><br>表示这个事件我处理了，那么事件从此结束,<code>ViewGroup</code>的<code>dispatchTouchEvent</code>也返回<code>true</code><br>最后回到<code>Activity</code>的<code>dispatchTouchEvent</code>，也是直接返回<code>true</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Activity.java</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            onUserInteraction();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>小结：如果子<code>View</code>消费事件的话，事件就此结束了   </p>
<h4 id="3-2-2-如果子View不消费事件会怎么样？"><a href="#3-2-2-如果子View不消费事件会怎么样？" class="headerlink" title="3.2.2 如果子View不消费事件会怎么样？"></a>3.2.2 如果子<code>View</code>不消费事件会怎么样？</h4><p>子<code>View</code>不拦截事件，那么<code>mFirstTouchTarget</code>就为<code>null</code>，退出循环后，调用了<code>dispatchTransformedTouchEvent</code>方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>小结一下：<br>1.子<code>View</code>不拦截事件，就回调到了<code>dispatchTransformedTouchEvent</code><br>2.然后就调到了<code>super.dispatchTouchEvent</code><br>3.那么接下来<code>ViewGroup</code>就跟子<code>View</code>的逻辑一样了,默认执行<code>onTouchEvent</code>，如果设置了<code>setOnTouchLister</code>则执行<code>onTouch</code></p>
<h3 id="3-3-如果ViewGroup与子View都不拦截会怎么样"><a href="#3-3-如果ViewGroup与子View都不拦截会怎么样" class="headerlink" title="3.3 如果ViewGroup与子View都不拦截会怎么样"></a>3.3 如果<code>ViewGroup</code>与子<code>View</code>都不拦截会怎么样</h3><p>如果<code>ViewGroup</code>与子<code>View</code>都不拦截，即<code>mFirstTouchTarget == null</code>,<code>dispatchTouchEvent</code>也返回<code>false</code><br>再看看<code>Activity</code>的源码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>答案很明显：会执行<code>Activity</code>的<code>onTouchEvent</code>方法   </p>
<h3 id="3-4-后续事件如何分发？"><a href="#3-4-后续事件如何分发？" class="headerlink" title="3.4 后续事件如何分发？"></a>3.4 后续事件如何分发？</h3><p>事件分发的处理者已经找到了，看起来任务已经完成了。<br>但其实事件分发是包括<code>ACTION_DOWN、ACTION_MOVE、ACTION_UP、ACTION_CANCEL</code>的一系列事件，我们上面分析的都是<code>Action_DOWN</code>的过程<br>后续事件如何处理？<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">           <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;   </span><br><span class="line">                            ...</span><br><span class="line">                        	<span class="comment">//1.遍历子View</span></span><br><span class="line">                        	<span class="comment">//2.判断是否在坐标范围</span></span><br><span class="line">                           <span class="comment">//3.分发事件，给mFirstTouchTarget赋值</span></span><br><span class="line">                           <span class="comment">//4.如果分发成功，alreadyDispatchedToNewTouchTarget赋值为true</span></span><br><span class="line">                           ...      </span><br><span class="line">           	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">               handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                       TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               TouchTarget target = mFirstTouchTarget;</span><br><span class="line">               <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                   <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                       handled = <span class="keyword">true</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                           target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                              handled = <span class="keyword">true</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   predecessor = target;</span><br><span class="line">                   target = next;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上可以看出<br>1.后续的事件不会走对子<code>View</code>的循环判断的方法，因为已经找到了目标<code>View</code>，直接通过<code>mFirstTouchTarget</code>分发<br>2.如果某个<code>View</code>开始处理拦截事件，后续事件序列只能由它处理    </p>
<h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><ul>
<li>事件分发的本质就是一个递归方法，通过往下传递，调用<code>dispatchTouchEvent</code>方法，找到事件的处理者，这也就是项目中常见的责任链模式。</li>
<li>在分发过程中，<code>ViewGroup</code>通过<code>onInterceptTouchEvent</code>判断是否拦截事件</li>
<li>在分发过程中，<code>View</code>的默认通过<code>onTouchEvent</code>处理事件</li>
<li>如果底层<code>View</code>不消费，则默认一步步往上执行父元素<code>onTouchEvent</code>方法。</li>
<li>如果所有<code>View</code>的<code>onTouchEvent</code>方法都返回<code>false</code>，则最后会执行到<code>Activity</code>的<code>onTouchEvent</code>方法，事件分发也就结束了。</li>
</ul>
<h2 id="4-滑动冲突解决"><a href="#4-滑动冲突解决" class="headerlink" title="4 滑动冲突解决"></a>4 滑动冲突解决</h2><p>我们在开发中经常会碰到滑动冲突的问题，比如一个页面同时有横向与竖向两个方向的滑动，这个时候就需要根据情况在<code>Action_MOVE</code>时对事件进行判断和拦截<br>常见的滑动冲突解决方法有两种：<br>1.外部拦截法<br>2.内部拦截法   </p>
<h3 id="4-1-外部拦截法"><a href="#4-1-外部拦截法" class="headerlink" title="4.1 外部拦截法"></a>4.1 外部拦截法</h3><p>外部拦截法的原理很简单，就是通过我们上面分析的<code>onInterceptTouchEvent</code>进行<br>外部拦截法的模板代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部拦截法：父view.java      </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//父view拦截条件</span></span><br><span class="line">    <span class="keyword">boolean</span> parentCanIntercept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ev.getActionMasked()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (parentCanIntercept) &#123;</span><br><span class="line">                intercepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            intercepted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这种方式会带来一个问题，如果<code>ACTION_DOWN</code>交给了子<code>View</code>处理，那么后续事件应该会直接被分发给这个<code>view</code>呀，为什么还能被父<code>View</code>拦截的？<br>我们再来看看<code>dispatchTouchEvent</code>方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//1.判断拦截</span></span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">    <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="comment">//4.后续事件就直接交给ViewGroup处理了</span></span><br><span class="line">        handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                handled = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            	<span class="comment">//2.cancelChild为ture</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                        || intercepted;</span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                    target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   	   <span class="comment">//3.mFirstTouchTarget被置为null</span></span><br><span class="line">                       mFirstTouchTarget = next;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       predecessor.next = next;</span><br><span class="line">                   &#125;</span><br><span class="line">                   target.recycle();</span><br><span class="line">                   target = next;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel,</span></span></span><br><span class="line"><span class="function"><span class="params">        View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上可知：<br>1.首先通过<code>onInterceptTouchEvent</code>方法拦截事件<br>2.<code>intercepted</code>为<code>true</code>导致<code>cancelChild</code>也为<code>true</code>，<code>dispatchTransformedTouchEvent</code>方法传递<code>Action_CANCEL</code>给子<code>View</code><br>3.<code>cancelChild</code>后将<code>mFirstTouchTarget</code>置为空<br>4.<code>mFirstTouchTarget</code>为空后，后续的事件都由<code>ViewGroup</code>处理了    </p>
<p>综上就是外部拦截法能成功的原因   </p>
<h3 id="4-2-内部拦截法"><a href="#4-2-内部拦截法" class="headerlink" title="4.2 内部拦截法"></a>4.2 内部拦截法</h3><p>接下来看下内部拦截法的模板代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父view.java            </span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.getActionMasked() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子view.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//父view拦截条件</span></span><br><span class="line">    <span class="keyword">boolean</span> parentCanIntercept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (event.getActionMasked()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            getParent().requestDisallowInterceptTouchEvent(!parentCanIntercept);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>内部拦截法是将主动权交给子<code>View</code>，如果子<code>View</code>需要事件就直接消耗，否则交给父容器处理<br>内部拦截法主要通过<code>requestDisallowInterceptTouchEvent</code>方法控制     </p>
<p>我们看下为什么调用这个方式可以实现内部拦截<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">    <span class="comment">//只有ActionDown或者mFirstTouchTarget为空时才会判断是否拦截</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">            intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，原理很简单<br>1.子<code>View</code>通过<code>requestDisallowInterceptTouchEvent</code>控制<code>mGroupFlags</code>的值，从而控制<code>disallowIntercept</code>的值<br>2.<code>disallowIntercept</code>为<code>true</code>时就不会走到<code>onInterceptTouchEvent</code>，外部也就无法拦截了,当需要外部处理时，将<code>disallowIntercept</code>置为<code>false</code>即可    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细总结了事件分发机制从屏幕到<code>View</code>的详细过程，下面列出几个问题供读者参考，方便读者判断是否真正掌握了这个知识点     </p>
<ul>
<li>1.简单描述下事件是怎么从屏幕传递到<code>View</code>的     </li>
<li>2.事件分发过程中有几次责任链分发？  </li>
<li>3.为什么事件分发从<code>DecorView</code> -&gt; <code>Activity</code> -&gt; <code>PhoneWindow</code> -&gt; <code>DecorView</code>    </li>
<li>4.滑动冲突有几种解决方法？分别介绍一下 </li>
<li>5.如果只在<code>onInterceptTouchEvent</code>的<code>ACTION_MOVE</code>中拦截事件，说一下从<code>ViewGroup</code>到<code>View</code>的各个<code>Action</code>是如何传递的    </li>
<li>6.点击<code>ViewGroup</code>中的一个<code>View</code>，然后手指移动到其他地方然后抬起，事件是如何分发的      </li>
<li>7.<code>View</code>的<code>OnTouch</code>和<code>OnTouchEvent</code>有什么关系？<code>OnTouch</code>和<code>OnClick</code>事件呢？   </li>
<li>8.手写一下长按事件的伪代码</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6950089742943780894" target="_blank" rel="noopener">拇指记者深入Android公司，打探事件分发机制背后的秘密</a><br><a href="https://wanandroid.com/wenda/show/12119" target="_blank" rel="noopener">每日一问 | 事件到底是先到DecorView还是先到Window的？</a><br><a href="https://juejin.cn/post/6844903926446161927" target="_blank" rel="noopener">反思|Android 事件分发机制的设计与实现</a><br><a href="https://www.jianshu.com/p/3581fcf302fd" target="_blank" rel="noopener">一个view事件分发，面试官6连问直击灵魂，我被虐的体无完肤</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【带着问题学】协程到底是怎么切换线程的？</title>
    <url>/blog/2021/06/coroutine-thread-expection.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前对协程做了一个简单的介绍，回答了<strong>协程到底是什么的问题</strong>,感兴趣的同学可以了解下：<a href="https://juejin.cn/post/6973650934664527885" target="_blank" rel="noopener">【带着问题学】协程到底是什么?</a><br>通过上文，我们了解了以下内容<br>1.<code>kotlin</code>协程本质上对线程池的封装<br>2.<code>kotlin</code>协程可以用同步方式写异步代码，自动实现对线程切换的管理    </p>
<p>这就引出了本文的主要内容，<code>kotlin</code>协程到底是怎么切换线程的?<br>具体内容如下:<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/july/p3.png" alt>    </p>
<h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h2><h3 id="1-1-CoroutineScope到底是什么"><a href="#1-1-CoroutineScope到底是什么" class="headerlink" title="1.1 CoroutineScope到底是什么?"></a>1.1 <code>CoroutineScope</code>到底是什么?</h3><p><code>CoroutineScope</code>即协程运行的作用域,它的源码很简单<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出<code>CoroutineScope</code>的代码很简单，主要作用是提供<code>CoroutineContext</code>，协程运行的上下文<br>我们常见的实现有<code>GlobalScope</code>,<code>LifecycleScope</code>,<code>ViewModelScope</code>等   </p>
<h3 id="1-2-GlobalScope与ViewModelScope有什么区别"><a href="#1-2-GlobalScope与ViewModelScope有什么区别" class="headerlink" title="1.2 GlobalScope与ViewModelScope有什么区别?"></a>1.2 <code>GlobalScope</code>与<code>ViewModelScope</code>有什么区别?</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">object</span> GlobalScope : CoroutineScope &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 [EmptyCoroutineContext].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">        <span class="keyword">get</span>() = EmptyCoroutineContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> ViewModel.viewModelScope: CoroutineScope</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">val</span> scope: CoroutineScope? = <span class="keyword">this</span>.getTag(JOB_KEY)</span><br><span class="line">        <span class="keyword">if</span> (scope != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> scope</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTagIfAbsent(</span><br><span class="line">            JOB_KEY,</span><br><span class="line">            CloseableCoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>两者的代码都挺简单，从上面可以看出<br>1.<code>GlobalScope</code>返回的为<code>CoroutineContext</code>的空实现<br>2.<code>ViewModelScope</code>则往<code>CoroutineContext</code>中添加了<code>Job</code>与<code>Dispatcher</code></p>
<p>我们先来看一段简单的代码<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">	GlobalScope.launch &#123;</span><br><span class="line">           print(<span class="string">"1:"</span> + Thread.currentThread().name)</span><br><span class="line">           delay(<span class="number">1000</span>)</span><br><span class="line">           print(<span class="string">"2:"</span> + Thread.currentThread().name)</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果为：DefaultDispatcher-worker-1</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">testTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">       viewModelScope.launch &#123;</span><br><span class="line">           print(<span class="string">"1:"</span> + Thread.currentThread().name)</span><br><span class="line">           delay(<span class="number">1000</span>)</span><br><span class="line">           print(<span class="string">"2:"</span> + Thread.currentThread().name)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//打印结果为: main</span></span><br></pre></td></tr></table></figure></p>
<p>上面两种<code>Scope</code>启动协程后，打印当前线程名是不同的，一个是线程池中的一个线程，一个则是主线程<br>这是因为<code>ViewModelScope</code>在<code>CoroutineContext</code>中添加了<code>Dispatchers.Main.immediate</code>的原因    </p>
<p>我们可以得出结论：协程就是通过<code>Dispatchers</code>调度器来控制线程切换的    </p>
<h3 id="1-3-什么是调度器？"><a href="#1-3-什么是调度器？" class="headerlink" title="1.3 什么是调度器？"></a>1.3 什么是调度器？</h3><p>从使用上来讲，调度器就是我们使用的<code>Dispatchers.Main</code>,<code>Dispatchers.Default</code>，<code>Dispatcher.IO</code>等<br>从作用上来讲，调度器的作用是控制协程运行的线程<br>从结构上来讲，<code>Dispatchers</code>的父类是<code>ContinuationInterceptor</code>,然后再继承于<code>CoroutineContext</code><br>它们的类结构关系如下：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b656d8d082494105a9329950fa976ed4~tplv-k3u1fbpfcp-watermark.image" alt><br>这也是为什么<code>Dispatchers</code>能加入到<code>CoroutineContext</code>中的原因,并且支持<code>+</code>操作符来完成增加      </p>
<h3 id="1-4-什么是拦截器"><a href="#1-4-什么是拦截器" class="headerlink" title="1.4 什么是拦截器"></a>1.4 什么是拦截器</h3><p>从命名上很容易看出，<code>ContinuationInterceptor</code>即协程拦截器，先看一下接口<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContinuationInterceptor</span> : <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line">    <span class="comment">// ContinuationInterceptor 在 CoroutineContext 中的 Key</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;ContinuationInterceptor&gt;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截 continuation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">interceptContinuation</span><span class="params">(continuation: <span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;)</span></span>: Continuation&lt;T&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以提炼出两个信息<br>1.拦截器的<code>Key</code>是单例的，因此当你添加多个拦截器时，生效的只会有一个<br>2.我们都知道，<code>Continuation</code>在调用其<code>Continuation#resumeWith()</code>方法，会执行其<code>suspend</code>修饰的函数的代码块，如果我们提前拦截到，是不是可以做点其他事情？这就是调度器切换线程的原理   </p>
<p>上面我们已经介绍了是通过<code>Dispatchers</code>指定协程运行的线程，通过<code>interceptContinuation</code>在协程恢复前进行拦截，从而切换线程<br>带着这些前置知识，我们一起来看下协程启动的具体流程，明确下协程切换线程源码具体实现           </p>
<h2 id="2-协程线程切换源码分析"><a href="#2-协程线程切换源码分析" class="headerlink" title="2. 协程线程切换源码分析"></a>2. 协程线程切换源码分析</h2><h3 id="2-1-launch方法解析"><a href="#2-1-launch方法解析" class="headerlink" title="2.1 launch方法解析"></a>2.1 <code>launch</code>方法解析</h3><p>我们首先看一下协程是怎样启动的，传入了什么参数<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Job &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = newCoroutineContext(context)</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总共有3个参数：<br>1.传入的协程上下文<br>2.<code>CoroutinStart</code>启动器，是个枚举类，定义了不同的启动方法，默认是<code>CoroutineStart.DEFAULT</code><br>3.<code>block</code>就是我们传入的协程体，真正要执行的代码     </p>
<p>这段代码主要做了两件事:<br>1.组合新的<code>CoroutineContext</code><br>2.再创建一个 Continuation     </p>
<h4 id="2-1-1-组合新的CoroutineContext"><a href="#2-1-1-组合新的CoroutineContext" class="headerlink" title="2.1.1 组合新的CoroutineContext"></a>2.1.1 组合新的<code>CoroutineContext</code></h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">newCoroutineContext</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span>: CoroutineContext &#123;</span><br><span class="line">    <span class="keyword">val</span> combined = coroutineContext + context</span><br><span class="line">    <span class="keyword">val</span> debug = <span class="keyword">if</span> (DEBUG) combined + CoroutineId(COROUTINE_ID.incrementAndGet()) <span class="keyword">else</span> combined</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (combined !== Dispatchers.Default &amp;&amp; combined[ContinuationInterceptor] == <span class="literal">null</span>)</span><br><span class="line">        debug + Dispatchers.Default <span class="keyword">else</span> debug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以提炼出以下信息:<br>1.会将<code>launch</code>方法传入的<code>context</code>与<code>CoroutineScope</code>中的<code>context</code>组合起来<br>2.如果<code>combined</code>中没有拦截器，会传入一个默认的拦截器，即<code>Dispatchers.Default</code>,这也解释了为什么我们没有传入拦截器时会有一个默认切换线程的效果    </p>
<h4 id="2-1-2-创建一个Continuation"><a href="#2-1-2-创建一个Continuation" class="headerlink" title="2.1.2 创建一个Continuation"></a>2.1.2 创建一个<code>Continuation</code></h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> coroutine = <span class="keyword">if</span> (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) <span class="keyword">else</span></span><br><span class="line">        StandaloneCoroutine(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br></pre></td></tr></table></figure>
<p>默认情况下，我们会创建一个<code>StandloneCoroutine</code><br>值得注意的是，这个<code>coroutine</code>其实是我们协程体的<code>complete</code>，即成功后的回调，而不是协程体本身<br>然后调用<code>coroutine.start</code>，这表明协程开始启动了    </p>
<h3 id="2-2-协程的启动"><a href="#2-2-协程的启动" class="headerlink" title="2.2 协程的启动"></a>2.2 协程的启动</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">start</span><span class="params">(start: <span class="type">CoroutineStart</span>, receiver: <span class="type">R</span>, block: <span class="type">suspend</span> <span class="type">R</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    initParentJob()</span><br><span class="line">    start(block, receiver, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用<code>CoroutineStart</code>的<code>start</code>来启动协程，默认情况下调用的是<code>CoroutineStart.Default</code>     </p>
<p>经过层层调用，最后到达了：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> (R)</span></span> -&gt; T).startCoroutineCancellable(receiver: R, completion: Continuation&lt;T&gt;) =</span><br><span class="line">    runSafely(completion) &#123;</span><br><span class="line">        <span class="comment">// 外面再包一层 Coroutine</span></span><br><span class="line">        createCoroutineUnintercepted(receiver, completion)</span><br><span class="line">            <span class="comment">// 如果需要，做拦截处理</span></span><br><span class="line">            .intercepted()</span><br><span class="line">            <span class="comment">// 调用 resumeWith 方法      </span></span><br><span class="line">            .resumeCancellableWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就是协程启动的核心代码，虽然比较短，却包括3个步骤：<br>1.创建协程体<code>Continuation</code><br>2.创建拦截 <code>Continuation</code>,即<code>DispatchedContinuation</code><br>3.执行<code>DispatchedContinuation.resumeWith</code>方法    </p>
<h3 id="2-3-创建协程体Continuation"><a href="#2-3-创建协程体Continuation" class="headerlink" title="2.3 创建协程体Continuation"></a>2.3 创建协程体<code>Continuation</code></h3><p>调用<code>createCoroutineUnintercepted</code>,会把我们的协程体即<code>suspend block</code>转换成<code>Continuation</code>,它是<code>SuspendLambda</code>，继承自<code>ContinuationImpl</code><br><code>createCoroutineUnintercepted</code>方法在源码中找不到具体实现，不过如果你把协程体代码反编译后就可以看到真正的实现<br>详情可见：<a href="https://juejin.cn/post/6883652600462327821#heading-14" target="_blank" rel="noopener">字节码反编译</a>   </p>
<h3 id="2-4-创建DispatchedContinuation"><a href="#2-4-创建DispatchedContinuation" class="headerlink" title="2.4 创建DispatchedContinuation"></a>2.4 创建<code>DispatchedContinuation</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt; =</span><br><span class="line">    (<span class="keyword">this</span> <span class="keyword">as</span>? ContinuationImpl)?.intercepted() ?: <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ContinuationImpl</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;Any?&gt; =</span><br><span class="line">        intercepted</span><br><span class="line">            ?: (context[ContinuationInterceptor]?.interceptContinuation(<span class="keyword">this</span>) ?: <span class="keyword">this</span>)</span><br><span class="line">                .also &#123; intercepted = it &#125;     </span><br><span class="line"></span><br><span class="line"><span class="comment">//CoroutineDispatcher</span></span><br><span class="line">public final override fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; =</span><br><span class="line">      DispatchedContinuation(<span class="keyword">this</span>, continuation)</span><br></pre></td></tr></table></figure>
<p>从上可以提炼出以下信息<br>1.<code>interepted</code>是个扩展方法，最后会调用到<code>ContinuationImpl.intercepted</code>方法<br>2.在<code>intercepted</code>会利用<code>CoroutineContext</code>，获取当前的拦截器<br>3.因为当前的拦截器是<code>CoroutineDispatcher</code>，因此最终会返回一个<code>DispatchedContinuation</code>，我们其实也是利用它实现线程切换的<br>4.我们将协程体的<code>Continuation</code>传入<code>DispatchedContinuation</code>,这里其实用到了<code>装饰器模式</code>，实现功能的增强<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/july/p1.png" alt><br>这里其实很明显了，通过<code>DispatchedContinuation</code>装饰原有协程，在<code>DispatchedContinuation</code>里通过调度器处理线程切换，不影响原有逻辑，实现功能的增强   </p>
<h3 id="2-5-拦截处理"><a href="#2-5-拦截处理" class="headerlink" title="2.5 拦截处理"></a>2.5 拦截处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//DispatchedContinuation</span><br><span class="line">inline fun resumeCancellableWith(</span><br><span class="line">    result: Result&lt;T&gt;,</span><br><span class="line">    noinline onCancellation: ((cause: Throwable) -&gt; Unit)?</span><br><span class="line">) &#123;</span><br><span class="line">    val state = result.toState(onCancellation)</span><br><span class="line">    if (dispatcher.isDispatchNeeded(context)) &#123;</span><br><span class="line">        _state = state</span><br><span class="line">        resumeMode = MODE_CANCELLABLE</span><br><span class="line">        dispatcher.dispatch(context, this)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        executeUnconfined(state, MODE_CANCELLABLE) &#123;</span><br><span class="line">            if (!resumeCancelled(state)) &#123;</span><br><span class="line">                resumeUndispatchedWith(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面说到了启动时会调用<code>DispatchedContinuation</code>的<code>resumeCancellableWith</code>方法<br>这里面做的事也很简单：<br>1.如果需要切换线程，调用<code>dispatcher.dispatcher</code>方法，这里的<code>dispatcher</code>是通过<code>CoroutineConext</code>取出来的<br>2.如果不需要切换线程，直接运行原有线程即可    </p>
<h4 id="2-5-2-调度器的具体实现"><a href="#2-5-2-调度器的具体实现" class="headerlink" title="2.5.2 调度器的具体实现"></a>2.5.2 调度器的具体实现</h4><p>我们首先明确下，<code>CoroutineDispatcher</code>是通过<code>CoroutineContext</code>取出来的,这也是协程上下文作用的体现<br><code>CoroutineDispater</code>官方提供了四种实现：<code>Dispatchers.Main</code>,<code>Dispatchers.IO</code>,<code>Dispatchers.Default</code>,<code>Dispatchers.Unconfined</code><br>我们一起简单看下<code>Dispatchers.Main</code>的实现<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerContext</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> handler: Handler,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> name: String?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> invokeImmediately: <span class="built_in">Boolean</span></span><br><span class="line">) : HandlerDispatcher(), Delay &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(</span><br><span class="line">        handler: Handler,</span><br><span class="line">        name: String? = <span class="literal">null</span></span><br><span class="line">    ) : <span class="keyword">this</span>(handler, name, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(context: <span class="type">CoroutineContext</span>, block: <span class="type">Runnable</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 利用主线程的 Handler 执行任务</span></span><br><span class="line">        handler.post(block)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，其实就是用<code>handler</code>切换到了主线程<br>如果用<code>Dispatcers.IO</code>也是一样的，只不过换成线程池切换了<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/july/p2.png" alt><br>如上所示，其实就是一个装饰模式<br>1.调用<code>CoroutinDispatcher.dispatch</code>方法切换线程<br>2.切换完成后调用<code>DispatchedTask.run</code>方法，执行真正的协程体   </p>
<h2 id="3-delay是怎样切换线程的"><a href="#3-delay是怎样切换线程的" class="headerlink" title="3 delay是怎样切换线程的?"></a>3 <code>delay</code>是怎样切换线程的?</h2><p>上面我们介绍了协程线程调度的基本原理与实现,下面我们来回答几个小问题<br>我们知道<code>delay</code>函数会挂起，然后等待一段时间再恢复。<br>可以想象，这里面应该也涉及到线程的切换，具体是怎么实现的呢？<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delay</span><span class="params">(timeMillis: <span class="type">Long</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="comment">// don't delay</span></span><br><span class="line">    <span class="keyword">return</span> suspendCancellableCoroutine <span class="symbol">sc@</span> &#123; cont: CancellableContinuation&lt;<span class="built_in">Unit</span>&gt; -&gt;</span><br><span class="line">        <span class="comment">// if timeMillis == Long.MAX_VALUE then just wait forever like awaitCancellation, don't schedule.</span></span><br><span class="line">        <span class="keyword">if</span> (timeMillis &lt; <span class="built_in">Long</span>.MAX_VALUE) &#123;</span><br><span class="line">            cont.context.delay.scheduleResumeAfterDelay(timeMillis, cont)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> CoroutineContext.delay: Delay <span class="keyword">get</span>() = <span class="keyword">get</span>(ContinuationInterceptor) <span class="keyword">as</span>? Delay ?: DefaultDelay</span><br></pre></td></tr></table></figure></p>
<p><code>Dealy</code>的代码也很简单，从上面可以提炼出以下信息<br><code>delay</code>的切换也是通过拦截器来实现的，内置的拦截器同时也实现了<code>Delay</code>接口<br>我们来看一个具体实现<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerContext</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> handler: Handler,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> name: String?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> invokeImmediately: <span class="built_in">Boolean</span></span><br><span class="line">) : HandlerDispatcher(), Delay &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleResumeAfterDelay</span><span class="params">(timeMillis: <span class="type">Long</span>, continuation: <span class="type">CancellableContinuation</span>&lt;<span class="type">Unit</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 利用主线程的 Handler 延迟执行任务，将完成的 continuation 放在任务中执行</span></span><br><span class="line">        <span class="keyword">val</span> block = Runnable &#123;</span><br><span class="line">            with(continuation) &#123; resumeUndispatched(<span class="built_in">Unit</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handler.postDelayed(block, timeMillis.coerceAtMost(MAX_DELAY))</span><br><span class="line">        continuation.invokeOnCancellation &#123; handler.removeCallbacks(block) &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.可以看出，其实也是通过<code>handler.postDelayed</code>实现延时效果的<br>2.时间到了之后，再通过<code>resumeUndispatched</code>方法恢复协程<br>3.如果我们用的是<code>Dispatcher.IO</code>，效果也是一样的，不同的就是延时效果是通过切换线程实现的     </p>
<h2 id="4-withContext是怎样切换线程的"><a href="#4-withContext是怎样切换线程的" class="headerlink" title="4. withContext是怎样切换线程的?"></a>4. <code>withContext</code>是怎样切换线程的?</h2><p>我们在协程体内，可能通过<code>withContext</code>方法简单便捷的切换线程，用同步的方式写异步代码，这也是<code>kotin</code>协程的主要优势之一<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    viewModelScope.launch(Dispatchers.Main) &#123;</span><br><span class="line">        print(<span class="string">"1:"</span> + Thread.currentThread().name)</span><br><span class="line">        withContext(Dispatchers.IO)&#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            print(<span class="string">"2:"</span> + Thread.currentThread().name)</span><br><span class="line">        &#125;</span><br><span class="line">        print(<span class="string">"3:"</span> + Thread.currentThread().name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1，2，3处分别输出main,DefaultDispatcher-worker-1,main</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出这段代码做了一个切换线程然后再切换回来的操作，我们可以提出两个问题<br>1.<code>withContext</code>是怎样切换线程的?<br>2.<code>withContext</code>内的协程体结束后，线程怎样切换回到<code>Dispatchers.Main</code>?     </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: T &#123;  </span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn <span class="symbol">sc@</span> &#123; uCont -&gt;</span><br><span class="line">        <span class="comment">// 创建新的context</span></span><br><span class="line">        <span class="keyword">val</span> oldContext = uCont.context</span><br><span class="line">        <span class="keyword">val</span> newContext = oldContext + context</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">//使用新的Dispatcher，覆盖外层</span></span><br><span class="line">        <span class="keyword">val</span> coroutine = DispatchedCoroutine(newContext, uCont)</span><br><span class="line">        coroutine.initParentJob()</span><br><span class="line">        <span class="comment">//DispatchedCoroutine作为了complete传入</span></span><br><span class="line">        block.startCoroutineCancellable(coroutine, coroutine)</span><br><span class="line">        coroutine.getResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchedCoroutine</span>&lt;<span class="type">in T</span>&gt;</span>(</span><br><span class="line">    context: CoroutineContext,</span><br><span class="line">    uCont: Continuation&lt;T&gt;</span><br><span class="line">) : ScopeCoroutine&lt;T&gt;(context, uCont) &#123;</span><br><span class="line">	<span class="comment">//在complete时会会回调</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterCompletion</span><span class="params">(state: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        afterResume(state)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">afterResume</span><span class="params">(state: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//uCont就是父协程，context仍是老版context,因此可以切换回原来的线程上</span></span><br><span class="line">        uCont.intercepted().resumeCancellableWith(recoverResult(state, uCont))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码其实也很简单，可以提炼出以下信息<br>1.<code>withContext</code>其实就是一层<code>Api</code>封装，最后调用到了<code>startCoroutineCancellable</code>,这就跟<code>launch</code>后面的流程一样了，我们就不继续跟了<br>2.传入的<code>context</code>会覆盖外层的拦截器并生成一个<code>newContext</code>，因此可以实现线程的切换<br>3.<code>DispatchedCoroutine</code>作为<code>complete</code>传入协程体的创建函数中，因此协程体执行完成后会回调到<code>afterCompletion</code>中<br>4.<code>DispatchedCoroutine</code>中传入的<code>uCont</code>是父协程，它的拦截器仍是外层的拦截器，因此会切换回原来的线程中   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要回答了<code>kotlin</code>协程到底是怎么切换线程的这个问题，并对源码进行了分析<br>简单来讲主要包括以下步骤：<br>1.向<code>CoroutineContext</code>添加<code>Dispatcher</code>，指定运行的协程<br>2.在启动时将<code>suspend block</code>创建成<code>Continuation</code>,并调用<code>intercepted</code>生成<code>DispatchedContinuation</code><br>3.<code>DispatchedContinuation</code>就是对原有协程的装饰，在这里调用<code>Dispatcher</code>完成线程切换任务后，<code>resume</code>被装饰的协程，就会执行协程体内的代码了   </p>
<p><strong>其实<code>kotlin</code>协程就是用装饰器模式实现线程切换的</strong><br>看起来似乎有不少代码，但是真正的思路其实还是挺简单的，这大概就是设计模式的作用吧<br>如果本文对你有所帮助，欢迎点赞收藏~     </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6862548590092140558" target="_blank" rel="noopener">深入浅出kotlin协程</a><br><a href="https://www.bennyhuo.com/2019/04/11/coroutine-dispatchers/" target="_blank" rel="noopener">破解 Kotlin 协程(3) - 协程调度篇</a>    </p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>【带着问题学】 关于LeakCanary2.0的四个问题</title>
    <url>/blog/2021/05/leakcanary-sum-up.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>LeakCanary</code>是一个简单方便的内存泄漏检测框架，相信很多同学都用过，使用起来非常方便，它有以下几个特点<br>1.不需要手动初始化<br>2.可自动检测内存泄漏并通过通知报警<br>3.不能用于线上      </p>
<p>那我们自然可以提出以下几个问题<br>1.说一下<code>LeakCanary</code>检测内存泄漏的原理与基本流程<br>2.<code>LeakCanary</code>是如何初始化的？<br>3.说一下<code>LeakCanary</code>是如何查找内存泄露的？<br>4.为什么<code>LeakCanary</code>不能用于线上？                </p>
<p>本文主要梳理<code>LeakCanary</code>内存泄漏检测的主要流程并回答以上几个问题 </p>
<h2 id="1-LeakCanary检测内存泄漏的原理与基本流程"><a href="#1-LeakCanary检测内存泄漏的原理与基本流程" class="headerlink" title="1. LeakCanary检测内存泄漏的原理与基本流程"></a>1. <code>LeakCanary</code>检测内存泄漏的原理与基本流程</h2><h3 id="1-1-内存泄漏的原理"><a href="#1-1-内存泄漏的原理" class="headerlink" title="1.1 内存泄漏的原理"></a>1.1 内存泄漏的原理</h3><p>内存泄漏的原因：不再需要的对象依然被引用，导致对象被分配的内存无法被回收。<br>例如：一个<code>Activity</code>实例对象在调用了<code>onDestory</code>方法后是不再被需要的，如果存储了一个引用<code>Activity</code>对象的静态域，将导致<code>Activity</code>无法被垃圾回收器回收。<br>引用链来自于垃圾回收器的可达性分析算法：当一个对象到<code>GC Roots</code> 没有任何引用链相连时，则证明此对象是不可用的。如图：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog11/p3.jpg" alt><br>对象<code>object5</code>、<code>object6</code>、<code>object7</code> 虽然互相有关联，但是它们到 <code>GC Roots</code> 是不可达的，所以它们将会被判定为是可回收的对象。<br>在<code>Java</code>语言中，可作为<code>GC Roots</code>的对象包括下面几种：     </p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<h3 id="1-2-LeakCanary检测内存泄漏的基本流程"><a href="#1-2-LeakCanary检测内存泄漏的基本流程" class="headerlink" title="1.2 LeakCanary检测内存泄漏的基本流程"></a>1.2 <code>LeakCanary</code>检测内存泄漏的基本流程</h3><p>知道了内存泄漏的原理，我们可以推测到<code>LeakCanary</code>的基本流程大概是怎样的<br>1.在页面关闭后触发检测(不再需要的对象)<br>2.触发<code>GC</code>，然后获取仍然存在的对象，这些是可能泄漏的<br>3.<code>dump heap</code>然后分析<code>hprof</code>文件，构建可能泄漏的对象与<code>GCRoot</code>间的引用链,如果存在则证明泄漏<br>4.存储结果并使用通知提醒用户存在泄漏        </p>
<p>总体流程图如下所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog11/p1.png" alt>        </p>
<ul>
<li>1.<code>ObjectWatcher</code> 创建了一个<code>KeyedWeakReference</code>来监视对象.</li>
<li>2.稍后，在后台线程中，延时检查引用是否已被清除，如果没有则触发<code>GC</code>     </li>
<li>3.如果引用一直没有被清除，它会<code>dumps the heap</code> 到一个<code>.hprof</code> 文件中，然后将<code>.hprof</code> 文件存储到文件系统。</li>
<li>4.分析过程主要在<code>HeapAnalyzerService</code>中进行，<code>Leakcanary2.0</code>中使用<code>Shark</code>来解析<code>hprof</code>文件。</li>
<li>5.<code>HeapAnalyzer</code> 获取<code>hprof</code>中的所有<code>KeyedWeakReference</code>，并获取<code>objectId</code>    </li>
<li>6.<code>HeapAnalyzer</code>计算<code>objectId</code>到<code>GC Root</code>的最短强引用链路径来确定是否有泄漏，然后构建导致泄漏的引用链。</li>
<li>7.将分析结果存储在数据库中，并显示泄漏通知。</li>
</ul>
<p>这里只做一个总体的介绍，具体流程可以阅读下文</p>
<h2 id="2-LeakCanary是如何自动安装的？"><a href="#2-LeakCanary是如何自动安装的？" class="headerlink" title="2. LeakCanary是如何自动安装的？"></a>2. <code>LeakCanary</code>是如何自动安装的？</h2><p><code>LeakCanary</code>的使用非常方便，只需要添加依赖便可以自动初始化，这是如何实现的呢？<br>我们看一下源码，其实主要是通过<code>ContentProvider</code>实现的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">AppWatcherInstaller</span> : <span class="type">ContentProvider</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">MainProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class="line"><span class="comment">   * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakCanaryProcess</span> : <span class="type">AppWatcherInstaller</span></span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">    AppWatcher.manualInstall(application)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们启动<code>App</code>时，一般启动顺序为：<code>Application</code>-&gt;<code>attachBaseContext</code> =====&gt;<code>ContentProvider</code>-&gt;<code>onCreate</code> =====&gt;<code>Application</code>-&gt;<code>onCreate</code><br><code>ContentProvider</code>会在<code>Application.onCreate</code>前初始化，这样就调用到了<code>LeakCanary</code>的初始化方法<br>实现了免手动初始化</p>
<h3 id="2-1-跨进程初始化"><a href="#2-1-跨进程初始化" class="headerlink" title="2.1 跨进程初始化"></a>2.1 跨进程初始化</h3><p>注意,<code>AppWatcherInstaller</code>有两个子类,<code>MainProcess</code>与<code>LeakCanaryProcess</code><br>其中默认使用<code>MainProcess</code>,会在<code>App</code>进程初始化<br>有时我们考虑到<code>LeakCanary</code>比较耗内存，需要在独立进程初始化<br>使用<code>leakcanary-android-process</code>模块的时候，会在一个新的进程中去开启<code>LeakCanary</code>      </p>
<h3 id="2-2-LeakCanary2-0手动初始化的方法"><a href="#2-2-LeakCanary2-0手动初始化的方法" class="headerlink" title="2.2 LeakCanary2.0手动初始化的方法"></a>2.2 <code>LeakCanary2.0</code>手动初始化的方法</h3><p><code>LeakCanary</code>在检测内存泄漏时比较耗时，同时会打断<code>App</code>操作，在不需要检测时的体验并不太好<br>所以虽然<code>LeakCanary</code>可以自动初始化，但我们有时其实还是需要手动初始化   </p>
<p><code>LeakCanary</code>的自动初始化可以手动关闭<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bool</span> <span class="attr">name</span>=<span class="string">"leak_canary_watcher_auto_install"</span>&gt;</span>false<span class="tag">&lt;/<span class="name">bool</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>1.然后在需要初始化的时候，调用<code>AppWatcher.manualInstall</code>即可<br>2.是否开始<code>dump</code>与分析开头：<code>LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)</code><br>3.桌面图标开头：重写<code>R.bool.leak_canary_add_launcher_icon</code>或者调用<code>LeakCanary.showLeakDisplayActivityLauncherIcon(false)</code>     </p>
<h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p><code>LeakCanary</code>利用<code>ContentProvier</code>进行了初始化。<br><code>ContentProvier</code>一般会在<code>Application.onCreate</code>之前被加载，<code>LeakCanary</code>在其<code>onCreate()</code>方法中调用了<code>AppWatcher.manualInstall</code>进行初始化<br>这种写法虽然方便，免去了初始化的步骤，但是可能会带来启动耗时的问题，用户不能控制初始化的时机，这也是谷歌推出<code>StartUp</code>的原因<br>不过对于<code>LeakCanary</code>这个问题并不严重，因为它只在<code>Debug</code>阶段被依赖     </p>
<h2 id="3-LeakCanary如何检测内存泄漏"><a href="#3-LeakCanary如何检测内存泄漏" class="headerlink" title="3.LeakCanary如何检测内存泄漏?"></a>3.<code>LeakCanary</code>如何检测内存泄漏?</h2><h3 id="3-1-首先我们来看下初始化时做了什么"><a href="#3-1-首先我们来看下初始化时做了什么" class="headerlink" title="3.1 首先我们来看下初始化时做了什么?"></a>3.1 首先我们来看下初始化时做了什么?</h3><p>当我们初始化时，调用了<code>AppWatcher.manualInstall</code>，下面来看看这个方法，都安装了什么东西<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">manualInstall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  retainedDelayMillis: <span class="type">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>)</span></span>,</span><br><span class="line">  watchersToInstall: List&lt;InstallableWatcher&gt; = appDefaultWatchers(application)</span><br><span class="line">) &#123;</span><br><span class="line">  ....</span><br><span class="line">  watchersToInstall.forEach &#123;</span><br><span class="line">    it.install()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">appDefaultWatchers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  reachabilityWatcher: <span class="type">ReachabilityWatcher</span> = objectWatcher</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: List&lt;InstallableWatcher&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> listOf(</span><br><span class="line">    ActivityWatcher(application, reachabilityWatcher),</span><br><span class="line">    FragmentAndViewModelWatcher(application, reachabilityWatcher),</span><br><span class="line">    RootViewWatcher(reachabilityWatcher),</span><br><span class="line">    ServiceWatcher(reachabilityWatcher)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，初始化时即安装了一些<code>Watcher</code>，即在默认情况下，我们只会观察<code>Activity</code>,<code>Fragment</code>,<code>RootView</code>,<code>Service</code>这些对象是否泄漏<br>如果需要观察其他对象，需要手动添加并处理       </p>
<h3 id="3-2-LeakCanary如何触发检测"><a href="#3-2-LeakCanary如何触发检测" class="headerlink" title="3.2 LeakCanary如何触发检测?"></a>3.2 <code>LeakCanary</code>如何触发检测?</h3><p>如上文所述，在初始化时会安装一些<code>Watcher</code>，我们以<code>ActivityWatcher</code>为例<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityWatcher</span></span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> reachabilityWatcher: ReachabilityWatcher</span><br><span class="line">) : InstallableWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">        reachabilityWatcher.expectWeaklyReachable(</span><br><span class="line">          activity, <span class="string">"<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback"</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.registerActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">uninstall</span><span class="params">()</span></span> &#123;</span><br><span class="line">    application.unregisterActivityLifecycleCallbacks(lifecycleCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在<code>Activity.onDestory</code>时，就会触发检测内存泄漏</p>
<h3 id="3-3-LeakCanary如何检测可能泄漏的对象"><a href="#3-3-LeakCanary如何检测可能泄漏的对象" class="headerlink" title="3.3 LeakCanary如何检测可能泄漏的对象?"></a>3.3 <code>LeakCanary</code>如何检测可能泄漏的对象?</h3><p>从上面可以看出，<code>Activity</code>关闭后会调用到<code>ObjectWatcher.expectWeaklyReachable</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">expectWeaklyReachable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    description: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    removeWeaklyReachableObjects()</span><br><span class="line">    <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">      .toString()</span><br><span class="line">    <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">    <span class="keyword">val</span> reference =</span><br><span class="line">      KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">    SharkLog.d &#123;</span><br><span class="line">      <span class="string">"Watching "</span> +</span><br><span class="line">        (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">"instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>"</span>) +</span><br><span class="line">        (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">" (<span class="variable">$description</span>)"</span> <span class="keyword">else</span> <span class="string">""</span>) +</span><br><span class="line">        <span class="string">" with key <span class="variable">$key</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    watchedObjects[key] = reference</span><br><span class="line">    checkRetainedExecutor.execute &#123;</span><br><span class="line">      moveToRetained(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">    <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">    <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">      <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">        watchedObjects.remove(ref.key)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出<br>1.传入的观察对象都会被存储在<code>watchedObjects</code>中<br>2.会为每个<code>watchedObject</code>生成一个<code>KeyedWeakReference</code>弱引用对象并与一个<code>queue</code>关联，当对象被回收时，该弱引用对象将进入<code>queue</code>当中<br>3.在检测过程中，我们会调用多次<code>removeWeaklyReachableObjects</code>,将已回收对象从<code>watchedObjects</code>中移除<br>4.如果<code>watchedObjects</code>中没有移除对象，证明它没有被回收，那么就会调用<code>moveToRetained</code>      </p>
<h3 id="3-4-LeakCanary触发堆快照，生成hprof文件"><a href="#3-4-LeakCanary触发堆快照，生成hprof文件" class="headerlink" title="3.4 LeakCanary触发堆快照，生成hprof文件"></a>3.4 <code>LeakCanary</code>触发堆快照，生成<code>hprof</code>文件</h3><p><code>moveToRetained</code>之后会调用到<code>HeapDumpTrigger.checkRetainedInstances</code>方法<br><code>checkRetainedInstances()</code> 方法是确定泄露的最后一个方法了。<br>这里会确认引用是否真的泄露，如果真的泄露，则发起 <code>heap dump</code>，分析 <code>dump</code> 文件，找到引用链<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      gcTrigger.runGc()</span><br><span class="line">      retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold)) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">    <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line">    <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">      onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">      ....</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dismissRetainedCountNotification()</span><br><span class="line">    <span class="keyword">val</span> visibility = <span class="keyword">if</span> (applicationVisible) <span class="string">"visible"</span> <span class="keyword">else</span> <span class="string">"not visible"</span></span><br><span class="line">    dumpHeap(</span><br><span class="line">      retainedReferenceCount = retainedReferenceCount,</span><br><span class="line">      retry = <span class="literal">true</span>,</span><br><span class="line">      reason = <span class="string">"<span class="variable">$retainedReferenceCount</span> retained objects, app is <span class="variable">$visibility</span>"</span></span><br><span class="line">    ) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">dumpHeap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    retainedReferenceCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    retry: <span class="type">Boolean</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    reason: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span> &#123;</span><br><span class="line">     ....</span><br><span class="line">  	 heapDumper.dumpHeap()</span><br><span class="line">  	 ....</span><br><span class="line">     lastDisplayedRetainedObjectCount = <span class="number">0</span></span><br><span class="line">     lastHeapDumpUptimeMillis = SystemClock.uptimeMillis()</span><br><span class="line">     objectWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)</span><br><span class="line">     HeapAnalyzerService.runAnalysis(</span><br><span class="line">       context = application,</span><br><span class="line">       heapDumpFile = heapDumpResult.file,</span><br><span class="line">       heapDumpDurationMillis = heapDumpResult.durationMillis,</span><br><span class="line">       heapDumpReason = reason</span><br><span class="line">     )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>1.如果<code>retainedObjectCount</code>数量大于0，则进行一次<code>GC</code>,避免额外的<code>Dump</code><br>2.默认情况下，如果<code>retainedReferenceCount&lt;5</code>，不会进行<code>Dump</code>，节省资源<br>3.如果两次<code>Dump</code>之间时间少于60s，也会直接返回，避免频繁<code>Dump</code><br>4.调用<code>heapDumper.dumpHeap()</code>进行真正的<code>Dump</code>操作<br>5.<code>Dump</code>之后，要删除已经处理过了的引用<br>6.调用<code>HeapAnalyzerService.runAnalysis</code>对结果进行分析      </p>
<h3 id="3-5-LeakCanary如何分析hprof文件"><a href="#3-5-LeakCanary如何分析hprof文件" class="headerlink" title="3.5 LeakCanary如何分析hprof文件"></a>3.5 <code>LeakCanary</code>如何分析<code>hprof</code>文件</h3><p>分析<code>hprof</code>文件的工作主要是在<code>HeapAnalyzerService</code>类中完成的<br>关于<code>Hprof</code>文件的解析细节，就需要牵扯到<code>Hprof</code>二进制文件协议,通过阅读协议文档，<code>hprof</code>的二进制文件结构大概如下：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog11/p1.jpg" alt></p>
<p>解析流程如下所示:<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog11/p2.jpg" alt><br>简要说下流程：<br>1.解析文件头信息，得到解析开始位置<br>2.根据头信息创建<code>Hprof</code>文件对象<br>3.构建内存索引<br>4.使用<code>hprof</code>对象和索引构建<code>Graph</code>对象<br>5.查找可能泄漏的对象与<code>GCRoot</code>间的引用链来判断是否存在泄漏(使用广度优先算法在<code>Graph</code>中查找)</p>
<p><code>Leakcanary2.0</code>较之前的版本最大变化是改由<code>kotlin</code>实现以及开源了自己实现的<code>hprof</code>解析的代码，总体的思路是根据<code>hprof</code>文件的二进制协议将文件的内容解析成一个图的数据结构，然后广度遍历这个图找到最短路径，路径的起始就是<code>GCRoot</code>对象，结束就是泄漏的对象</p>
<p>具体分析可见：<a href="https://zhuanlan.zhihu.com/p/360944586" target="_blank" rel="noopener">Android内存泄漏检测之LeakCanary2.0（Kotlin版）的实现原理</a>  </p>
<h3 id="3-6-泄漏结果存储与通知"><a href="#3-6-泄漏结果存储与通知" class="headerlink" title="3.6 泄漏结果存储与通知"></a>3.6 泄漏结果存储与通知</h3><p>结果的存储与通知主要在<code>DefaultOnHeapAnalyzedListener</code>中完成<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHeapAnalyzed</span><span class="params">(heapAnalysis: <span class="type">HeapAnalysis</span>)</span></span> &#123;</span><br><span class="line">    SharkLog.d &#123; <span class="string">"\u200B\n<span class="subst">$&#123;LeakTraceWrapper.wrap(heapAnalysis.toString(), <span class="number">120</span>)&#125;</span>"</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> db = LeaksDbHelper(application).writableDatabase</span><br><span class="line">    <span class="keyword">val</span> id = HeapAnalysisTable.insert(db, heapAnalysis)</span><br><span class="line">    db.releaseReference()</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InternalLeakCanary.formFactor == TV) &#123;</span><br><span class="line">      showToast(heapAnalysis)</span><br><span class="line">      printIntentInfo()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      showNotification(screenToShow, contentTitle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要做了两件事<br>1.存储泄漏分析结果到数据库中<br>2.展示通知，提醒用户去查看内存泄漏情况      </p>
<h2 id="4-为什么LeakCanary不能用于线上"><a href="#4-为什么LeakCanary不能用于线上" class="headerlink" title="4.为什么LeakCanary不能用于线上?"></a>4.为什么<code>LeakCanary</code>不能用于线上?</h2><p>理解了<code>LeakCanary</code>判定对象泄漏后所做的工作后就不难知道，直接将<code>LeakCanary</code>应用于线上会有如下一些问题：<br>1.每次内存泄漏以后，都会生成一个<code>.hprof</code>文件，然后解析，并将结果写入<code>.hprof.result</code>。增加手机负担，引起手机卡顿等问题。<br>2.多次调用<code>GC</code>，可能会对线上性能产生影响<br>3.同样的泄漏问题，会重复生成 <code>.hprof</code> 文件，重复分析并写入磁盘。<br>4.<code>.hprof</code>文件较大，信息回捞成问题。      </p>
<p>了解了这些问题，我们可以尝试提出一些解决方案：<br>1.可以根据手机信息来设定一个内存阈值 <code>M</code> ，当已使用内存小于 <code>M</code>时，如果此时有内存泄漏，只将泄漏对象的信息放入内存当中保存，不生成<code>.hprof</code>文件。当已使用大于 <code>M</code> 时，生成<code>.hprof</code>文件<br>2.当引用链路相同时，可根据实际情况去重。<br>3.不直接回捞<code>.hprof</code>文件，可以选择回捞分析的结果<br>4.可以尝试将已泄漏对象存储在数据库中，一个用户同一个泄漏只检测一次，减少对用户的影响       </p>
<p>以上想法并没有经过实际验证，仅供读者参考    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们引入<code>LeakCanary</code>后，它就会自动安装并且开始分析内存泄漏并报警<br>主要分为以下几步<br>1.自动安装<br>2.检测可能泄漏的对象<br>3.堆快照，生成<code>hprof</code>文件<br>4.分析<code>hprof</code>文件<br>5.对泄漏进行分类并通知   </p>
<p>本文主要梳理了<code>LeakCanary</code>的主要流程与文章开始提出的几个问题，如果对您有所帮助，欢迎点赞~</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/360944586" target="_blank" rel="noopener">Android内存泄漏检测之LeakCanary2.0（Kotlin版）的实现原理</a><br><a href="https://juejin.cn/post/6949759784253915172" target="_blank" rel="noopener">从LeakCanary探究线上内存泄漏检测方案</a><br><a href="https://juejin.cn/post/6844903876043210759" target="_blank" rel="noopener">全新 LeakCanary 2 ! 完全基于 Kotlin 重构升级 ！</a><br><a href="https://blog.csdn.net/wangjiang_qianmo/article/details/83069467" target="_blank" rel="noopener">为什么使用LeakCanary检测内存泄漏？</a>   </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>官方推荐 Flow 取代 LiveData,有必要吗？</title>
    <url>/blog/2021/07/need-replace-livedata.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打开<a href="https://developer.android.com/jetpack" target="_blank" rel="noopener">Android架构组件页面</a>,我们可以发现一些最新发布的<code>jetpack</code>组件，如<code>Room</code>，<code>DataStore</code>, <code>Paging3</code>,<code>DataBinding</code> 等都支持了<code>Flow</code><br><code>Google开发者</code>账号最近也发布了几篇使用<code>Flow</code>的文章，比如：<a href="https://juejin.cn/post/6979008878029570055" target="_blank" rel="noopener">从 LiveData 迁移到 Kotlin 数据流</a><br>看起来官方在大力推荐使用<code>Flow</code>取代<code>LiveData</code>，那么问题来了,有必要吗？<br>我<code>LiveData</code>用得好好的，有必要再学<code>Flow</code>吗?本文主要回答这个问题,具体包括以下内容<br>1.<code>LiveData</code>有什么不足?<br>2.<code>Flow</code>介绍以及为什么要有<code>Flow</code><br>3.<code>SharedFlow</code>与<code>StateFlow</code>的介绍与它们之间的区别      </p>
<p>本文具体目录如下所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/july/p10.jpg" alt></p>
<h2 id="1-LiveData有什么不足"><a href="#1-LiveData有什么不足" class="headerlink" title="1. LiveData有什么不足?"></a>1. <code>LiveData</code>有什么不足?</h2><h3 id="1-1-为什么引入LiveData"><a href="#1-1-为什么引入LiveData" class="headerlink" title="1.1 为什么引入LiveData?"></a>1.1 为什么引入<code>LiveData</code>?</h3><p>要了解<code>LiveData</code>的不足，我们先了解下<code>LiveData</code>为什么被引入     </p>
<blockquote>
<p><code>LiveData</code> 的历史要追溯到 2017 年。彼时，观察者模式有效简化了开发，但诸如 <code>RxJava</code> 一类的库对新手而言有些太过复杂。为此，架构组件团队打造了 <code>LiveData</code>: 一个专用于 <code>Android</code> 的具备自主生命周期感知能力的可观察的数据存储器类。<code>LiveData</code> 被有意简化设计，这使得开发者很容易上手；而对于较为复杂的交互数据流场景，建议您使用 <code>RxJava</code>，这样两者结合的优势就发挥出来了</p>
</blockquote>
<p>可以看出,<code>LiveData</code>就是一个简单易用的，具备感知生命周期能力的观察者模式<br>它使用起来非常简单，这是它的优点，也是它的不足，因为它面对比较复杂的交互数据流场景时，处理起来比较麻烦        </p>
<h3 id="1-2-LiveData的不足"><a href="#1-2-LiveData的不足" class="headerlink" title="1.2 LiveData的不足"></a>1.2 <code>LiveData</code>的不足</h3><p>我们上文说过<code>LiveData</code>结构简单，但是不够强大，它有以下不足<br>1.<code>LiveData</code>只能在主线程更新数据<br>2.<code>LiveData</code>的操作符不够强大,在处理复杂数据流时有些捉襟见肘    </p>
<p>关于<code>LiveData</code>只能在主线程更新数据，有的同学可能要问，不是有<code>postValue</code>吗？其实<code>postValue</code>也是需要切换到到主线程的,如下图所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/july/p9.png" alt><br>这意味着当我们想要更新<code>LiveData</code>对象时，我们会经常更改线程（工作线程→主线程）,如果在修改<code>LiveData</code>后又要切换回到工作线程那就更麻烦了,同时<code>postValue</code>可能会有丢数据的问题。      </p>
<h2 id="2-Flow介绍"><a href="#2-Flow介绍" class="headerlink" title="2. Flow介绍"></a>2. <code>Flow</code>介绍</h2><p><code>Flow</code> 就是 <code>Kotlin</code> 协程与响应式编程模型结合的产物，你会发现它与 <code>RxJava</code> 非常像，二者之间也有相互转换的 <code>API</code>，使用起来非常方便。     </p>
<h3 id="2-1-为什么引入Flow"><a href="#2-1-为什么引入Flow" class="headerlink" title="2.1 为什么引入Flow"></a>2.1 为什么引入<code>Flow</code></h3><p>为什么引入<code>Flow</code>，我们可以从<code>Flow</code>解决了什么问题的角度切入    </p>
<ol>
<li><code>LiveData</code>不支持线程切换，所有数据转换都将在主线程上完成，有时需要频繁更改线程，面对复杂数据流时处理起来比较麻烦     </li>
<li>而<code>RxJava</code>又有些过于麻烦了，有许多让人傻傻分不清的操作符，入门门槛较高，同时需要自己处理生命周期，在生命周期结束时取消订阅       </li>
</ol>
<p>可以看出，<code>Flow</code>是介于<code>LiveData</code>与<code>RxJava</code>之间的一个解决方案，它有以下特点   </p>
<ul>
<li><code>Flow</code> 支持线程切换、背压</li>
<li><code>Flow</code> 入门的门槛很低，没有那么多傻傻分不清楚的操作符</li>
<li>简单的数据转换与操作符，如 <code>map</code> 等等</li>
<li>冷数据流，不消费则不生产数据,这一点与<code>LiveData</code>不同：<code>LiveData</code>的发送端并不依赖于接收端。 </li>
<li>属于<code>kotlin</code>协程的一部分，可以很好的与协程基础设施结合    </li>
</ul>
<p>关于<code>Flow</code>的使用，比较简单，有兴趣的同学可参阅文档：<a href="http://www.kotlincn.net/docs/reference/coroutines/flow.html" target="_blank" rel="noopener">Flow文档</a></p>
<h2 id="3-SharedFlow介绍"><a href="#3-SharedFlow介绍" class="headerlink" title="3. SharedFlow介绍"></a>3. <code>SharedFlow</code>介绍</h2><p>我们上面介绍过,<code>Flow 是冷流</code>，什么是冷流？         </p>
<ul>
<li>冷流 :只有<code>订阅者</code>订阅时，才开始执行发射数据流的代码。并且<code>冷流</code>和<code>订阅者</code>只能是一对一的关系，当有多个不同的<code>订阅者</code>时，消息是重新完整发送的。也就是说对<code>冷流</code>而言，有多个<code>订阅者</code>的时候，他们各自的事件是独立的。</li>
<li>热流:无论有没有<code>订阅者</code>订阅，事件始终都会发生。当 <code>热流</code>有多个<code>订阅者</code>时，<code>热流</code>与<code>订阅者</code>们的关系是一对多的关系，可以与多个订阅者共享信息。</li>
</ul>
<h3 id="3-1-为什么引入SharedFlow"><a href="#3-1-为什么引入SharedFlow" class="headerlink" title="3.1 为什么引入SharedFlow"></a>3.1 为什么引入<code>SharedFlow</code></h3><p>上面其实已经说得很清楚了，<code>冷流</code>和<code>订阅者</code>只能是一对一的关系，当我们要实现一个流，多个<code>订阅者</code>的需求时(这在开发中是很常见的)，就需要<code>热流</code>了<br>从命名上也很容易理解，<code>SharedFlow</code>即共享的<code>Flow</code>，可以实现一对多关系,<code>SharedFlow</code>是一种热流  </p>
<h3 id="3-2-SharedFlow的使用"><a href="#3-2-SharedFlow的使用" class="headerlink" title="3.2 SharedFlow的使用"></a>3.2 <code>SharedFlow</code>的使用</h3><p>我们来看看<code>SharedFlow</code>的构造函数<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">MutableSharedFlow</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    replay: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    extraBufferCapacity: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onBufferOverflow: <span class="type">BufferOverflow</span> = BufferOverflow.SUSPEND</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: MutableSharedFlow&lt;T&gt;</span><br></pre></td></tr></table></figure></p>
<p>其主要有3个参数<br>1.<code>replay</code>表示当新的订阅者<code>Collect</code>时，发送几个已经发送过的数据给它，默认为0，即默认新订阅者不会获取以前的数据<br>2.<code>extraBufferCapacity</code>表示减去<code>replay</code>，<code>MutableSharedFlow</code>还缓存多少数据，默认为0<br>3.<code>onBufferOverflow</code>表示缓存策略，即缓冲区满了之后<code>Flow</code>如何处理，默认为挂起    </p>
<p>简单使用如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewModel</span></span><br><span class="line"><span class="keyword">val</span> sharedFlow=MutableSharedFlow&lt;String&gt;()</span><br><span class="line"></span><br><span class="line">viewModelScope.launch&#123;</span><br><span class="line">      sharedFlow.emit(<span class="string">"Hello"</span>)</span><br><span class="line">      sharedFlow.emit(<span class="string">"SharedFlow"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity</span></span><br><span class="line">lifecycleScope.launch&#123;</span><br><span class="line">    viewMode.sharedFlow.collect &#123; </span><br><span class="line">       print(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-将冷流转化为SharedFlow"><a href="#3-3-将冷流转化为SharedFlow" class="headerlink" title="3.3 将冷流转化为SharedFlow"></a>3.3 将冷流转化为<code>SharedFlow</code></h3><p>普通<code>flow</code>可使用<code>shareIn</code>扩展方法，转化成<code>SharedFlow</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sharedFlow <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    flow&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;.shareIn(viewModelScope, WhileSubscribed(<span class="number">500</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>shareIn</code>主要也有三个参数：   </p>
<blockquote>
<p>@param <code>scope</code> 共享开始时所在的协程作用域范围<br>@param <code>started</code> 控制共享的开始和结束的策略<br>@param <code>replay</code> 状态流的重播个数      </p>
</blockquote>
<p><code>started</code> 接受以下的三个值:<br>1.<code>Lazily</code>: 当首个订阅者出现时开始，在<code>scope</code>指定的作用域被结束时终止。<br>2.<code>Eagerly</code>: 立即开始，而在<code>scope</code>指定的作用域被结束时终止。<br>3.<code>WhileSubscribed</code>: 这种情况有些复杂，后面会详细讲解      </p>
<p>对于那些只执行一次的操作，您可以使用<code>Lazily</code>或者<code>Eagerly</code>。然而，如果您需要观察其他的流，就应该使用<code>WhileSubscribed</code>来实现细微但又重要的优化工作         </p>
<h3 id="3-4-Whilesubscribed策略"><a href="#3-4-Whilesubscribed策略" class="headerlink" title="3.4 Whilesubscribed策略"></a>3.4 <code>Whilesubscribed</code>策略</h3><p><code>WhileSubscribed</code>策略会在没有收集器的情况下取消上游数据流,通过<code>shareIn</code>运算符创建的<code>SharedFlow</code>会把数据暴露给视图 (<code>View</code>)，同时也会观察来自其他层级或者是上游应用的数据流。<br>让这些流持续活跃可能会引起不必要的资源浪费，例如一直通过从数据库连接、硬件传感器中读取数据等等。当您的应用转而在后台运行时，您应当保持克制并中止这些协程。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">WhileSubscribed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   stopTimeoutMillis: <span class="type">Long</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">   replayExpirationMillis: <span class="type">Long</span> = <span class="built_in">Long</span>.MAX_VALUE</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p>
<p>如上所示，它支持两个参数：    </p>
<ul>
<li>1.<code>stopTimeoutMillis</code> 控制一个以毫秒为单位的延迟值，指的是最后一个订阅者结束订阅与停止上游流的时间差。默认值是 0 (立即停止).这个值非常有用，因为您可能并不想因为视图有几秒钟不再监听就结束上游流。这种情况非常常见——比如当用户旋转设备时，原来的视图会先被销毁，然后数秒钟内重建。  </li>
<li>2.<code>replayExpirationMillis</code>表示数据重播的过时时间，如果用户离开应用太久，此时您不想让用户看到陈旧的数据，你可以用到这个参数        </li>
</ul>
<h2 id="4-StateFlow介绍"><a href="#4-StateFlow介绍" class="headerlink" title="4. StateFlow介绍"></a>4. <code>StateFlow</code>介绍</h2><h3 id="4-1-为什么引入StateFlow"><a href="#4-1-为什么引入StateFlow" class="headerlink" title="4.1 为什么引入StateFlow"></a>4.1 为什么引入<code>StateFlow</code></h3><p>我们前面刚刚看了<code>SharedFlow</code>，为什么又冒出个<code>StateFlow</code>?<br><code>StateFlow</code> 是 <code>SharedFlow</code> 的一个比较特殊的变种，<code>StateFlow</code> 与 <code>LiveData</code> 是最接近的，因为:    </p>
<ul>
<li>1.它始终是有值的。</li>
<li>2.它的值是唯一的。</li>
<li>3.它允许被多个观察者共用 (因此是共享的数据流)。</li>
<li>4.它永远只会把最新的值重现给订阅者，这与活跃观察者的数量是无关的。</li>
</ul>
<p>可以看出，<code>StateFlow</code>与<code>LiveData</code>是比较接近的，可以获取当前的值，可以想像之所以引入<code>StateFlow</code>就是为了替换<code>LiveData</code><br>总结如下：<br>1.<code>StateFlow</code>继承于<code>SharedFlow</code>,是<code>SharedFlow</code>的一个特殊变种<br>2.<code>StateFlow</code>与<code>LiveData</code>比较相近，相信之所以推出就是为了替换<code>LiveData</code>    </p>
<h3 id="4-2-StateFlow的简单使用"><a href="#4-2-StateFlow的简单使用" class="headerlink" title="4.2 StateFlow的简单使用"></a>4.2 <code>StateFlow</code>的简单使用</h3><p>我们先来看看构造函数：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">MutableStateFlow</span><span class="params">(value: <span class="type">T</span>)</span></span>: MutableStateFlow&lt;T&gt; = StateFlowImpl(value ?: NULL)</span><br></pre></td></tr></table></figure></p>
<p>1.<code>StateFlow</code>构造函数较为简单，只需要传入一个默认值<br>2.<code>StateFlow</code>本质上是一个<code>replay</code>为1，并且没有缓冲区的<code>SharedFlow</code>,因此第一次订阅时会先获得默认值<br>3.<code>StateFlow</code>仅在值已更新，并且值发生了变化时才会返回，即如果更新后的值没有变化，也没会回调<code>Collect</code>方法，这点与<code>LiveData</code>不同   </p>
<p>与<code>SharedFlow</code>类似，我们也可以用<code>stateIn</code>将普通流转化成<code>StateFlow</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> result: StateFlow&lt;Result&lt;UiState&gt;&gt; = someFlow</span><br><span class="line">    .stateIn(</span><br><span class="line">        scope = viewModelScope, </span><br><span class="line">        started = WhileSubscribed(<span class="number">5000</span>), </span><br><span class="line">        initialValue = Result.Loading</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>与<code>shareIn</code>类似，唯一不同的时需要传入一个默认值<br>同时之所以<code>WhileSubscribed</code>中传入了<code>5000</code>，是为了实现等待<code>5</code>秒后仍然没有订阅者存在就终止协程的功能，这个方法有以下功能     </p>
<ul>
<li>用户将您的应用转至后台运行，5 秒钟后所有来自其他层的数据更新会停止，这样可以节省电量。</li>
<li>最新的数据仍然会被缓存，所以当用户切换回应用时，视图立即就可以得到数据进行渲染。</li>
<li>订阅将被重启，新数据会填充进来，当数据可用时更新视图。</li>
<li>在屏幕旋转时，因为重新订阅的时间在5s内，因此上游流不会中止   </li>
</ul>
<h3 id="4-3-在页面中观察StateFlow"><a href="#4-3-在页面中观察StateFlow" class="headerlink" title="4.3 在页面中观察StateFlow"></a>4.3 在页面中观察<code>StateFlow</code></h3><p>与<code>LiveData</code>类似，我们也需要经常在页面中观察<code>StateFlow</code><br>观察<code>StateFlow</code>需要在协程中，因此我们需要协程构建器，一般我们会使用下面几种      </p>
<ol>
<li><code>lifecycleScope.launch</code> : 立即启动协程，并且在本 <code>Activity</code>或<code>Fragment</code> 销毁时结束协程。     </li>
<li><code>LaunchWhenStarted</code> 和 <code>LaunchWhenResumed</code>,它会在<code>lifecycleOwner</code>进入<code>X</code>状态之前一直等待，又在离开<code>X</code>状态时挂起协程     </li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d2e0e47e1bd479fa1e3f04aa06c74c3~tplv-k3u1fbpfcp-zoom-1.image" alt><br>如上图所示：<br>1.使用<code>launch</code>是不安全的，在应用在后台时也会接收数据更新，可能会导致应用崩溃<br>2.使用<code>launchWhenStarted</code>或<code>launchWhenResumed</code>会好一些，在后台时不会接收数据更新，但是，上游数据流会在应用后台运行期间保持活跃，因此可能浪费一定的资源       </p>
<p>这么说来，我们使用<code>WhileSubscribed</code>进行的配置岂不是无效了吗？订阅者一直存在，只有页面关闭时才会取消订阅<br><strong>官方推荐<code>repeatOnLifecycle</code>来构建协程</strong><br>在某个特定的状态满足时启动协程，并且在生命周期所有者退出该状态时停止协程,如下图所示。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5b31c118c7345a0add842aabed3c587~tplv-k3u1fbpfcp-zoom-1.image" alt><br>比如在某个<code>Fragment</code>的代码中:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onCreateView(...) &#123;</span><br><span class="line">    viewLifecycleOwner.lifecycleScope.launch &#123;</span><br><span class="line">        viewLifecycleOwner.lifecycle.repeatOnLifecycle(STARTED) &#123;</span><br><span class="line">            myViewModel.myUiState.collect &#123; ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当这个<code>Fragment</code>处于<code>STARTED</code>状态时会开始收集流，并且在<code>RESUMED</code>状态时保持收集，最终在<code>Fragment</code>进入<code>STOPPED</code>状态时结束收集过程。<br>结合使用<code>repeatOnLifecycle API</code>和<code>WhileSubscribed</code>,可以帮助您的应用妥善利用设备资源的同时，发挥最佳性能    </p>
<h3 id="4-4-页面中观察Flow的最佳方式"><a href="#4-4-页面中观察Flow的最佳方式" class="headerlink" title="4.4 页面中观察Flow的最佳方式"></a>4.4 页面中观察<code>Flow</code>的最佳方式</h3><p>通过<code>ViewModel</code>暴露数据，并在页面中获取的最佳方式是:       </p>
<ul>
<li>✔️ 使用带超时参数的 <code>WhileSubscribed</code> 策略暴露 <code>Flow</code>。<a href="https://gist.github.com/JoseAlcerreca/4eb0be817d8f94880dab279d1c27a4af" target="_blank" rel="noopener">示例 1</a></li>
<li>✔️ 使用 <code>repeatOnLifecycle</code> 来收集数据更新。<a href="https://gist.github.com/JoseAlcerreca/6e2620b5615425a516635744ba59892e" target="_blank" rel="noopener">示例 2</a></li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18816ce5cfdc411dbd642b2f66e0a406~tplv-k3u1fbpfcp-zoom-1.image" alt><br>最佳实践如上图所示，如果采用其他方式，上游数据流会被一直保持活跃，导致资源浪费<br>当然，如果您并不需要使用到<code>Kotlin Flow</code>的强大功能，就用<code>LiveData</code>好了 :)       </p>
<h2 id="5-StateFlow与SharedFlow有什么区别？"><a href="#5-StateFlow与SharedFlow有什么区别？" class="headerlink" title="5 StateFlow与SharedFlow有什么区别？"></a>5 <code>StateFlow</code>与<code>SharedFlow</code>有什么区别？</h2><p>从上文其实可以看出，<code>StateFlow</code>与<code>SharedFlow</code>其实是挺像的，让人有些傻傻分不清，有时候也挺难选择该用哪个的    </p>
<p>我们总结一下，它们的区别如下:   </p>
<ol>
<li><code>SharedFlow</code>配置更为灵活，支持配置<code>replay</code>,缓冲区大小等，<code>StateFlow</code>是<code>SharedFlow</code>的特化版本，<code>replay</code>固定为1，缓冲区大小默认为0     </li>
<li><code>StateFlow</code>与<code>LiveData</code>类似，支持通过<code>myFlow.value</code>获取当前状态，如果有这个需求，必须使用<code>StateFlow</code>      </li>
<li><code>SharedFlow</code>支持发出和收集重复值，而<code>StateFlow</code>当<code>value</code>重复时，不会回调<code>collect</code>      </li>
<li>对于新的订阅者，<code>StateFlow</code>只会重播当前最新值，<code>SharedFlow</code>可配置重播元素个数（默认为0，即不重播）   </li>
</ol>
<p>可以看出,<code>StateFlow</code>为我们做了一些默认的配置，在<code>SharedFlow</code>上添加了一些默认约束，这些配置可能并不符合我们的要求     </p>
<ol>
<li>它忽略重复的值，并且是不可配置的。这会带来一些问题，比如当往<code>List</code>中添加元素并更新时，<code>StateFlow</code>会认为是重复的值并忽略         </li>
<li>它需要一个初始值，并且在开始订阅时会回调初始值，这有可能不是我们想要的     </li>
<li>它默认是粘性的，新用户订阅会获得当前的最新值，而且是不可配置的,而<code>SharedFlow</code>可以修改<code>replay</code>       </li>
</ol>
<p><code>StateFlow</code>施加在<code>SharedFlow</code>上的约束可能不是最适合您，如果不需要访问<code>myFlow.value</code>，并且享受<code>SharedFlow</code>的灵活性，可以选择考虑使用<code>SharedFlow</code>    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单往往意味着不够强大，而强大又常常意味着复杂,两者往往不能兼得，软件开发过程中常常面临这种取舍。<br><code>LiveData</code>的简单并不是它的缺点，而是它的特点。<code>StateFlow</code>与<code>SharedFlow</code>更加强大，但是学习成本也显著的更高.<br>我们应该根据自己的需求合理选择组件的使用       </p>
<ol>
<li>如果你的数据流比较简单，不需要进行线程切换与复杂的数据变换，<code>LiveData</code>对你来说相信已经足够了     </li>
<li>如果你的数据流比较复杂，需要切换线程等操作，不需要发送重复值，需要获取<code>myFlow.value</code>，<code>StateFlow</code>对你来说是个好的选择     </li>
<li>如果你的数据流比较复杂，同时不需要获取<code>myFlow.value</code>，需要配置新用户订阅重播无素的个数，或者需要发送重复的值，可以考虑使用<code>SharedFlow</code></li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6854573211930066951" target="_blank" rel="noopener">Google 推荐在 MVVM 架构中使用 Kotlin Flow</a><br><a href="https://alexzh.com/migrate-from-livedata-to-stateflow-and-sharedflow/" target="_blank" rel="noopener">Migrate from LiveData to StateFlow and SharedFlow</a><br><a href="https://juejin.cn/post/6979008878029570055" target="_blank" rel="noopener">从 LiveData 迁移到 Kotlin 数据流</a><br><a href="https://juejin.cn/post/6979793981928374308#heading-9" target="_blank" rel="noopener">关于kotlin中的Collections、Sequence、Channel和Flow (二)</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识点】Java泛型机制7连问</title>
    <url>/blog/2021/06/java-generic-questions.html</url>
    <content><![CDATA[<p>泛型机制是我们开发中的常用技巧，也是面试常见问题<br>不过泛型机制这个知识点也比较繁杂又不成体系，学了容易忘<br>本文从几个问题出发梳理<code>Java</code>泛型机制知识点，如果对你有用，欢迎点赞~       </p>
<p>本文主要包括以下内容<br>1.我们为什么需要泛型?<br>2.什么是泛型擦除及泛型擦除带来的一些问题,如<code>retrofit</code>怎么获得擦除后的类型,<code>Gson</code>怎么获得擦除后的类型?<br>3.什么是<code>PECS</code>原则     </p>
<p>本文目录如下<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/june/p1.png" alt>          </p>
<h2 id="1-我们为什么需要泛型"><a href="#1-我们为什么需要泛型" class="headerlink" title="1.我们为什么需要泛型?"></a>1.我们为什么需要泛型?</h2><p>我们为什么需要泛型，即泛型有什么用?<br>首先举两个例子    </p>
<h3 id="1-1-求和函数"><a href="#1-1-求和函数" class="headerlink" title="1.1 求和函数"></a>1.1 求和函数</h3><p>实际开发中，经常有数值类型求和的需求，例如实现<code>int</code>类型的加法, 有时候还需要实现<code>long</code>类型的求和 如果还需要<code>double</code>类型的求和，又需要重新在重载一个输入是<code>double</code>类型的<code>add</code>方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addInt</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">addFloat</span><span class="params">(<span class="keyword">float</span> x,<span class="keyword">float</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有泛型，我们需要写不少重复代码     </p>
<h3 id="1-2-List中添加元素"><a href="#1-2-List中添加元素" class="headerlink" title="1.2 List中添加元素"></a>1.2 <code>List</code>中添加元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"mark"</span>);</span><br><span class="line">list.add(<span class="string">"OK"</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        String name = list.get(i); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1.<code>list</code>默认是<code>Object</code>类型，因此可以存任意类型数据<br>2.但是当取出来时，我们并不知道取出元素的类型，就需要进行强制类型转换了，并且容易出错    </p>
<h3 id="1-3-泛型机制的优点"><a href="#1-3-泛型机制的优点" class="headerlink" title="1.3 泛型机制的优点"></a>1.3 泛型机制的优点</h3><p>从上面的两个例子我们可以直观的得出泛型机制的优点<br>1.使用泛型可以编写模板代码来适应任意类型，减少重复代码<br>2.使用时不必对类型进行强制转换,方便且减少出错机会   </p>
<h2 id="2-泛型擦除"><a href="#2-泛型擦除" class="headerlink" title="2.泛型擦除"></a>2.泛型擦除</h2><h3 id="2-1-什么是泛型擦除"><a href="#2-1-什么是泛型擦除" class="headerlink" title="2.1 什么是泛型擦除?"></a>2.1 什么是泛型擦除?</h3><p>大家都知道，<code>Java</code>的泛型是伪泛型，这是因为<code>Java</code>在编译期间，所有的泛型信息都会被擦掉，正确理解泛型概念的首要前提是理解类型擦除。<br><code>Java</code>的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程就是泛型擦除。    </p>
<p>举个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list1.add(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list2.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list1.getClass() == list2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上<code>list1.getClass==list2.getClass</code>返回<code>true</code>,说明泛型类型<code>String</code>和<code>Integer</code>都被擦除掉了，只剩下原始类型<br><code>Java</code>的泛型也可以被称作是伪泛型        </p>
<ul>
<li>真泛型：泛型中的类型是真实存在的。</li>
<li>伪泛型：仅于编译时类型检查，在运行时擦除类型信息。</li>
</ul>
<p>看到这里我们可以自然地引出下一个问题，为什么<code>Java</code>中的泛型是伪泛型，为什么要这样实现？    </p>
<h3 id="2-2-为什么需要泛型擦除"><a href="#2-2-为什么需要泛型擦除" class="headerlink" title="2.2 为什么需要泛型擦除?"></a>2.2 为什么需要泛型擦除?</h3><p>泛型擦除看起来有些反直觉，有些奇怪。为什么<code>Java</code>不能像<code>C#</code>一样实现真正的泛型呢?为什么<code>Java</code>的泛型要用”擦除”实现<br>单从技术来说，<code>Java</code>是完全<code>100%</code>能实现我们所说的<code>真泛型</code>，而之所以选择使用泛型擦除主要是从<code>API</code>兼容的角度考虑的<br>导致<code>Java 5</code>引入的泛型采用擦除式实现的根本原因是兼容性上的取舍，而不是“实现不了”的问题。     </p>
<p>举个例子,<code>Java</code>到<code>1.4.2</code>都没有支持泛型，而到<code>Java 5</code>突然支持泛型了，要让以前编译的程序在新版本的<code>JRE</code>还能正常运行，就意味着以前没有的限制不能突然冒出来。<br>假如在没有泛型的<code>Java</code>里，我们有程序使用了<code>java.util.ArrayList</code>类，而且我们利用了它可以存异质元素的特性：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList things = <span class="keyword">new</span> ArrayList();</span><br><span class="line">things.add(Integer.valueof(<span class="number">42</span>));</span><br><span class="line">things.add(<span class="string">"Hello World"</span>)</span><br></pre></td></tr></table></figure></p>
<p>为了这段代码在<code>Java 5</code>引入泛型之后还必须要继续可以运行,有两种设计思路<br>1.需要泛型化的类型（主要是容器（<code>Collections</code>）类型），以前有的就保持不变，然后平行地加一套泛型化版本的新类型；<br>2.直接把已有的类型泛型化，让所有需要泛型化的已有类型都原地泛型化，不添加任何平行于已有类型的泛型版。     </p>
<p><code>.NET</code>在<code>1.1 -&gt; 2.0</code>的时候选择了上面选项的1，而<code>Java</code>则选择了2。         </p>
<p>从<code>Java</code>设计者的角度看，这个取舍很明白。<br><code>.NET</code>在<code>1.1 -&gt; 2.0</code>的时候，实际的应用代码量还很少（相对<code>Java</code>来说），而且整个体系都在微软的控制下，要做变更比较容易；<br>而<code>Java</code>在<code>1.4.2 -&gt; 5.0</code>的时候，Java已经有大量程序部署在生产环境中，已经有很多应用和库程序的代码。<br>如果这些代码在新版本的<code>Java</code>中，为了使用<code>Java</code>的新功能（例如泛型）而必须做大量源码层修改，那么新功能的普及速度就会大受影响。          </p>
<h3 id="2-3-泛型擦除后retrofit是怎么获取类型的"><a href="#2-3-泛型擦除后retrofit是怎么获取类型的" class="headerlink" title="2.3 泛型擦除后retrofit是怎么获取类型的?"></a>2.3 泛型擦除后<code>retrofit</code>是怎么获取类型的?</h3><p><code>Retrofit</code>是如何传递泛型信息的？<br>上一段常见的网络接口请求代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>jad</code>查看反编译后的<code>class</code>文件：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> retrofit2.Call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Call <span class="title">listRepos</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>class</code>文件中已经将泛型信息给擦除了，那么<code>Retrofit</code>是如何拿到<code>Call&lt;List&gt;</code>的类型信息的?<br>我们看一下<code>retrofit</code>的源码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">ServiceMethod&lt;T&gt; <span class="title">parseAnnotations</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  Type returnType = method.getGenericReturnType();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Type <span class="title">getGenericReturnType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 根据 Signature 信息 获取 泛型类型 </span></span><br><span class="line">    <span class="keyword">if</span> (getGenericSignature() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getGenericInfo().getReturnType();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    	<span class="keyword">return</span> getReturnType();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出,<code>retrofit</code>是通过<code>getGenericReturnType</code>来获取类型信息的<br><code>jdk</code>的<code>Class</code> 、<code>Method</code> 、<code>Field</code> 类提供了一系列获取 泛型类型的相关方法。<br>以<code>Method</code>为例,<code>getGenericReturnType</code>获取带泛型信息的返回类型 、 <code>getGenericParameterTypes</code>获取带泛型信息的参数类型。     </p>
<p>问：泛型的信息不是被擦除了吗？<br>答：是被擦除了， 但是某些（声明侧的泛型，接下来解释） 泛型信息会被<code>class</code>文件 以<code>Signature</code>的形式 保留在<code>Class</code>文件的<code>Constant pool</code>中。       </p>
<p>通过<code>javap</code>命令 可以看到在<code>Constant pool</code>中<code>#5 Signature</code>记录了泛型的类型。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #16            //  com/example/diva/leet/GitHubService</span><br><span class="line">   #2 = Class              #17            //  java/lang/Object</span><br><span class="line">   #3 = Utf8               listRepos</span><br><span class="line">   #4 = Utf8               (Ljava/lang/String;)Lretrofit2/Call;</span><br><span class="line">   #5 = Utf8               Signature</span><br><span class="line">   #6 = Utf8               (Ljava/lang/String;)Lretrofit2/Call&lt;Ljava/util/List&lt;Lcom/example/diva/leet/Repo;&gt;;&gt;;</span><br><span class="line">   #7 = Utf8               RuntimeVisibleAnnotations</span><br><span class="line">   #8 = Utf8               Lretrofit2/http/GET;</span><br><span class="line">   #9 = Utf8               value</span><br><span class="line">  #10 = Utf8               users/&#123;user&#125;/repos</span><br><span class="line">  #11 = Utf8               RuntimeVisibleParameterAnnotations</span><br><span class="line">  #12 = Utf8               Lretrofit2/http/Path;</span><br><span class="line">  #13 = Utf8               user</span><br><span class="line">  #14 = Utf8               SourceFile</span><br><span class="line">  #15 = Utf8               GitHubService.java</span><br><span class="line">  #16 = Utf8               com/example/diva/leet/GitHubService</span><br><span class="line">  #17 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> retrofit2.Call&lt;java.util.List&lt;com.example.diva.leet.Repo&gt;&gt; listRepos(java.lang.String);</span><br><span class="line">    flags: ACC_PUBLIC, ACC_ABSTRACT</span><br><span class="line">    Signature: #6                           // (Ljava/lang/String;)Lretrofit2/Call&lt;Ljava/util/List&lt;Lcom/example/diva/leet/Repo;&gt;;&gt;;</span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      0: #8(#9=s#10)</span><br><span class="line">    RuntimeVisibleParameterAnnotations:</span><br><span class="line">      parameter <span class="number">0</span>:</span><br><span class="line">        0: #12(#9=s#13)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是我们<code>retrofit</code>中能够获取泛型类型的原因    </p>
<h3 id="2-4-Gson解析为什么要传入内部类"><a href="#2-4-Gson解析为什么要传入内部类" class="headerlink" title="2.4 Gson解析为什么要传入内部类"></a>2.4 <code>Gson</code>解析为什么要传入内部类</h3><p><code>Gson</code>是我们常用的<code>json</code>解析库,一般是这样使用的<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Gson 常用的情况</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  List&lt;String&gt; <span class="title">parse</span><span class="params">(String jsonStr)</span></span>&#123;</span><br><span class="line">       List&lt;String&gt; topNews =  <span class="keyword">new</span> Gson().fromJson(jsonStr, <span class="keyword">new</span> TypeToken&lt;List&lt;String&gt;&gt;() &#123;&#125;.getType());</span><br><span class="line">       <span class="keyword">return</span> topNews;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们这里可以提出两个问题<br>1.<code>Gson</code>是怎么获取泛型类型的，也是通过<code>Signature</code>吗?<br>2.为什么<code>Gson</code>解析要传入匿名内部类？这看起来有些奇怪    </p>
<h3 id="2-4-1-那些泛型信息会被保留，哪些是真正的擦除了？"><a href="#2-4-1-那些泛型信息会被保留，哪些是真正的擦除了？" class="headerlink" title="2.4.1 那些泛型信息会被保留，哪些是真正的擦除了？"></a>2.4.1 那些泛型信息会被保留，哪些是真正的擦除了？</h3><p>上面我们说了，声明侧泛型会被记录在<code>Class</code>文件的<code>Constant pool</code>中,使用侧泛型则不会    </p>
<p>声明侧泛型主要指以下内容<br>1.泛型类，或泛型接口的声明<br>2.带有泛型参数的方法<br>3.带有泛型参数的成员变量</p>
<p>使用侧泛型<br>也就是方法的局部变量,方法调用时传入的变量。    </p>
<p><code>Gson</code>解析时传入的参数属于使用侧泛型，因此不能通过<code>Signature</code>解析    </p>
<h3 id="2-4-2-为什么Gson解析要传入匿名内部类"><a href="#2-4-2-为什么Gson解析要传入匿名内部类" class="headerlink" title="2.4.2 为什么Gson解析要传入匿名内部类"></a>2.4.2 为什么<code>Gson</code>解析要传入匿名内部类</h3><p>根据以上的总结，方法的局部变量的泛型是不会被保存的<br><code>Gson</code>是如何获取到<code>List&lt;String&gt;</code>的泛型信息<code>String</code>的呢？<br><code>Class</code>类提供了一个方法<code>public Type getGenericSuperclass()</code> ，可以获取到带泛型信息的父类<code>Type</code>。<br>也就是说<code>java</code>的<code>class</code>文件会保存继承的父类或者接口的泛型信息。          </p>
<p>所以<code>Gson</code>使用了一个巧妙的方法来获取泛型类型：<br>1.创建一个泛型抽象类<code>TypeToken &lt;T&gt;</code> ，这个抽象类不存在抽象方法，因为匿名内部类必须继承自抽象类或者接口。所以才定义为抽象类。<br>2.创建一个 继承自<code>TypeToken</code>的匿名内部类， 并实例化泛型参数<code>TypeToken&lt;String&gt;</code><br>3.通过<code>class</code>类的<code>public Type getGenericSuperclass()</code>方法，获取带泛型信息的父类<code>Type</code>，也就是<code>TypeToken&lt;String&gt;</code>      </p>
<p>总结：<code>Gson</code>利用子类会保存父类<code>class</code>的泛型参数信息的特点。 通过匿名内部类实现了泛型参数的传递。       </p>
<h2 id="3-什么是PECS原则"><a href="#3-什么是PECS原则" class="headerlink" title="3.什么是PECS原则?"></a>3.什么是<code>PECS</code>原则?</h2><h3 id="3-1-PECS介绍"><a href="#3-1-PECS介绍" class="headerlink" title="3.1 PECS介绍"></a>3.1 <code>PECS</code>介绍</h3><p><code>PECS</code>的意思是<code>Producer Extend Consumer Super</code>，简单理解为如果是生产者则使用<code>Extend</code>，如果是消费者则使用<code>Super</code>，不过，这到底是啥意思呢？   </p>
<p><code>PECS</code>是从集合的角度出发的<br>1.如果你只是从集合中取数据，那么它是个生产者，你应该用<code>extend</code><br>2.如果你只是往集合中加数据，那么它是个消费者，你应该用<code>super</code><br>3.如果你往集合中既存又取，那么你不应该用<code>extend</code>或者<code>super</code>     </p>
<p>让我们通过一个典型的例子理解一下到底什么是<code>Producer</code>和<code>Consumer</code><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span>   </span>&#123;  </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++) &#123; </span><br><span class="line">          dest.set(i, src.get(i)); </span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中将<code>src</code>中的数据复制到<code>dest</code>中，这里<code>src</code>就是生产者，它「生产」数据，<code>dest</code>是消费者，它「消费」数据。             </p>
<h3 id="3-2-为什么需要PECS"><a href="#3-2-为什么需要PECS" class="headerlink" title="3.2 为什么需要PECS"></a>3.2 为什么需要<code>PECS</code></h3><p><strong>使用<code>PECS</code>主要是为了实现集合的多态</strong><br>举个例子，现在有这样一个需求，将水果篮子中所有水果拿出来（即取出集合所有元素并进行操作）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getOutFruits</span><span class="params">(List&lt;Fruit&gt; basket)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Fruit fruit : basket) &#123;</span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">        <span class="comment">//...do something other</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Fruit&gt; fruitBasket = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line">getOutFruits(fruitBasket);<span class="comment">//成功</span></span><br><span class="line"></span><br><span class="line">List&lt;Apple&gt; appleBasket = <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">getOutFruits(appleBasket);<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure></p>
<p>如上所示:<br>1.将<code>List&lt;Apple&gt;</code>传递给<code>List&lt;Fruit&gt;</code>会编译错误。<br>2.因为虽然<code>Fruit</code>是<code>Apple</code>的父类，但是<code>List&lt;Apple&gt;</code>和<code>List&lt;Fruit&gt;</code>之间没有继承关系<br>3.因为这种限制，我们不能很好的完成取出水果篮子中的所有水果需求，总不能每个类型都写一遍一样的代码吧？    </p>
<p>使用<code>extend</code>可以方便地解决这个问题<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**参数使用List&lt;? extends Fruit&gt;**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getOutFruits</span><span class="params">(List&lt;? extends Fruit&gt; basket)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Fruit fruit : basket) &#123;</span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">        <span class="comment">//...do something other</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Fruit&gt; fruitBasket = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    fruitBasket.add(<span class="keyword">new</span> Fruit());</span><br><span class="line">    getOutFruits(fruitBasket);</span><br><span class="line"></span><br><span class="line">    List&lt;Apple&gt; appleBasket = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    appleBasket.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    getOutFruits(appleBasket);<span class="comment">//编译正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>List&lt;? extends Fruit&gt;</code>，同时兼容了<code>List&lt;Fruit&gt;</code>和<code>List&lt;Apple&gt;</code>，我们可以理解为<code>List&lt;? extends Fruit&gt;</code>现在是<code>List&lt;Fruit&gt;</code>和<code>List&lt;Apple&gt;</code>的超类型（父类型）<br>通过这种方式就实现了泛型集合的多态    </p>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><ul>
<li>在<code>List&lt;? extends Fruit&gt;</code>的泛型集合中，对于元素的类型，编译器只能知道元素是继承自<code>Fruit</code>，具体是<code>Fruit</code>的哪个子类是无法知道的。 所以「向一个无法知道具体类型的泛型集合中插入元素是不能通过编译的」。但是由于知道元素是继承自<code>Fruit</code>，所以从这个泛型集合中取<code>Fruit</code>类型的元素是可以的。</li>
<li>在<code>List&lt;? super Apple&gt;</code>的泛型集合中，元素的类型是<code>Apple</code>的父类，但无法知道是哪个具体的父类，因此「读取元素时无法确定以哪个父类进行读取」。 插入元素时可以插入<code>Apple</code>与<code>Apple</code>的子类，因为这个集合中的元素都是<code>Apple</code>的父类，子类型是可以赋值给父类型的。   </li>
</ul>
<p>有一个比较好记的口诀：<br>1.只读不可写时,使用<code>List&lt;? extends Fruit&gt;:Producer</code><br>2.只写不可读时,使用<code>List&lt;? super Apple&gt;:Consumer</code>     </p>
<p>总得来说，<code>List&lt;Fruit&gt;</code>和<code>List&lt;Apple&gt;</code>之间没有任何继承关系。<code>API</code>的参数想要同时兼容2者，则只能使用<code>PECS</code>原则。这样做提升了<code>API</code>的灵活性，实现了泛型集合的多态<br>当然，为了提升了灵活性，自然牺牲了部分功能。鱼和熊掌不能兼得。     </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了<code>Java</code>泛型机制这个知识点，回答了如下几个问题<br>1.我们为什么需要泛型?<br>2.什么是泛型擦除?<br>3.为什么需要泛型擦除？<br>4.泛型擦除后<code>retrofit</code>怎么获得类型的?<br>5.<code>Gson</code>解析为什么要传入内部类<br>6.什么是<code>PECS</code>原则?<br>7.为什么需要<code>PECS</code>原则?    </p>
<p>如果对您有所帮助，欢迎点赞，谢谢~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/question/28665443/answer/118148143" target="_blank" rel="noopener">Java 不能实现真正泛型的原因是什么？</a><br><a href="https://blog.csdn.net/wakewakewake/article/details/104836651" target="_blank" rel="noopener">java 的泛型擦除与 TypeToken</a><br><a href="https://elsef.com/2020/04/06/%E5%85%B3%E4%BA%8EPECS%E5%8E%9F%E5%88%99/" target="_blank" rel="noopener">关于PECS原则</a></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-flow作者称其不适用于持续交付?</title>
    <url>/blog/2021/07/git-flow-compare.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Git-flow</code>是由<code>Vincent Driessen</code>在2010年提出的一个<code>Git</code>分支模型,在这10年中，<code>Git-flow</code>在许多软件团队中变得非常流行，以至于人们开始将其视为某种标准。<br>不过最近<code>Vincent Driessen</code>更新了他10年前那篇著名的<a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a>，大意是<code>Git-flow</code>已不适用于当今持续交付的软件工程方式,推荐更简单的<code>Github flow</code>等模型</p>
<p>连<code>Git-flow</code>作者都承认<code>Git-flow</code>不适合持续交付了，那我们更有必要好好研究一下了，以免掉坑里。<br>本文主要包括以下内容：<br>1.<code>Git-flow</code>介绍<br>2.为什么<code>Git-flow</code>不适用于持续交付？<br>3.<code>Github flow</code>介绍<br>4.<code>Gitlab flow</code>介绍        </p>
<h2 id="1-Git-flow是什么"><a href="#1-Git-flow是什么" class="headerlink" title="1. Git-flow是什么?"></a>1. <code>Git-flow</code>是什么?</h2><p><code>Git-flow</code>是由<code>Vincent Driessen</code>在2010年提出的一个<code>Git</code>分支模型,其结构图如下所示，相信大家都看过<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/july/p5.png" alt><br><code>Git-flow</code>主要包括以下分支</p>
<ul>
<li><code>master</code> 是长期分支，一般用于管理对外发布版本，每个<code>commit</code>对一个<code>tag</code>，也就是一个发布版本     </li>
<li><code>develop</code> 是长期分支，一般用于作为日常开发汇总，即开发版的代码     </li>
<li><code>feature</code> 是短期分支，一般用于一个新功能的开发  </li>
<li><code>hotfix</code> 是短期分支 ，一般用于正式发布以后，出现<code>bug</code>，需要创建一个分支，进行<code>bug</code>修补。</li>
<li><code>release</code> 是短期分支，一般用于发布正式版本之前（即合并到 <code>master</code> 分支之前），需要对预发布的版本进行测试。<code>release</code> 分支在经历测试之后，测试确认验收，将会被合并到 <code>develop</code> 和 <code>master</code></li>
</ul>
<h3 id="1-1-Git-flow工作流程"><a href="#1-1-Git-flow工作流程" class="headerlink" title="1.1 Git-flow工作流程"></a>1.1 <code>Git-flow</code>工作流程</h3><p>一般工作流程如下： </p>
<ul>
<li>1.日常在<code>develop</code>开发</li>
<li>2.如果有比较大的功能或者其他需求，那么新开分支：<code>feature/xxx</code> 来做，并在这个分支上进行打包和提测。</li>
<li>3.在封版日，将该版本上线的需求合并到<code>develop</code>，然后将开个新的分支<code>release/版本号</code>(如<code>release/1.0.1</code>),将<code>develop</code>合并至该分支。</li>
<li>4.灰度阶段，在<code>releases/版本号</code> 分支上修复BUG，打包并发布,发布完成后反合入<code>master</code>与<code>develop</code>分支</li>
<li>5.如果在全量发布后，发现有线上问题，那么在对应的<code>master</code>分支上新开分支<code>hotfix/{版本号}</code>来修复，并升级版本号，修复完成后，然后将<code>hotfix</code>合并到<code>master</code>，同时将合并到<code>develop</code></li>
</ul>
<h2 id="2-为什么Git-flow不适用于持续交付？"><a href="#2-为什么Git-flow不适用于持续交付？" class="headerlink" title="2. 为什么Git-flow不适用于持续交付？"></a>2. 为什么<code>Git-flow</code>不适用于持续交付？</h2><blockquote>
<p>在这 10 年中，<code>Git</code> 本身已经席卷全球，并且使用 <code>Git</code> 开发的最受欢迎的软件类型正在更多地转向 <code>Web</code> 应用程序——至少在我的过滤器气泡中。 <code>Web</code> 应用程序通常是持续交付的，而不是回滚的，而且您不必支持同时 运行的多个版本的软件。</p>
</blockquote>
<p>如<code>Vincent Driessen</code>所述。<code>Git-flow</code>描述了<code>feature</code>分支、<code>release</code>分支、<code>master</code>或<code>develop</code>分支以及<code>hotfix</code>分支是如何相互关联的。<br>这种方法非常适用于用户下载的打包软件，例如库和桌面应用程序。</p>
<p>然而，对于许多<code>Web</code>应用来说，<code>Git-flow</code>是矫枉过正的。有时，您的<code>develop</code>分支和<code>release</code>分支之间没有足够大的差异来区分值得。或者，您的<code>hotfix</code>分支和<code>feature</code>分支的工作流程可能相同。<br>在这种情况下，<code>Vincent Driessen</code>推荐<code>Github flow</code>分支模型</p>
<p><code>Git-flow</code>的主要优点在于结构清晰，每个分支的任务划分的很清楚，而它的缺点自然就是有些复杂了<br><code>Git-flow</code>需要同时维护两个长期分支。大多数工具都将<code>master</code>当作默认分支，可是开发是在<code>develop</code>分支进行的，这导致经常要切换分支，非常烦人。<br>更大问题在于，这个模式是基于”版本发布”的，目标是一段时间以后产出一个新版本。但是，很多网站项目是”持续发布”，代码一有变动，就部署一次。这时，<code>master</code>分支和<code>develop</code>分支的差别不大，没必要维护两个长期分支</p>
<h3 id="2-1-Git-fow何时值得额外的复杂性"><a href="#2-1-Git-fow何时值得额外的复杂性" class="headerlink" title="2.1 Git-fow何时值得额外的复杂性"></a>2.1 <code>Git-fow</code>何时值得额外的复杂性</h3><p>当然，是否使用<code>Git-flow</code>取决于你的业务复杂性，有时使用<code>Git-flow</code>是必须的，主要是当你需要同时维护多版本的时候,适合的是需要『多个版本并存』的场景<br>所谓『多版本并存』，就是说开发团队要同时维护多个有客户使用的版本，对于传统软件，比如我开发一个新的操作系统叫做<code>Doors</code>，先卖<code>v1</code>，卖出去1000万份，然后看在<code>v1</code>的基础上开发<code>v2</code>，但是客户会持续给<code>v1</code>提<code>bug</code>，这些<code>bug</code>既要在<code>v1</code>的后续补丁中<code>fix</code>，也要在<code>v2</code>中<code>fix</code>，等<code>v2</code>再卖出去2000万份开始开发<code>v3</code>的时候，<code>v1</code>依然有客户，我就必须要维持<code>v1</code>、<code>v2</code>、<code>v3</code>三个多版本都要支持。</p>
<p>关于<code>Git-flow</code>同时支持多个版本，很多人可能会有疑问，因为<code>develop</code>只针对一个版本能持续交付<br>说实话我也感觉挺疑问的，后面查阅资料发现还有一个衍生的<code>support</code>分支，可以同时支持多个版本,在兴趣的同学可参考:<a href="https://mindsers.blog/post/several-versions-gitflow/" target="_blank" rel="noopener">https://mindsers.blog/post/several-versions-gitflow/</a></p>
<h2 id="3-Github-flow介绍"><a href="#3-Github-flow介绍" class="headerlink" title="3.Github flow介绍"></a>3.<code>Github flow</code>介绍</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b2a5994eafe41ec964b4792b8a9fc1a~tplv-k3u1fbpfcp-watermark.image" alt><br><code>Github flow</code>它只有一个长期分支，就是<code>master</code>，因此用起来非常简单。   </p>
<ul>
<li>第一步：根据需求，从<code>master</code>拉出新分支，不区分功能分支或补丁分支。</li>
<li>第二步：新分支开发完成后，或者需要讨论的时候，就向<code>master</code>发起一个<code>pull request</code>（简称<code>PR</code>）。</li>
<li>第三步：<code>Pull Request</code>既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码</li>
<li>第四步：布署流程：当项目负责人同意新功能可以发布，且代码也通过审核了。但是在代码合并之前还是要进行测试。所以要把<code>feature</code>分支的代码部署到测试环境进行测试</li>
<li>第五步：你的<code>Pull Request</code>被接受，合并进<code>master</code>，重新部署到生产环境后，原来你拉出来的那个分支就被删除。</li>
<li>第六步：修复正式环境<code>bug</code>流程：从<code>master</code>分支切一个<code>HotFix</code>分支，经过以上同样的流程发起<code>PR</code>合并即可</li>
</ul>
<h3 id="3-1-Github-flow的优点"><a href="#3-1-Github-flow的优点" class="headerlink" title="3.1 Github flow的优点"></a>3.1 <code>Github flow</code>的优点</h3><p><code>Github flow</code>的最大优点就是简单，对于”持续发布”的产品，可以说是最合适的流程。     </p>
<h3 id="3-2-Github-flow的缺点"><a href="#3-2-Github-flow的缺点" class="headerlink" title="3.2 Github flow的缺点"></a>3.2 <code>Github flow</code>的缺点</h3><p>它的问题也在于它的假设：<code>master</code>分支的更新与产品的发布是一致的。也就是说，<code>master</code>分支的最新代码，默认就是当前的线上代码。<br>可是，有些时候并非如此，代码合并进入<code>master</code>分支，并不代表它就能立刻发布。比如，苹果商店的<code>APP</code>提交审核以后，等一段时间才能上架。这时，如果还有新的代码提交，<code>master</code>分支就会与刚发布的版本不一致。另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于<code>master</code>分支。<br>上面这种情况，只有<code>master</code>一个主分支就不够用了。通常，你不得不在<code>master</code>分支以外，另外新建一个<code>production</code>分支跟踪线上版本。   </p>
<p>同时对于<code>Github flow</code>我还有个疑问，合并到<code>master</code>分支后即会部署到生产环境，但是在<code>merge</code>后的代码难道不会产生冲突吗？合并冲突难道不需要重新测试吗？如果评论区有了解的小伙伴可以解惑下</p>
<p><code>Github flow</code>用起来比较简单，但是在很多公司的业务开发过程中一般都有开发、测试、预发布、生产几个环境，没有强有力的工具来支撑，我认为很难用这种简单的模式来实现管理。<br>看起来这种模式特别适合小团队，人少，需求少，比较容易通过这种方式管理分支。    </p>
<h2 id="4-Gitlab-flow介绍"><a href="#4-Gitlab-flow介绍" class="headerlink" title="4.Gitlab flow介绍"></a>4.<code>Gitlab flow</code>介绍</h2><p><code>Gitlab flow</code> 是 <code>Git-flow</code>与<code>Github flow</code>的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是<code>Gitlab.com</code>推荐的做法。<br><code>Gitlab flow</code>的最大原则叫做”上游优先”（<code>upsteam first</code>），即只存在一个主分支<code>master</code>，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。<br><code>Gitlab flow</code>分为持续发布与版本发布两种情况，以适应不同的发布类型    </p>
<h3 id="4-1-持续发布"><a href="#4-1-持续发布" class="headerlink" title="4.1 持续发布"></a>4.1 持续发布</h3><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/july/p6.png" alt><br>对于”持续发布”的项目，它建议在<code>master</code>分支以外，再建立不同的环境分支。<br>比如，”开发环境”的分支是<code>master</code>，”预发环境”的分支是<code>pre-production</code>，”生产环境”的分支是<code>production</code>。    </p>
<p>开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了<code>bug</code>，这时就要新建一个功能分支，先把它合并到<code>master</code>，确认没有问题，再<code>cherry-pick</code>到<code>pre-production</code>，这一步也没有问题，才进入<code>production</code>。</p>
<p>只有紧急情况，才允许跳过上游，直接合并到下游分支。</p>
<h3 id="4-2-版本发布"><a href="#4-2-版本发布" class="headerlink" title="4.2 版本发布"></a>4.2 版本发布</h3><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/july/p7.png" alt><br>对于”版本发布”的项目，建议的做法是每一个稳定版本，都要从<code>master</code>分支拉出一个分支，比如<code>2-3-stable</code>、<code>2-4-stable</code>等等。<br>以后，只有修补<code>bug</code>，才允许将代码合并到这些分支，并且此时要更新小版本号。     </p>
<h3 id="4-3-Gitlab-flow开发流程"><a href="#4-3-Gitlab-flow开发流程" class="headerlink" title="4.3 Gitlab flow开发流程"></a>4.3 <code>Gitlab flow</code>开发流程</h3><p>对于<code>Android</code>开发，我们一般使用版本发布，因此我们使用<code>Gitlab flow</code>开发的工作流为     </p>
<ul>
<li>1.新的迭代开始，所有开发人员从主干<code>master</code>拉个人分支开发特性, 分支命名规范 <code>feature-name</code></li>
<li>2.开发完成后，在迭代结束前，合入<code>master</code>分支</li>
<li>3.<code>master</code>分支合并后，自动<code>cicd</code>到<code>dev</code>环境</li>
<li>4.开发自测通过后，从<code>master</code>拉取要发布的分支，<code>release-$version</code>，将这个分支部署到测试环境进行测试</li>
<li>5.测出的<code>bug</code>，通过从<code>release-$versio</code>拉出分支进行修复，修复完成后，再合入<code>release-$versio</code></li>
<li>6.正式发布版本，如果上线后，又有<code>bug</code>，根据5的方式处理</li>
<li>7.等发布版本稳定后，将<code>release-$versio</code>反合入主干<code>master</code>分支</li>
</ul>
<p>值得注意的是，按照<code>Github flow</code>规范，第5步如果测出<code>bug</code>,应该在<code>master</code>上修改，然后<code>cherry-pick</code>到<code>releases</code>上来，但是这样做太麻烦了，直接在<code>releases</code>分支上修复<code>bug</code>然后再反合入<code>master</code>分支应该是一个简单而且可以接受的做法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正如<code>Vincent Driessen</code>所说的,<strong>总而言之，请永远记住，灵丹妙药并不存在。考虑你自己的背景。不要讨厌。自己决定</strong>。      </p>
<p><code>Git-flow</code>适用于大团队多版本并存迭代的开发流程<br><code>Github-flow</code>适用于中小型团队持续集成的开发流程<br><code>Gitlab-flow</code>适用范围则介于上面二者之间，支持持续发布与版本发布两种情况    </p>
<p>总得来说，各种<code>Git</code>工作流自有其适合工作的场景,毕竟软件工程中没有银弹,读者可根据自己的项目情况对比选择使用，自己决定~      </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/question/379545619" target="_blank" rel="noopener">如何看待 Git flow 发明人称其不适用于持续交付？</a><br><a href="https://www.freshconsulting.com/insights/blog/git-development-workflows-git-flow-vs-github-flow/" target="_blank" rel="noopener">Git 开发工作流程：Git Flow 与 GitHub Flow</a><br><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">Git 工作流程</a><br><a href="https://www.cnblogs.com/xiaoqi/p/gitlab-flow.html" target="_blank" rel="noopener">高效团队的gitlab flow最佳实践</a></p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>一些大厂的<code>Git</code>工作流，有兴趣的同学可以了解下<br><a href="https://developer.aliyun.com/article/573549" target="_blank" rel="noopener">在阿里，我们如何管理代码分支？</a><br><a href="https://juejin.cn/post/6875874533228838925" target="_blank" rel="noopener">字节研发设施下的 Git 工作流</a><br><a href="https://juejin.cn/post/6844903593015787534" target="_blank" rel="noopener">简介我的 Git Work Flow</a>         </p>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>从 XML 到 View 显示在屏幕上，都发生了什么?</title>
    <url>/blog/2021/07/android-view-question.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>View</code>绘制可以说是<code>Android</code>开发的必备技能，但是关于<code>View</code>绘制的的知识点也有些繁杂。<br>如果我们从头开始阅读源码，往往千头万绪，抓不住要领。<br>目前当我们写页面时，布局都是写在<code>XML</code>里的，我们可以思考下:<strong>布局从<code>XML</code>到显示到屏幕上，都发生了什么，可以分为哪几个部分?</strong><br>我们将整个显示流程分解为以下几个部分    </p>
<ol>
<li>代码是怎么从<code>XML</code>转换成<code>View</code>的?</li>
<li><code>View</code>是怎么添加到页面上的?</li>
<li>在内存中<code>View</code>到底是怎么绘制的?</li>
<li><code>View</code>绘制完成后是怎么显示到屏幕上的?</li>
</ol>
<p>本文目录如下所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/augest/p1.jpg" alt></p>
<h2 id="1-XML是怎么转换成View的？"><a href="#1-XML是怎么转换成View的？" class="headerlink" title="1. XML是怎么转换成View的？"></a>1. <code>XML</code>是怎么转换成<code>View</code>的？</h2><p>我们都知道，在<code>android</code>中写布局一般是通过<code>XML</code>，然后通过<code>setContentView</code>方法配置到页面中<br>看来<code>XML</code>转换成<code>View</code>就是在这个<code>setContentView</code>中了     </p>
<h3 id="1-1-setContentView中做了什么"><a href="#1-1-setContentView中做了什么" class="headerlink" title="1.1 setContentView中做了什么"></a>1.1 <code>setContentView</code>中做了什么</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void setContentView(int resId) &#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>resId</code>传给了我们熟悉的<code>LayoutInflater</code>,看来<code>xml</code>转化成<code>View</code>就是在<code>LayoutInflater</code>方法中实现的了</p>
<h3 id="1-2-LayoutInflater中做了什么？"><a href="#1-2-LayoutInflater中做了什么？" class="headerlink" title="1.2 LayoutInflater中做了什么？"></a>1.2 <code>LayoutInflater</code>中做了什么？</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> View inflate(<span class="meta">@LayoutRes</span> int resource, <span class="meta">@Nullable</span> ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">    <span class="comment">//预编译直接返回view,目前还未启用</span></span><br><span class="line">    View view = tryInflatePrecompiled(resource, res, root, attachToRoot);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">    XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">//真正将`XML`转化为`View`</span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也比较简单,我们一起来分析下      </p>
<ol>
<li>首先我们需要明确，将<code>XML</code>转化为<code>View</code>牵涉到一些耗时操作，比如<code>XML</code>解析是一个<code>io</code>操作，将<code>XML</code>转化为<code>View</code>涉及到反射，这也是耗时的        </li>
<li>我们可以看到在解析前有个<code>tryInflatePrecompiled</code>方法,这个方法就是希望可以在编译阶段直接预编译<code>XML</code>，在运行时直接返回构建好的<code>View</code>，看起来<code>Google</code>希望通过这种方式解决<code>XML</code>的性能问题。不过这个功能目前还没有启用，因此此方法直接返回<code>null</code>,目前生效的还是下面的方法        </li>
<li>真正将<code>XML</code>解析为<code>View</code>的还是在<code>inflate</code>方法中,将标签名转化为<code>View</code>的名称,<code>XML</code>中的各种属性转化为<code>AttributeSet</code>对象,然后通过反射生成<code>View</code>对象      </li>
</ol>
<p>由于篇幅原因，这里就不再粘贴<code>inflate</code>方法的源码了，里面主要需要注意下<code>setFactory</code>与<code>setFactory2</code>方法<br>在真正进行反射前，会先调用这两个方法尝试创建一下<code>View</code>，而且系统开放了<code>API</code>，我们可以自定义解析<code>XML</code>方式<br>这就给了我们一些面向切面编程的空间，可以利用这两个<code>API</code>实现换肤，替换字体，替换<code>View</code>,提升<code>View</code>构建速度等操作<br>希望进一步了解的同学可参考：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650820263&amp;idx=1&amp;sn=f7cbcf70570decc064fa5f05531e2c5d&amp;scene=38#wechat_redirect" target="_blank" rel="noopener">探究 LayoutInflater setFactory</a></p>
<h3 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h3><p><code>XML</code>转化为<code>View</code>转化为主要是通过<code>LayoutInflator</code>来完成的，将标签名转化为<code>View</code>的名称,<code>XML</code>中的各种属性转化为<code>AttributeSet</code>对象,然后通过反射生成<code>View</code>对象<br>这个过程中存在一些耗时操作，比如解析<code>XML</code>的<code>IO</code>操作，通过反射生成<code>View</code>等,我们可以通过多种方式优化这个过程,比如将反向的耗时转移到编译期，有兴趣的同学可以参阅:<a href="https://juejin.cn/post/6844904179048120334" target="_blank" rel="noopener">Android “退一步”的布局加载优化
</a>        </p>
<h2 id="2-View是怎么添加到页面上的"><a href="#2-View是怎么添加到页面上的" class="headerlink" title="2. View是怎么添加到页面上的?"></a>2. <code>View</code>是怎么添加到页面上的?</h2><p>经过上面这步，<code>View</code>已经被创建出来了，但是<code>View</code>又是怎么添加到页面(<code>Activity</code>)上的呢？<br>我们再来看下<code>setContentView</code>方法<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> void setContentView(int resId) &#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mAppCompatWindowCallback.getWrapped().onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LayoutInflater</code>有两个参数，第二个参数就是<code>root</code>，即创建出的<code>view</code>要被添加的父<code>view</code><br>所以答案也就呼之欲出了，创建出来的<code>view</code>被添加到了<code>contentParent</code>上，即<code>R.id.content</code>上<br>那么问题来了，这个<code>R.id.content</code>是哪来的呢？    </p>
<h3 id="2-1-R-id-content从何而来"><a href="#2-1-R-id-content从何而来" class="headerlink" title="2.1 R.id.content从何而来?"></a>2.1 <code>R.id.content</code>从何而来?</h3><p>我们看到，<code>setContentView</code>开头调用了<code>ensureSubDecor</code>方法，一起来看下它的源码<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void ensureSubDecor() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSubDecorInstalled) &#123;</span><br><span class="line">        mSubDecor = createSubDecor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ViewGroup createSubDecor() &#123;</span><br><span class="line">    <span class="comment">// Now let's make sure that the Window has installed its decor by retrieving it</span></span><br><span class="line">    ensureWindow();</span><br><span class="line">    mWindow.getDecorView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> LayoutInflater inflater = LayoutInflater.from(mContext);</span><br><span class="line">    ViewGroup subDecor = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//省略其他样式subDecor布局的实例化</span></span><br><span class="line">   <span class="comment">//包含 actionBar floatTitle ActionMode等样式</span></span><br><span class="line">   subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, <span class="literal">null</span>);</span><br><span class="line">   <span class="keyword">final</span> ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById(R.id.action_bar_activity_content);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content);</span><br><span class="line">    <span class="comment">// 把`contentView`的id设置为android.R.id.content,把windowContentView的id设置为View.NO_ID</span></span><br><span class="line">    windowContentView.setId(View.NO_ID);</span><br><span class="line">    contentView.setId(android.R.id.content);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将subDecor添加到window</span></span><br><span class="line">    mWindow.setContentView(subDecor);</span><br><span class="line">    <span class="keyword">return</span> subDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，主要工作是创建<code>subDecor</code>并添加到<code>window</code>上    </p>
<ul>
<li>步骤一：确认<code>window</code>并<code>attach</code>(设置背景等操作)</li>
<li>步骤二：获取<code>DecorView</code>，因为是第一次调用所以会<code>installDecor</code>(创建<code>DecorView</code>和<code>windowContentView</code>)</li>
<li>步骤三：从<code>xml</code>中实例化出<code>subDecor</code>布局</li>
<li>步骤四：将<code>subDecor</code>的<code>contentView</code>的<code>id</code>设置为<code>R.id.content</code></li>
<li>步骤四：将<code>subDecor</code>添加到<code>window</code>中</li>
</ul>
<p>现在我们已经知道<code>R.id.content</code>从何而来了，并且知道了<code>subDecor</code>最终会添加到<code>window</code>中<br>那么问题来了，<code>window</code>又是什么呢？</p>
<h3 id="2-2-window到底是什么？"><a href="#2-2-window到底是什么？" class="headerlink" title="2.2 window到底是什么？"></a>2.2 <code>window</code>到底是什么？</h3><p>我们上文提到，我们创建的<code>view</code>会被添加到<code>subDecor</code>上，最后会被添加到<code>window</code>中，那么<code>window</code>是什么？为什么要有<code>window</code>?    </p>
<p>我们在应用中有多个页面，手机上也有多个应用，这么多页面同时只能有一个页面显示在手机上，这个时候就需要有一个机制来管理当前显示哪个页面<br>于是<code>Android</code>在系统进程中创建了一个系统服务<code>WindowManagerService(WMS)</code>专门用来管理屏幕上的<code>窗口</code>，而<code>View</code>只能显示在对应的<code>窗口</code>上，如果不符合规定就不开辟<code>窗口</code>进而对应的<code>View</code>也无法显示      </p>
<blockquote>
<p><code>window</code>机制就是为了管理屏幕上的<code>view</code>的显示以及触摸事件的传递问题</p>
</blockquote>
<p>值得注意的事，上面的<code>window</code>与<code>窗口</code>很容易混淆，<code>Android SDK</code>中的<code>Window</code>是一个抽象类，它有一个唯一实现类<code>PhoneWindow</code>，<code>PhoneWindow</code>内部会持有一个<code>DecorView</code>(根<code>View</code>)，它的职责就是对<code>DecorView</code>做一些标准化的处理，比如标题、背景、导航栏、事件中转等，很显然与我们前面所说的窗口概念不符合        </p>
<p>总得来说<code>PhoneWindow</code>只是提供些标准的<code>UI</code>方案，与<code>窗口</code>不等价<br><code>窗口</code>是一个抽象概念，即当前应该显示哪个页面，系统通过<code>WindowManagerService(WMS)</code>来管理<br>关于<code>窗口</code>机制，想了解更加详细的同学，可参考：<a href="https://juejin.cn/post/6974696075038982152" target="_blank" rel="noopener">通俗易懂 Android视图系统的设计与实现</a>,写得非常通俗易懂，有兴趣的可以了解下      </p>
<h3 id="2-3-View什么时候真正可见"><a href="#2-3-View什么时候真正可见" class="headerlink" title="2.3 View什么时候真正可见?"></a>2.3 <code>View</code>什么时候真正可见?</h3><p>上面提到<code>PhoneWindow</code>只是提供些标准的<code>UI</code>方案，并不是真正的<code>窗口</code><br>那么我们的<code>View</code>到底什么时候添加到窗口上，什么时候真正对用户可见？       </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">#ActivityThread</span><br><span class="line">	<span class="keyword">public</span> void handleResumeActivity(...) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//注释1</span></span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//注释2</span></span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#ViewRootImpl.java</span><br><span class="line">    <span class="keyword">public</span> void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">        synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mView == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//记录DecorView</span></span><br><span class="line">                mView = view;</span><br><span class="line">                <span class="comment">//省略</span></span><br><span class="line">                <span class="comment">//开启View的三大流程（measure、layout、draw)</span></span><br><span class="line">                requestLayout();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//添加到WindowManagerService里，这里是真正添加window到底层</span></span><br><span class="line">                    <span class="comment">//这里的返回值判断window是否成功添加，权限判断等。</span></span><br><span class="line">                    <span class="comment">//比如用Application的context开启dialog，这里会添加不成功</span></span><br><span class="line">                    <span class="comment">// 注释3</span></span><br><span class="line">                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                            getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                            mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">                            mTempInsets);</span><br><span class="line">                    setFrame(mTmpFrame);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//省略</span></span><br><span class="line">                <span class="comment">//输入事件接收</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>注释1处会从<code>Activity</code>中取出<code>PhoneWindow</code>,<code>DecorView</code>,<code>WindowManager</code>      </li>
<li>注释2处调用了<code>WindowManager</code>的<code>addView</code>方法，顾名思义就是将<code>DecorView</code>添加至<code>窗口</code>当中       </li>
<li>最后会调到<code>ViewRootImpl</code>中注释3处，这里才是真正的通过<code>WMS</code>在屏幕上开辟一个窗口，到这一步我们的<code>View</code>也就可以显示到屏幕上了</li>
</ol>
<p>可以看出，当我们打开一个<code>Activity</code>时，界面真正可见是在<code>onResume</code>之后    </p>
<h3 id="2-4-Activity-PhoneWindow-View的关系"><a href="#2-4-Activity-PhoneWindow-View的关系" class="headerlink" title="2.4 Activity,PhoneWindow,View的关系"></a>2.4 <code>Activity</code>,<code>PhoneWindow</code>,<code>View</code>的关系</h3><ol>
<li><code>Phonewindow</code> 是 <code>activity</code> 的一个成员变量,会在<code>Activity.attatch</code>时初始化 </li>
<li><code>PhoneWindow</code>是<code>View</code>的容器,对<code>DecorView</code>做一些标准化的处理，比如标题、背景、导航栏、事件中转等  </li>
<li><code>Activity</code>则提供了<code>窗口</code>的生命周期,屏蔽了窗口机制的复杂细节，开发者只需要基于模板方法开发即可     </li>
</ol>
<p>如下图所示<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7443ba71659d4cd0afb9e41b3de4d145~tplv-k3u1fbpfcp-watermark.image" alt></p>
<h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p><code>View</code>添加到页面上，主要经过了这么几个过程     </p>
<ul>
<li>1.启动<code>activity</code>        </li>
<li>2.创建<code>PhoneWindow</code>         </li>
<li>3.设置布局<code>setContentView</code>,将<code>layoutId</code>转化为<code>View</code></li>
<li>4.确认<code>subDecorView</code>的初始化，将<code>subDecorView</code>添加到<code>PhoneWindow</code>中    </li>
<li>5.添加<code>layoutId</code>转化后的<code>View</code>到<code>android.R.id.content</code>上</li>
<li>6.在<code>onResume</code>中将<code>DecorViewView</code>添加到<code>WindowManager</code>中   </li>
<li>7.<code>View</code>真正显示到屏幕上了</li>
</ul>
<h2 id="3-View到底是怎么绘制的"><a href="#3-View到底是怎么绘制的" class="headerlink" title="3. View到底是怎么绘制的?"></a>3. <code>View</code>到底是怎么绘制的?</h2><p>经过上一步，<code>View</code>已经添加到<code>window</code>上了，接下来就是<code>View</code>本身的绘制了<br><code>View</code>的绘制主要经过以下几步<br>1、首先需要确定<code>View</code>占的空间尺寸(<code>measure</code>)<br>2、确定了空间尺寸，就需要确定摆放在哪个位置(<code>layout</code>)<br>3、确认了摆放位置，就需要确定在上面展示些什么东西(<code>draw</code>)       </p>
<p>这几个阶段，<code>View</code>已经封装了模板方法给我们，我们直接重写<code>onMeasure</code>,<code>onLayout</code>,<code>onDraw</code>这几个方法就好了<br>而绘制的入口，就是上面<code>ViewRootImpl.setView</code>中的<code>requestLayout</code></p>
<h3 id="3-1-requestLayout如何触发绘制"><a href="#3-1-requestLayout如何触发绘制" class="headerlink" title="3.1 requestLayout如何触发绘制"></a>3.1 <code>requestLayout</code>如何触发绘制</h3><p>上文说到<code>requestLayout</code>会触发绘制，我们一起来看下源码<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ViewRootImpl.java</span><br><span class="line">    <span class="keyword">public</span> void requestLayout() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">            <span class="comment">//检查是否是主线程，如果不是则直接抛出异常，ViewRootImpl创建的时候生成一个主线程引用</span></span><br><span class="line">            <span class="comment">//用当前线程和引用比较，如果是同一个则是主线程</span></span><br><span class="line">            <span class="comment">//这也是为什么在子线程对View进行更新、绘制会报错的原因</span></span><br><span class="line">            checkThread();</span><br><span class="line">            <span class="comment">//用来标记需要进行layout</span></span><br><span class="line">            mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//绘制请求</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void scheduleTraversals() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">            <span class="comment">//标记一次绘制请求，用来屏蔽短时间内的重复请求</span></span><br><span class="line">            mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//往主线程Looper队列里放同步屏障消息，用来控制异步消息的执行</span></span><br><span class="line">            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            <span class="comment">//放入mChoreographer队列里</span></span><br><span class="line">            <span class="comment">//主要是将mTraversalRunnable放入队列</span></span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="title">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> void run() &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void doTraversal() &#123;</span><br><span class="line">        <span class="comment">//没有取消绘制的话则开始绘制</span></span><br><span class="line">        <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//移除同步屏障</span></span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//真正开始执行measure、layout、draw等方法</span></span><br><span class="line">            performTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>requestLayout</code>中其实主要也是做了以下几件事    </p>
<ol>
<li>检查绘制的线程与<code>View</code>创建的线程是否是同一个线程        </li>
<li>通过<code>Handler</code>同步屏障机制，保证<code>UI</code>绘制消息优先级是最高的    </li>
<li>将<code>mTraversalRunnable</code>传入<code>Choreographer</code>，监听<code>vsync</code>信号。      </li>
<li>收到<code>vsync</code>信号后会回调<code>TraversalRunnable</code>,移除同步屏障并开始真正的<code>measure</code>,<code>layout</code>,<code>draw</code>         </li>
</ol>
<p><code>View</code>绘制流程图如下：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a96414811c143748bea0595e4fd63fb~tplv-k3u1fbpfcp-zoom-1.image" alt></p>
<h3 id="3-2-MeasureSpec分析"><a href="#3-2-MeasureSpec分析" class="headerlink" title="3.2 MeasureSpec分析"></a>3.2 <code>MeasureSpec</code>分析</h3><p>在测量过程中，会传入一个<code>MeasureSpec</code>参数,<code>MeasureSpec</code>封装了<code>View</code>的规格尺寸参数，包括<code>View</code>的宽高以及测量模式。<br>它的高2位代表测量模式，低30位代表尺寸。其中测量模式总共有3中。       </p>
<ul>
<li><code>UNSPECIFIED</code>：未指定模式不对子<code>View</code>的尺寸进行限制。</li>
<li><code>AT_MOST</code>：最大模式对应于<code>wrap_content</code>属性，父容器已经确定子<code>View</code>的大小，并且子<code>View</code>不能大于这个值。</li>
<li><code>EXACTLY</code>：精确模式对应于<code>match_parent</code>属性和具体的数值，子<code>View</code>可以达到父容器指定大小的值。</li>
</ul>
<p>普通<code>view</code>的<code>MeasureSpec</code>创建规则如下<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8567a71763ef4ece930b32ef8c44104e~tplv-k3u1fbpfcp-zoom-1.image" alt></p>
<p>结合这个表，我们可以一起来看一个问题<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;FrameLayout</span><br><span class="line">    android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">    android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">    android:background=<span class="string">"@android:color/red"</span></span><br><span class="line">    xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width=<span class="string">"wrap_content"</span></span><br><span class="line">        android:layout_height=<span class="string">"wrap_content"</span></span><br><span class="line">        android:background=<span class="string">"@android:color/blue"</span>/&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>请问这样一个布局，最后是什么颜色呢？<br>答案是蓝色，并且占满屏幕    </p>
<p>简单来说，当我们自定义<code>View</code> 时，如果没有对<code>MODE</code>做处理，设置<code>wrap_content</code>和<code>match_content</code>结果其实是一样的，<code>View</code> 的宽高都是取父 <code>View</code> 的宽高<br>本问题的详细解析可见：<a href="https://juejin.cn/post/6897920522828152839#heading-10" target="_blank" rel="noopener">一道滴滴面试题</a>   </p>
<h3 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h3><ol>
<li><code>View</code>的绘制需要定位，测量，绘制三个步骤，为了简化自定义<code>View</code>的过程，官方已经提供了模板方法，我们重写相关方法即可       </li>
<li><code>ViewRootImpl</code>中的<code>requestLayout</code>是绘制的入口，当然我们在<code>View</code>中调用<code>invalidate</code>或者<code>requestLayout</code>也会触发重绘         </li>
<li>绘制过程本质上也是通过<code>Handler</code>发送消息，为了提高绘制消息的优先级，会开启同步屏蔽机制    </li>
<li>将<code>mTraversalRunnable</code>传入<code>Choreographer</code>，监听<code>vsync</code>信号。注意，<code>vsync</code>信号注册了才会监听。       </li>
<li>收到<code>vsync</code>信号后会回调<code>TraversalRunnable</code>,移除同步屏障并开始真正的<code>measure</code>,<code>layout</code>,<code>draw</code>过程      </li>
<li>接下来就是回调各个<code>View</code>的<code>onMeasure</code>,<code>onLayout</code>,<code>onDraw</code>过程     </li>
</ol>
<h2 id="4-View绘制完成后是怎么显示到屏幕上的"><a href="#4-View绘制完成后是怎么显示到屏幕上的" class="headerlink" title="4 View绘制完成后是怎么显示到屏幕上的?"></a>4 <code>View</code>绘制完成后是怎么显示到屏幕上的?</h2><p>目前我们已经知道了，从<code>XML</code>到调用<code>View.onDraw</code>的过程，但是从<code>onDraw</code>到显示到屏幕上似乎还有些距离<br>我们知道，<code>View</code>最后要显示在屏幕上，<code>CPU</code>负责计算帧数据，把计算好的数据交给<code>GPU</code>，<code>GPU</code>会对图形数据进行渲染，渲染好后放到<code>buffer</code>(图像缓冲区)里存起来，然后<code>Display</code>（屏幕或显示器）负责把<code>buffer</code>里的数据呈现到屏幕上<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog3/p12.webp" alt><br>那么问题来了，<code>canvas.draw</code>是怎么转化成<code>Graphic Buffer</code>的呢？     </p>
<p>其大概流程如图所示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d4108a9971b4b57928d7835236e300e~tplv-k3u1fbpfcp-zoom-1.image" alt><br>可以看出，这个过程还是相当复杂的，由于篇幅原因，这里就不展开了，感兴趣的同学可以参阅苍耳叔叔的系列文章：<a href="https://juejin.cn/post/6898525503960186887" target="_blank" rel="noopener">Android图形系统综述(干货篇)</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从<code>XML</code>到<code>View</code>显示到屏幕上主要涉及到以下知识点     </p>
<ol>
<li><code>Activity</code>的启动    </li>
<li><code>LayoutInflater</code>填充<code>View</code>的原理   </li>
<li><code>PhoneWindow</code>,<code>Activity</code>,<code>View</code>的关系    </li>
<li><code>Android</code>窗口机制与<code>WindowManagerService</code>管理窗口     </li>
<li><code>View</code>的绘制流程，<code>measure</code>,<code>layout</code>,<code>draw</code>等与<code>Handler</code>同步屏障机制        </li>
<li><code>Android</code>屏幕刷新机制,<code>VSync</code>信号监听，三级缓冲等      </li>
<li><code>Android</code>图形绘制，包括<code>SurfaceFinger</code>工作流程，软件绘制，硬件加速等     </li>
</ol>
<p>这篇文章其实已经比较长了，但是要完全了解从<code>XML</code>到显示到屏幕上的过程，还是不够详细，有很多地方只做了简述，如果有什么错误或者需要补充的地方，欢迎在评论区提出<br>由于篇幅原因，有一些知识点没有写得很详细，下面列出一些更好的文章供参考：<br><code>Android</code>窗口机制：<a href="https://juejin.cn/post/6974696075038982152" target="_blank" rel="noopener">通俗易懂 Android视图系统的设计与实现</a><br><code>Android</code>屏幕刷新机制： <a href="https://juejin.cn/post/6863756420380196877" target="_blank" rel="noopener">“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！</a><br><code>Android</code>图形系统: <a href="https://juejin.cn/post/6898525503960186887" target="_blank" rel="noopener">Android图形系统综述(干货篇)</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6989428675196223525" target="_blank" rel="noopener">【Android进阶】这一次把View绘制流程刻在脑子里！！</a><br><a href="https://www.jianshu.com/p/7e260b7890a3" target="_blank" rel="noopener">Android Activity创建到View的显示过程</a>         </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【译】Google 是怎么设计一个 API 的,了解一下~</title>
    <url>/blog/2021/08/desin-api-story.html</url>
    <content><![CDATA[<blockquote>
<p>原标题: repeatOnLifecycle API design story<br>原文地址: <a href="https://medium.com/androiddevelopers/repeatonlifecycle-api-design-story-8670d1a7d333" target="_blank" rel="noopener">repeatOnLifecycle API design story</a><br>原文作者：Manuel Vivo</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，<code>Google</code>发布一个新的<code>Library</code>都要经历<code>alpha</code>,<code>beta</code>,<code>rc</code>,<code>release</code>等多个版本的迭代<br>在这个漫长的迭代过程中，通常会有<code>Bug</code>的修复，代码与功能的增删等等，哪些代码应该该增加，哪些代码应该删除，这就是考验设计者的地方        </p>
<p>本文主要讲述了<code>Google</code>在设计及迭代<code>repeatOnLifecycle API</code>过程中的设计与决策<br><code>repeatOnLifecycle</code>主要用于在<code>UI</code>中收集<code>flow</code>,关于它的用法可见：<a href="https://juejin.cn/post/6984258307293151239" target="_blank" rel="noopener">使用更为安全的方式收集 Android UI 数据流</a>    </p>
<p>通过本文你将了解以下内容:   </p>
<ol>
<li><code>repeatOnLifecycle API</code>背后的设计决策     </li>
<li>为什么<code>alpha</code>版本中添加的<code>addRepeatingJob API</code>会被移除?      </li>
<li>为什么<code>flowWithLifecycle API</code>会被保留?    </li>
<li>为什么<code>API</code>命名是重要且困难的     </li>
<li>为什么只保留库中最基础的几个 <code>API</code>。      </li>
</ol>
<h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><h3 id="repeatOnLifecycle介绍"><a href="#repeatOnLifecycle介绍" class="headerlink" title="repeatOnLifecycle介绍"></a><code>repeatOnLifecycle</code>介绍</h3><p><code>Lifecycle.repeatOnLifecycle API</code>主要是为了在<code>UI</code>层进行更安全的<code>Flow</code>收集<br>比如<code>lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED)</code>,会在<code>onStart</code>时启动协程，在<code>onStop</code>时取消协程<br>然后在<code>Activity</code>重新回到<code>onStart</code>时重新启动一个协程        </p>
<p>这种特性与<code>UI</code>生命周期的可重启性比较契合，让它成为仅当<code>UI</code>可见时才收集<code>flow</code>的完美默认<code>API</code>      </p>
<ol>
<li><code>repeatOnLifecycle</code> 是一个挂起函数,<code>repeatOnLifecycle</code> 会挂起调用协程              </li>
<li>每次给定的生命周期达到目标状态或更高时,都会启动一个新的协程,运行传入的<code>block</code>      </li>
<li>如果生命周期状态低于目标，则为块启动的协程将被取消。 </li>
<li>最后，在生命周期被销毁之前，<code>repeatOnLifecycle</code> 函数本身不会恢复调用协程。        </li>
</ol>
<p>下面来看一下这个<code>API</code>的示例，关于它的用法更详细的介绍可见：<a href="https://juejin.cn/post/6984258307293151239" target="_blank" rel="noopener">使用更为安全的方式收集 Android UI 数据流</a><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocationActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从lifecycleScope创建一个新的协程</span></span><br><span class="line">        <span class="comment">// 因为repeatOnLifecycle 是一个挂起函数</span></span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            <span class="comment">// 阻塞协程，直到生命周期到达DESTOYED</span></span><br><span class="line">			<span class="comment">// repeatOnLifecycle会在每次生命周期处于 STARTED 状态（或更高状态）时，启动一个新的协程运行传入的block</span></span><br><span class="line">			<span class="comment">// 并在 STOPPED 时取消协程。</span></span><br><span class="line">            repeatOnLifecycle(Lifecycle.State.STARTED) &#123;</span><br><span class="line">                <span class="comment">// 安全的collect flow当生命周期到达STARTED</span></span><br><span class="line">                <span class="comment">// 当生命周期到达STOPPED 时停止collect</span></span><br><span class="line">                someLocationProvider.locations.collect &#123;</span><br><span class="line">                    <span class="comment">// 收集到新的位置，更新UI</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意，当运行到这的时候，说明lifecycle已经是DESTROYED</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你对<code>repeatOnLifecycle</code>是怎么实现的感兴趣，可以查看源码：<a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/RepeatOnLifecycle.kt" target="_blank" rel="noopener">repeatOnLifecycle源码</a>   </p>
<h3 id="为什么repeatOnLifecycle是挂起函数"><a href="#为什么repeatOnLifecycle是挂起函数" class="headerlink" title="为什么repeatOnLifecycle是挂起函数?"></a>为什么<code>repeatOnLifecycle</code>是挂起函数?</h3><p>针对<code>repeatOnLifecycle</code>可重启的特性，挂起函数是最佳选择       </p>
<ol>
<li>因为它保留了调用的上下文，即<code>CoroutineContext</code>      </li>
<li>同时<code>repeatOnLifecycle</code>内部使用了<code>suspendCancellableCoroutine</code>,因此它支持取消，当取消协程时，<code>repeatOnLifecycle</code>与它的子协程都会被取消        </li>
</ol>
<p>此外，我们可以在<code>repeatOnLifecycle</code>之上扩展更多<code>API</code>，例如<code>Flow.flowWithLifecycle</code>流操作符。<br>更重要的是，如果您的项目需要，它还允许您在此<code>API</code>基础上扩展封装辅助函数.这就是我们尝试使用<code>LifecycleOwner.addRepeatingJob API</code>做的事情<br>我们在 <code>lifecycle-runtime-ktx:2.4.0-alpha01</code> 中添加了该 <code>API</code>，但是在<code>alpha02</code>中删除了该<code>API</code>。            </p>
<h3 id="为什么移除addRepeatingJob-API"><a href="#为什么移除addRepeatingJob-API" class="headerlink" title="为什么移除addRepeatingJob API?"></a>为什么移除<code>addRepeatingJob API</code>?</h3><p><code>LifecycleOwner.addRepeatingJob API</code>在<code>alpha01</code>中添加，但是在<code>alpha02</code>中被移除了<br>为什么呢？我们先来看看实现<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> LifecycleOwner.<span class="title">addRepeatingJob</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    state: <span class="type">Lifecycle</span>.<span class="type">State</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    coroutineContext: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Job = lifecycleScope.launch(coroutineContext) &#123;</span><br><span class="line">    repeatOnLifecycle(state, block)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出代码很简单，本质上就是对<code>repeatOnLifecycle</code>的封装，传入<code>state</code>与<code>block</code>就能实现与<code>repeatOnLifecycle</code>同样的效果<br>之所以引入这个<code>API</code>是为了简化调用方式，一起看下代码:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocationActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleOwner.addRepeatingJob(Lifecycle.State.STARTED) &#123;</span><br><span class="line">            someLocationProvider.locations.collect &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>乍一看，您可能认为这段代码更简洁，需要的代码更少。 但是，如果您不密切注意，使用这个<code>API</code>会带来一些隐藏的陷阱          </p>
<ul>
<li>尽管<code>addRepeatingJob</code>需要传入一个挂起的<code>block</code>，但<code>addRepeatingJob</code>不是挂起函数。 因此，你不应该在协程中调用它！！！    </li>
<li>再来看收益，您只节省了一行代码，代价是拥有了一个更容易出错的<code>API</code>。    </li>
</ul>
<p>第一点可能有些同学会奇怪，为什么不应该在协程中调用非挂起函数？<br>实际上是因为协程最核心的概念之一:<a href="https://elizarov.medium.com/structured-concurrency-722d765aa952" target="_blank" rel="noopener">结构化并发</a>          </p>
<h4 id="什么是结构化并发？"><a href="#什么是结构化并发？" class="headerlink" title="什么是结构化并发？"></a>什么是结构化并发？</h4><p>要了解结构化并发，我们先来看看线程，线程的并发是非结构化的<br>可以想想这几个问题在线程中要怎么解决：<br>1.结束一个线程时，怎么同时结束这个线程中创建的子线程？<br>2.当某个子线程在执行时需要结束兄弟线程要做怎么做？<br>3.如何等待所有子线程都执行完了再结束父线程？               </p>
<p>当然这些问题，都可以通过共享标记位等方式解决，但是这几个问题说明，线程间没有级联关系；<br>所有线程执行的上下文都是整个进程，多个线程的并发是相对整个进程的，而不是相对某一个父线程。<br>这就是线程并发的「非结构化」。    </p>
<p><strong>但与此同时，业务的并发通常是结构化的</strong><br>通常，每个并发操作都是在处理一个任务单元，这个任务单元可能属于某个父任务单元，同时它也可能有子任务单元。<br>而每个任务单元都有自己的生命周期，子任务的生命周期理应继了父任务的生命周期。<br>这就是业务的「结构化」。   </p>
<p>因此协程中引入结构化并发的概念，在结构化并发中，每个并发操作都有自己的作用域，并且：<br>1.在父作用域内新建作用域都属于它的子作用域；<br>2.父作用域和子作用域具有级联关系；<br>3.父作用域的生命周期持续到所有子作用域执行完；<br>4.当主动结束父作用域时，会级联结束它的各个子作用域。      </p>
<p><code>Kotlin</code>的协程就是结构化的并发，它有 「协程作用域(<code>CoroutineScope</code>)」 的角色。<br>全局的 <code>GlobalScope</code> 是一个作用域，每个协程自身也是一个作用域。新建的协程对象和父协程保持着级联关系。      </p>
<p>关于结构化并发的更多内容可见：<a href="https://www.jianshu.com/p/3dc8ba43c28b" target="_blank" rel="noopener">什么是 结构化并发 ？</a></p>
<h4 id="addRepeatingJob的问题"><a href="#addRepeatingJob的问题" class="headerlink" title="addRepeatingJob的问题"></a><code>addRepeatingJob</code>的问题</h4><p><code>addRepeatingJob</code>不是挂起函数，因此默认情况下不支持结构化并发<br>由于<code>block</code>参数是一个挂起的<code>lambda</code>，您很容易将此<code>API</code>与协程相关联，您可以轻松编写如下危险代码：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocationActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> job = lifecycleScope.launch &#123;</span><br><span class="line"></span><br><span class="line">            doSomeSuspendInitWork()            </span><br><span class="line">            <span class="comment">// 危险的！ 此 API 没有保留调用上下文！</span></span><br><span class="line">			<span class="comment">// 当父协程被取消时它不会被取消！</span></span><br><span class="line">            addRepeatingJob(Lifecycle.State.STARTED) &#123;</span><br><span class="line">                someLocationProvider.locations.collect &#123;</span><br><span class="line">                    <span class="comment">// 更新ui</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果发生错误，取消上面启动的协程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(t: Throwable) &#123;</span><br><span class="line">            job.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码有什么问题？ <code>addRepeatingJob</code> 是处理协程相关的东西，没有什么能阻止我在协程中调用它，对吧？         </p>
<p>因为<code>addRepeatingJob</code>不是挂起函数，在内部实现中会调用<code>lifecycleScope</code>来启动一个新的协程<br>因此不会保留调用协程的上下文，也不支持结构化并发，即当调用<code>job.cancel()</code>时不会取消<code>addRepeatingJob</code>中创建的协程<br>这是非常不符合预期的，也很容易导致难以调试的不可预知的<code>BUG</code>    </p>
<p>在<code>addRepeatingJob</code>内部隐式调用了<code>CoroutineScope</code>，导致这个<code>API</code>在某些情况下使用是不安全的。<br>用户如果要正确使用这个<code>API</code>，还需要了解一下额外的知识，这是不可接收的，这也是移除这个<code>API</code>的原因      </p>
<p>而<code>repeatOnLifecycle</code>的主要好处在于它默认支持结构化并发，它还可以帮助您思考您希望重复工作在哪个生命周期内发生。 <code>API</code>一目了然，符合开发人员的期望      </p>
<h3 id="为什么保留Flow-flowWithLifecycle"><a href="#为什么保留Flow-flowWithLifecycle" class="headerlink" title="为什么保留Flow.flowWithLifecycle?"></a>为什么保留<code>Flow.flowWithLifecycle</code>?</h3><p><code>Flow.flowWithLifecycle</code> 运算符构建在<code>repeatOnLifecycle</code>之上<br>并且仅在生命周期至少处于<code>minActiveState</code>时才发出上游流发送的元素,当生命周期低于<code>minActiveState</code>会取消上游流<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocationActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            someLocationProvider.locations</span><br><span class="line">                .flowWithLifecycle(lifecycle, STARTED)</span><br><span class="line">                .collect &#123;</span><br><span class="line">                    <span class="comment">//更新UI</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尽管这个<code>API</code>也有一些隐式的需要注意的问题，但我们决定保留它，因为它作为一个<code>Flow</code>操作符很实用。<br>例如，它可以轻松地用于<code>Jetpack Compose</code>。尽管您可以通过使用<code>produceState</code> 和<code>repeatOnLifecycle API</code> 在<code>Compose</code> 中实现相同的功能,我们将此<code>API</code> 保留在库中，作为一个替代方案。     </p>
<p><code>flowWithLifecycle</code>需要注意的问题是，添加<code>flowWithLifecycle</code>运算符的顺序很重要。<br>当生命周期低于<code>minActiveState</code>时，在<code>flowWithLifecycle</code>运算符之前添加的运算符将被取消。<br>但是，即使没有发送任何元素，在<code>flowWithLifecycle</code>之后添加的运行符也不会被取消。     </p>
<p>因此，这个<code>API</code>命名参照了<code>Flow.flowOn(CoroutineContext)</code>运算符<br>因为此<code>API</code>更改了用于收集上游流的<code>CoroutineContext</code>，同时使下游不受影响，与<code>flowOn</code>类似。     </p>
<h3 id="我们应该添加更多的API吗？"><a href="#我们应该添加更多的API吗？" class="headerlink" title="我们应该添加更多的API吗？"></a>我们应该添加更多的<code>API</code>吗？</h3><p>鉴于我们已经拥有了<code>Lifecycle.repeatOnLifecycle</code>、<code>LifecycleOwner.repeatOnLifecycle</code> 和 <code>Flow.flowWithLifecycle API</code>。<br>我们还应该添加任何其他<code>API</code>吗？      </p>
<p>新<code>API</code>可能会带来与它们解决的问题一样多的混乱。支持不同用例的方式有多种，最好的方式取决于你的业务代码是怎样的.对您的项目有效的方法可能对其他人无效。     </p>
<p>这就是为什么我们不想为所有可能的情况提供<code>API</code>，可用的 <code>API</code> 越多，开发人员就越不知道何时使用什么。<br>因此，我们决定只保留最底层的 <code>API</code>。有时，<strong>少即是多</strong>。      </p>
<h3 id="API命名是重要且困难的"><a href="#API命名是重要且困难的" class="headerlink" title="API命名是重要且困难的"></a><code>API</code>命名是重要且困难的</h3><p><code>API</code>命名是重要的，命名应符合开发人员的期望并遵循<code>Kotlin</code>协程的约定。例如：      </p>
<ul>
<li>如果<code>API</code>中隐式地使用<code>CoroutineScope</code>启动新的协程，则必须在名称中反映出来，以避免错误的期望！在这种情况下，<code>launch</code> 应该以某种方式包含在命名中。      </li>
<li><code>collect</code>是一个挂起函数。如果<code>API</code>不是挂起函数，则不要在<code>API</code>命名中加上<code>collect</code>。        </li>
</ul>
<p><code>LifecycleOwner.addRepeatingJob API</code>也很难命名。<code>API</code>内部使用<code>CoroutineScope</code>创建新的协程时，看起来它应该以<code>launch</code> 为前缀。<br>但是，我们想将此<code>API</code>与内部的协程分离开来，同时因为它添加了一个新的<code>Lifecycle Observer</code>，因此命名与其他<code>LifecycleOwner API</code>更加一致。       </p>
<p>命名也受到现有的<code>LifecycleCoroutineScope.launchWhenX API</code>的影响。<br>因为<code>launchWhenStarted</code>和<code>repeatOnLifecycle(STARTED)</code>提供完全不同的功能（<code>launchWhenStarted</code>挂起协程的执行，而<code>repeatOnLifecycle</code>取消并重新启动一个新的协程）<br>如果新<code>API</code>的名称相似（例如，使用<code>launchWhenever</code>作为重新启动的<code>API</code>） ，开发人员可能会感到困惑，甚至在没有注意到的情况下混淆使用它们。    </p>
<h3 id="一行代码实现flow收集"><a href="#一行代码实现flow收集" class="headerlink" title="一行代码实现flow收集"></a>一行代码实现<code>flow</code>收集</h3><p>目前的收集方法还是有些烦琐的，如果你是从<code>LiveData</code>迁移到<code>Flow</code>,你可能会觉得要是可以一行代码实现<code>collect</code>就好了<br>这样你就可以删除模板代码，并且使迁移变得简单     </p>
<p>因此，您可以像<a href="https://twitter.com/ianhlake" target="_blank" rel="noopener">Ian Lake</a>刚开始使用<code>repeatOnLifecycle API</code> 时所做的那样。<br>他创建了一个名为<code>collectIn</code>的包装器，如下所示（为了遵循上面讨论的命名约定，我将其重命名为<code>launchAndCollectIn</code>）：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">launchAndCollectIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    owner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    minActiveState: <span class="type">Lifecycle</span>.<span class="type">State</span> = Lifecycle.State.STARTED,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">crossinline</span> action: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.(<span class="type">T</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> = owner.lifecycleScope.launch &#123;</span><br><span class="line">        owner.repeatOnLifecycle(minActiveState) &#123;</span><br><span class="line">            collect &#123;</span><br><span class="line">                action(it)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后你可以在<code>UI</code>中这样使用<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocationActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        someLocationProvider.locations.launchAndCollectIn(<span class="keyword">this</span>, STARTED) &#123;</span><br><span class="line">            <span class="comment">// 更新UI</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个包装器在这个例子中看起来很好很简单，但遇到了我们之前提到的<code>LifecycleOwner.addRepeatingJob</code>相同的问题。它不支持结构化并发，在其他协程中使用可能很危险。<br>此外，原来的名称确实具有误导性：<code>collectIn</code>不是挂起函数！如前所述，开发人员预期<code>collect</code>会挂起。<br>也许，这个包装器的更好名称可能是<code>Flow.launchAndCollectIn</code> 以防止不良用法。   </p>
<h3 id="你需要一个API包装器吗？"><a href="#你需要一个API包装器吗？" class="headerlink" title="你需要一个API包装器吗？"></a>你需要一个<code>API</code>包装器吗？</h3><p>如果您需要在<code>repeatOnLifecycle API</code>之上创建包装器来方便开发，请问问自己是否真的需要它，以及为什么需要它。<br>如果你确信需要，我建议你选择一个非常明确的<code>API</code>命名来清楚地定义包装器的行为，以避免误用。此外，要非常清楚地记录它，以便新手可以完全理解使用它的含义。      </p>
<h2 id="阅读源码的小技巧"><a href="#阅读源码的小技巧" class="headerlink" title="阅读源码的小技巧"></a>阅读源码的小技巧</h2><p>当我们查看源码的时候，已经是<code>API</code>完成的状态了，其实我们可以查看<code>API</code>迭代开发过程的源码，看看在迭代过程中都发生了什么，这些都是开源的<br>比如<code>repeatOnLifecycle API</code>是在<code>lifecycle-runtime-ktx</code>库中，我们可以看下它的<code>git log</code>,<a href="https://android.googlesource.com/platform/frameworks/support/+log/refs/changes/92/1684192/10/lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle" target="_blank" rel="noopener">lifecycle-runtime-ktx库git历史</a>如下图所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/augest/p2.jpg" alt><br>从上面我们可以看出<code>repeatOnLifecycle</code>功能是怎样一步一步被引入并修改的    </p>
<p>我们甚至可以看看代码的<code>review</code>过程，看看<code>reviewr</code>有提出什么意见,比如<a href="https://android-review.googlesource.com/c/platform/frameworks/support/+/1684192" target="_blank" rel="noopener">addRepeatingJob Review过程</a>如下图所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/augest/p3.jpg" alt>  </p>
<p>通过查看功能引入的<code>git log</code>，我们可以学习<code>Google</code>是怎么一步一步引入一个新功能并迭代的，相信对我们学习或者开发<code>API</code>都有所帮助    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要讲解了<code>repeatOnLifecycle API</code>在开发与迭代过程中的一些设计与思考，总结如下：   </p>
<ol>
<li><code>API</code>决策通常需要在复杂性、可读性以及<code>API</code>容易出错的程度方面进行一些权衡思考    </li>
<li>之所以移除<code>addRepeatingJob API</code>是因为它不支持结构化并发，在协程中使用可能会带来不可预期的错误     </li>
<li><code>API</code>命名是重要且困难的，命名应符合开发人员的期望并遵循原有<code>API</code>的规范    </li>
<li>我们不可能为所有情况提供<code>API</code>, 可用的<code>API</code> 越多，开发人员反倒不知道何时使用什么,因此我们只需保留最底层的<code>API</code>，有时少就是多    </li>
<li>我们可以通过查看新<code>API</code>引入的<code>git log</code>，来学习理解新<code>API</code>的引入与迭代过程        </li>
</ol>
<p>更文不易，如果本文对你有所帮助，欢迎点赞收藏~      </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识点】Http协议8连问</title>
    <url>/blog/2021/08/know-http-sum.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Http</code>协议是我们开发中的必备知识，也是面试中的常客<br>本文从几个问题出发梳理<code>Http</code>相关知识点，以便快速构建<code>Http</code>知识体系，如果对你有用，欢迎点赞~      </p>
<p>本文主要包括以下内容    </p>
<ol>
<li><code>Http</code>到底是什么？    </li>
<li><code>Http</code>协议为什么是无状态的?</li>
<li>什么是队头阻塞问题?</li>
<li><code>GET</code>,<code>POST</code>,<code>PUT</code>等方法有什么区别？</li>
<li>为什么引入<code>Https</code>?</li>
<li>为什么引入<code>Http2.0</code>?</li>
<li>为什么引入<code>Http3.0</code>?</li>
<li>浏览器输入<code>url</code>后发生了什么?       </li>
</ol>
<p>本文目录如下所示<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/augest/p10.png" alt></p>
<h2 id="1-Http到底是什么"><a href="#1-Http到底是什么" class="headerlink" title="1. Http到底是什么?"></a>1. <code>Http</code>到底是什么?</h2><p><code>Http</code>翻译过来就是超文本传输协议，它的主要作用就是在客户端与服务端之间进行通信<br>我们平常在浏览器查看网页时就用到了<code>Http</code>协议，根据浏览器地址栏中指定的<code>URL</code>，<code>Web</code>浏览器从<code>Web</code>服务器端获取文件资源（<code>resource</code>）等信息，从而显示出 <code>Web</code> 页面。        </p>
<p><code>Http</code>协议主要具有以下特点    </p>
<ul>
<li>无连接：每一次请求都要连接一次，请求结束就会断掉，不会保持连接</li>
<li>无状态：每一次请求都是独立的，请求结束不会记录连接的任何信息，减少了网络开销，这是优点也是缺点</li>
<li>灵活：通过<code>http</code>协议中头部的<code>Content-Type</code>标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活</li>
<li>简单快速：发送请求访问某个资源时，只需传送请求方法和<code>URL</code>就可以了，使用简单，正由于<code>http</code>协议简单，使得<code>http</code>服务器的程序规模小，因而通信速度很快  </li>
</ul>
<p>当然<code>Http</code>协议也有一些缺点       </p>
<ul>
<li>无状态：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</li>
<li>明文传输：<code>Http</code>报文使用明文传输，如果在通信的过程中存在中间人，可以轻易的获取请求的所有内容      </li>
<li>队头阻塞：当开启长连接时，多个<code>Http</code>请求复用一个<code>TCP</code>连接，同一时刻只能处理一个请求，那么当前面的请求耗时过长时，其他请求就只能处于阻塞状态</li>
</ul>
<h2 id="2-Http协议为什么是无状态的"><a href="#2-Http协议为什么是无状态的" class="headerlink" title="2. Http协议为什么是无状态的?"></a>2. <code>Http</code>协议为什么是无状态的?</h2><p>上面我们介绍了<code>Http</code>协议是无状态的，即每次请求都是独立的，服务端中不保存客户端的状态<br>因此为了区分用户的身份，我们需要每次都在<code>Header</code>中携带身份信息(比如<code>Cookie</code>)，这样其实导致了每次连接传送的数据量变大了不少。        </p>
<p><strong>那么为什么<code>Http</code>要这样设计呢？</strong>      </p>
<ol>
<li><code>http</code>最初设计成无状态的是因为只是用来浏览静态文件的，无状态协议已经足够，也没什么其他的负担。          </li>
<li>随着<code>web</code>的发展，它需要变得有状态，但是不是就要修改<code>http</code>协议使之有状态呢？是不需要的。因为我们经常长时间逗留在某一个网页，然后才进入到另一个网页，如果在这两个页面之间维持状态，代价是很高的。     </li>
<li>其次，老版本<code>http</code>是无状态的，但是现在对<code>http</code>提出了新的要求，按照软件领域的通常做法是，兼容历史版本，在<code>http</code>协议上再加上一层实现我们的目的。所以引入了<code>cookie</code>、<code>session</code>等机制来实现这种有状态的连接。      </li>
<li>同时，保存用户状态是一个很复杂的过程，而<code>Http</code>协议为了更快地处理大量事务，确保协议的可伸缩性，故意把<code>HTTP</code>协议设计的比较简单。因此没有必要在<code>Http</code>协议中引入状态管理     </li>
</ol>
<h2 id="3-什么是队头阻塞问题"><a href="#3-什么是队头阻塞问题" class="headerlink" title="3. 什么是队头阻塞问题?"></a>3. 什么是队头阻塞问题?</h2><p><code>Http1.0</code>是无连接的，即每个请求/应答客户与服务器都要新建一个连接，完成之后立即断开连接<br>在<code>Http1.1</code>中引入了<code>Keep-Alive</code>支持长连接，即多个<code>Http</code>请求复用一个<code>TCP</code>连接,如下图所示：    </p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c244fcd0478b4cacaa0a147c24290a8a~tplv-k3u1fbpfcp-watermark.awebp" alt><br>如上所示，使用长连接，可以减少<code>TCP</code>握手时间，提高请求速度<br>但是在长连接下同样<code>Http</code>协议同样会有队头阻塞问题，因为我们虽然可以复用<code>TCP</code>连接，但<code>Http</code>请求仍然是串行的       </p>
<blockquote>
<p>请求1 -&gt; 响应1 -&gt; 请求2 -&gt; 响应2 -&gt; 请求3 -&gt; 响应3</p>
</blockquote>
<p>如上所示，就是这样一个先进先出的串行队列，没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求最先处理，就导致如果队首的请求耗时过长，后面的请求就只能处于阻塞状态，这就是队头阻塞问题<br>当然我们也可以通过一些方式缓解这个问题    </p>
<ol>
<li>一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务。现在的浏览器标准中一个域名并发连接可以有<code>6~8</code>个(<code>Chrome</code>6个/<code>Firefox</code>8个)          </li>
<li>一个域名最多可以并发<code>6~8</code>个,那我们可以使用多个二级域名，当我们访问服务端时，可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器，这样能够并发更多的长连接了，从而减少队头阻塞     </li>
</ol>
<h2 id="4-GET-POST-PUT等方法有什么区别？"><a href="#4-GET-POST-PUT等方法有什么区别？" class="headerlink" title="4. GET,POST,PUT等方法有什么区别？"></a>4. <code>GET</code>,<code>POST</code>,<code>PUT</code>等方法有什么区别？</h2><h3 id="4-1-GET与POST的区别"><a href="#4-1-GET与POST的区别" class="headerlink" title="4.1 GET与POST的区别"></a>4.1 <code>GET</code>与<code>POST</code>的区别</h3><ol>
<li><code>GET</code> 用于获取信息，是无副作用的，是幂等的，且可缓存.          </li>
<li><code>POST</code> 用于修改服务器上的数据，有副作用，非幂等，不可缓存          </li>
</ol>
<p>其实<code>GET</code>与<code>POST</code>的区别主要就是这些，网上有些文章说<code>GET</code>的<code>URL</code>长度有限制，<code>HTTP</code> 协议没有<code>Body</code> 和 <code>URL</code> 的长度限制，对 <code>URL</code> 限制的大多是浏览器和服务器的原因。<br>浏览器原因就不说了，服务器是因为处理长<code>URL</code>要消耗比较多的资源，为了性能和安全（防止恶意构造长<code>URL</code>来攻击）考虑，会给<code>URL</code>长度加限制。</p>
<h3 id="4-2-PUT与POST的区别"><a href="#4-2-PUT与POST的区别" class="headerlink" title="4.2 PUT与POST的区别"></a>4.2 <code>PUT</code>与<code>POST</code>的区别</h3><p>有人说,<code>PUT</code>与<code>POST</code>的区别在于<code>POST</code>是用来创建数据的,<code>PUT</code>是用来更新数据的.<br>其实<code>PUT</code>与<code>POST</code>都能创建数据，它们的主要区别是<code>PUT</code>是幂等的，而<code>POST</code>不是幂等的<br>因此<code>PUT</code>能用于更新数据，也能用于创建数据，而<code>POST</code>只能用于创建数据     </p>
<p>如果<code>POST</code>两条相同的数据，则会创建两条数据<br>而<code>PUT</code>两条相同的数据，则只会创建一条数据    </p>
<h2 id="5-为什么引入Https"><a href="#5-为什么引入Https" class="headerlink" title="5. 为什么引入Https?"></a>5. 为什么引入<code>Https</code>?</h2><p>上面说到了<code>HTTP</code>是明文传输的，在安全方面主要有以下缺点     </p>
<ol>
<li><code>Http</code>通信使用明文（不加密），内容可能会被窃听        </li>
<li>不验证通信方的身份，因此有可能遭遇伪装           </li>
<li>无法证明报文的完整性，所以有可能已遭篡改       </li>
</ol>
<p>正因此才推出了<code>Https</code>协议来保证<code>Client</code>和<code>Server</code>交流的信息不能被其它第三方窃听及防止篡改与伪装            </p>
<p><code>Https</code>通信的主要过程如图所示:<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02d2699f4cd84c849d61c3bfe64de16a~tplv-k3u1fbpfcp-watermark.awebp" alt><br>主要做了以下几件事<br>1.客户端&amp;服务端通信，协商加密方式<br>2.客户端(<code>Client</code>)和服务端(<code>Server</code>)互相确认身份<br>3.双方安全地交换<code>https</code>通信使用的密钥（<code>Session Key</code>）     </p>
<p><code>Https</code>加密的具体流程比较复杂，里面还涉及到证书链校验，中间人攻击等知识点<br>我之前总结过一篇文章，这里就不缀述了，有兴趣的同学可以了解下:<a href="https://juejin.cn/post/6880024440143347719" target="_blank" rel="noopener">Android程序员需要了解的https与中间人攻击</a></p>
<h2 id="6-为什么引入Http2-0"><a href="#6-为什么引入Http2-0" class="headerlink" title="6. 为什么引入Http2.0?"></a>6. 为什么引入<code>Http2.0</code>?</h2><p>上面我们已经介绍了<code>Http</code>协议的主要缺点<br>1.请求 / 响应头部（<code>Header</code>）未经压缩就发送，首部信息越多延迟越大。<br>2.发送冗长的首部。每次互相发送相同的首部造成的浪费较多；<br>3.服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；<br>4.没有请求优先级控制；<br>5.请求只能从客户端开始，服务器只能被动响应             </p>
<p><code>Http2.0</code>正是为了解决以上问题才被引入的,相比<code>Http1.1</code>,<code>Http2.0</code>主要有以下改进     </p>
<h3 id="6-1-头部压缩"><a href="#6-1-头部压缩" class="headerlink" title="6.1 头部压缩"></a>6.1 头部压缩</h3><p><code>HTTP/2</code> 会压缩头（<code>Header</code>）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。           </p>
<p>这就是所谓的<code>HPACK</code>算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了</p>
<h3 id="6-2-多路复用"><a href="#6-2-多路复用" class="headerlink" title="6.2 多路复用"></a>6.2 多路复用</h3><h4 id="6-2-1-二进制分帧"><a href="#6-2-1-二进制分帧" class="headerlink" title="6.2.1 二进制分帧"></a>6.2.1 二进制分帧</h4><p><code>HTTP/2</code> 不再像<code>HTTP/1.1</code>里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（<code>frame</code>）：头信息帧和数据帧。<br><img src="https://pic1.zhimg.com/80/v2-0d9d34d1a916a84e8780dd76e5654ee0_720w.jpg" alt><br>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率     </p>
<h4 id="6-2-2-多路复用解决队头阻塞"><a href="#6-2-2-多路复用解决队头阻塞" class="headerlink" title="6.2.2 多路复用解决队头阻塞"></a>6.2.2 多路复用解决队头阻塞</h4><p>原来<code>Headers + Body</code>的报文格式如今被拆分成了一个个二进制的帧，用<code>Headers</code>帧存放头部字段，<code>Data</code>帧存放请求体数据。<br>分帧之后，服务器看到的不再是一个个完整的 <code>HTTP</code> 请求报文，而是一堆乱序的二进制帧。            </p>
<p>通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做流(<code>Stream</code>)。<br><code>HTTP/2</code> 用流(<code>Stream</code>)来在一个 <code>TCP</code> 连接上来进行多个数据帧的通信，这就是多路复用的概念。<br>这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 <code>HTTP</code> 的队头阻塞问题。            </p>
<p>举例来说，在一个 <code>TCP</code> 连接里，服务器收到了客户端 <code>A</code> 和 <code>B</code> 的两个请求，如果发现 <code>A</code> 处理过程非常耗时，于是就回应 <code>A</code> 请求已经处理好的部分，接着回应 <code>B</code> 请求，完成后，再回应 <code>A</code> 请求剩下的部分。<br><img src="https://pic4.zhimg.com/80/v2-c4a1ea4b9ac0045921360e11f68e6837_720w.jpg" alt></p>
<h3 id="6-5-服务器推送"><a href="#6-5-服务器推送" class="headerlink" title="6.5 服务器推送"></a>6.5 服务器推送</h3><p><code>HTTP/2</code> 还在一定程度上改善了传统的<code>「请求 - 应答」</code>工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</p>
<p>举例来说，在浏览器刚请求 <code>HTML</code> 的时候，就提前把可能会用到的 <code>JS</code>、<code>CSS</code> 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送</p>
<h2 id="7-为什么引入Http3-0"><a href="#7-为什么引入Http3-0" class="headerlink" title="7. 为什么引入Http3.0?"></a>7. 为什么引入<code>Http3.0</code>?</h2><p><code>Http2.0</code>还没学，怎么<code>Http3.0</code>又来了？<br>总得来说，这是因为<code>Http2.0</code>还存在一定的缺陷     </p>
<p><code>HTTP/2</code> 主要的问题在于，多个 <code>HTTP</code> 请求在复用一个 <code>TCP</code> 连接，下层的 <code>TCP</code> 协议是不知道有多少个 <code>HTTP</code> 请求的。<br>所以一旦发生了丢包现象，就会触发 <code>TCP</code> 的重传机制，这样在一个 <code>TCP</code> 连接中的所有的 <code>HTTP</code> 请求都必须等待这个丢了的包被重传回来。    </p>
<p><code>HTTP/2</code> 多请求复用一个<code>TCP</code>连接，一旦发生丢包，就会阻塞住所有的 <code>HTTP</code> 请求。<br>可以看出，这其实不是<code>Http</code>协议的问题，而是传输层协议的问题<br>所以 <code>HTTP/3</code> 把 <code>HTTP</code> 下层的 <code>TCP</code> 协议改成了 <code>UDP</code>！       </p>
<p><img src="https://pic4.zhimg.com/80/v2-e76adbd5dca9e3ade94f14b486692083_720w.jpg" alt><br><code>UDP</code> 发生是不管顺序，也不管丢包的，所以不会出现 <code>HTTP/1.1</code> 的队头阻塞 和 <code>HTTP/2</code> 的一个丢包全部重传问题。<br>大家都知道 <code>UDP</code> 是不可靠传输的，但基于 <code>UDP</code> 的 <code>QUIC</code> 协议 可以实现类似 <code>TCP</code> 的可靠性传输。<br><code>QUIC</code> 是一个在 <code>UDP</code> 之上的伪 <code>TCP</code> + <code>TLS</code> + <code>HTTP/2</code> 的多路复用的协议,在这里就不详细介绍了，有兴趣的同学可参考：<a href="https://zhuanlan.zhihu.com/p/111716047" target="_blank" rel="noopener">QUIC协议连接过程介绍</a>    </p>
<p>总得来说，<code>QUIC</code> 是新协议，对于很多网络设备，根本不知道什么是 <code>QUIC</code>，只会当做 <code>UDP</code>，这样会出现新的问题。<br>所以 <code>HTTP/3</code> 现在普及的进度非常的缓慢，大家只做简单了解即可。       </p>
<h2 id="8-浏览器输入url后发生了什么？"><a href="#8-浏览器输入url后发生了什么？" class="headerlink" title="8. 浏览器输入url后发生了什么？"></a>8. 浏览器输入<code>url</code>后发生了什么？</h2><p>这个是面试中的常见问题了，我们在了解了上面的知识点后，再一起来看下这个问题<br>要回答这个问题，我们需要对<code>TCP/IP</code>协议族有一定的了解     </p>
<h3 id="8-1-Tcp-IP协议族"><a href="#8-1-Tcp-IP协议族" class="headerlink" title="8.1 Tcp/IP协议族"></a>8.1 <code>Tcp/IP</code>协议族</h3><p><code>TCP/IP</code> 协议族里重要的一点就是分层。<br><code>TCP/IP</code> 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。<br>把 <code>TCP/IP</code> 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。<br>而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。         </p>
<p>值得一提的是，层次化之后，设计也变得相对简单了。<br>处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。      </p>
<h4 id="8-1-1-应用层"><a href="#8-1-1-应用层" class="headerlink" title="8.1.1 应用层"></a>8.1.1 应用层</h4><p>应用层决定了向用户提供应用服务时通信的活动。<br><code>TCP/IP</code> 协议族内预存了各类通用的应用服务。比如，<code>FTP</code>（<code>File Transfer Protocol</code>,文件传输协议）和 <code>DNS</code>（<code>Domain Name System</code>，域名系统）服务就是其中两类。<br><code>HTTP</code> 协议也处于该层。</p>
<h4 id="8-1-2-传输层"><a href="#8-1-2-传输层" class="headerlink" title="8.1.2 传输层"></a>8.1.2 传输层</h4><p>传输层对上层应用层，<strong>提供处于网络连接中的两台计算机之间的数据传输</strong>。<br>在传输层有两个性质不同的协议：<code>TCP</code>（<code>Transmission ControlProtocol</code>，传输控制协议）和 <code>UDP</code>（<code>User Data Protocol</code>，用户数据报协议）。</p>
<h4 id="8-1-3-网络层"><a href="#8-1-3-网络层" class="headerlink" title="8.1.3 网络层"></a>8.1.3 网络层</h4><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。<br>该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。<br>与对方计算机之间通过多台计算机或网络设备进行传输时，<strong>网络层所起的作用就是在众多的选项内选择一条传输路线</strong>。<br><code>IP</code>协议就在网络层</p>
<h4 id="8-1-4-数据链路层"><a href="#8-1-4-数据链路层" class="headerlink" title="8.1.4 数据链路层"></a>8.1.4 数据链路层</h4><p><strong>用来处理连接网络的硬件部分。</strong><br>包括控制操作系统、硬件的设备驱动、<code>NIC</code>（<code>Network Interface Card</code>，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。<br>硬件上的范畴均在链路层的作用范围之内。    </p>
<h3 id="8-2-浏览器输入url后大致流程"><a href="#8-2-浏览器输入url后大致流程" class="headerlink" title="8.2 浏览器输入url后大致流程"></a>8.2 浏览器输入<code>url</code>后大致流程</h3><ol>
<li>解析用户输入的<code>Url</code>       </li>
<li>通过<code>DNS</code>协议根据域名查询<code>ip</code>地址         </li>
<li>客户端发起请求       </li>
<li>服务端接受请求并处理            </li>
<li>客户端接受响应        </li>
<li>浏览器渲染页面         </li>
</ol>
<p>这里我们主要关注客户端发起请求及服务端接受请求的过程，这里就用到了<code>TCP/IP</code>协议族<br>在发送数据时，每层都要对数据进行封装，在接收数据时，每层都要对数据进行解封，如下图所示：<br><img src="https://pic3.zhimg.com/80/v2-6e7f3f12f414b1e970467f50c0062c6e_720w.jpg" alt>          </p>
<p>简单来说，就是从应用层发<code>http</code>请求，到传输层通过三次握手建立<code>tcp</code>连接，再到网络层的<code>ip</code>寻址，再经过数据链路层与物理层，最后到达服务端。<br>然后服务端经过相反的过程，在每一层将数据取出来即可。<br>关于浏览器输入<code>url</code>后的流程我们这里没有讲得很详细，想要了解更多细节的同学可参考：<a href="https://zhuanlan.zhihu.com/p/80551769" target="_blank" rel="noopener">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要梳理了<code>Http</code>协议相关知识点，并回答了以下问题    </p>
<ol>
<li><code>Http</code>到底是什么？    </li>
<li><code>Http</code>协议为什么是无状态的?</li>
<li>什么是队头阻塞问题?</li>
<li><code>GET</code>,<code>POST</code>,<code>PUT</code>等方法有什么区别？</li>
<li>为什么引入<code>Https</code>?</li>
<li>为什么引入<code>Http2.0</code>?</li>
<li>为什么引入<code>Http3.0</code>?</li>
<li>浏览器输入<code>url</code>后发生了什么?    </li>
</ol>
<p>如果对您有所帮助，欢迎点赞，谢谢~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6994629873985650696" target="_blank" rel="noopener">20分钟助你拿下HTTP和HTTPS，巩固你的HTTP知识体系</a><br><a href="https://www.byway.xyz/tips/http.html" target="_blank" rel="noopener">Http协议为什么是无状态的</a><br><a href="https://stackoverflow.com/questions/630453/what-is-the-difference-between-post-and-put-in-http" target="_blank" rel="noopener">What is the difference between POST and PUT in HTTP?</a><br><a href="https://zhuanlan.zhihu.com/p/111716047" target="_blank" rel="noopener">图解网络： HTTP 常见的面试题</a><br><a href="https://zhuanlan.zhihu.com/p/80551769" target="_blank" rel="noopener">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>【Gradle7.0】依赖统一管理的全新方式，了解一下~</title>
    <url>/blog/2021/08/gradle-catalog-learn.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着项目的不断发展，项目中的依赖也越来越多，有时可能会有几百个，这个时候对项目依赖做一个统一的管理很有必要，我们一般会有以下需求：    </p>
<ol>
<li>项目依赖统一管理，在单独文件中配置      </li>
<li>不同<code>Module</code>中的依赖版本号统一      </li>
<li>不同项目中的依赖版本号统一     </li>
</ol>
<p>针对这些需求，目前其实已经有了一些方案：   </p>
<ol>
<li><a href="https://juejin.cn/post/6947675376835362846#heading-2" target="_blank" rel="noopener">使用循环优化Gradle依赖管理</a>                   </li>
<li><a href="https://juejin.cn/post/6844903615346245646" target="_blank" rel="noopener">使用buildSrc管理Gradle依赖</a>      </li>
<li><a href="https://juejin.cn/post/6844904169833234439" target="_blank" rel="noopener">使用includeBuild统一配置依赖版本</a>     </li>
</ol>
<p>上面的方案支持在不同<code>Module</code>间统一版本号，同时如果需要在项目间共享，也可以做成<code>Gradle</code>插件发布到远端，已经基本可以满足我们的需求<br>不过<code>Gradle7.0</code>推出了一个新的特性，使用<code>Catalog</code>统一依赖版本，它支持以下特性：   </p>
<ol>
<li>对所有<code>module</code>可见，可统一管理所有<code>module</code>的依赖      </li>
<li>支持声明依赖<code>bundles</code>,即总是一起使用的依赖可以组合在一起     </li>
<li>支持版本号与依赖名分离，可以在多个依赖间共享版本号     </li>
<li>支持在单独的<code>libs.versions.toml</code>文件中配置依赖     </li>
<li>支持在项目间共享依赖    </li>
</ol>
<h2 id="使用Version-Catalog"><a href="#使用Version-Catalog" class="headerlink" title="使用Version Catalog"></a>使用<code>Version Catalog</code></h2><p>注意，<code>Catalog</code>仍然是一个孵化中的特性，如需使用,需要在<code>settings.gradle</code>中添加以下内容：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">enableFeaturePreview(<span class="string">'VERSION_CATALOGS'</span>)</span><br></pre></td></tr></table></figure></p>
<p>从命名上也可以看出，<code>Version Catalog</code>其实就是一个版本的目录,我们可以从目录中选出我们需要的依赖使用<br>我们可以通过如下方式使用<code>Catalog</code>中声明的依赖<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation(libs.retrofit)</span><br><span class="line">    implementation(libs.groovy.core)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这种情况下，<code>libs</code>是一个目录，<code>retrofit</code>表示该目录中可用的依赖项。 与直接在构建脚本中声明依赖项相比，<code>Version Catalog</code>具有许多优点：          </p>
<ul>
<li>对于每个<code>catalog</code>,<code>Gradle</code>都会生成类型安全的访问器,以便你在<code>IDE</code>中可以自动补全.(注:目前在<code>build.gradle</code>中还不能自动补全，可能是指<code>kts</code>或者开发中？)      </li>
<li>声明在<code>catalog</code>中的依赖对所有<code>module</code>可见，当修改版本号时，可以统一管理统一修改    </li>
<li><code>catalog</code>支持声明一个依赖<code>bundles</code>,即一些总是一起使用的依赖的组合</li>
<li><code>catalog</code>支持版本号与依赖名分离，可以在多个依赖间共享版本号</li>
</ul>
<h2 id="声明Version-Catalog"><a href="#声明Version-Catalog" class="headerlink" title="声明Version Catalog"></a>声明<code>Version Catalog</code></h2><p><code>Version Catalog</code>可以在<code>settings.gradle(.kts)</code>文件中声明。<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            alias(<span class="string">'retrofit'</span>).to(<span class="string">'com.squareup.retrofit2:retrofit:2.9.0'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-core'</span>).to(<span class="string">'org.codehaus.groovy:groovy:3.0.5'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-json'</span>).to(<span class="string">'org.codehaus.groovy:groovy-json:3.0.5'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-nio'</span>).to(<span class="string">'org.codehaus.groovy:groovy-nio:3.0.5'</span>)</span><br><span class="line">            alias(<span class="string">'commons-lang3'</span>).to(<span class="string">'org.apache.commons'</span>, <span class="string">'commons-lang3'</span>).version &#123;</span><br><span class="line">                strictly <span class="string">'[3.8, 4.0['</span></span><br><span class="line">                prefer <span class="string">'3.9'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>别名必须由一系列以破折号（<code>-</code>，推荐）、下划线 (<code>_</code>) 或点 (<code>.</code>) 分隔的标识符组成。<br>标识符本身必须由<code>ascii</code>字符组成，最好是小写，最后是数字。     </p>
<p>值得注意的是，<code>groovy-core</code>会被映射成<code>libs.groovy.core</code><br>如果你想避免映射可以使用大小写来区分，比如<code>groovyCore</code>会被处理成<code>libs.groovyCore</code>         </p>
<h2 id="具有相同版本号的依赖"><a href="#具有相同版本号的依赖" class="headerlink" title="具有相同版本号的依赖"></a>具有相同版本号的依赖</h2><p>在上面的示例中，我们可以看到三个<code>groovy</code>依赖具有相同的版本号，我们可以把它们统一起来<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            version(<span class="string">'groovy'</span>, <span class="string">'3.0.5'</span>)</span><br><span class="line">            version(<span class="string">'compilesdk'</span>, <span class="string">'30'</span>)</span><br><span class="line">            version(<span class="string">'targetsdk'</span>, <span class="string">'30'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-core'</span>).to(<span class="string">'org.codehaus.groovy'</span>, <span class="string">'groovy'</span>).versionRef(<span class="string">'groovy'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-json'</span>).to(<span class="string">'org.codehaus.groovy'</span>, <span class="string">'groovy-json'</span>).versionRef(<span class="string">'groovy'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-nio'</span>).to(<span class="string">'org.codehaus.groovy'</span>, <span class="string">'groovy-nio'</span>).versionRef(<span class="string">'groovy'</span>)</span><br><span class="line">            alias(<span class="string">'commons-lang3'</span>).to(<span class="string">'org.apache.commons'</span>, <span class="string">'commons-lang3'</span>).version &#123;</span><br><span class="line">                strictly <span class="string">'[3.8, 4.0['</span></span><br><span class="line">                prefer <span class="string">'3.9'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除了在依赖中，我们同样可以在<code>build.gradle</code>中获取版本,比如可以用来指定<code>compileSdk</code>等<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdk libs.versions.compilesdk.get().toInteger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.zj.gradlecatalog"</span></span><br><span class="line">        minSdk <span class="number">21</span></span><br><span class="line">        targetSdk libs.versions.targetsdk.get().toInteger()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，可以使用<code>catalog</code>统一<code>compileSdk</code>,<code>targetSdk</code>,<code>minSdk</code>的版本号  </p>
<h2 id="依赖bundles"><a href="#依赖bundles" class="headerlink" title="依赖bundles"></a>依赖<code>bundles</code></h2><p>因为在不同的项目中经常系统地一起使用某些依赖项，所以<code>Catalog</code>提供了<code>bundle</code>(依赖包)的概念。依赖包基本上是几个依赖项打包的别名。<br>例如，你可以这样使用一个依赖包，而不是像上面那样声明 3 个单独的依赖项：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation libs.bundles.groovy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>groovy</code>依赖包声明如下：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            version(<span class="string">'groovy'</span>, <span class="string">'3.0.5'</span>)</span><br><span class="line">            version(<span class="string">'checkstyle'</span>, <span class="string">'8.37'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-core'</span>).to(<span class="string">'org.codehaus.groovy'</span>, <span class="string">'groovy'</span>).versionRef(<span class="string">'groovy'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-json'</span>).to(<span class="string">'org.codehaus.groovy'</span>, <span class="string">'groovy-json'</span>).versionRef(<span class="string">'groovy'</span>)</span><br><span class="line">            alias(<span class="string">'groovy-nio'</span>).to(<span class="string">'org.codehaus.groovy'</span>, <span class="string">'groovy-nio'</span>).versionRef(<span class="string">'groovy'</span>)</span><br><span class="line">            alias(<span class="string">'commons-lang3'</span>).to(<span class="string">'org.apache.commons'</span>, <span class="string">'commons-lang3'</span>).version &#123;</span><br><span class="line">                strictly <span class="string">'[3.8, 4.0['</span></span><br><span class="line">                prefer <span class="string">'3.9'</span></span><br><span class="line">            &#125;</span><br><span class="line">            bundle(<span class="string">'groovy'</span>, [<span class="string">'groovy-core'</span>, <span class="string">'groovy-json'</span>, <span class="string">'groovy-nio'</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示：添加<code>groovy</code>依赖包等同于添加依赖包下的所有依赖项       </p>
<h2 id="插件版本"><a href="#插件版本" class="headerlink" title="插件版本"></a>插件版本</h2><p>除了<code>Library</code>之外，<code>Catalog</code>还支持声明插件版本。<br>因为<code>library</code>由它们的<code>group</code>、<code>artifact</code>和<code>version</code>表示，但<code>Gradle</code>插件仅由它们的<code>id</code>和<code>version</code>标识。<br>因此，插件需要单独声明：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            alias(<span class="string">'jmh'</span>).toPluginId(<span class="string">'me.champeau.jmh'</span>).version(<span class="string">'0.6.5'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后可以在<code>plugins</code>块下面使用<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'java-library'</span></span><br><span class="line">    id <span class="string">'checkstyle'</span></span><br><span class="line">    <span class="comment">// 使用声明的插件</span></span><br><span class="line">    alias(libs.plugins.jmh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在单独文件中配置Catalog"><a href="#在单独文件中配置Catalog" class="headerlink" title="在单独文件中配置Catalog"></a>在单独文件中配置<code>Catalog</code></h2><p>除了在<code>settings.gradle</code>中声明<code>Catalog</code>外，也可以通过一个单独的文件来配置<code>Catalog</code><br>如果在根构建的<code>gradle</code>目录中找到了<code>libs.versions.toml</code>文件,则将使用该文件的内容自动声明一个<code>Catalog</code>           </p>
<p><code>TOML</code>文件主要由4个部分组成：     </p>
<ul>
<li><code>[versions]</code> 部分用于声明可以被依赖项引用的版本</li>
<li><code>[libraries]</code> 部分用于声明<code>Library</code>的别名</li>
<li><code>[bundles]</code> 部分用于声明依赖包</li>
<li><code>[plugins]</code> 部分用于声明插件</li>
</ul>
<p>如下所示：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[versions]</span><br><span class="line">groovy = <span class="string">"3.0.5"</span></span><br><span class="line">checkstyle = <span class="string">"8.37"</span></span><br><span class="line">compilesdk = <span class="string">"30"</span></span><br><span class="line">targetsdk = <span class="string">"30"</span></span><br><span class="line"></span><br><span class="line">[libraries]</span><br><span class="line">retrofit = <span class="string">"com.squareup.retrofit2:retrofit:2.9.0"</span></span><br><span class="line">groovy-core = &#123; module = <span class="string">"org.codehaus.groovy:groovy"</span>, version.ref = <span class="string">"groovy"</span> &#125;</span><br><span class="line">groovy-json = &#123; module = <span class="string">"org.codehaus.groovy:groovy-json"</span>, version.ref = <span class="string">"groovy"</span> &#125;</span><br><span class="line">groovy-nio = &#123; module = <span class="string">"org.codehaus.groovy:groovy-nio"</span>, version.ref = <span class="string">"groovy"</span> &#125;</span><br><span class="line">commons-lang3 = &#123; group = <span class="string">"org.apache.commons"</span>, name = <span class="string">"commons-lang3"</span>, version = &#123; strictly = <span class="string">"[3.8, 4.0["</span>, prefer=<span class="string">"3.9"</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line">[bundles]</span><br><span class="line">groovy = [<span class="string">"groovy-core"</span>, <span class="string">"groovy-json"</span>, <span class="string">"groovy-nio"</span>]</span><br><span class="line"></span><br><span class="line">[plugins]</span><br><span class="line">jmh = &#123; id = <span class="string">"me.champeau.jmh"</span>, version = <span class="string">"0.6.5"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，依赖可以定义成一个字符串，也可以将<code>module</code>与<code>version</code>分离开来<br>其中<code>versions</code>可以定义成一个字符串，也可以定义成一个范围，详情可参见<a href="https://docs.gradle.org/current/userguide/rich_versions.html#rich-version-constraints" target="_blank" rel="noopener">rich-version</a><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[versions]</span><br><span class="line">my-lib = &#123; strictly = <span class="string">"[1.0, 2.0["</span>, prefer = <span class="string">"1.2"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="在项目间共享Catalog"><a href="#在项目间共享Catalog" class="headerlink" title="在项目间共享Catalog"></a>在项目间共享<code>Catalog</code></h2><p><code>Catalog</code>不仅可以在项目内统一管理依赖，同样可以实现在项目间共享<br>例如我们需要在团队内制定一个依赖规范，不同组的不同项目需要共享这些依赖，这是个很常见的需求     </p>
<h3 id="通过文件共享"><a href="#通过文件共享" class="headerlink" title="通过文件共享"></a>通过文件共享</h3><p><code>Catalog</code>支持通过从<code>Toml</code>文件引入依赖，这就让我们可以通过指定文件路径来实现共享依赖<br>如下所示，我们在<code>settins.gradle</code>中配置如下：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            from(files(<span class="string">"../gradle/libs.versions.toml"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此技术可用于声明来自不同文件的多个目录：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        <span class="comment">// 声明一个'testLibs'目录, 从'test-libs.versions.toml'文件中</span></span><br><span class="line">        testLibs &#123;</span><br><span class="line">            from(files(<span class="string">'gradle/test-libs.versions.toml'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="发布插件实现共享"><a href="#发布插件实现共享" class="headerlink" title="发布插件实现共享"></a>发布插件实现共享</h3><p>虽然从本地文件导入<code>Catalog</code>很方便，但它并没有解决在组织或外部消费者中共享<code>Catalog</code>的问题。<br>我们还可能通过<code>Catalog</code>插件来发布目录，这样用户直接引入这个插件即可   </p>
<p><code>Gradle</code>提供了一个<code>Catalog</code>插件，它提供了声明然后发布<code>Catalog</code>的能力。     </p>
<h4 id="1-首先引入两个插件"><a href="#1-首先引入两个插件" class="headerlink" title="1. 首先引入两个插件"></a>1. 首先引入两个插件</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'version-catalog'</span></span><br><span class="line">    id <span class="string">'maven-publish'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，此插件将公开可用于声明目录的<code>catalog</code>扩展</p>
<h4 id="2-定义目录"><a href="#2-定义目录" class="headerlink" title="2. 定义目录"></a>2. 定义目录</h4><p>上面引入插件后，即可使用<code>catalog</code>扩展定义目录<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">catalog &#123;</span><br><span class="line">    <span class="comment">// 定义目录</span></span><br><span class="line">    versionCatalog &#123;</span><br><span class="line">        from files(<span class="string">'../libs.versions.toml'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后可以通过<code>maven-publish</code>插件来发布目录 </p>
<h4 id="3-发布目录"><a href="#3-发布目录" class="headerlink" title="3. 发布目录"></a>3. 发布目录</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">publishing &#123;</span><br><span class="line">    publications &#123;</span><br><span class="line">        maven(MavenPublication) &#123;</span><br><span class="line">            groupId = <span class="string">'com.zj.catalog'</span></span><br><span class="line">            artifactId = <span class="string">'catalog'</span></span><br><span class="line">            version = <span class="string">'1.0.0'</span></span><br><span class="line">            from components.versionCatalog</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义好<code>groupId</code>,<code>artifactId</code>,<code>version</code>,<code>from</code>就可以发布了<br>我们这里发布到<code>mavenLocal</code>，你也可以根据需要配置发布到自己的<code>maven</code><br>以上发布的所有代码可见：<a href="https://github.com/shenzhen2017/GradleCatalog" target="_blank" rel="noopener">Catalog发布相关代码</a></p>
<h4 id="4-使用目录"><a href="#4-使用目录" class="headerlink" title="4. 使用目录"></a>4. 使用目录</h4><p>因为我们已经发布到了<code>mavenLocal</code>,在仓库中引入<code>mavenLocal</code>就可以使用插件了<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"># settings.gradle</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enableFeaturePreview(<span class="string">'VERSION_CATALOGS'</span>)</span><br><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    versionCatalogs &#123;</span><br><span class="line">        libs &#123;</span><br><span class="line">            from(<span class="string">"com.zj.catalog:catalog:1.0.0"</span>)</span><br><span class="line">            <span class="comment">// 我们也可以重写覆盖catalog中的groovy版本</span></span><br><span class="line">            version(<span class="string">"groovy"</span>, <span class="string">"3.0.6"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上就成功引入了插件，就可以使用<code>catalog</code>中的依赖了<br>这样就完成了依赖的项目间共享，以上使用的所有代码可见：<a href="https://github.com/shenzhen2017/GradleCatalog/tree/feature/useCatalog" target="_blank" rel="noopener">Catalog使用相关代码</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>项目间共享依赖是比较常见的需求，虽然我们也可以通过自定义插件实现，但还是不够方便<br><code>Gradle</code>官方终于推出了<code>Catalog</code>,让我们可以方便地实现依赖的共享,<code>Catalog</code>主要具有以下特性：     </p>
<ol>
<li>对所有<code>module</code>可见，可统一管理所有<code>module</code>的依赖      </li>
<li>支持声明依赖<code>bundles</code>,即总是一起使用的依赖可以组合在一起     </li>
<li>支持版本号与依赖名分离，可以在多个依赖间共享版本号     </li>
<li>支持在单独的<code>libs.versions.toml</code>文件中配置依赖     </li>
<li>支持在项目间共享依赖    </li>
</ol>
<h3 id="本文所有相关代码"><a href="#本文所有相关代码" class="headerlink" title="本文所有相关代码"></a>本文所有相关代码</h3><p><a href="https://github.com/shenzhen2017/GradleCatalog" target="_blank" rel="noopener">Catalog发布相关代码</a><br><a href="https://github.com/shenzhen2017/GradleCatalog/tree/feature/useCatalog" target="_blank" rel="noopener">Catalog使用相关代码</a>          </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.gradle.org/current/userguide/platforms.html" target="_blank" rel="noopener">Sharing dependency versions between projects</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【开源项目】Compose仿豆瓣榜单客户端，了解一下~</title>
    <url>/blog/2021/08/open-source-douban.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Compose</code>正式发布也有一段时间了，感觉要上手还是得实战一波。<br>所以借着空闲时间，参照豆瓣榜单页面的设计，开发了几个<code>Compose</code>版的豆瓣榜单页面<br><code>UI</code>效果还是挺好看的，有兴趣的同学可以点个<code>Star</code>:<a href="https://github.com/shenzhen2017/ComposeDouban" target="_blank" rel="noopener">Compose仿豆瓣榜单客户端</a>    </p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先看下最终的效果图    </p>
<p><img src="https://github.com/shenzhen2017/resource/blob/main/2021/augest/douban_compress.gif?raw=true" alt></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>在项目中主要用到了以下几个特性，以美化<code>UI</code>及体验    </p>
<ol>
<li>支持设置沉浸式状态栏及状态栏颜色     </li>
<li>支持水平方向滚动，竖直方向滚动等多种<code>UI</code>效果     </li>
<li>支持给<code>Image</code>设置渐变滤镜，以美化显示效果      </li>
<li>支持标题与列表页联动      </li>
<li>通过<code>Paging</code>支持了分页加载    </li>
</ol>
<h2 id="主要实现"><a href="#主要实现" class="headerlink" title="主要实现"></a>主要实现</h2><p>具体源码可以直接查看，这里主要介绍一些主要功能的实现      </p>
<h3 id="沉浸式状态栏设置"><a href="#沉浸式状态栏设置" class="headerlink" title="沉浸式状态栏设置"></a>沉浸式状态栏设置</h3><p>状态栏主要是通过<code>accompanist-insets</code>及<code>accompanist-systemuicontroller</code>库设置的<br><a href="https://github.com/google/accompanist" target="_blank" rel="noopener">accompanist</a>上提供了一系列常用的，如状态栏，权限，<code>FlowLayout</code>,<code>ViewPager</code>等<code>Compose</code>库<br>如果有时你发现基础库里没有相应的内容，可以去这里查找下     </p>
<p>设置状态栏主要分为以下几步       </p>
<ol>
<li>设置沉浸时状态栏    </li>
<li>获取状态栏高度   </li>
<li>设置状态栏颜色   </li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 1. 设置状态栏沉浸式</span></span><br><span class="line">        WindowCompat.setDecorFitsSystemWindows(window, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        setContent &#123;</span><br><span class="line">            BD_ToolTheme &#123;</span><br><span class="line">            	<span class="comment">// 加入ProvideWindowInsets</span></span><br><span class="line">                ProvideWindowInsets &#123;</span><br><span class="line">                    <span class="comment">// 2. 设置状态栏颜色</span></span><br><span class="line">                    rememberSystemUiController().setStatusBarColor(</span><br><span class="line">                        Color.Transparent, darkIcons = MaterialTheme.colors.isLight)</span><br><span class="line">                    Column &#123;</span><br><span class="line">                    	<span class="comment">// 3. 获取状态栏高度并设置占位</span></span><br><span class="line">                        Spacer(modifier = Modifier</span><br><span class="line">                            .statusBarsHeight()</span><br><span class="line">                            .fillMaxWidth())</span><br><span class="line">                        Text(text = <span class="string">"首页\r\n首页1\r\n首页2\r\n首页3"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过以上方法，就可以比较简单的实现沉浸状态栏的设置    </p>
<h3 id="Image设置渐变滤镜"><a href="#Image设置渐变滤镜" class="headerlink" title="Image设置渐变滤镜"></a><code>Image</code>设置渐变滤镜</h3><p>豆瓣榜单页面都给<code>Image</code>设置了渐变滤镜，以美化<code>UI</code>效果<br>其实实现起来也比较简单，给<code>Image</code>前添加一层渐变的蒙层即可<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TopRankItem</span><span class="params">(item: <span class="type">HomeTopRank</span>)</span></span> &#123;</span><br><span class="line">    Box(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .size(<span class="number">180</span>.dp, <span class="number">220</span>.dp)</span><br><span class="line">            .padding(<span class="number">8</span>.dp)</span><br><span class="line">            .clip(RoundedCornerShape(<span class="number">10</span>.dp))</span><br><span class="line">    ) &#123;</span><br><span class="line">    	<span class="comment">// 1. 图片</span></span><br><span class="line">        Image(</span><br><span class="line">            painter = rememberCoilPainter(request = item.imgUrl),</span><br><span class="line">            contentDescription = <span class="literal">null</span>,</span><br><span class="line">            contentScale = ContentScale.Crop,</span><br><span class="line">            modifier = Modifier.fillMaxSize()</span><br><span class="line">        )</span><br><span class="line">        Column(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .fillMaxSize()</span><br><span class="line">                <span class="comment">// 渐变滤镜</span></span><br><span class="line">                .background(</span><br><span class="line">                    brush = Brush.linearGradient(</span><br><span class="line">                        colors = listOf(Color(item.startColor), Color(item.endColor)),</span><br><span class="line">                        start = Offset(<span class="number">0f</span>, <span class="built_in">Float</span>.POSITIVE_INFINITY),</span><br><span class="line">                        end = Offset(<span class="built_in">Float</span>.POSITIVE_INFINITY, <span class="number">0f</span>)</span><br><span class="line">                    )</span><br><span class="line">                )</span><br><span class="line">                .padding(<span class="number">8</span>.dp)</span><br><span class="line"></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">//内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，使用<code>Box</code>布局，给前景设置一个从左下到右上渐变的背景即可       </p>
<h3 id="标题与列表联动"><a href="#标题与列表联动" class="headerlink" title="标题与列表联动"></a>标题与列表联动</h3><p>具体效果可见上面的动图，即在列表滚动时标题会有一个渐现渐隐效果<br>这个效果其实我们在<code>Android View</code>体系中也很常见，主要思路也很简单:       </p>
<ol>
<li>监听列表滚动，获取列表滚动<code>offset</code>      </li>
<li>根据列表滚动<code>offset</code>设置<code>Header</code>效果,如背景或者高度变化等   </li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RankScreen</span><span class="params">(viewModel: <span class="type">RankViewModel</span> = RankViewModel()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> scrollState = rememberLazyListState()</span><br><span class="line">    Box &#123;</span><br><span class="line">    	<span class="comment">// 1. 监听列表</span></span><br><span class="line">        LazyColumn(state = scrollState) &#123;</span><br><span class="line">            <span class="comment">//列表内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        RankHeader(scrollState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RankHeader</span><span class="params">(scrollState: <span class="type">LazyListState</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> target = LocalDensity.current.run &#123;</span><br><span class="line">        <span class="number">200</span>.dp.toPx()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 根据列表偏移量计算比例</span></span><br><span class="line">    <span class="keyword">val</span> scrollPercent: <span class="built_in">Float</span> = <span class="keyword">if</span> (scrollState.firstVisibleItemIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="number">1f</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scrollState.firstVisibleItemScrollOffset / target</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> activity = LocalContext.current <span class="keyword">as</span> Activity</span><br><span class="line">    <span class="keyword">val</span> backgroundColor = Color(<span class="number">0xFF7F6351</span>)</span><br><span class="line">    Column() &#123;</span><br><span class="line">        Spacer(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .fillMaxWidth()</span><br><span class="line">                .statusBarsHeight()</span><br><span class="line">                <span class="comment">// 3. 根据比例设置Header的alpha，以实现渐变效果</span></span><br><span class="line">                .alpha(scrollPercent)</span><br><span class="line">                .background(backgroundColor)</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，主要有三步：  </p>
<ol>
<li>监听列表     </li>
<li>根据列表偏移量计算比例    </li>
<li>根据比例设置<code>Header</code>的<code>alpha</code>，以实现渐变效果</li>
</ol>
<h3 id="利用Paging实现分页"><a href="#利用Paging实现分页" class="headerlink" title="利用Paging实现分页"></a>利用<code>Paging</code>实现分页</h3><p>目前<code>Pagin3</code>已经支持了<code>Compose</code>，我们可以利用<code>Paging</code>轻松实现分页效果<br>主要分为以下几步：  </p>
<ol>
<li>在<code>ViewModel</code>中设置数据源    </li>
<li>在页面中监听<code>Paging</code>数据     </li>
<li>根据加载状态设置加载更多<code>footr</code>状态         </li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 设置数据源</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RankViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> rankItems: Flow&lt;PagingData&lt;RankDetail&gt;&gt; =</span><br><span class="line">        Pager(PagingConfig(pageSize = <span class="number">10</span>, prefetchDistance = <span class="number">1</span>)) &#123;</span><br><span class="line">            MovieSource()</span><br><span class="line">        &#125;.flow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">RankScreen</span><span class="params">(viewModel: <span class="type">RankViewModel</span> = RankViewModel()</span></span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> lazyMovieItems = viewModel.rankItems.collectAsLazyPagingItems()</span><br><span class="line">    Box &#123;</span><br><span class="line">        LazyColumn(state = scrollState) &#123;</span><br><span class="line">            <span class="comment">// 2. 在页面中监听paging</span></span><br><span class="line">            items(lazyMovieItems) &#123;</span><br><span class="line">                it?.let &#123;</span><br><span class="line">                    RankListItem(it)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 根据paging状态设置加载更多footer状态等</span></span><br><span class="line">            lazyMovieItems.apply &#123;</span><br><span class="line">                <span class="keyword">when</span> (loadState.append) &#123;</span><br><span class="line">                    <span class="keyword">is</span> LoadState.Loading -&gt; &#123;</span><br><span class="line">                        item &#123; LoadingItem() &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上步骤，就可以比较简单方便地实现分页了   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shenzhen2017/ComposeDouban" target="_blank" rel="noopener">ComposeDouban</a><br>开源不易，如果项目对你有所帮助，欢迎点赞,<code>Star</code>,收藏~        </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/sinat_38184748/article/details/119345811" target="_blank" rel="noopener">Android Jetpack Compose 沉浸式/透明状态栏</a><br><a href="https://codingtroops.com/android/collapsing-toolbar-made-easy-with-compose/" target="_blank" rel="noopener">Collapsing Toolbar made easy with Compose</a><br><a href="https://proandroiddev.com/infinite-lists-with-paging-3-in-jetpack-compose-b095533aefe6" target="_blank" rel="noopener">Infinite Lists With Paging 3 in Jetpack Compose</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>【开源项目】简单易用的Compose版骨架屏,了解一下~</title>
    <url>/blog/2021/09/open-source-shimmer.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>骨架屏是页面的一个空白版本，通常会在页面完全渲染之前，通过一些灰色的区块大致勾勒出轮廓，待数据加载完成后，再替换成真实的内容。骨架屏加载中效果，比起传统的加载中效果可以提供更多信息，用户体验更好，因此也变得越来越流行<br>本文主要介绍如何使用Compose实现一个简单易用的骨架屏效果,有兴趣的同学可以点个<code>Star</code>：<a href="https://github.com/shenzhen2017/ComposeShimmer" target="_blank" rel="noopener">Compose版骨架屏</a></p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先看下最终的效果图<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/september/p1.gif" alt><br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/september/p2.gif" alt></p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>简单易用，可复用页面<code>UI</code>,不需要针对骨架屏定制<code>UI</code>        </li>
<li>支持设置骨架屏是否显示，一般结合加载状态使用      </li>
<li>支持设置骨架屏背景与高亮颜色    </li>
<li>支持设置骨架屏高度部分宽度，渐变部分宽度       </li>
<li>支持设置骨架屏动画的角度与方向</li>
<li>支持设置骨架屏动画的时间与两次动画间隔</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h3><p>第 1 步:在工程的<code>build.gradle</code>中添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		...</span><br><span class="line">		mavenCentral()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第2步：在应用的<code>build.gradle</code>中添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        implementation <span class="string">'io.github.shenzhen2017:shimmer:1.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ShimmerSample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> loading: <span class="built_in">Boolean</span> <span class="keyword">by</span> remember &#123;</span><br><span class="line">        mutableStateOf(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .shimmer(loading,config = ShimmerConfig())</span><br><span class="line">    ) &#123;</span><br><span class="line">        repeat(<span class="number">3</span>) &#123;</span><br><span class="line">            PlaceHolderItem()</span><br><span class="line">            Spacer(modifier = Modifier.height(<span class="number">10</span>.dp))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示:    </p>
<ol>
<li>只需要在<code>Column</code>的<code>Modifier</code>中加上<code>shimmer</code>，<code>Column</code>下的所有组件即可实现骨架屏效果    </li>
<li>可通过<code>loading</code>参数，控制骨架屏效果是否显示    </li>
<li>如果需要定制骨架屏动画效果，也可通过一些参数配置         </li>
</ol>
<p>具体主要有以下这些参数<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ShimmerConfig</span></span>(</span><br><span class="line">    <span class="comment">// 未高亮部分颜色</span></span><br><span class="line">    <span class="keyword">val</span> contentColor: Color = Color.LightGray.copy(alpha = <span class="number">0.3f</span>),</span><br><span class="line">    <span class="comment">// 高亮部分颜色</span></span><br><span class="line">    <span class="keyword">val</span> higLightColor: Color = Color.LightGray.copy(alpha = <span class="number">0.9f</span>),</span><br><span class="line">    <span class="comment">// 渐变部分宽度</span></span><br><span class="line">    <span class="meta">@FloatRange(from = 0.0, to = 1.0)</span></span><br><span class="line">    <span class="keyword">val</span> dropOff: <span class="built_in">Float</span> = <span class="number">0.5f</span>,</span><br><span class="line">    <span class="comment">// 高亮部分宽度</span></span><br><span class="line">    <span class="meta">@FloatRange(from = 0.0, to = 1.0)</span></span><br><span class="line">    <span class="keyword">val</span> intensity: <span class="built_in">Float</span> = <span class="number">0.2f</span>,</span><br><span class="line">    <span class="comment">//骨架屏动画方向</span></span><br><span class="line">    <span class="keyword">val</span> direction: ShimmerDirection = ShimmerDirection.LeftToRight,</span><br><span class="line">    <span class="comment">//动画旋转角度</span></span><br><span class="line">    <span class="keyword">val</span> angle: <span class="built_in">Float</span> = <span class="number">20f</span>,</span><br><span class="line">    <span class="comment">//动画时长</span></span><br><span class="line">    <span class="keyword">val</span> duration: <span class="built_in">Float</span> = <span class="number">1000f</span>,</span><br><span class="line">    <span class="comment">//两次动画间隔</span></span><br><span class="line">    <span class="keyword">val</span> delay: <span class="built_in">Float</span> = <span class="number">200f</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><h3 id="通过图像混合模式复用页面UI"><a href="#通过图像混合模式复用页面UI" class="headerlink" title="通过图像混合模式复用页面UI"></a>通过图像混合模式复用页面<code>UI</code></h3><p>如果我们要实现骨架屏效果，首先想到的是需要按照页面的结构再写一套<code>UI</code>，然后在加载中的时候，显示这套<code>UI</code>，否则隐藏<br>一般的加载中效果都是这样实现的，但这样会带来一个问题，不同的页面结构不同，那我们岂不是要一个页面就重写一套<code>UI</code>?这显然是不可接受的     </p>
<p>我们可以想到，页面的结构其实我们已经写过一遍了，如果我们能复用我们写的页面结构不就好了吗？<br>我们可以通过图像混合模式来实现这一点      </p>
<p>图像混合模式定义的是，当两个图像合成时，图像最终的展示方式。在<code>Androd</code>中，有相应的<code>API</code>接口来支持图像混合模式，即<code>Xfermode</code>.<br>图像混合模式主要有以下16种,以下这张图片从一定程度上形象地说明了图像混合的作用，两个图形一圆一方通过一定的计算产生不同的组合效果，具体如下<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/24/16dfbb120666a993~tplv-t2oaga2asx-watermark.awebp" alt><br>我们介绍几个常用的,其它的感兴趣的同学可自行查阅         </p>
<ul>
<li><code>SRC_IN</code>:只在源图像和目标图像相交的地方绘制【源图像】</li>
<li><code>DST_IN</code>:只在源图像和目标图像相交的地方绘制【目标图像】，绘制效果受到源图像对应地方透明度影响</li>
<li><code>SRC_OUT</code>:只在源图像和目标图像不相交的地方绘制【源图像】，相交的地方根据目标图像的对应地方的<code>alpha</code>进行过滤，目标图像完全不透明则完全过滤，完全透明则不过滤</li>
<li><code>DST_OUT</code>:只在源图像和目标图像不相交的地方绘制【目标图像】，在相交的地方根据源图像的<code>alpha</code>进行过滤，源图像完全不透明则完全过滤，完全透明则不过滤</li>
</ul>
<p>如果我们把页面的<code>UI</code>结构作为目标图像，骨架屏效果作为源图像，然后使用<code>SRC_IN</code>混合模式<br>就可以实现只在页面的结构上显示骨架屏，在空白部分不显示，这样就可以避免重复写<code>UI</code>了     </p>
<h3 id="通过平移实现动画效果"><a href="#通过平移实现动画效果" class="headerlink" title="通过平移实现动画效果"></a>通过平移实现动画效果</h3><p>上面我们已经实现了在页面结构上显示骨架屏，但是骨架屏效果还有一个动画效果<br>其实也很简单，给骨架屏设置一个渐变效果，然后做一个平移动画，然后看起来就是现在的骨架屏闪光动画了<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">shimmer</span><span class="params">()</span></span>: Modifier = composed &#123;</span><br><span class="line">    <span class="keyword">var</span> progress: <span class="built_in">Float</span> <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0f</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> infiniteTransition = rememberInfiniteTransition()</span><br><span class="line">    progress = infiniteTransition.animateFloat().value  <span class="comment">// 动画效果，计算百分比</span></span><br><span class="line">    ShimmerModifier(visible = visible, progress = progress, config = config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">ShimmerModifier</span></span>(progress:<span class="built_in">Float</span>) : DrawModifier, LayoutModifier &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> paint = Paint().apply &#123;</span><br><span class="line">        blendMode = BlendMode.SrcIn <span class="comment">//设置混合模式</span></span><br><span class="line">        shader = LinearGradientShader(Offset(<span class="number">0f</span>, <span class="number">0f</span>),toOffset,colors,colorStops)<span class="comment">//设置渐变色</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> ContentDrawScope.<span class="title">draw</span><span class="params">()</span></span> &#123;</span><br><span class="line">        drawContent()</span><br><span class="line">        <span class="keyword">val</span> (dx, dy) = getOffset(progress) <span class="comment">//根据progress，设置平移的位置</span></span><br><span class="line">        paint.shader?.postTranslate(dx, dy) <span class="comment">// 平移操作</span></span><br><span class="line">        it.drawRect(Rect(<span class="number">0f</span>, <span class="number">0f</span>, size.width, size.height), paint = paint)<span class="comment">//绘制骨架屏效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，主要是几步：   </p>
<ol>
<li>启动动画，获得当前进度<code>progress</code>，并根据<code>progress</code>获得当前平移的位置    </li>
<li>设置骨架屏的背景渐变颜色与混合模式    </li>
<li>绘制骨架屏效果    </li>
</ol>
<h3 id="自定义骨架屏效果"><a href="#自定义骨架屏效果" class="headerlink" title="自定义骨架屏效果"></a>自定义骨架屏效果</h3><p>上面介绍了我们提供了一些参数，可以自定义骨架屏的效果，其它参数都比较好理解，主要是以下两个参数有点难理解         </p>
<ol>
<li><code>dropOff</code>：渐变部分宽度     </li>
<li><code>intensity</code>: 高亮部分宽度    </li>
</ol>
<p>我们知道，可以通过<code>contentColor</code>自定义普通部分颜色,<code>higLightColor</code>自定义高亮部分颜色<br>但是这两种颜色是如何分布的呢？渐变的比例是怎样的呢？可以看下下面的代码：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> paint = Paint().apply &#123;</span><br><span class="line">    shader = LinearGradientShader(Offset(<span class="number">0f</span>, <span class="number">0f</span>),toOffset,colors,colorStops)<span class="comment">//设置渐变色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> colors = listOf(</span><br><span class="line">    config.contentColor,</span><br><span class="line">    config.higLightColor,</span><br><span class="line">    config.higLightColor,</span><br><span class="line">    config.contentColor</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> colorStops: List&lt;<span class="built_in">Float</span>&gt; = listOf(</span><br><span class="line">    ((<span class="number">1f</span> - intensity - dropOff) / <span class="number">2f</span>).coerceIn(<span class="number">0f</span>, <span class="number">1f</span>),</span><br><span class="line">    ((<span class="number">1f</span> - intensity - <span class="number">0.001f</span>) / <span class="number">2f</span>).coerceIn(<span class="number">0f</span>, <span class="number">1f</span>),</span><br><span class="line">    ((<span class="number">1f</span> + intensity + <span class="number">0.001f</span>) / <span class="number">2f</span>).coerceIn(<span class="number">0f</span>, <span class="number">1f</span>),</span><br><span class="line">    ((<span class="number">1f</span> + intensity + dropOff) / <span class="number">2f</span>).coerceIn(<span class="number">0f</span>, <span class="number">1f</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>可以看出，我们的颜色渐变有以下特点：   </p>
<ol>
<li>渐变颜色分布为：<code>contentColor</code>-&gt;<code>higLightColor</code>-&gt;<code>higLightColor</code>-&gt;<code>contentColor</code>     </li>
<li><code>LinearGradientShader</code>使用<code>colors</code>定义颜色,<code>colorStops</code>定义颜色渐变的分布,<code>colorStops</code>由<code>intensity</code>与<code>dropoff</code>计算得来              </li>
<li><code>intensity</code>决定了高亮部分的宽度，即<code>intensity</code>越大，高亮部分越大      </li>
<li><code>dropOff</code>决定了渐变部分的宽度，即<code>dropOff</code>越大，渐变部分越大          </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h3><p>在实现<code>Compose</code>版本骨架屏的过程中，主要借鉴了以下开源框架的思想，有兴趣的同学也可以了解下<br><a href="https://github.com/facebook/shimmer-android" target="_blank" rel="noopener">Facebook开源的shimmer-android</a><br><a href="https://github.com/kazemihabib/compose-shimmer" target="_blank" rel="noopener">Habib Kazemi开源的compose-shimmer</a>       </p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shenzhen2017/ComposeShimmer" target="_blank" rel="noopener">简单易用的Compose版骨架屏</a><br>开源不易，如果项目对你有所帮助，欢迎点赞,<code>Star</code>,收藏~</p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>相比 XML , Compose 性能到底怎么样？</title>
    <url>/blog/2021/09/compose-performance-summary.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近<code>Compose</code>已经正式发布了<code>1.0</code>版本，这说明谷歌认为<code>Compose</code>已经可以用于正式生产环境了<br>那么相比传统的<code>XML</code>,<code>Compose</code>的性能到底怎么样呢？      </p>
<p>本文主要从构建性能与运行时两个方面来分析<code>Compose</code>的性能，数据主要来源于：<a href="https://medium.com/androiddevelopers/jetpack-compose-before-and-after-8b43ba0b7d4f" target="_blank" rel="noopener">Jetpack Compose — Before and after</a>与<a href="https://engineering.premise.com/measuring-render-performance-with-jetpack-compose-c0bf5814933" target="_blank" rel="noopener">Measuring Render Performance with Jetpack Compose</a>,想了解更多的同学可以直接点击查看    </p>
<h2 id="构建性能"><a href="#构建性能" class="headerlink" title="构建性能"></a>构建性能</h2><p><code>Compose</code>构建性能主要以<a href="https://github.com/chrisbanes/tivi/" target="_blank" rel="noopener">tivi</a>为例来进行说明<br><code>Tivi</code>是一个开源的电影<code>App</code>，原本基于<code>Fragment</code>与<code>XML</code>构建，同时还使用了<code>DataBinding</code>等使用了注解处理器的框架<br>后来迁移到使用<code>Compose</code>构建<code>UI</code>,迁移过程分为两步    </p>
<ol>
<li>第一步：迁移到<code>Navigation</code>与<code>Fragment</code>,每个<code>Fragment</code>的<code>UI</code>则由<code>Compose</code>构建     </li>
<li>第二步：移除<code>Fragment</code>，完全基于<code>Compose</code>实现<code>UI</code>     </li>
</ol>
<p>下面我们就对<code>Pre-Compose</code>,<code>Fragments + Compose</code>,<code>Entirely Compose</code>三个阶段的性能进行分析对比    </p>
<h3 id="APK体积"><a href="#APK体积" class="headerlink" title="APK体积"></a><code>APK</code>体积</h3><p>包体积是我们经常关注的性能指标之一，我们一起看下3个阶段的包体积对比<br><img src="https://miro.medium.com/max/700/1*PHXoFXOmuPojvmjtOapYrw.png" alt><br><img src="https://miro.medium.com/max/700/1*3NoYE8XV00OY1JPAriyKsA.png" alt><br>可以看出，<code>Tivi</code> 的 <code>APK</code> 大小缩减了 <code>46%</code>，从 <code>4.49MB</code> 缩减到 <code>2.39MB</code>，同时方法数也减少了<code>17%</code>             </p>
<p>值得注意的是，在刚开始在应用中采用<code>Compose</code>时，有时您会发现<code>APK</code>大小反而变大了<br>这是因为迁移没有完成，老的依赖没有完成移除，而新的依赖已经添加了，导致<code>APK</code>体积变大<br>而在项目完全迁移到<code>Compose</code>后，<code>APK</code> 大小会减少，并且优于原始指标。       </p>
<h3 id="代码行数"><a href="#代码行数" class="headerlink" title="代码行数"></a>代码行数</h3><p>我们知道在比较软件项目时，代码行数并不是一个特别有用的统计数据，但它确实提供了对事物如何变化的一个观察指标。<br>我们使用<a href="https://github.com/AlDanial/cloc" target="_blank" rel="noopener">cloc工具</a>来计算代码行数<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">cloc . <span class="params">--exclude-dir=build</span>,<span class="string">.idea</span>,schemas</span><br></pre></td></tr></table></figure></p>
<p>结果如下图所示：<br><img src="https://miro.medium.com/max/2000/1*9Ryb9ZOTZUcgQgTKS3Zu2g.png" alt><br>可以看出，在迁移到<code>Compose</code>后，毫无意外的，<code>XML</code>代码行减少了<code>76%</code><br>有趣的是<code>kotlin</code>代码同样减少了，可能是因为我们可以减少很多模板代码，同时也可以移除之前写的一些<code>View Helper</code>代码     </p>
<h3 id="构建速度"><a href="#构建速度" class="headerlink" title="构建速度"></a>构建速度</h3><p>随着项目的不断变大，构建速度是开发人员越来越关心的一个指标。<br>在开始重构之前，我们知道，删除大量的注解处理器会有助于提高构建速度，但我们不确定会有多少。           </p>
<p>我们运行以下命令5次，然后取平均值<br><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./gradlew</span> <span class="params">--profile</span> <span class="params">--offline</span> <span class="params">--rerun-tasks</span> <span class="params">--max-workers=4</span> assembleDebug</span><br></pre></td></tr></table></figure></p>
<p>结果如下<br><img src="https://miro.medium.com/max/2000/1*pmfuV2Hqtj3K6JAq9Z4ChQ.png" alt><br>这里考虑的是调试构建时间，您在开发期间会更关注此时间。      </p>
<p>在迁移到<code>Compose</code>前，<code>Tivi</code> 的平均构建时间为 <code>108.71</code> 秒。<br>在完全迁移到 <code>Compose</code> 后，平均构建时间缩短至 <code>76.96</code> 秒！构建时间缩短了 <code>29%</code>。<br>构建时间能缩短这么多，当然不仅仅是<code>Compose</code>的功劳，在很大程度上受两个因素的影响：          </p>
<ol>
<li>一个是移除了使用注解处理器的<code>DataBinding</code>和<code>Epoxy</code>                    </li>
<li>另一个是<code>Hilt</code>在 <code>AGP 7.0</code> 中的运行速度更快。       </li>
</ol>
<h2 id="运行时性能"><a href="#运行时性能" class="headerlink" title="运行时性能"></a>运行时性能</h2><p>上面我们介绍了<code>Compose</code>在构建时的性能，下面来看下<code>Compose</code>在运行时渲染的性能怎么样    </p>
<h3 id="分析前的准备"><a href="#分析前的准备" class="headerlink" title="分析前的准备"></a>分析前的准备</h3><p>使用<code>Compose</code>时，可能有多种影响性能的指标      </p>
<ul>
<li>如果我们完全在<code>Compose</code>中构建<code>UI</code>会怎样？ </li>
<li>如果我们对复杂视图使用<code>Compose</code>（例如用 <code>LazyColumn</code> 替换 <code>RecyclerViews</code>）,但根布局仍然添加在<code>XML</code>中</li>
<li>如果我们使用<code>Compose</code>替换页面中一个个元素，而不是整个页面，会怎么样？      </li>
<li>是否可调试和<code>R8</code>编译器对性能的影响有多大？</li>
</ul>
<p>为了开始回答这些问题，我们构建了一个简单的测试程序。<br>在第一个版本中，我们添加了一个包含50个元素的列表（其中实际绘制了大约 12 个）。该列表包括一个单选按钮和一些随机文本。<br><img src="https://miro.medium.com/max/190/1*Nt71eQ51T3iz30ec5oaIEg.jpeg" alt><br>为了测试各种选项的影响，我们添加以下4种配置,以下4种都是开启了<code>R8</code>同时关闭了<code>debug</code>        </p>
<ol>
<li><code>纯Compose</code>     </li>
<li>一个<code>XML</code>中，只带有一个<code>ComposeView</code>,具体布局写在<code>Compose</code>中      </li>
<li><code>XML</code>中只包含一个<code>RecyclerView</code>，但是<code>RecyclerView</code>的每一项是一个<code>ComposeView</code>       </li>
<li>纯<code>XML</code></li>
</ol>
<p>同时为了测试<code>build type</code>对性能的影响，也添加了以下3种配置     </p>
<ol>
<li>纯<code>Compose</code>,关闭<code>R8</code>并打开<code>debug</code>        </li>
<li>纯<code>Compose</code>,关闭<code>R8</code>并关闭<code>debug</code>         </li>
<li>纯<code>XML</code>，关闭<code>R8</code>并打开<code>debug</code>         </li>
</ol>
<h3 id="如何定义性能"><a href="#如何定义性能" class="headerlink" title="如何定义性能?"></a>如何定义性能?</h3><p><code>Compose</code>运行时性能，我们一般理解的就是页面启动到用户看到内容的时间<br>因此下面几个时机对我们比较重要    </p>
<ol>
<li><code>Activity</code>启动时间,即<code>onCreate</code>       </li>
<li><code>Activity</code>启动完成时间，即<code>onResume</code>       </li>
<li><code>Activity</code>渲染绘制完成时间，即用户看到内容的时间        </li>
</ol>
<p><code>onCreate</code>与<code>onResume</code>的时机很容易掌握，重写系统方法即可，但如何获得<code>Activity</code>完全绘制的时间呢？<br>我们可以给页面根<code>View</code>添加一个<code>ViewTreeObserver</code>,然后记录最后一次<code>onDraw</code>调用的时间   </p>
<p>使用<code>Profile</code>查看上面说的过程，如下分别为使用<code>XML</code>渲染与使用<code>Compose</code>渲染的具体过程,即从<code>OnCreate</code>到调用最后一次<code>onDraw</code>的过程<br><img src="https://miro.medium.com/max/700/1*y3js-GEDW1EXWkT8Yt___w.png" alt="使用XML"><br><img src="https://miro.medium.com/max/700/1*_7AvTpiPG8PHpa2VGbfViw.png" alt="使用Compose"></p>
<h3 id="渲染性能分析"><a href="#渲染性能分析" class="headerlink" title="渲染性能分析"></a>渲染性能分析</h3><p>知道了如何定义性能，我们就可以开始测试了      </p>
<ol>
<li>每次测试都在几台设备上运行，包括最近的旗舰、没有<code>Google Play</code>服务的设备和一些廉价手机。      </li>
<li>每次测试在同一台手机上都会运行10次，因此我们不仅可以获取首次渲染时间，也可以获取二次渲染时间     </li>
<li>测试<code>Compose</code>版本为1.0.0</li>
</ol>
<p>我们根据上面定义的配置，重复跑了多次，得到了一些数据，感兴趣的同学可以直接查看<a href="https://docs.google.com/spreadsheets/d/1wSP6HDV8r_xq6_Lt3mTWgZcjwSktHkAaNgAR2HS3rZM/edit#gid=1695681986" target="_blank" rel="noopener">所有数据</a><br><img src="https://miro.medium.com/max/1400/0*0UiI3BvvLqLC8Z5x" alt><br>分析结果如上图所示，我们可以得出一些结论   </p>
<ul>
<li><code>R8</code>和是否可调试对<code>Jetpack Compose</code>渲染时间产生了显着影响。在每次实验中，禁用<code>R8</code>和启用可调试性的构建所花费的时间是没有它们的构建的两倍多。在我们最慢的设备上，<code>R8</code> 将渲染速度加快了半秒以上，而禁用<code>debug</code>又使渲染速度加快了半秒。       </li>
<li><code>XML</code>中只包含一个<code>ComposeView</code>的渲染时间，跟纯<code>Compose</code>的耗时差不多 </li>
<li><code>RecyclerView</code>中包含多个<code>ComposeView</code>是最慢的。这并不奇怪,在<code>XML</code>中使用<code>ComposeView</code>是有成本的，所以页面中使用的<code>ComposeView</code>越少越好。</li>
<li><code>XML</code>在呈现方面比<code>Compose</code>更快。没有办法解决这个问题，在每种情况下，<code>Compose</code> 的渲染时间比 <code>XML</code> 长约 33%。</li>
<li>第一次启动总是比后续启动花费更长的时间来渲染。如果您查看完整的数据，第一个页面的渲染时间几乎是后续的两倍。</li>
</ul>
<p>比较让我惊讶的是,尽管<code>Compose</code>没有了将<code>XML</code>转化成<code>View</code>的<code>IO</code>操作，测量过程也因为固有特性测量提高了测量效率，但性能仍然比<code>XML</code>要差<br>不过,根据<a href="https://twitter.com/intelligibabble" target="_blank" rel="noopener"><code>Leland Richardson</code></a>的<a href="https://www.twitch.tv/codewiththeitalians" target="_blank" rel="noopener">说法</a>，当从<code>Google Play</code>安装应用程序时，由于捆绑的<code>AOT</code>编译，<code>Compose</code> 在启动时渲染会更快，从而进一步缩小了与<code>XML</code>的差距</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面对<code>Compose</code>性能方面的分析，总结如下      </p>
<ol>
<li>如果完全迁移到<code>Compose</code>，在包体积，代码行数，编译速度等方面应该会有比较大的改善     </li>
<li>如果处于迁移中的阶段，可能因为旧的依赖没有去除，而已经引入了新的依赖，反而导致包体积等变大    </li>
<li>尽管没有了<code>XML</code>转换的<code>IO</code>操作，测量过程也通过固有特性测量进行了优化，<code>Compose</code>的渲染性能比起<code>XML</code>仍然有一定差距       </li>
<li>尽管目前<code>Compose</code>在性能方面略有欠缺(在大多数设备上仅超过一两帧)，但由于其在开发人员生产力、代码重用和声明式<code>UI</code>的强大特性等方面的优势，<code>Compose</code>仍被推荐使用</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://medium.com/androiddevelopers/jetpack-compose-before-and-after-8b43ba0b7d4f" target="_blank" rel="noopener">Jetpack Compose — Before and after</a><br><a href="https://engineering.premise.com/measuring-render-performance-with-jetpack-compose-c0bf5814933" target="_blank" rel="noopener">Measuring Render Performance with Jetpack Compose</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>【中秋征文】Compose 实现月亮阴晴圆缺动画</title>
    <url>/blog/2021/09/compose-moon-animatin.html</url>
    <content><![CDATA[<p>我正在参加中秋创意投稿大赛，详情请看：<a href="https://juejin.cn/post/7003154195826081800" target="_blank" rel="noopener">中秋创意投稿大赛</a>    </p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/september/p4.gif" alt>       </p>
<blockquote>
<p>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。<br>恰逢中秋佳节，我们今天就使用<code>Compose</code>来实现一下月相变化动画吧~<br>感兴趣的同学可以点个<code>Star</code> : <a href="https://github.com/shenzhen2017/ComposeMoon" target="_blank" rel="noopener">Compose 实现月亮阴晴圆缺动画</a>     </p>
</blockquote>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><h3 id="满天繁星"><a href="#满天繁星" class="headerlink" title="满天繁星"></a>满天繁星</h3><p>为了实现月相动画，我们首先需要一个背景，因此我们需要一个好看的星空，最好还有闪烁的效果<br>为为实现星空背景，我们需要做以下几件事       </p>
<ol>
<li>绘制背景       </li>
<li>生成几十个星星，在背景上随机分布   </li>
<li>通过<code>scale</code>与<code>alpha</code>动画，实现每个星星的闪烁效果    </li>
</ol>
<p>我们一起来看下代码<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Stars</span><span class="params">(starNum: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    BoxWithConstraints(modifier = Modifier.fillMaxSize()) &#123;</span><br><span class="line">        <span class="keyword">val</span> list = remember &#123; mutableStateListOf&lt;Star&gt;() &#125;</span><br><span class="line">        LaunchedEffect(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span>..starNum) &#123;</span><br><span class="line">                delay(<span class="number">100L</span>)</span><br><span class="line">                <span class="comment">//添加星星，它们的位置在屏幕上随机</span></span><br><span class="line">                list.add(Star(maxWidth.value * density, maxHeight.value * density))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            Star(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Star</span><span class="params">(star: <span class="type">Star</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> progress: <span class="built_in">Float</span> <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0f</span>) &#125;</span><br><span class="line">    <span class="keyword">val</span> infiniteTransition = rememberInfiniteTransition()</span><br><span class="line">    .... </span><br><span class="line">    star.updateStar(progress) <span class="comment">// 通过动画更新progress,从而更新star的属性值</span></span><br><span class="line">    Canvas(modifier = Modifier.wrapContentSize()) &#123;</span><br><span class="line">        scale(star.scale, Offset(star.x, star.y)) &#123; <span class="comment">// 缩放动画</span></span><br><span class="line">            drawCircle(</span><br><span class="line">                star.starColor,</span><br><span class="line">                star.radius,</span><br><span class="line">                center = Offset(star.x, star.y),</span><br><span class="line">                alpha = star.alpha <span class="comment">// alpha动画</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="月相变化"><a href="#月相变化" class="headerlink" title="月相变化"></a>月相变化</h3><p>月相，天文学术语。（<code>phase of the moon</code>）是天文学中对于地球上看到的月球被太阳照明部分的称呼。随着月亮每天在星空中自东向西移动一大段距离，它的形状也在不断地变化着，这就是月亮位相变化，叫做月相。<br>它的变化过程如下图所示<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/september/p5.jpeg" alt><br>每个阶段都有各自的名字，如下图所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/september/p6.jpeg" alt>     </p>
<p>可以看出，月相变化过程还是有些复杂的，那我们怎么实现这个效果呢？       </p>
<h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>为了实现月相变化,首先我们需要画一个圆，代表月亮，最终的满月其实就是这样，比较简单<br>有了满月，如何在它的基础上，画出其它的月相呢？我们可以通过图像混合模式来实现       </p>
<p>图像混合模式定义的是，当两个图像合成时，图像最终的展示方式。在<code>Androd</code>中，有相应的<code>API</code>接口来支持图像混合模式，即<code>Xfermode</code>.<br>图像混合模式主要有以下16种,以下这张图片从一定程度上形象地说明了图像混合的作用，两个图形一圆一方通过一定的计算产生不同的组合效果，具体如下<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ccb418c0dc8431fb449cb5ddd117bd5~tplv-k3u1fbpfcp-watermark.awebp" alt>      </p>
<p>我们为了实现月相动画，主要需要使用以下两种混合模式    </p>
<ul>
<li><code>DST_OUT</code>:只在源图像和目标图像不相交的地方绘制【目标图像】，在相交的地方根据源图像的<code>alpha</code>进行过滤，源图像完全不透明则完全过滤，完全透明则不过滤    </li>
<li><code>DST_OVER</code>:将目标图像放在源图像上方</li>
</ul>
<p>我们已经了解了图形混合模式，那么需要在满月上画什么才能实现其它效果呢?<br>我们可以通过在满月上放一个半圆<code>+</code>一个椭圆来实现<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f872b4e4c2e6417bbd46c8547deb007a~tplv-k3u1fbpfcp-watermark.awebp" alt>      </p>
<ol>
<li>如上所示，椭圆上水平的线叫长轴，竖直的线叫短轴      </li>
<li>短轴不变，长轴半径从0到满月半径发生变化，再加上一个半圆，就可以实现不同的月相     </li>
<li>比如为了画上蛾眉月，可以通过左半边画半圆，再加上一个椭圆，两都都使用<code>DST_OVER</code>混合模式来实现，就实现了它们两的并集，然后覆盖在下层满月上，就实现了上蛾眉月               </li>
<li>为了画渐盈凸月,则同样就左半边以<code>DST_OVER</code>画半圆,再以<code>DST_OUT</code>画椭圆，就只剩下半圆与椭圆不相交的部分，再与下层的满月混合，就实现了渐盈凸月        </li>
</ol>
<p>这样说可能还是比较抽象，感兴趣的同学可下载源码详细了解下   </p>
<h4 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//月亮动画控件</span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Moon</span><span class="params">(modifier: <span class="type">Modifier</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> progress: <span class="built_in">Float</span> <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0f</span>) &#125;</span><br><span class="line">    BoxWithConstraints(modifier = modifier) &#123;</span><br><span class="line">        Canvas(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .size(canvasSize)</span><br><span class="line">                .align(Alignment.TopCenter)</span><br><span class="line">        ) &#123;</span><br><span class="line">            drawMoonCircle(<span class="keyword">this</span>, progress)</span><br><span class="line">            drawIntoCanvas &#123;</span><br><span class="line">                it.withSaveLayer(Rect(<span class="number">0f</span>, <span class="number">0f</span>, size.width, size.height), paint = Paint()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (progress != <span class="number">1f</span>) &#123;</span><br><span class="line">                    	<span class="comment">//必须先画半圆，再画椭圆</span></span><br><span class="line">                        drawMoonArc(<span class="keyword">this</span>, it, paint, progress)</span><br><span class="line">                        drawMoonOval(<span class="keyword">this</span>, it, paint, progress)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.首先画一个满月</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawMoonCircle</span><span class="params">(scope: <span class="type">DrawScope</span>, progress: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">    drawCircle(Color(<span class="number">0xfff9dc60</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 画半圆</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawMoonArc</span><span class="params">(scope: <span class="type">DrawScope</span>, canvas: <span class="type">Canvas</span>, paint: <span class="type">Paint</span>, progress: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sweepAngle = <span class="keyword">when</span> &#123; <span class="comment">//从新月到满月在一边画半圆，从满月回到新月则在另一边画半圆</span></span><br><span class="line">        progress &lt;= <span class="number">0.5f</span> -&gt; <span class="number">180f</span></span><br><span class="line">        progress &lt;= <span class="number">1f</span> -&gt; <span class="number">180f</span></span><br><span class="line">        progress &lt;= <span class="number">1.5f</span> -&gt; -<span class="number">180f</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; -<span class="number">180f</span></span><br><span class="line">    &#125;</span><br><span class="line">    paint.blendMode = BlendMode.DstOver <span class="comment">//半圆的混合模式始终是DstOver</span></span><br><span class="line">    scope.run &#123;</span><br><span class="line">        canvas.drawArc(Rect(<span class="number">0f</span>, <span class="number">0f</span>, size.width, size.height), <span class="number">90f</span>, sweepAngle, <span class="literal">false</span>, paint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 画椭圆</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">drawMoonOval</span><span class="params">(scope: <span class="type">DrawScope</span>, canvas: <span class="type">Canvas</span>, paint: <span class="type">Paint</span>, progress: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> blendMode = <span class="keyword">when</span> &#123; <span class="comment">//椭圆的混合模式会发生变化，这里需要注意下</span></span><br><span class="line">        progress &lt;= <span class="number">0.5f</span> -&gt; BlendMode.DstOver</span><br><span class="line">        progress &lt;= <span class="number">1f</span> -&gt; BlendMode.DstOut</span><br><span class="line">        progress &lt;= <span class="number">1.5f</span> -&gt; BlendMode.DstOut</span><br><span class="line">        <span class="keyword">else</span> -&gt; BlendMode.DstOver</span><br><span class="line">    &#125;</span><br><span class="line">    paint.blendMode = blendMode</span><br><span class="line">    scope.run &#123;</span><br><span class="line">        canvas.drawOval(</span><br><span class="line">            Rect(offset = topLeft, size = Size(horizontalAxis, verticalAxis)), <span class="comment">//椭圆的长轴会随着动画变化</span></span><br><span class="line">            paint = paint</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示:   </p>
<ol>
<li>主要就是3个步骤，画满月，再画半圆，再画椭圆    </li>
<li>半圆的混合模式始终是<code>DstOver</code>,而椭圆的混合模式会发生变化，它们的颜色都是黑色。     </li>
<li>可以看到半圆与椭圆新建了一个<code>Layer</code>，混合模式的变化，表示的就是最后剩下的是它们的并集，还是<code>Dst</code>不相交的部分，最后覆盖到满月上，所以必须先画半圆     </li>
<li>随着动画的变化，椭圆的长轴会发生变化，这样就可以实现不同的月相    </li>
</ol>
<h3 id="诗歌打字机效果"><a href="#诗歌打字机效果" class="headerlink" title="诗歌打字机效果"></a>诗歌打字机效果</h3><p>上面其实已经做得差不多了，我们最后再添加一些诗歌，并为它们添加打字机效果<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">PoetryColumn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    list: <span class="type">List</span>&lt;<span class="type">Char</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    offsetX: <span class="type">Float</span> = <span class="number">0</span>f,</span></span></span><br><span class="line"><span class="function"><span class="params">    offsetY: <span class="type">Float</span> = <span class="number">0</span>f</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> targetList = remember &#123; mutableStateListOf&lt;<span class="built_in">Char</span>&gt;() &#125;</span><br><span class="line">    LaunchedEffect(list) &#123;</span><br><span class="line">        targetList.clear()</span><br><span class="line">        list.forEach &#123;</span><br><span class="line">            delay(<span class="number">500</span>) <span class="comment">//通过在LaunchedEffect中delay实现动画效果</span></span><br><span class="line">            targetList.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将 Jetpack Compose 环境的 Paint 对象转换为原生的 Paint 对象</span></span><br><span class="line">    <span class="keyword">val</span> textPaint = Paint().asFrameworkPaint().apply &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    Canvas(modifier = Modifier.wrapContentSize()) &#123;</span><br><span class="line">        drawIntoCanvas &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> targetList.indices) &#123;</span><br><span class="line">                it.nativeCanvas.drawText(list[i].toString(), x, y, textPaint)</span><br><span class="line">                y += delta <span class="comment">// 更新文字y轴位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，代码比较简单   </p>
<ol>
<li>通过在<code>LaunchedEffect</code>中调用挂起函数，来实现动画效果    </li>
<li>为了实现竖直方向的文字，我们需要使用<code>Paint</code>来绘制<code>Text</code>，而不能使用<code>Text</code>组件   </li>
<li><code>Compose</code>目前还不支持直接绘制<code>Text</code>，所以我们需要调用<code>asFrameworkPaint</code>将其转化为原生的<code>Paint</code></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，我们就通过<code>Compose</code>实现了月相阴晴圆缺+星空闪耀+诗歌打字机的动画效果<br>开发起来跟<code>Android</code>自定义绘制其实并没有多大差别，代码量因为<code>Compose</code>强大的<code>API</code>与声明式特点可能还有所减少<br>在我看来，<code>Compose</code>已经相当成熟了，而且将是<code>Android UI</code>的未来~     </p>
<p>开源不易，如果项目对你有所帮助，欢迎点赞,<code>Star</code>,收藏~        </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/7006142194230755341" target="_blank" rel="noopener">蹭中秋热度来了~Android 自定义View——月有阴晴圆缺</a><br><a href="https://juejin.cn/post/7005355142413287438" target="_blank" rel="noopener">「寒草的中秋献礼🥮，实现30s前端创意动画」陪你看日落和月升｜与你赏星空和诗歌</a>    </p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shenzhen2017/ComposeMoon" target="_blank" rel="noopener">Compose 实现月亮阴晴圆缺动画</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>【总结】Compose学习资源总结</title>
    <url>/blog/2021/09/compose-summary-resource.html</url>
    <content><![CDATA[<ul>
<li><a href="https://docs.compose.net.cn/" target="_blank" rel="noopener">Compose博物馆</a></li>
<li><a href="https://www.jetpackcompose.app/" target="_blank" rel="noopener">Compose开源项目目录</a></li>
<li><a href="https://www.jetpackcompose.app/What-is-the-equivalent-of--in-Jetpack-Compose" target="_blank" rel="noopener">在Compose中有什么与View相等的API?</a></li>
<li><a href="https://github.com/Gurupreet/ComposeCookBook" target="_blank" rel="noopener">ComposeCookBook,各种UI效果的合集</a></li>
</ul>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 Compose 没有布局嵌套问题?</title>
    <url>/blog/2021/09/compose-measure-onece.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做过布局性能优化的同学都知道，为了优化界面加载速度，要尽可能的减少布局的层级。这主要是因为布局层级的增加，可能会导致测量时间呈指数级增长。<br>而<code>Compose</code>却没有这个问题，它从根本上解决了布局层级对布局性能的影响: <code>Compose</code>界面只允许一次测量。这意味着随着布局层级的加深，测量时间也只是线性增长的.<br>下面我们就一起来看看<code>Compose</code>到底是怎么只测量一次就把活给干了的,本文主要包括以下内容：      </p>
<ol>
<li>布局层级过深为什么影响性能?     </li>
<li><code>Compose</code>为什么没有布局嵌套问题?         </li>
<li><code>Compose</code>测量过程源码分析    </li>
</ol>
<h2 id="1-布局层级过深为什么影响性能"><a href="#1-布局层级过深为什么影响性能" class="headerlink" title="1. 布局层级过深为什么影响性能?"></a>1. 布局层级过深为什么影响性能?</h2><p>我们总说布局层级过深会影响性能，那么到底是怎么影响的呢？主要是因为在某些情况下<code>ViewGroup</code>会对子<code>View</code>进行多次测量<br>举个例子<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@android:color/holo_red_dark"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@android:color/black"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>LinearLayout</code>宽度为<code>wrap_content</code>,因此它将选择子<code>View</code>的最大宽度为其最后的宽度     </li>
<li>但是有个子<code>View</code>的宽度为<code>match_parent</code>，意思它将以<code>LinearLayout</code>的宽度为宽度，这就陷入死循环了     </li>
<li>因此这时候， <code>LinearLayout</code> 就会先以<code>0</code>为强制宽度测量一下子<code>View</code>，并正常地测量剩下的其他子<code>View</code>，然后再用其他子<code>View</code>里最宽的那个的宽度，二次测量这个<code>match_parent</code>的子 <code>View</code>，最终得出它的尺寸，并把这个宽度作为自己最终的宽度。      </li>
<li>这是对单个子<code>View</code>的二次测量，如果有多个子<code>View</code>写了<code>match_parent</code> ，那就需要对它们每一个都进行二次测量。       </li>
<li>除此之外，如果在<code>LinearLayout</code>中使用了<code>weight</code>会导致测量3次甚至更多,重复测量在<code>Android</code>中是很常见的        </li>
</ol>
<p>上面介绍了为什么会出现重复测量，那么会有什么影响呢？不过是多测量了几次，会对性能有什么大的影响吗？<br><strong>之所以需要避免布局层级过深是因为它对性能的影响是指数级的</strong>       </p>
<ol>
<li>如果我们的布局有两层，其中父<code>View</code>会对每个子<code>View</code>做二次测量，那它的每个子<code>View</code>一共需要被测量 2 次        </li>
<li>如果增加到三层，并且每个父<code>View</code>依然都做二次测量，这时候最下面的子<code>View</code>被测量的次数就直接翻倍了，变成 4 次     </li>
<li>同理，增加到 4 层的话会再次翻倍，子 View 需要被测量 8 次<br><img src="https://image.rengwuxian.com/2021/05/05/8220fbcb38a10.png" alt>     </li>
</ol>
<p>也就是说，对于会做二次测量的系统，层级加深对测量时间的影响是指数级的,这就是<code>Android</code>官方文档建议我们减少布局层级的原因     </p>
<h2 id="2-Compose为什么没有布局嵌套问题"><a href="#2-Compose为什么没有布局嵌套问题" class="headerlink" title="2. Compose为什么没有布局嵌套问题?"></a>2. <code>Compose</code>为什么没有布局嵌套问题?</h2><p>我们知道，<code>Compose</code>只允许测量一次，不允许重复测量。<br>如果每个父组件对每个子组件只测量一次，那就直接意味着界面中的每个组件只会被测量一次<br><img src="http://image.rengwuxian.com/2021/05/05/5585808964f8c.png" alt><br>这样即使布局层级加深，测量时间却没有增加，把组件加载的时间复杂度从<code>O(2ⁿ)</code> 降到了 <code>O(n)</code>。          </p>
<p>那么问题就来了，上面我们已经知道，多次测量有时是必要的，但是为什么<code>Compose</code>不需要呢？<br><strong><code>Compose</code>中引入了固有特性测量(<code>Intrinsic Measurement</code>)</strong>         </p>
<p>固有特性测量即<code>Compose</code>允许父组件在对子组件进行测量之前，先测量一下子组件的「固有尺寸」<br>我们上面说的，<code>ViewGroup</code>的二次测量，也是先进行这种「粗略测量」再进行最终的「正式测量」，使用固有特性测量可以产生同样的效果      </p>
<p>而使用固有特性测量之所以有性能优势，主要是因为其不会随着层级的加深而加倍，固有特性测量也只进行一次<br><code>Compose</code>会先对整个组件树进行一次<code>Intrinsic</code>测量，然后再对整体进行正式的测量。这样开辟两个平行的测量过程，就可以避免因为层级增加而对同一个子组件反复测量所导致的测量时间的不断加倍了。<br><img src="http://image.rengwuxian.com/2021/05/05/58596a6ec9dc5.png" alt><br>总结成一句话就是，在<code>Compose</code>里疯狂嵌套地写界面，和把所有组件全都写进同一层里面，性能是一样的！所以<code>Compose</code>没有布局嵌套问题     </p>
<h3 id="2-1-固有特性测量使用"><a href="#2-1-固有特性测量使用" class="headerlink" title="2.1 固有特性测量使用"></a>2.1 固有特性测量使用</h3><p>假设我们需要创建一个可组合项，该可组合项在屏幕上显示两个用分隔线隔开的文本，如下所示：<br><img src="https://developer.android.com/images/jetpack/compose/layout-text-with-divider.png?hl=zh-cn" alt><br>为了实现分隔线与最高的文本一样高，我们可以怎么做呢？<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">TwoTexts</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    text1: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    text2: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    Row(modifier = modifier.height(IntrinsicSize.Min)) &#123;</span><br><span class="line">        Text(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .weight(<span class="number">1f</span>)</span><br><span class="line">                .padding(start = <span class="number">4</span>.dp)</span><br><span class="line">                .wrapContentWidth(Alignment.Start),</span><br><span class="line">            text = text1</span><br><span class="line">        )</span><br><span class="line">        Divider(</span><br><span class="line">            color = Color.Black,</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .fillMaxHeight()</span><br><span class="line">                .width(<span class="number">1</span>.dp)</span><br><span class="line">        )</span><br><span class="line">        Text(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .weight(<span class="number">1f</span>)</span><br><span class="line">                .padding(end = <span class="number">4</span>.dp)</span><br><span class="line">                .wrapContentWidth(Alignment.End),</span><br><span class="line">            text = text2</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里给<code>Row</code>的<code>height</code>设置为了<code>IntrinsicSize.Min</code>,<code>IntrinsicSize.Min</code>会递归查询它子项的最小高度，其中两个<code>Text</code>的最小高度即文本的宽度，而<code>Divider</code>的最小高度为0<br>因此最后<code>Row</code>的高度即为最长的文本的高度，而<code>Divider</code>的高度为<code>fillMaxHeight</code>，也就跟最高的文本一样高了<br>如果我们这里不设置高度为<code>IntrinsicSize.Min</code>的话，<code>Divider</code>的高度是占满屏幕的，如下所示<br><img src="https://developer.android.com/images/jetpack/compose/layout-text-with-divider-too-long.png?hl=zh-cn" alt>        </p>
<h2 id="3-Compose测量过程源码分析"><a href="#3-Compose测量过程源码分析" class="headerlink" title="3. Compose测量过程源码分析"></a>3. <code>Compose</code>测量过程源码分析</h2><p>上面我们介绍了固有特性测量是什么，及固有特性测量的使用，下面我们来看看<code>Compose</code>的测量究竟是怎么实现的    </p>
<h3 id="3-1-测量入口"><a href="#3-1-测量入口" class="headerlink" title="3.1 测量入口"></a>3.1 测量入口</h3><p>我们知道，在<code>Compose</code>中自定义<code>Layout</code>是通过<code>Layout</code>方法实现的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">Layout</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="function"><span class="params">    measurePolicy: <span class="type">MeasurePolicy</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure></p>
<p>主要传入3个参数     </p>
<ol>
<li><code>content</code>：自定义布局的子项，我们后续需要对它们测量和定位       </li>
<li><code>modifier</code>: 对<code>Layout</code>添加的一些修饰<code>modifier</code>     </li>
<li><code>measurePolicy</code>: 即测量规则，这个是我们主要需要处理的地方    </li>
</ol>
<p><code>measurePolicy</code>中主要有五个接口<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="keyword">interface</span> MeasurePolicy &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(measurables: <span class="type">List</span>&lt;<span class="type">Measurable</span>&gt;,constraints: <span class="type">Constraints</span>)</span></span>: MeasureResult</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">minIntrinsicWidth</span><span class="params">(measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,height: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">minIntrinsicHeight</span><span class="params">(measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,width: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">maxIntrinsicWidth</span><span class="params">(measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,height: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">maxIntrinsicHeight</span><span class="params">(measurables: <span class="type">List</span>&lt;<span class="type">IntrinsicMeasurable</span>&gt;,width: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出：    </p>
<ol>
<li>使用固有特性测量的时候，会调用对应的<code>IntrinsicMeasureScope</code>方法，如使用<code>Modifier.height(IntrinsicSize.Min)</code>，就会调用<code>minIntrinsicHeight</code>方法</li>
<li>父项测量子项时，就是在<code>MeasureScope.measure</code>方法中调用<code>measure.meausre(constraints)</code>，但是具体是怎么实现的呢?我们来看个例子</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">MeasureTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Row() &#123;</span><br><span class="line">        Layout(content = &#123; &#125;, measurePolicy = &#123; measurables, constraints -&gt;</span><br><span class="line">        	measurables.forEach &#123;</span><br><span class="line">            	it.measure(constraints)</span><br><span class="line">        	&#125;</span><br><span class="line">            layout(<span class="number">100</span>, <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的例子，我们在<code>measure</code>方法中打个断点，如下图所示:<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/september/p11.jpg" alt>    </p>
<ol>
<li>如下图所示，是由<code>Row</code>的<code>MeasurePolicy</code>中开始测量子项，<code>rowColumnMeasurePolicy</code>我们定义为<code>ParentPolicy</code>       </li>
<li>然后调用到<code>LayoutNode</code>,<code>OuterMeasurablePlaceable</code>,<code>InnerPlaceable</code>的<code>measure</code>方法     </li>
<li>最后再由<code>InnerPlaceable</code>中调用到子项的<code>MeasurePolicy</code>,即我们自定义<code>Layout</code>时实现的部分，我们定义它为<code>ChildPolicy</code>        </li>
<li>子项中也可能会测量它的子项，在这种情况下它就变成了一个<code>ParentPolicy</code>,然后继续后续的测量<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/september/p12.png" alt>    </li>
</ol>
<p>综上所述，父项在测量子项时，子项的测量入口就是<code>LayoutNode.measure</code>，然后经过一系列调用到子项自己的<code>MeasurePolicy</code>，也就是我们自定义<code>Layout</code>中自定义的部分     </p>
<h3 id="3-2-LayoutNodeWrapper链构建"><a href="#3-2-LayoutNodeWrapper链构建" class="headerlink" title="3.2 LayoutNodeWrapper链构建"></a>3.2 <code>LayoutNodeWrapper</code>链构建</h3><p>上面我们说了，测量入口是<code>LayoutNode</code>,后续还要经过<code>OuterMeasurablePlaceable</code>,<code>InnerPlaceable</code>的<code>measure</code>方法,那么问题来了，这些东西是怎么来的呢?<br>首先给出结论     </p>
<ol>
<li>子项都是以<code>LayoutNode</code>的形式，存在于<code>Parent</code>的<code>children</code>中的     </li>
<li>给<code>Layout</code>的设置的<code>modifier</code>会以<code>LayoutNodeWrapper</code>链的形式存储在<code>LayoutNode</code>中，然后后续做相应变换      </li>
</ol>
<p>由于篇幅原因，关于第一点就不在这里详述了，有兴趣的同学可以参考：<a href="https://juejin.cn/post/6981805443219718151" target="_blank" rel="noopener">Jetpack Compose 测量流程源码分析</a><br>我们这里主要看下<code>LayoutNodeWrapper</code>链是怎么构建的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> innerLayoutNodeWrapper: LayoutNodeWrapper = InnerPlaceable(<span class="keyword">this</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> outerMeasurablePlaceable = OuterMeasurablePlaceable(<span class="keyword">this</span>, innerLayoutNodeWrapper)</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">measure</span><span class="params">(constraints: <span class="type">Constraints</span>)</span></span> = outerMeasurablePlaceable.measure(constraints)</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> modifier: Modifier = Modifier</span><br><span class="line">      <span class="keyword">set</span>(value) &#123;</span><br><span class="line">          <span class="comment">// …… code</span></span><br><span class="line">          field = value</span><br><span class="line">          <span class="comment">// …… code</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 创建新的 LayoutNodeWrappers 链</span></span><br><span class="line">          <span class="comment">// foldOut 相当于遍历 modifier</span></span><br><span class="line">          <span class="keyword">val</span> outerWrapper = modifier.foldOut(innerLayoutNodeWrapper) &#123; mod <span class="comment">/*📍 modifier*/</span> , toWrap -&gt;</span><br><span class="line">              <span class="keyword">var</span> wrapper = toWrap</span><br><span class="line">              <span class="keyword">if</span> (mod <span class="keyword">is</span> OnGloballyPositionedModifier) &#123;</span><br><span class="line">                  onPositionedCallbacks += mod</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (mod <span class="keyword">is</span> RemeasurementModifier) &#123;</span><br><span class="line">                  mod.onRemeasurementAvailable(<span class="keyword">this</span>)</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">val</span> delegate = reuseLayoutNodeWrapper(mod, toWrap)</span><br><span class="line">              <span class="keyword">if</span> (delegate != <span class="literal">null</span>) &#123;</span><br><span class="line">                  wrapper = delegate</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// …… 省略了一些 Modifier判断 </span></span><br><span class="line">                    <span class="keyword">if</span> (mod <span class="keyword">is</span> KeyInputModifier) &#123;</span><br><span class="line">                      wrapper = ModifiedKeyInputNode(wrapper, mod).assignChained(toWrap)</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (mod <span class="keyword">is</span> PointerInputModifier) &#123;</span><br><span class="line">                      wrapper = PointerInputDelegatingWrapper(wrapper, mod).assignChained(toWrap)</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (mod <span class="keyword">is</span> NestedScrollModifier) &#123;</span><br><span class="line">                      wrapper = NestedScrollDelegatingWrapper(wrapper, mod).assignChained(toWrap)</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 布局相关的 Modifier</span></span><br><span class="line">                  <span class="keyword">if</span> (mod <span class="keyword">is</span> LayoutModifier) &#123;</span><br><span class="line">                      wrapper = ModifiedLayoutNode(wrapper, mod).assignChained(toWrap)</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> (mod <span class="keyword">is</span> ParentDataModifier) &#123;</span><br><span class="line">                      wrapper = ModifiedParentDataNode(wrapper, mod).assignChained(toWrap)</span><br><span class="line">                  &#125;</span><br><span class="line">                 </span><br><span class="line">              &#125;</span><br><span class="line">              wrapper</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          outerWrapper.wrappedBy = parent?.innerLayoutNodeWrapper</span><br><span class="line">          outerMeasurablePlaceable.outerWrapper = outerWrapper</span><br><span class="line"></span><br><span class="line">          ……</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示：   </p>
<ol>
<li>默认的<code>LayoutNodeWrapper</code>链即由<code>LayoutNode</code>,<code>OuterMeasurablePlaceable</code>,<code>InnerPlaceable</code>组成    </li>
<li>当添加了<code>modifier</code>时，<code>LayoutNodeWrapper</code>链会更新，<code>modifier</code>会作为一个结点插入到其中    </li>
</ol>
<p>举个例子，如果我们给<code>Layout</code>设置一些<code>modifier</code>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Modifier.size(100.dp).padding(10.dp).background(Color.Blue)</span><br></pre></td></tr></table></figure></p>
<p>那么对应的<code>LayoutNodeWrapper</code>链如下图所示<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c991f8852bbc413aaab7f99311b36561~tplv-k3u1fbpfcp-watermark.awebp" alt><br>这样一个接一个链式调用下一个的<code>measure</code>，直到最后一个结点<code>InnerPlaceable</code><br>那么<code>InnerPlaceable</code>又会调用到哪儿呢？<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4a41cfc8c0b45bab4489c3b680811c8~tplv-k3u1fbpfcp-watermark.awebp" alt><br><code>InnerPlaceable</code>最终调用到了我们自定义<code>Layout</code>时写的<code>measure</code>方法    </p>
<h3 id="3-3-固有特性测量是怎样实现的？"><a href="#3-3-固有特性测量是怎样实现的？" class="headerlink" title="3.3 固有特性测量是怎样实现的？"></a>3.3 固有特性测量是怎样实现的？</h3><p>上面我们介绍了固有特性测量的使用，也介绍了<code>LayoutNodeWrapper</code>链的构建，那么固有特性测量是怎么实现的呢？<br>其实固有特性测量就是往<code>LayoutNodeWrapper</code>链中插入了一个<code>Modifier</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Stable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Modifier.<span class="title">height</span><span class="params">(intrinsicSize: <span class="type">IntrinsicSize</span>)</span></span> = <span class="keyword">when</span> (intrinsicSize) &#123;</span><br><span class="line">    IntrinsicSize.Min -&gt; <span class="keyword">this</span>.then(MinIntrinsicHeightModifier)</span><br><span class="line">    IntrinsicSize.Max -&gt; <span class="keyword">this</span>.then(MaxIntrinsicHeightModifier)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">object</span> MinIntrinsicHeightModifier : IntrinsicSizeModifier &#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">measure</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: MeasureResult &#123;</span><br><span class="line">    	<span class="comment">//正式测量前先根据固有特性测量获得一个约束</span></span><br><span class="line">        <span class="keyword">val</span> contentConstraints = calculateContentConstraints(measurable, constraints)</span><br><span class="line">        <span class="comment">//正式测量</span></span><br><span class="line">        <span class="keyword">val</span> placeable = measurable.measure(</span><br><span class="line">            <span class="keyword">if</span> (enforceIncoming) constraints.constrain(contentConstraints) <span class="keyword">else</span> contentConstraints</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> layout(placeable.width, placeable.height) &#123;</span><br><span class="line">            placeable.placeRelative(IntOffset.Zero)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> MeasureScope.<span class="title">calculateContentConstraints</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        measurable: <span class="type">Measurable</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        constraints: <span class="type">Constraints</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Constraints &#123;</span><br><span class="line">        <span class="keyword">val</span> height = measurable.minIntrinsicHeight(constraints.maxWidth)</span><br><span class="line">        <span class="keyword">return</span> Constraints.fixedHeight(height)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> IntrinsicMeasureScope.<span class="title">maxIntrinsicHeight</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        measurable: <span class="type">IntrinsicMeasurable</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        width: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> = measurable.minIntrinsicHeight(width)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示：   </p>
<ol>
<li><code>IntrinsicSize.Min</code>其实也是个<code>Modifier</code>     </li>
<li><code>MinIntrinsicHeightModifier</code>会在测量之间，先调用<code>calculateContentConstraints</code>计算约束    </li>
<li><code>calculateContentConstraints</code>中则会递归地调用子项的<code>minIntrinsicHeight</code>,并找出最大值，这样父项的高度就确定了    </li>
<li>固有特性测量完成后，再调用<code>measurable.measure</code>，开始真正的递归测量    </li>
</ol>
<h3 id="3-4-测量过程小结"><a href="#3-4-测量过程小结" class="headerlink" title="3.4 测量过程小结"></a>3.4 测量过程小结</h3><p><strong>准备阶段</strong><br>子项在声明时，会生成<code>LayoutNode</code>添加到父项的<code>chindredn</code>中，同时子项的<code>modifier</code>也将构建成<code>LayoutNodeWrapper</code>链，保存在<code>LayoutNode</code>中<br>值得注意的是，如果使用了固有特性测量，将会添加一个<code>IntrinsicSizeModifier</code>到<code>LayoutNodeWrapper</code>链中    </p>
<p><strong>测量阶段</strong><br>父容器在其测量策略<code>MeasurePolicy</code>的<code>measure</code>函数中会执行<code>child</code>的<code>measure</code>函数。<br><code>child</code>的<code>measure</code>方法按照构建好的<code>LayoutNodeWrapper</code>链一步步的执行各个节点的<code>measure</code>函数，最终走到<code>InnerPlaceable</code>的<code>measure</code>函数，在这里又会继续它的<code>children</code>进行测量，此时它的<code>children</code> 就会和它一样进行执行上述流程，一直到所有<code>children</code>测量完成。    </p>
<p>用下面这张图总结一下上述流程。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4b74f5f51764e06a0545fb0f9a1600e~tplv-k3u1fbpfcp-watermark.awebp" alt></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了以下内容    </p>
<ol>
<li>在<code>Android</code>中布局层级过深为什么会对性能有影响?     </li>
<li>在<code>Compose</code>中为什么没有布局嵌套问题?    </li>
<li>什么是固有特性测量及固有特性测量的使用    </li>
<li><code>Compose</code>测量过程源码分析及固有特性测量到底是怎样实现的?    </li>
</ol>
<p>如果本文对你有所帮助，欢迎点赞收藏~     </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://rengwuxian.com/compose-intrinsic-measurement/" target="_blank" rel="noopener">View 嵌套太深会卡？来用 Jetpack Compose，随便套——Intrinsic Measurement</a><br><a href="https://juejin.cn/post/6981805443219718151" target="_blank" rel="noopener">Jetpack Compose 测量流程源码分析</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>【开源项目】简单易用的Compose版StateLayout,了解一下~</title>
    <url>/blog/2021/09/compose-state-layout.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在页面中常常需要展示网络请求状态，以带来更好的用户体验，具体来说通常有<code>加载中</code>，<code>加载失败</code>，<code>加载为空</code>，<code>加载成功</code>等状态.<br>在<code>XML</code>中我们通常用一个<code>ViewGroup</code>封装各种状态来实现，那么使用<code>Compose</code>该如何实现这种效果呢?<br>本文主要介绍<code>Compose</code>如何封装一个简单易用的<code>StateLayout</code>,有兴趣的同学可以点个<code>Star</code>:<a href="https://github.com/shenzhen2017/ComposeStateLayout" target="_blank" rel="noopener">Compose版StateLayout</a>    </p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先看下最终的效果图<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/september/p10.gif" alt>     </p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>支持配置全局默认布局,如默认加载中，默认成功失败等     </li>
<li>支持自定义默认样式文案，图片等细节     </li>
<li>支持完全自定义样式，如自定义加载中样式     </li>
<li>支持自定义处理点击重试事件     </li>
<li>完全使用数据驱动，使用简单，接入方便    </li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h3><p>第 1 步:在工程的<code>build.gradle</code>中添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		...</span><br><span class="line">		mavenCentral()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第2步：在应用的<code>build.gradle</code>中添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        implementation <span class="string">'io.github.shenzhen2017:compose-statelayout:1.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><h4 id="定义全局样式"><a href="#定义全局样式" class="headerlink" title="定义全局样式"></a>定义全局样式</h4><p>在框架中没有指定任何默认样式，因此你需要自定义自己的默认加载中，加载失败等页面样式<br>同时需要自定义传给自定义样式的数据结构类型，方便数据驱动<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StateData</span></span>(</span><br><span class="line">    <span class="keyword">val</span> tipTex: String? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> tipImg: <span class="built_in">Int</span>? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> btnText: String? = <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">DefaultStateLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="function"><span class="params">    pageStateData: <span class="type">PageStateData</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onRetry: <span class="type">OnRetry</span> = &#123; &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    loading: @<span class="type">Composable</span> (<span class="type">StateLayoutData</span>) -&gt; <span class="type">Unit</span> = &#123; DefaultLoadingLayout(it)</span></span> &#125;,</span><br><span class="line">    empty: <span class="meta">@Composable</span> (StateLayoutData) -&gt; <span class="built_in">Unit</span> = &#123; DefaultEmptyLayout(it) &#125;,</span><br><span class="line">    error: <span class="meta">@Composable</span> (StateLayoutData) -&gt; <span class="built_in">Unit</span> = &#123; DefaultErrorLayout(it) &#125;,</span><br><span class="line">    content: <span class="meta">@Composable</span> () -&gt; <span class="built_in">Unit</span> = &#123; &#125;</span><br><span class="line">) &#123;</span><br><span class="line">    ComposeStateLayout(</span><br><span class="line">        modifier = modifier,</span><br><span class="line">        pageStateData = pageStateData,</span><br><span class="line">        onRetry = onRetry,</span><br><span class="line">        loading = &#123; loading(it) &#125;,</span><br><span class="line">        empty = &#123; empty(it) &#125;,</span><br><span class="line">        error = &#123; error(it) &#125;,</span><br><span class="line">        content = content</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示,初始化时我们主要需要做以下事    </p>
<ol>
<li>自定义默认加载中，加载失败，加载为空等样式    </li>
<li>自定义<code>StateData</code>，即传给默认样式的数据结构，比如文案，图片等，这样后续需要修改的时候只需修改<code>StateData</code>即可      </li>
</ol>
<h4 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h4><p>如果我们直接使用默认样式，直接如下使用即可<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StateDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageStateData <span class="keyword">by</span> remember &#123;</span><br><span class="line">        mutableStateOf(PageState.CONTENT.bindData())</span><br><span class="line">    &#125;</span><br><span class="line">    DefaultStateLayout(</span><br><span class="line">        modifier = Modifier.fillMaxSize(),</span><br><span class="line">        pageStateData = pageStateData,</span><br><span class="line">        onRetry = &#123;</span><br><span class="line">            pageStateData = PageState.LOADING.bindData()</span><br><span class="line">        &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">//Content</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，可以直接使用，如果需要修改状态，修改<code>pageStateData</code>即可      </p>
<h4 id="自定义文案"><a href="#自定义文案" class="headerlink" title="自定义文案"></a>自定义文案</h4><p>如果我们需要自定义文案或者图片等细节，可简单直接修改<code>StateData</code>即可<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StateDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageStateData <span class="keyword">by</span> remember &#123;</span><br><span class="line">        mutableStateOf(PageState.CONTENT.bindData())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    pageStateData = PageState.LOADING.bindData(StateData(tipTex = <span class="string">"自定义加载中文案"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="自定义布局"><a href="#自定义布局" class="headerlink" title="自定义布局"></a>自定义布局</h4><p>有时页面的加载中样式与全局的并不一样，这就需要自定义布局样式了<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">StateDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pageStateData <span class="keyword">by</span> remember &#123;</span><br><span class="line">        mutableStateOf(PageState.CONTENT.bindData())</span><br><span class="line">    &#125;</span><br><span class="line">    DefaultStateLayout(</span><br><span class="line">        modifier = Modifier.fillMaxSize(),</span><br><span class="line">        pageStateData = pageStateData,</span><br><span class="line">        loading = &#123; CustomLoadingLayout(it) &#125;,</span><br><span class="line">        onRetry = &#123;</span><br><span class="line">            pageStateData = PageState.LOADING.bindData()</span><br><span class="line">        &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">//Content</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><p>其实<code>Compose</code>要实现不同的状态非常简单，传入不同的数据即可，如下所示:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Box(modifier = modifier) &#123;</span><br><span class="line">    <span class="keyword">when</span> (pageStateData.status) &#123;</span><br><span class="line">        PageState.LOADING -&gt; loading()</span><br><span class="line">        PageState.EMPTY -&gt; empty()</span><br><span class="line">        PageState.ERROR -&gt; error()</span><br><span class="line">        PageState.CONTENT -&gt; content()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实代码非常简单，但是这段代码是个通用逻辑，如果每个页面都要写这一段代码可能也挺烦的<br>所以这段代码其实是模板代码，我们想到<code>Scaffold</code>脚手架，提供了组合各个组件的<code>API</code>，包括标题栏、底部栏、<code>SnackBar</code>（类似吐司功能）、浮动按钮、抽屉组件、剩余内容布局等，让我们可以快速定义一个基本的页面结构。    </p>
<p>仿照<code>Scaffold</code>,我们也可以定义一个模板组件，用户可以传入自定义的<code>looading</code>,<code>empty</code>,<code>error</code>,<code>content</code>等组件，再将它们组合起来，这样就形成了<code>ComposeStateLayout</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">PageStateData</span></span>(<span class="keyword">val</span> status: PageState, <span class="keyword">val</span> tag: Any? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StateLayoutData</span></span>(<span class="keyword">val</span> pageStateData: PageStateData, <span class="keyword">val</span> retry: OnRetry = &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typealias</span> OnRetry = (PageStateData) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposeStateLayout</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    modifier: <span class="type">Modifier</span> = Modifier,</span></span></span><br><span class="line"><span class="function"><span class="params">    pageStateData: <span class="type">PageStateData</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    onRetry: <span class="type">OnRetry</span> = &#123; &#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    loading: @<span class="type">Composable</span> (<span class="type">StateLayoutData</span>) -&gt; <span class="type">Unit</span> = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    empty: @<span class="type">Composable</span> (<span class="type">StateLayoutData</span>) -&gt; <span class="type">Unit</span> = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    error: @<span class="type">Composable</span> (<span class="type">StateLayoutData</span>) -&gt; <span class="type">Unit</span> = &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span> = &#123; &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stateLayoutData = StateLayoutData(pageStateData, onRetry)</span><br><span class="line">    Box(modifier = modifier) &#123;</span><br><span class="line">        <span class="keyword">when</span> (pageStateData.status) &#123;</span><br><span class="line">            PageState.LOADING -&gt; loading(stateLayoutData)</span><br><span class="line">            PageState.EMPTY -&gt; empty(stateLayoutData)</span><br><span class="line">            PageState.ERROR -&gt; error(stateLayoutData)</span><br><span class="line">            PageState.CONTENT -&gt; content()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，代码很简单，主要需要注意以下几点：   </p>
<ol>
<li><code>PageStateData</code>的<code>tag</code>即传递给自定义<code>loading</code>等页面的信息，为<code>Any</code>类型，没有任何限制，用户可灵活处理     </li>
<li>自定义<code>loading</code>等页面也传入了<code>OnRetry</code>,因此我们也可以处理自定义点击事件   </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要实现了一个<code>Compose</code>版的<code>StateLayout</code>，它具有以下特性      </p>
<ol>
<li>支持配置全局默认布局,如默认加载中，默认成功失败等     </li>
<li>支持自定义默认样式文案，图片等细节     </li>
<li>支持完全自定义样式，如自定义加载中样式     </li>
<li>支持自定义处理点击重试事件     </li>
<li>完全使用数据驱动，使用简单，接入方便    <h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><a href="https://github.com/shenzhen2017/ComposeStateLayout" target="_blank" rel="noopener">简单易用的Compose版StateLayout</a><br>开源不易，如果项目对你有所帮助，欢迎点赞,Star,收藏~</li>
</ol>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>【一道面试题】 Glide做了哪些优化?</title>
    <url>/blog/2021/05/glide-optimize-sum.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Glide</code>可以说是最常用的图片加载框架了，<code>Glide</code>链式调用使用方便，性能上也可以满足大多数场景的使用，<code>Glide</code>源码与原理也是面试中的常客。<br>但是<code>Glide</code>的源码内容比较多，想要学习它的源码往往千头万绪，一时抓不住重点.<br>本文以<code>Glide</code>做了哪些优化为切入点，介绍与学习<code>Glide</code>的源码与原理，如果对您有所帮助，欢迎点赞.             </p>
<blockquote>
<p><code>Glide</code>做了哪些优化?</p>
</blockquote>
<p>要想要回答这个问题，我们可以先想一想，如果我们自己要实现一个图片加载框架，我们会思考什么问题？<br>1.图片下载是个耗时过程，我们首先需要考虑的就是图片缓存的问题<br>2.图片加载也是个耗内存的操作，很多<code>OOM</code>都是图片加载导致的，所以我们也要考虑内存优化问题<br>3.图片加载到一半，页面关闭了，图片加载也应该中止，这又牵扯到了生命周期管理的问题<br>4.还有就是图片加载框架是否支持大图加载？大图情况下会有什么问题？     </p>
<p>以上就是我们提出的有关于<code>Glide</code>的几个问题了，这样我们可以轻松得出本文主要包括的内容<br>1.<code>Glide</code>图片加载的总体流程介绍<br>2.<code>Glide</code>缓存机制做了哪些优化？<br>3.<code>Glide</code>做了哪些内存优化？<br>4.<code>Glide</code>如何管理生命周期?<br>5.<code>Glide</code>怎么做大图加载?</p>
<p>下面就带着问题进入正文~</p>
<h2 id="1-Glide图片加载总体流程介绍"><a href="#1-Glide图片加载总体流程介绍" class="headerlink" title="1.Glide图片加载总体流程介绍"></a>1.<code>Glide</code>图片加载总体流程介绍</h2><p>在开始了解<code>Glide</code>具体做了哪些优化之前，我们先对<code>Glide</code>图片加载的总体流程做一个简单的介绍，让大家首先有个整体概念。<br>同时在后面对<code>Glide</code>做的优化具体发生在哪一步也可以方便的知道.<br>概括来说，图片加载包含封装，解析，下载，解码，变换，缓存，显示等操作，如下图所示：<br><img src="https://raw.githubusercontent.com/shenzhen2017/newImage/master/blog5/p11.png" alt>       </p>
<ul>
<li>1.封装参数：从指定来源，到输出结果，中间可能经历很多流程，所以第一件事就是封装参数，这些参数会贯穿整个过程；</li>
<li>2.解析路径：图片的来源有多种，格式也不尽相同，需要规范化；</li>
<li>3.读取缓存：为了减少计算，通常都会做缓存；同样的请求，从缓存中取图片（<code>Bitmap</code>）即可；</li>
<li>4.查找文件/下载文件：如果是本地的文件，直接解码即可；如果是网络图片，需要先下载；</li>
<li>5.解码：这一步是整个过程中最复杂的步骤之一，有不少细节；</li>
<li>6.变换：解码出<code>Bitmap</code>之后，可能还需要做一些变换处理（圆角，滤镜等）；</li>
<li>7.缓存：得到最终bitmap之后，可以缓存起来，以便下次请求时直接取结果；</li>
<li>8.显示：显示结果，可能需要做些动画（淡入动画，crossFade等）。</li>
</ul>
<p>以上就是<code>Glide</code>图片加载的总体流程,这里只做了简单的介绍，详情可见：<a href="https://juejin.cn/post/6844904002551808013" target="_blank" rel="noopener">聊一聊关于Glide在面试中的那些事</a></p>
<h2 id="2-Glide缓存机制做了哪些优化？"><a href="#2-Glide缓存机制做了哪些优化？" class="headerlink" title="2.Glide缓存机制做了哪些优化？"></a>2.<code>Glide</code>缓存机制做了哪些优化？</h2><p>我们知道，下载图片是非常耗费资源的，所以图片缓存机制是图片加载框架很重要的一部分,下面就以一张表格来说明下 Glide 缓存。     </p>
<table>
<thead>
<tr>
<th>缓存类型</th>
<th>缓存代表</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>活动缓存</td>
<td>ActiveResources</td>
<td>如果当前对应的图片资源是从内存缓存中获取的，那么会将这个图片存储到活动资源中。</td>
</tr>
<tr>
<td>内存缓存</td>
<td>LruResourceCache</td>
<td>图片解析完成并最近被加载过，则放入内存中</td>
</tr>
<tr>
<td>磁盘缓存-资源类型</td>
<td>DiskLruCacheWrapper</td>
<td>被解码后的图片写入磁盘文件中</td>
</tr>
<tr>
<td>磁盘缓存-原始数据</td>
<td>DiskLruCacheWrapper</td>
<td>网络请求成功后将原始数据在磁盘中缓存</td>
</tr>
</tbody>
</table>
<p>在介绍具体缓存前，先来看一张加载缓存执行顺序，有个大概的印象<br><img src="https://user-gold-cdn.xitu.io/2019/9/26/16d6ce1ae35966f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br><code>Glide</code>的缓存机制，主要分为2种缓存，一种是内存缓存，一种是磁盘缓存。<br>之所以使用内存缓存的原因是：防止应用重复将图片读入到内存，造成内存资源浪费。<br>之所以使用磁盘缓存的原因是：防止应用重复的从网络或者其他地方下载和读取数据。<br>正式因为有着这两种缓存的结合，才构成了<code>Glide</code>极佳的缓存效果。        </p>
<h3 id="2-1-内存缓存"><a href="#2-1-内存缓存" class="headerlink" title="2.1 内存缓存"></a>2.1 内存缓存</h3><p><code>Glide</code>默认开启内存缓存，我们也可以通过<code>skipMemoryCache</code>关闭<br>上面我们可以看到内存缓存其实分两个部分，<code>ActiveResource</code>缓存与<code>LRU</code>缓存<br><code>ActiveResources</code> 就是一个弱引用的 <code>HashMap</code> ，用来缓存正在使用中的图片,使用 <code>ActiveResources</code> 来缓存正在使用中的图片，可以保护这些图片不会被 <code>LruCache</code> 算法回收掉     </p>
<p>内存缓存加载顺序如下：<br>1.根据图片地址，宽高，变换，签名等生成<code>key</code><br>2.第一次加载没有获取到活动缓存。<br>3.接着加载内存资源缓存，先清理掉内存缓存，在添加进行活动缓存。<br>4.第二次加载活动缓存已经存在。<br>5.当前图片引用为 0 的时候，清理活动资源，并且添加进内存资源。<br>6.又回到了第一步，然后就这样环环相扣。    </p>
<p>总结为流程图如下：<br><img src="https://user-gold-cdn.xitu.io/2019/9/26/16d6ce19e147ab45?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>这里没有贴出源码，如果想要看源码的同学可参考：<a href="https://juejin.cn/post/6844903953604280328#heading-3" target="_blank" rel="noopener">从源码的角度分析 Glide 缓存策略</a>    </p>
<p>我们上面总结了<code>Glide</code>内存缓存加载的流程,看到这里我们很容易有个疑问，为什么<code>Glide</code>要设计两种内存缓存？    </p>
<h4 id="2-1-1-为什么设计两种内存缓存？"><a href="#2-1-1-为什么设计两种内存缓存？" class="headerlink" title="2.1.1 为什么设计两种内存缓存？"></a>2.1.1 为什么设计两种内存缓存？</h4><blockquote>
<p><code>LruCache</code>算法的实现，你会发现它其实是用一个<code>Set</code>来缓存对象的，每次内存超出缓存设定触发<code>trim</code>操作的时候，其实是对这个<code>Set</code>进行遍历，然后移除缓存。但是我们都知道<code>Set</code>是无序的，因此遍历的时候有可能会把正在使用的缓存给误伤了，我还在用着它呢就给移出去了。因此这个弱引用可能是对正在使用中的图片的一种保护，使用的时候先从<code>LruCache</code>里面移出去，用完了再把它重新加到缓存里面。</p>
</blockquote>
<p>举个例子<br><img src="https://user-gold-cdn.xitu.io/2019/9/26/16d6ce1ae2b3f7ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt><br>比如我们 <code>Lru</code> 内存缓存 <code>size</code> 设置装 99 张图片，在滑动 <code>RecycleView</code> 的时候，如果刚刚滑动到 100 张，那么就会回收掉我们已经加载出来的第一张，这个时候如果返回滑动到第一张，会重新判断是否有内存缓存，如果没有就会重新开一个 <code>Request</code> 请求，很明显这里如果清理掉了第一张图片并不是我们要的效果。所以在从内存缓存中拿到资源数据的时候就主动添加到活动资源中，并且清理掉内存缓存中的资源。这么做很显然好处是 保护不想被回收掉的图片不被 <code>LruCache</code> 算法回收掉,充分利用了资源。</p>
<h4 id="2-1-1-小结"><a href="#2-1-1-小结" class="headerlink" title="2.1.1 小结"></a>2.1.1 小结</h4><p>本节主要总结了<code>Glide</code>内存缓存加载的流程<br>1.首先去获取活动缓存，如果加载到则直接返回，没有则进入下一步<br>2.接着去获取<code>LRU</code>缓存，在获取时会将其从<code>LRU</code>中删除并添加到活动缓存中<br>3.下次加载就可以直接加载活动缓存了<br>4.当图片引用为0时，会从活动缓存中清除并添加到<code>LRU</code>缓存中<br>5.之所以要设计两种内存缓存的原因是为了防止加载中的图片被<code>LRU</code>回收     </p>
<h3 id="2-2-磁盘缓存"><a href="#2-2-磁盘缓存" class="headerlink" title="2.2 磁盘缓存"></a>2.2 磁盘缓存</h3><p>首先了解一下磁盘缓存策略   </p>
<ul>
<li><code>DiskCacheStrategy.NONE</code>： 表示不缓存任何内容。</li>
<li><code>DiskCacheStrategy.RESOURCE</code>： 在资源解码后将数据写入磁盘缓存，即经过缩放等转换后的图片资源。</li>
<li><code>DiskCacheStrategy.DATA</code>： 在资源解码前将原始数据写入磁盘缓存。</li>
<li><code>DiskCacheStrategy.ALL</code> ： 使用<code>DATA</code>和<code>RESOURCE</code>缓存远程数据，仅使用<code>RESOURCE</code>来缓存本地数据。</li>
<li><code>DiskCacheStrategy.AUTOMATIC</code>：它会尝试对本地和远程图片使用最佳的策略。当你加载远程数据时，<code>AUTOMATIC</code> 策略仅会存储未被你的加载过程修改过的原始数据，因为下载远程数据相比调整磁盘上已经存在的数据要昂贵得多。对于本地数据，<code>AUTOMATIC</code> 策略则会仅存储变换过的缩略图，因为即使你需要再次生成另一个尺寸或类型的图片，取回原始数据也很容易。默认使用这种缓存策略</li>
</ul>
<p>在了解磁盘缓存时我们主要需要明确一个概念，是当我们使用 <code>Glide</code> 去加载一张图片的时候，<code>Glide</code> 默认并不会将原始图片展示出来，而是会对图片进行压缩和转换，总之就是经过种种一系列操作之后得到的图片，就叫转换过后的图片。<br>我们既可以缓存变换之前的原始图片，也可以缓存变换后的图片     </p>
<h4 id="2-2-1-为什么需要两种磁盘缓存"><a href="#2-2-1-为什么需要两种磁盘缓存" class="headerlink" title="2.2.1 为什么需要两种磁盘缓存"></a>2.2.1 为什么需要两种磁盘缓存</h4><p>上文已经说了，<code>DiskCacheStrategy.RESOURCE</code>缓存的是变换后的资源，<code>DiskCacheStrategy.DATA</code>缓存的是变换前的资源<br>举个例子，同一张图片，我们先在<code>100*100</code>的<code>View</code>是展示，再在<code>200*200</code>的<code>View</code>上展示<br>如果不缓存变换后的类型相当于每次都要进行一次变换操作，如果不缓存原始数据则每次都要去重新下载数据<br>如下可以看出，两种缓存的<code>key</code>不一样<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiskCacheStrategy.RESOURCE</span><br><span class="line">currentKey = <span class="keyword">new</span> ResourceCacheKey(helper.getArrayPool(),sourceId,helper.getSignature(),helper.getWidth(),helper.getHeight(),transformation,resourceClass,helper.getOptions());</span><br><span class="line"></span><br><span class="line">DiskCacheStrategy.DATA</span><br><span class="line">DataCacheKey newOriginalKey = <span class="keyword">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-2-小结"><a href="#2-2-2-小结" class="headerlink" title="2.2.2 小结"></a>2.2.2 小结</h4><p>本节主要介绍了<code>Glide</code>磁盘缓存的几种策略并介绍了为什么需要两种磁盘缓存的原因<br>这里也没有贴什么源码，如果想要看源码的同学可参考：<a href="https://juejin.cn/post/6844903953604280328#heading-8" target="_blank" rel="noopener">从源码的角度分析 Glide 缓存策略</a></p>
<h2 id="3-Glide做了哪些内存优化？"><a href="#3-Glide做了哪些内存优化？" class="headerlink" title="3.Glide做了哪些内存优化？"></a>3.<code>Glide</code>做了哪些内存优化？</h2><p><code>Glide</code>的内存优化主要也是对<code>Bitmap</code>的优化，在回答这个问题前，我们可以想想有哪些常见的<code>Bitmap</code>优化手段<br>1.当图片大小与<code>View</code>大小不一致时，可以用<code>inSampleSize</code>进行尺寸优化<br>2.图片所占内存即宽<em>高</em>每像素所占内存大小，不同的模式每个像素所占的内存大小不同，我们可以利用<code>inpreferredconfig</code>配置<br>3.<code>Bitmpa</code>所占内存比较大，如果频繁创建回收<code>Bitmap</code>内存可能造成内存抖动，我们可以利用<code>inBitmap</code>利用<code>Bitmap</code>内存<br>4.内存缓存，上文我们已经介绍了<code>Glide</code>的弱引用缓存与<code>LRU</code>缓存     </p>
<p>其实常见的<code>Bitmap</code>内存优化也就这么几种了，不过我们在工作中比较少直接使用他们。<br>下面我们就介绍下<code>Glide</code>中具体是怎么使用他们的.</p>
<h3 id="3-1-尺寸优化"><a href="#3-1-尺寸优化" class="headerlink" title="3.1 尺寸优化"></a>3.1 尺寸优化</h3><p>当装载图片的容器例如ImageView只有<code>100*100</code>，而图片的分辨率为<code>800 * 800</code>，这个时候将图片直接放置在容器上，很容易<code>OOM</code>，同时也是对图片和内存资源的一种浪费。当容器的宽高都很小于图片的宽高，其实就需要对图片进行尺寸上的压缩，将图片的分辨率调整为<code>ImageView</code>宽高的大小，一方面不会对图片的质量有影响，同时也可以很大程度上减少内存的占用</p>
<p>我们通常使用<code>inSampleSize</code>对<code>Bitmap</code>进行尺寸缩放    </p>
<blockquote>
<p>如果<code>inSampleSize</code> 设置的值大于1，则请求解码器对原始的<code>bitmap</code>进行子采样图像，然后返回较小的图片来减少内存的占用，例如<code>inSampleSize</code> == 4，则采样后的图像宽高为原图像的1/4，而像素值为原图的1/16，也就是说采样后的图像所占内存也为原图所占内存的1/16；当<code>inSampleSize</code> &lt;=1时，就当作1来处理也就是和原图一样大小。另外最后一句还注明，<code>inSampleSize</code>的值一直为2的幂，如1，2，4，8。任何其他的值也都是四舍五入到最接近2的幂。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">int</span> widthScaleFactor = orientedSourceWidth / outWidth;</span><br><span class="line"><span class="keyword">int</span> heightScaleFactor = orientedSourceHeight / outHeight;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">int</span> scaleFactor =</span><br><span class="line">    rounding == SampleSizeRounding.MEMORY</span><br><span class="line">        ? Math.max(widthScaleFactor, heightScaleFactor)</span><br><span class="line">        : Math.min(widthScaleFactor, heightScaleFactor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> powerOfTwoSampleSize;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= <span class="number">23</span></span><br><span class="line">    &amp;&amp; NO_DOWNSAMPLE_PRE_N_MIME_TYPES.contains(options.outMimeType)) &#123;</span><br><span class="line">  powerOfTwoSampleSize = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//4</span></span><br><span class="line">  powerOfTwoSampleSize = Math.max(<span class="number">1</span>, Integer.highestOneBit(scaleFactor));</span><br><span class="line">  <span class="comment">//5</span></span><br><span class="line">  <span class="keyword">if</span> (rounding == SampleSizeRounding.MEMORY</span><br><span class="line">  	  <span class="comment">// exactScaleFactor由各个裁剪策略如CenterCrop重写得到，详情可见代码</span></span><br><span class="line">      &amp;&amp; powerOfTwoSampleSize &lt; (<span class="number">1</span>.f / exactScaleFactor)) &#123;</span><br><span class="line">    powerOfTwoSampleSize = powerOfTwoSampleSize &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">options.inSampleSize = powerOfTwoSampleSize;</span><br></pre></td></tr></table></figure>
<p>如上就是<code>Glide</code>图片进行尺寸缩放相关的代码<br>1.首先计算出图片与<code>View</code>的宽高比<br>2.根据缩放策略是省内存还是高品质，决定取宽高比的最大值还是最小值<br>3.当<code>Build.VERSION.SDK_INT&lt;=23</code>时，一些格式的图片不能缩放<br>4.<code>highestOneBit</code>的功能是把我们计算的比例四舍五入到最接近2的幂<br>5.如果缩放策略为省内存，并且我们计算的<code>SampleSize&lt;exactScaleFactor</code>,将<code>inSampleSize*2</code></p>
<p>如上就是<code>Glide</code>图片加载时做尺寸优化的大概逻辑</p>
<h3 id="3-2-图片格式优化"><a href="#3-2-图片格式优化" class="headerlink" title="3.2 图片格式优化"></a>3.2 图片格式优化</h3><p>我们知道，<code>Bitmap</code>所占内存大小，由<code>宽*高*每像素所占内存</code>决定<br>上面的尺寸优化决定宽高，图片格式优化决定每像素所占内存    </p>
<p>在<code>API29</code>中，将<code>Bitmap</code>分为<code>ALPHA_8</code>, <code>RGB_565</code>, <code>ARGB_4444</code>, <code>ARGB_8888</code>, <code>RGBA_F16</code>, <code>HARDWARE</code>六个等级。</p>
<ul>
<li><code>ALPHA_8</code>：不存储颜色信息，每个像素占1个字节；</li>
<li><code>RGB_565</code>：仅存储<code>RGB</code>通道，每个像素占2个字节，对<code>Bitmap</code>色彩没有高要求，可以使用该模式；</li>
<li><code>ARGB_4444</code>：已弃用，用<code>ARGB_8888</code>代替；</li>
<li><code>ARGB_8888</code>：每个像素占用4个字节，保持高质量的色彩保真度，默认使用该模式；</li>
<li><code>RGBA_F16</code>：每个像素占用8个字节，适合宽色域和<code>HDR</code>；</li>
<li><code>HARDWARE</code>：一种特殊的配置，减少了内存占用同时也加快了<code>Bitmap</code>的绘制。</li>
</ul>
<p>每个等级每个像素所占用的字节也都不一样，所存储的色彩信息也不同。同一张100像素的图片，<code>ARGB_8888</code>就占了400字节，<code>RGB_565</code>才占200字节，RGB_565在内存上取得了优势，但是<code>Bitmap</code>的色彩值以及清晰度却不如<code>ARGB_8888</code>模式下的<code>Bitmap</code></p>
<p>值得注意的是在<code>Glide4.0</code>之前,<code>Glide</code>默认使用<code>RGB565</code>格式，比较省内存<br>但是<code>Glide4.0</code>之后，默认格式已经变成了<code>ARGB_8888</code>格式了,这一优势也就不存在了。<br>这本身也就是质量与内存之间的取舍，如果应用所需图片的质量要求不高，也可以修改默认格式   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认格式修改为了ARGB_8888</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Option&lt;DecodeFormat&gt; DECODE_FORMAT =</span><br><span class="line">      Option.memory(</span><br><span class="line">          <span class="string">"com.bumptech.glide.load.resource.bitmap.Downsampler.DecodeFormat"</span>, DecodeFormat.DEFAULT);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-内存复用优化"><a href="#3-3-内存复用优化" class="headerlink" title="3.3 内存复用优化"></a>3.3 内存复用优化</h3><p><code>Bitmap</code>所占内存比较大，如果我们频繁创建与回收<code>Bitmap</code>，那么很容易造成内存抖动,所以我们应该尽量复用<code>Bitmap</code>内存<br><code>Glide</code>主要使用了<code>inBitmap</code>与<code>BitmapPool</code>来实现内存的复用</p>
<h4 id="3-3-1-inBitmap介绍"><a href="#3-3-1-inBitmap介绍" class="headerlink" title="3.3.1 inBitmap介绍"></a>3.3.1 <code>inBitmap</code>介绍</h4><p>在 <code>Android 3.0（API 级别 11）</code>开始，系统引入了 <code>BitmapFactory.Options.inBitmap</code> 字段。如果设置了此选项，那么采用 <code>Options</code> 对象的解码方法会在生成目标 <code>Bitmap</code> 时尝试复用 <code>inBitmap</code>，这意味着 <code>inBitmap</code> 的内存得到了重复使用，从而提高了性能，同时移除了内存分配和取消分配。不过 <code>inBitmap</code> 的使用方式存在某些限制，在 <code>Android 4.4（API 级别 19）</code>之前系统仅支持复用大小相同的位图，4.4 之后只要 <code>inBitmap</code> 的大小比目标 <code>Bitmap</code> 大即可</p>
<h4 id="3-3-2-BitmapPool介绍"><a href="#3-3-2-BitmapPool介绍" class="headerlink" title="3.3.2 BitmapPool介绍"></a>3.3.2 <code>BitmapPool</code>介绍</h4><p>通过上文我们知道了可以通过<code>inBitmap</code>复用内存，但是还需要一个地方存储可复用的<code>Bitmap</code>,这就是<code>BitmapPool</code><br><code>JDK</code> 中的 <code>ThreadPoolExecutor</code> 相信大多数开发者都很熟悉，我们一般将之称为“线程池”。池化是一个很常见的概念，其目的都是为了实现对象复用，例如 <code>ThreadPoolExecutor</code> 就实现了线程的复用机制<br><code>BitmapPool</code>即实现了<code>Bitmap</code>的池化     </p>
<h4 id="3-3-3-Glide的应用"><a href="#3-3-3-Glide的应用" class="headerlink" title="3.3.3 Glide的应用"></a>3.3.3 <code>Glide</code>的应用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setInBitmap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BitmapFactory.Options options, BitmapPool bitmapPool, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Nullable</span> Bitmap.Config expectedConfig = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (expectedConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">    expectedConfig = options.inPreferredConfig;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// BitmapFactory will clear out the Bitmap before writing to it, so getDirty is safe.</span></span><br><span class="line">  options.inBitmap = bitmapPool.getDirty(width, height, expectedConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上即是<code>Glide</code>设置<code>inBitmap</code>的代码，向<code>BitmapPool</code>中传入宽高与格式，得到一个可复用的对象，这样就实现了<code>Bitmap</code>的内存复用<br>由于篇幅原因，详细的源码这里没有贴出来，想要了解更多的读者可参考:<a href="https://juejin.cn/post/6956090846470995975" target="_blank" rel="noopener">Coil 和 Glide 的 Bitmap 缓存复用机制</a></p>
<h2 id="4-Glide如何管理生命周期"><a href="#4-Glide如何管理生命周期" class="headerlink" title="4.Glide如何管理生命周期?"></a>4.<code>Glide</code>如何管理生命周期?</h2><p>当我们在做一个网络请示时，页面退出时应该中止请示，不然容易造成内存泄漏<br>对于图片加载也是如此，我们在页面退出时应该中止请示，销毁资源。<br>但是我们使用<code>Glide</code>的时候却不需要在页面退出时做什么操作，说明<code>Glide</code>可以做到在页面关闭时自动释放资源<br>下面我们一起看下<code>Glide</code>是如何实现的<br>主要是两步:<br>1.调用时通过<code>Glide.with</code>传入<code>context</code>,利用<code>context</code>构建一个<code>Fragment</code><br>2.监听<code>Fragment</code>生命周期，销毁时释放<code>Glide</code>资源   </p>
<h3 id="4-1-传入context构建Fragment"><a href="#4-1-传入context构建Fragment" class="headerlink" title="4.1 传入context构建Fragment"></a>4.1 传入<code>context</code>构建<code>Fragment</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过Activity拿到RequestManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//拿到当前Activity的FragmentManager</span></span><br><span class="line">      android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">      <span class="comment">//生成一个Fragment去绑定一个请求管理RequestManager</span></span><br><span class="line">      <span class="keyword">return</span> fragmentGet(</span><br><span class="line">          activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> RequestManager <span class="title">fragmentGet</span><span class="params">(@NonNull Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">     @NonNull android.app.FragmentManager fm,</span></span></span><br><span class="line"><span class="function"><span class="params">     @Nullable android.app.Fragment parentHint,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//①在当前Activity添加一个Fragment用于管理请求的生命周期</span></span><br><span class="line">   RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">   <span class="comment">//获取RequestManager</span></span><br><span class="line">   RequestManager requestManager = current.getRequestManager();</span><br><span class="line">   <span class="comment">//如果不存在RequestManager，则创建</span></span><br><span class="line">   <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">     Glide glide = Glide.get(context);</span><br><span class="line">     <span class="comment">//②构建RequestManager  </span></span><br><span class="line">     <span class="comment">//current.getGlideLifecycle()就是ActivityFragmentLifecycle，也就是构建RequestManager时会传入fragment中的ActivityFragmentLifecycle</span></span><br><span class="line">     requestManager =</span><br><span class="line">         factory.build(</span><br><span class="line">             glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">     <span class="comment">//将构建出来的RequestManager绑定到fragment中</span></span><br><span class="line">     current.setRequestManager(requestManager);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//返回当前请求的管理者</span></span><br><span class="line">   <span class="keyword">return</span> requestManager;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如上所示：<br>1.在当前<code>Activity</code>添加一个透明<code>Fragment</code>用于管理请示生命周期<br>2.构建<code>RequestManager</code>并传入<code>Fragment</code>生命周期    </p>
<h3 id="4-2-RequestManager监听生命周期"><a href="#4-2-RequestManager监听生命周期" class="headerlink" title="4.2 RequestManager监听生命周期"></a>4.2 <code>RequestManager</code>监听生命周期</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ModelTypes</span>&lt;<span class="title">RequestBuilder</span>&lt;<span class="title">Drawable</span>&gt;&gt; </span>&#123; </span><br><span class="line"></span><br><span class="line">	RequestManager(</span><br><span class="line">      Glide glide,</span><br><span class="line">      Lifecycle lifecycle,</span><br><span class="line">      RequestManagerTreeNode treeNode,</span><br><span class="line">      RequestTracker requestTracker,</span><br><span class="line">      ConnectivityMonitorFactory factory,</span><br><span class="line">      Context context) &#123;</span><br><span class="line">    ... </span><br><span class="line">    <span class="comment">//将当前对象注册到ActivityFragmentLifecycle</span></span><br><span class="line">    lifecycle.addListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">//RequestManager实现了fragment生命周期回调</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    resumeRequests();</span><br><span class="line">    targetTracker.onStart();</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pauseRequests();</span><br><span class="line">    targetTracker.onStop();</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    targetTracker.onDestroy();</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManagerFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="comment">//生命周期的关键就在ActivityFragmentLifecycle</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ActivityFragmentLifecycle lifecycle;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RequestManagerFragment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> ActivityFragmentLifecycle());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RequestManagerFragment(<span class="meta">@NonNull</span> ActivityFragmentLifecycle lifecycle) &#123;</span><br><span class="line">    <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    lifecycle.onStart();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    lifecycle.onStop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    lifecycle.onDestroy();</span><br><span class="line">    unregisterFragmentWithRoot();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单：<code>Fragment</code>生命周期变化会回调<code>RequestManager</code>生命周期，然后在进行相关的资源释放工作</p>
<h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/926e97d193d14bb88184079b4932dc86~tplv-k3u1fbpfcp-watermark.image" alt><br><code>Glide.with(this)</code>绑定了<code>Activity</code>的生命周期。在<code>Activity</code>内新建了一个无<code>UI</code>的<code>Fragment</code>，这个<code>Fragment</code>持有一个<code>Lifecycle</code>，通过<code>Lifecycle</code>在<code>Fragment</code>关键生命周期通知<code>RequestManager进</code>行相关从操作。在生命周期<code>onStart</code>时继续加载，<code>onStop</code>时暂停加载，<code>onDestory</code>时停止加载任务和清除操作。</p>
<p>由于篇幅有限，这里没有贴太多代码，更多细节可参考:<a href="https://www.jianshu.com/p/190285e18ae1" target="_blank" rel="noopener">Glide生命周期管理</a></p>
<h2 id="5-大图加载"><a href="#5-大图加载" class="headerlink" title="5.大图加载"></a>5.大图加载</h2><p>对于图片加载还有种情况，就是单个图片非常巨大，并且还不允许压缩。比如显示：世界地图、清明上河图、微博长图等<br>首先不压缩，按照原图尺寸加载，那么屏幕肯定是不够大的，并且考虑到内存的情况，不可能一次性整图加载到内存中<br>所以这种情况的优化思路一般是局部加载，通过<code>BitmapRegionDecoder</code>来实现<br>这种情况下通常<code>Glide</code>只负责将图片下载下来,图片的加载由我们自定义的<code>ImageView</code>来实现      </p>
<h3 id="5-1-BitmapRegionDecoder介绍"><a href="#5-1-BitmapRegionDecoder介绍" class="headerlink" title="5.1 BitmapRegionDecoder介绍"></a>5.1 <code>BitmapRegionDecoder</code>介绍</h3><p><code>BitmapRegionDecoder</code>主要用于显示图片的某一块矩形区域，如果你需要显示某个图片的指定区域，那么这个类非常合适。<br>对于该类的用法，非常简单，既然是显示图片的某一块区域，那么至少只需要一个方法去设置图片；一个方法传入显示的区域即可<br>举个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置显示图片的中心区域</span></span><br><span class="line">BitmapRegionDecoder bitmapRegionDecoder = BitmapRegionDecoder.newInstance(inputStream, <span class="keyword">false</span>);</span><br><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">Bitmap bitmap = bitmapRegionDecoder.decodeRegion(<span class="keyword">new</span> Rect(width / <span class="number">2</span> - <span class="number">100</span>, height / <span class="number">2</span> - <span class="number">100</span>, width / <span class="number">2</span> + <span class="number">100</span>, height / <span class="number">2</span> + <span class="number">100</span>), options);</span><br><span class="line">mImageView.setImageBitmap(bitmap);</span><br></pre></td></tr></table></figure></p>
<p>更详细的实现可见：<a href="https://blog.csdn.net/lmj623565791/article/details/49300989/" target="_blank" rel="noopener">Android 高清加载巨图方案 拒绝压缩图片</a><br>不过这种方法虽然也能加载大图，但做的还不够，滑动时内存抖动，卡顿现象比较明显，不能用于线上<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a433a5e33dfb47b8a60a76eebeb11e13~tplv-k3u1fbpfcp-zoom-1.image" alt><br>下面介绍一种可以用于线上的大图加载方案     </p>
<h3 id="5-2-可用于线上的大图加载方案"><a href="#5-2-可用于线上的大图加载方案" class="headerlink" title="5.2 可用于线上的大图加载方案"></a>5.2 可用于线上的大图加载方案</h3><p>介绍一个开源库：<a href="https://github.com/davemorrissey/subsampling-scale-image-view" target="_blank" rel="noopener">subsampling-scale-image-view</a><br><code>SubsamplingScaleImageView</code>将大图切片，再判断是否可见，如果可见则加入内存中，否则回收，减少了内存占用与抖动 同时根据不同的缩放比例选择合适的采样率，进一步减少内存占用 同时在子线程进行decodeRegion操作，解码成功后回调至主线程，减少UI卡顿.</p>
<p>之前我也做<code>BitmapRegionDecoder</code>与<code>SubsamplingScaleImageView</code>的内存分析<br>有兴趣的同学也可以了解下:<a href="https://juejin.cn/post/6870389004387385352" target="_blank" rel="noopener">Android性能优化之UI卡顿优化实例分析</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要以<code>Glide</code>做了哪些优化为切入点，回答了如下几个问题<br>1.说一下<code>Glide</code>图片加载的总体流程<br>2.<code>Glide</code>缓存机制做了哪些优化？<br>3.<code>Glide</code>做了哪些内存优化？<br>4.<code>Glide</code>如何管理生命周期?<br>5.<code>Glide</code>怎么做大图加载?    </p>
<p>如果对您有所帮助，欢迎点赞，谢谢~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844903986412126216" target="_blank" rel="noopener">面试官：简历上最好不要写Glide，不是问源码那么简单</a><br><a href="https://juejin.cn/post/6844904002551808013" target="_blank" rel="noopener">聊一聊关于Glide在面试中的那些事</a><br><a href="https://juejin.cn/post/6844903953604280328" target="_blank" rel="noopener">从源码的角度分析 Glide 缓存策略</a><br><a href="https://juejin.cn/post/6844904099297624077" target="_blank" rel="noopener">【优化篇】不使用第三方库，Bitmap的优化策略</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【开源项目】Compose 版 SmartRefreshLayout,了解一下~</title>
    <url>/blog/2021/10/compose-refresh-layout.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>下拉刷新是我们开发中的常见的需求，官方提供了<code>SwipeRefreshLayout</code>来实现下拉刷新，但我们常常需要定制<code>Header</code>或者<code>Header</code>与内容一起向下滚动，因此<code>SwipeRefreshLayout</code>往往不能满足我们的需求<br>在使用<code>XML</code>开发时,<code>Github</code>上有不少开源库如<a href="https://github.com/scwang90/SmartRefreshLayout" target="_blank" rel="noopener">SmartRefreshLayout</a>实现了下拉刷新功能，可以方便地定制化<code>Header</code>与滚动方式<br>本文主要介绍如何开发一个简单易用的<code>Compose</code>版<code>SmartRefreshLayout</code>,快速实现下拉刷新功能，如果对您有所帮助可以点个<code>Star</code>:<a href="https://github.com/shenzhen2017/compose-refreshlayout" target="_blank" rel="noopener">Compose版SmartRefreshLayout</a></p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>我们首先看下最终的效果图</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本使用</th>
<th style="text-align:center">自定义Header</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p1.gif" alt></td>
<td style="text-align:center"><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p2.gif" alt></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">Lottie Header</th>
<th style="text-align:center">FixedBehind(固定在背后)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p3.gif" alt></td>
<td style="text-align:center"><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p4.gif" alt></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">FixedFront(固定在前面)</th>
<th style="text-align:center">FixedContent(内容固定)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p5.gif" alt></td>
<td style="text-align:center"><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p6.gif" alt></td>
</tr>
</tbody>
</table>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol>
<li>接入方便，使用简单，快速实现下拉刷新功能         </li>
<li>支持自定义<code>Header</code>,<code>Header</code>可观察下拉状态并更新<code>UI</code>     </li>
<li>自定义<code>Header</code>支持<code>Lottie</code>,并支持观察下拉状态开始与暂停动画     </li>
<li>支持自定义<code>Translate</code>,<code>FixedBehind</code>,<code>FixedFront</code>,<code>FixedContent</code>等滚动方式       </li>
<li>支持与<code>Paging</code>结合实现上滑加载更多功能</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="接入"><a href="#接入" class="headerlink" title="接入"></a>接入</h3><p>第 1 步:在工程的<code>build.gradle</code>中添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">	repositories &#123;</span><br><span class="line">		...</span><br><span class="line">		mavenCentral()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第2步：在应用的<code>build.gradle</code>中添加：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">        implementation <span class="string">'io.github.shenzhen2017:compose-refreshlayout:1.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p><code>SwipeRefreshLayout</code>函数主要包括以下参数:   </p>
<ol>
<li><code>isRefreshing</code>: 是否正在刷新    </li>
<li><code>onRefresh</code>: 触发刷新回调     </li>
<li><code>modifier</code>: 样式修饰符</li>
<li><code>swipeStyle</code>: 下拉刷新方式      </li>
<li><code>swipeEnabled</code>: 是否允许下拉刷新   </li>
<li><code>refreshTriggerRate</code>: 刷新生效高度与<code>indicator</code>高度的比例       </li>
<li><code>maxDragRate</code>: 最大刷新距离与<code>indicator</code>高度的比例</li>
<li><code>indicator</code>: 自定义的<code>indicator</code>,有默认值</li>
</ol>
<p>在默认情况下，我们只需要传入<code>isRefreshing</code>(是否正在刷新)与<code>onRefresh</code>触发刷新回调两个参数即可<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">BasicSample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> refreshing <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">    LaunchedEffect(refreshing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (refreshing) &#123;</span><br><span class="line">            delay(<span class="number">2000</span>)</span><br><span class="line">            refreshing = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SwipeRefreshLayout(isRefreshing = refreshing, onRefresh = &#123; refreshing = <span class="literal">true</span> &#125;) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示:在触发刷新回调时将<code>refreshing</code>设置为<code>true</code>,并在刷新完成后设置为<code>false</code>即可实现简单的下拉刷新功能     </p>
<h3 id="自定义Header"><a href="#自定义Header" class="headerlink" title="自定义Header"></a>自定义<code>Header</code></h3><p><code>SwipeRefreshLayout</code>支持传入自定义的<code>Header</code>，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CustomHeaderSample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> refreshing <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="literal">false</span>) &#125;</span><br><span class="line">    LaunchedEffect(refreshing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (refreshing) &#123;</span><br><span class="line">            delay(<span class="number">2000</span>)</span><br><span class="line">            refreshing = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SwipeRefreshLayout(</span><br><span class="line">        isRefreshing = refreshing,</span><br><span class="line">        onRefresh = &#123; refreshing = <span class="literal">true</span> &#125;,</span><br><span class="line">        indicator = &#123;</span><br><span class="line">            BallRefreshHeader(state = it)</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">        	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示：<code>BallRefreshHeader</code>即为自定义的<code>Header</code>,<code>Header</code>中会传入<code>SwipeRefreshState</code>，我们通过<code>SwipeRefreshState</code>可获得以下参数    </p>
<ol>
<li><code>isRefreshing</code>: 是否正在刷新    </li>
<li><code>isSwipeInProgress</code>: 是否正在滚动     </li>
<li><code>maxDrag</code>: 最大下拉距离           </li>
<li><code>refreshTrigger</code>: 刷新触发距离    </li>
<li><code>headerState</code>: 刷新状态，包括<code>PullDownToRefresh</code>,<code>Refreshing</code>,<code>ReleaseToRefresh</code>三个状态     </li>
<li><code>indicatorOffset</code>: <code>Header</code>偏移量</li>
</ol>
<p>这些参数都是<code>MutableState</code>我们可以观察这些参数的变化以实现<code>Header UI</code>的更新  </p>
<h3 id="自定义Lottile-Header"><a href="#自定义Lottile-Header" class="headerlink" title="自定义Lottile Header"></a>自定义<code>Lottile Header</code></h3><p><code>Compose</code>目前已支持<code>Lottie</code>，我们接入<code>Lottie</code>依赖后，就可以很方便地实现一个<code>Lottie Header</code>，并且在正在刷新时播放动画，其它时间暂停动画，示例如下：    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LottieHeaderOne</span><span class="params">(state: <span class="type">SwipeRefreshState</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isPlaying <span class="keyword">by</span> remember &#123;</span><br><span class="line">        mutableStateOf(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> speed <span class="keyword">by</span> remember &#123;</span><br><span class="line">        mutableStateOf(<span class="number">1f</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    isPlaying = state.isRefreshing</span><br><span class="line">    <span class="keyword">val</span> lottieComposition <span class="keyword">by</span> rememberLottieComposition(</span><br><span class="line">        spec = LottieCompositionSpec.RawRes(R.raw.refresh_one),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> lottieAnimationState <span class="keyword">by</span> animateLottieCompositionAsState(</span><br><span class="line">        composition = lottieComposition, <span class="comment">// 动画资源句柄</span></span><br><span class="line">        iterations = LottieConstants.IterateForever, <span class="comment">// 迭代次数</span></span><br><span class="line">        isPlaying = isPlaying, <span class="comment">// 动画播放状态</span></span><br><span class="line">        speed = speed, <span class="comment">// 动画速度状态</span></span><br><span class="line">        restartOnPlay = <span class="literal">false</span> <span class="comment">// 暂停后重新播放是否从头开始</span></span><br><span class="line">    )</span><br><span class="line">    Box(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .fillMaxWidth()</span><br><span class="line">            .wrapContentHeight(), contentAlignment = Alignment.Center</span><br><span class="line">    ) &#123;</span><br><span class="line">        LottieAnimation(</span><br><span class="line">            lottieComposition,</span><br><span class="line">            lottieAnimationState,</span><br><span class="line">            modifier = Modifier.size(<span class="number">150</span>.dp)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义下滑方式"><a href="#自定义下滑方式" class="headerlink" title="自定义下滑方式"></a>自定义下滑方式</h3><p><code>SwipeRefreshLayout</code>支持以下4种下滑方式<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">SwipeRefreshStyle</span> </span>&#123;</span><br><span class="line">    Translate,  <span class="comment">//平移，即内容与Header一起向下滑动，Translate为默认样式</span></span><br><span class="line">    FixedBehind, <span class="comment">//固定在背后，即内容向下滑动，Header不动</span></span><br><span class="line">    FixedFront, <span class="comment">//固定在前面, 即Header固定在前，Header与Content都不滑动</span></span><br><span class="line">    FixedContent <span class="comment">//内容固定,Header向下滑动,即官方样式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，其中默认方式为<code>Translate</code>,即内容与<code>Header</code>一起向下滑动<br>各位可根据需求选择相应的下滑方式，比如要实现类似官方的下滑效果，即可使用<code>FixedContent</code>    </p>
<h3 id="上拉加载更多"><a href="#上拉加载更多" class="headerlink" title="上拉加载更多"></a>上拉加载更多</h3><p>在<code>Compose</code>中，上拉加载更多直接使用<code>Paging3</code>看起来已经足够用了，因此本库没有实现上拉加载更多相关功能<br>因此如果想要实现上拉加载更多，可自行结合<code>Paging3</code>使用     </p>
<h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><p>下拉刷新功能，其实主要是嵌套滚动的问题,我们将<code>Header</code>与<code>Content</code>放到一个父布局中统一管理，然后需要做以下事           </p>
<ol>
<li>当我们的手指向下滚动时，首先交由<code>Content</code>处理，如果<code>Content</code>滚动到顶部了，再交由父布局处理，然后父布局根据手势进行一定的偏移,增加<code>offset</code>      </li>
<li>当我们松手时，判断偏移的距离，如果大于刷新触发距离则触发刷新，否则回弹到顶部(<code>offset</code>置为0)</li>
<li>当我们手指向上滚动时，首先交由父布局处理，如果父布局的<code>offset</code>&gt;0则由父布局处理，减少<code>offset</code>，否则则由<code>Content</code>消费手势    </li>
</ol>
<h3 id="NestedScrollConnection介绍"><a href="#NestedScrollConnection介绍" class="headerlink" title="NestedScrollConnection介绍"></a><code>NestedScrollConnection</code>介绍</h3><p>为了实现上面说的需求，我们需要对滚动进行拦截，<code>Compose</code>提供了<code>NestedScrollConnection</code>来实现嵌套滚动<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NestedScrollConnection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPreScroll</span><span class="params">(available: <span class="type">Offset</span>, source: <span class="type">NestedScrollSource</span>)</span></span>: Offset = Offset.Zero</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onPostScroll</span><span class="params">(consumed: <span class="type">Offset</span>, available: <span class="type">Offset</span>, source: <span class="type">NestedScrollSource</span>)</span></span>: Offset = Offset.Zero</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreFling</span><span class="params">(available: <span class="type">Velocity</span>)</span></span>: Velocity = Velocity.Zero</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostFling</span><span class="params">(consumed: <span class="type">Velocity</span>, available: <span class="type">Velocity</span>)</span></span> = <span class="keyword">return</span> Velocity.Zero</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，<code>NestedScrollConnection</code>主要提供了4个接口   </p>
<ol>
<li><code>onPreScroll</code>: 先拦截滑动事件，消费后再交给子布局     </li>
<li><code>onPostScroll</code>: 子布局处理完滑动事件后再交给父布局，可获取当前还剩下多少可用的滑动事件偏移量     </li>
<li><code>onPreFling</code>: <code>Fling</code>开始前回调    </li>
<li><code>onPostFling</code>: <code>Fling</code>完成后回调    </li>
</ol>
<blockquote>
<p><code>Fling</code>含义：当我们手指在滑动列表时，如果是快速滑动并抬起，则列表会根据惯性继续飘一段距离后停下，这个行为就是 <code>Fling</code> ，<code>onPreFling</code> 在你手指刚抬起时便会回调，而 <code>onPostFling</code> 会在飘一段距离停下后回调。</p>
</blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>上面我们已经介绍了总体思路与<code>NestedScrollConnection API</code>，然后我们应该需要重写以下方法     </p>
<ol>
<li><code>onPostScroll</code>: 当<code>Content</code>滑动到顶部时，如果继续往上滑，我们就应该增加父布局的<code>offset</code>,因此在<code>onPostScroll</code>中判断<code>available.y &gt; 0</code>，然后进行相应的偏移,对我们来说是个合适的时机      </li>
<li><code>onPreScroll</code>: 当我们上滑时，如果<code>offset&gt;0</code>,则说明父布局有偏移，因此我们应先减小父布局的<code>offset</code>直到0,然后将剩余的偏移量传递给<code>Content</code>，因此下滑时应该使用<code>onPreScroll</code>拦截判断    </li>
<li><code>onPreFling</code>: 当我们松开手时，应判断当前的偏移量是否大于刷新触发距离，如果大于则触发刷新，否则父布局的<code>offset</code>置为0,这个判断在<code>onPreFling</code>时做比较合适    </li>
</ol>
<p>具体实现如下：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">SwipeRefreshNestedScrollConnection</span></span>() : NestedScrollConnection &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        available: <span class="type">Offset</span>,source: <span class="type">NestedScrollSource</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Offset = <span class="keyword">when</span> &#123;</span><br><span class="line">        <span class="comment">// 如果用户正在上滑，需要在这里拦截处理</span></span><br><span class="line">        source == NestedScrollSource.Drag &amp;&amp; available.y &lt; <span class="number">0</span> -&gt; onScroll(available)</span><br><span class="line">        <span class="keyword">else</span> -&gt; Offset.Zero</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostScroll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        consumed: <span class="type">Offset</span>,available: <span class="type">Offset</span>,source: <span class="type">NestedScrollSource</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: Offset = <span class="keyword">when</span> &#123;</span><br><span class="line">        <span class="comment">// 如果用户正在下拉，在这里处理剩余的偏移量</span></span><br><span class="line">        source == NestedScrollSource.Drag &amp;&amp; available.y &gt; <span class="number">0</span> -&gt; onScroll(available)</span><br><span class="line">        <span class="keyword">else</span> -&gt; Offset.Zero</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreFling</span><span class="params">(available: <span class="type">Velocity</span>)</span></span>: Velocity &#123;</span><br><span class="line">        <span class="comment">//如果偏移量大于刷新触发距离，则触发刷新</span></span><br><span class="line">        <span class="keyword">if</span> (!state.isRefreshing &amp;&amp; state.indicatorOffset &gt;= refreshTrigger) &#123;</span><br><span class="line">            onRefresh()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不消费速度，直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> Velocity.Zero</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍如何使用及实现一个<code>Compose</code>版的<code>SmartRefreshLayout</code>，它具有以下特性:     </p>
<ol>
<li>接入方便，使用简单，快速实现下拉刷新功能         </li>
<li>支持自定义<code>Header</code>,<code>Header</code>可观察下拉状态并更新<code>UI</code>     </li>
<li>自定义<code>Header</code>支持<code>Lottie</code>,并支持观察下拉状态开始与暂停动画     </li>
<li>支持自定义<code>Translate</code>,<code>FixedBehind</code>,<code>FixedFront</code>,<code>FixedContent</code>等滚动方式       </li>
<li>支持与<code>Paging</code>结合实现上滑加载更多功能   </li>
</ol>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shenzhen2017/compose-refreshlayout" target="_blank" rel="noopener">Compose版SmartRefreshLayout</a><br>开源不易，如果项目对你有所帮助，欢迎点赞,<code>Star</code>,收藏~   </p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>【知识点】OkHttp 原理 8 连问</title>
    <url>/blog/2021/10/okhttp-knowledge-sum.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>OkHttp</code>可以说是<code>Android</code>开发中最常见的网络请求框架,<code>OkHttp</code>使用方便，扩展性强，功能强大，<code>OKHttp</code>源码与原理也是面试中的常客<br>但是<code>OKHttp</code>的源码内容比较多，想要学习它的源码往往千头万绪，一时抓不住重点.<br>本文从几个问题出发梳理<code>OKHttp</code>相关知识点，以便快速构建<code>OKHttp</code>知识体系，如果对你有用，欢迎点赞~     </p>
<p>本文主要包括以下内容     </p>
<ol>
<li><code>OKHttp</code>请求的整体流程是怎样的?    </li>
<li><code>OKHttp</code>分发器是怎样工作的?     </li>
<li><code>OKHttp</code>拦截器是如何工作的?    </li>
<li>应用拦截器和网络拦截器有什么区别?      </li>
<li><code>OKHttp</code>如何复用<code>TCP</code>连接?    </li>
<li><code>OKHttp</code>空闲连接如何清除?     </li>
<li><code>OKHttp</code>有哪些优点?    </li>
<li><code>OKHttp</code>框架中用到了哪些设计模式?      </li>
</ol>
<h2 id="1-OKHttp请求整体流程介绍"><a href="#1-OKHttp请求整体流程介绍" class="headerlink" title="1. OKHttp请求整体流程介绍"></a>1. <code>OKHttp</code>请求整体流程介绍</h2><p>首先来看一个最简单的<code>Http</code>请求是如何发送的。<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> okHttpClient = OkHttpClient()</span><br><span class="line"><span class="keyword">val</span> request: Request = Request.Builder()</span><br><span class="line">    .url(<span class="string">"https://www.google.com/"</span>)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">object</span> :Callback&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFailure</span><span class="params">(call: <span class="type">Call</span>, e: <span class="type">IOException</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResponse</span><span class="params">(call: <span class="type">Call</span>, response: <span class="type">Response</span>)</span></span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这段代码看起来比较简单,<code>OkHttp</code>请求过程中最少只需要接触<code>OkHttpClient</code>、<code>Request</code>、<code>Call</code>、 <code>Response</code>，但是框架内部会进行大量的逻辑处理。<br>所有网络请求的逻辑大部分集中在拦截器中，但是在进入拦截器之前还需要依靠分发器来调配请求任务。<br>关于分发器与拦截器，我们在这里先简单介绍下，后续会有更加详细的讲解    </p>
<ul>
<li>分发器:内部维护队列与线程池，完成请求调配; </li>
<li>拦截器:五大默认拦截器完成整个请求过程。</li>
</ul>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/newImage/master/blog4/p12.png" alt><br>整个网络请求过程大致如上所示      </p>
<ol>
<li>通过建造者模式构建<code>OKHttpClient</code>与 <code>Request</code>     </li>
<li><code>OKHttpClient</code>通过<code>newCall</code>发起一个新的请求   </li>
<li>通过分发器维护请求队列与线程池，完成请求调配   </li>
<li>通过五大默认拦截器完成请求重试，缓存处理，建立连接等一系列操作    </li>
<li>得到网络请求结果</li>
</ol>
<h2 id="2-OKHttp分发器是怎样工作的"><a href="#2-OKHttp分发器是怎样工作的" class="headerlink" title="2. OKHttp分发器是怎样工作的?"></a>2. <code>OKHttp</code>分发器是怎样工作的?</h2><p>分发器的主要作用是维护请求队列与线程池,比如我们有100个异步请求，肯定不能把它们同时请求，而是应该把它们排队分个类，分为正在请求中的列表和正在等待的列表，<br>等请求完成后，即可从等待中的列表中取出等待的请求，从而完成所有的请求    </p>
<p>而这里同步请求各异步请求又略有不同   </p>
<p><strong>同步请求</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">	runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为同步请求不需要线程池，也不存在任何限制。所以分发器仅做一下记录。后续按照加入队列的顺序同步请求即可      </p>
<p><strong>异步请求</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//请求数最大不超过64,同一Host请求不能超过5个</span></span><br><span class="line">	<span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) 	  &#123;</span><br><span class="line">		runningAsyncCalls.add(call);</span><br><span class="line">		executorService().execute(call);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		readyAsyncCalls.add(call);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当正在执行的任务未超过最大限制64，同时同一<code>Host</code>的请求不超过5个，则会添加到正在执行队列，同时提交给线程池。否则先加入等待队列。<br>每个任务完成后，都会调用分发器的<code>finished</code>方法,这里面会取出等待队列中的任务继续执行     </p>
<h2 id="3-OKHttp拦截器是怎样工作的"><a href="#3-OKHttp拦截器是怎样工作的" class="headerlink" title="3. OKHttp拦截器是怎样工作的?"></a>3. <code>OKHttp</code>拦截器是怎样工作的?</h2><p>经过上面分发器的任务分发，下面就要利用拦截器开始一系列配置了<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"># RealCall</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      client.dispatcher.executed(<span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> getResponseWithInterceptorChain()</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.dispatcher.finished(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看下<code>RealCall</code>的<code>execute</code>方法，可以看出，最后返回了<code>getResponseWithInterceptorChain</code>,责任链的构建与处理其实就是在这个方法里面<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span></span>: Response &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    <span class="keyword">val</span> interceptors = mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors += client.interceptors</span><br><span class="line">    interceptors += RetryAndFollowUpInterceptor(client)</span><br><span class="line">    interceptors += BridgeInterceptor(client.cookieJar)</span><br><span class="line">    interceptors += CacheInterceptor(client.cache)</span><br><span class="line">    interceptors += ConnectInterceptor</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">      interceptors += client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors += CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> chain = RealInterceptorChain(</span><br><span class="line">        call = <span class="keyword">this</span>,interceptors = interceptors,index = <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> response = chain.proceed(originalRequest)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，构建了一个<code>OkHttp</code>拦截器的责任链<br>责任链，顾名思义，就是用来处理相关事务责任的一条执行链，执行链上有多个节点，每个节点都有机会（条件匹配）处理请求事务，如果某个节点处理完了就可以根据实际业务需求传递给下一个节点继续处理或者返回处理完毕。<br>如上所示责任链添加的顺序及作用如下表所示：       </p>
<p>拦截器                         | 作用                                                                                                                                 |<br>| ————————— | ———————————————————————————————————————————- |<br>| 应用拦截器                       | 拿到的是原始请求，可以添加一些自定义header、通用参数、参数加密、网关接入等等。                                                                                         |<br>| RetryAndFollowUpInterceptor | 处理错误重试和重定向                                                                                                                         |<br>| BridgeInterceptor           | 应用层和网络层的桥接拦截器，主要工作是为请求添加cookie、添加固定的header，比如Host、Content-Length、Content-Type、User-Agent等等，然后保存响应结果的cookie，如果响应使用gzip压缩过，则还需要进行解压。 |<br>| CacheInterceptor            | 缓存拦截器，如果命中缓存则不会发起网络请求。                                                                                                             |<br>| ConnectInterceptor          | 连接拦截器，内部会维护一个连接池，负责连接复用、创建连接（三次握手等等）、释放连接以及创建连接上的socket流。                                                                          |<br>| networkInterceptors（网络拦截器）  | 用户自定义拦截器，通常用于监控网络层的数据传输。                                                                                                           |<br>| CallServerInterceptor       | 请求拦截器，在前置准备工作完成后，真正发起了网络请求。                                                                                                        |</p>
<p>我们的网络请求就是这样经过责任链一级一级的递推下去，最终会执行到<code>CallServerInterceptor</code>的<code>intercept</code>方法，此方法会将网络响应的结果封装成一个<code>Response</code>对象并<code>return</code>。之后沿着责任链一级一级的回溯，最终就回到<code>getResponseWithInterceptorChain</code>方法的返回,如下图所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/newImage/master/blog4/p13.png" alt>     </p>
<h2 id="4-应用拦截器和网络拦截器有什么区别"><a href="#4-应用拦截器和网络拦截器有什么区别" class="headerlink" title="4. 应用拦截器和网络拦截器有什么区别?"></a>4. 应用拦截器和网络拦截器有什么区别?</h2><p>从整个责任链路来看，应用拦截器是最先执行的拦截器，也就是用户自己设置<code>request</code>属性后的原始请求，而网络拦截器位于<code>ConnectInterceptor</code>和<code>CallServerInterceptor</code>之间，此时网络链路已经准备好，只等待发送请求数据。它们主要有以下区别     </p>
<ol>
<li>首先，应用拦截器在<code>RetryAndFollowUpInterceptor</code>和<code>CacheInterceptor</code>之前，所以一旦发生错误重试或者网络重定向，网络拦截器可能执行多次，因为相当于进行了二次请求，但是应用拦截器永远只会触发一次。另外如果在<code>CacheInterceptor</code>中命中了缓存就不需要走网络请求了，因此会存在短路网络拦截器的情况。</li>
<li>其次，除了<code>CallServerInterceptor</code>之外，每个拦截器都应该至少调用一次<code>realChain.proceed</code>方法。实际上在应用拦截器这层可以多次调用<code>proceed</code>方法（本地异常重试）或者不调用<code>proceed</code>方法（中断），但是网络拦截器这层连接已经准备好，可且仅可调用一次<code>proceed</code>方法。      </li>
<li>最后，从使用场景看，应用拦截器因为只会调用一次，通常用于统计客户端的网络请求发起情况；而网络拦截器一次调用代表了一定会发起一次网络通信，因此通常可用于统计网络链路上传输的数据。</li>
</ol>
<h2 id="5-OKHttp如何复用TCP连接"><a href="#5-OKHttp如何复用TCP连接" class="headerlink" title="5. OKHttp如何复用TCP连接?"></a>5. <code>OKHttp</code>如何复用<code>TCP</code>连接?</h2><p><code>ConnectInterceptor</code>的主要工作就是负责建立<code>TCP</code>连接，建立<code>TCP</code>连接需要经历三次握手四次挥手等操作，如果每个<code>HTTP</code>请求都要新建一个<code>TCP</code>消耗资源比较多<br>而<code>Http1.1</code>已经支持<code>keep-alive</code>,即多个<code>Http</code>请求复用一个<code>TCP</code>连接，<code>OKHttp</code>也做了相应的优化，下面我们来看下<code>OKHttp</code>是怎么复用<code>TCP</code>连接的    </p>
<p><code>ConnectInterceptor</code>中查找连接的代码会最终会调用到<code>ExchangeFinder.findConnection</code>方法，具体如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># ExchangeFinder</span><br><span class="line"><span class="comment">//为承载新的数据流 寻找 连接。寻找顺序是 已分配的连接、连接池、新建连接</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="comment">// 1.尝试使用 已给数据流分配的连接.（例如重定向请求时，可以复用上次请求的连接）</span></span><br><span class="line">    releasedConnection = transmitter.connection;</span><br><span class="line">    result = transmitter.connection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2. 没有已分配的可用连接，就尝试从连接池获取。（连接池稍后详细讲解）</span></span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="keyword">null</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        result = transmitter.connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">      <span class="comment">//3. 现在有了IP地址，再次尝试从连接池获取。可能会因为连接合并而匹配。（这里传入了routes，上面的传的null）</span></span><br><span class="line">      routes = routeSelection.getAll();</span><br><span class="line">      <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">        result = transmitter.connection;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.第二次没成功，就把新建的连接，进行TCP + TLS 握手，与服务端建立连接. 是阻塞操作</span></span><br><span class="line">  result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled, call, eventListener);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">    <span class="comment">// 5. 最后一次尝试从连接池获取，注意最后一个参数为true，即要求 多路复用（http2.0）</span></span><br><span class="line">    <span class="comment">//意思是，如果本次是http2.0，那么为了保证 多路复用性，（因为上面的握手操作不是线程安全）会再次确认连接池中此时是否已有同样连接</span></span><br><span class="line">    <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">true</span>)) &#123;</span><br><span class="line">      <span class="comment">// 如果获取到，就关闭我们创建里的连接，返回获取的连接</span></span><br><span class="line">      result = transmitter.connection;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//最后一次尝试也没有的话，就把刚刚新建的连接存入连接池</span></span><br><span class="line">      connectionPool.put(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面精简了部分代码，可以看出，连接拦截器使用了5种方法查找连接    </p>
<ol>
<li>首先会尝试使用 已给请求分配的连接。（已分配连接的情况例如重定向时的再次请求，说明上次已经有了连接）     </li>
<li>若没有 已分配的可用连接，就尝试从连接池中 匹配获取。因为此时没有路由信息，所以匹配条件：<code>address</code>一致——<code>host</code>、<code>port</code>、代理等一致，且匹配的连接可以接受新的请求。     </li>
<li>若从连接池没有获取到，则传入<code>routes</code>再次尝试获取，这主要是针对<code>Http2.0</code>的一个操作,<code>Http2.0</code>可以复用<code>square.com</code>与<code>square.ca</code>的连接    </li>
<li>若第二次也没有获取到，就创建<code>RealConnection</code>实例，进行<code>TCP + TLS</code>握手，与服务端建立连接。    </li>
<li>此时为了确保<code>Http2.0</code>连接的多路复用性，会第三次从连接池匹配。因为新建立的连接的握手过程是非线程安全的，所以此时可能连接池新存入了相同的连接。         </li>
<li>第三次若匹配到，就使用已有连接，释放刚刚新建的连接；若未匹配到，则把新连接存入连接池并返回。      </li>
</ol>
<p>以上就是连接拦截器尝试复用连接的操作，流程图如下：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/14/172b2ffdbdb88963~tplv-t2oaga2asx-watermark.awebp" alt></p>
<h2 id="6-OKHttp空闲连接如何清除"><a href="#6-OKHttp空闲连接如何清除" class="headerlink" title="6. OKHttp空闲连接如何清除?"></a>6. <code>OKHttp</code>空闲连接如何清除?</h2><p>上面说到我们会建立一个<code>TCP</code>连接池，但如果没有任务了，空闲的连接也应该及时清除，<code>OKHttp</code>是如何做到的呢?<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> # RealConnectionPool</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">val</span> cleanupQueue: TaskQueue = taskRunner.newQueue()</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">val</span> cleanupTask = <span class="keyword">object</span> : Task(<span class="string">"<span class="variable">$okHttpName</span> ConnectionPool"</span>) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">runOnce</span><span class="params">()</span></span>: <span class="built_in">Long</span> = cleanup(System.nanoTime())</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> long cleanup(long now) &#123;</span><br><span class="line">   int inUseConnectionCount = <span class="number">0</span>;<span class="comment">//正在使用的连接数</span></span><br><span class="line">   int idleConnectionCount = <span class="number">0</span>;<span class="comment">//空闲连接数</span></span><br><span class="line">   RealConnection longestIdleConnection = <span class="literal">null</span>;<span class="comment">//空闲时间最长的连接</span></span><br><span class="line">   long longestIdleDurationNs = <span class="built_in">Long</span>.MIN_VALUE;<span class="comment">//最长的空闲时间</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//遍历连接：找到待清理的连接, 找到下一次要清理的时间（还未到最大空闲时间）</span></span><br><span class="line">   synchronized (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">       RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//若连接正在使用，continue，正在使用连接数+1</span></span><br><span class="line">       <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         inUseConnectionCount++;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//空闲连接数+1</span></span><br><span class="line">       idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 赋值最长的空闲时间和对应连接</span></span><br><span class="line">       long idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">       <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">         longestIdleDurationNs = idleDurationNs;</span><br><span class="line">         longestIdleConnection = connection;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  <span class="comment">//若最长的空闲时间大于5分钟 或 空闲数 大于5，就移除并关闭这个连接</span></span><br><span class="line">     <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</span><br><span class="line">         || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</span><br><span class="line">       connections.remove(longestIdleConnection);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// else，就返回 还剩多久到达5分钟，然后wait这个时间再来清理</span></span><br><span class="line">       <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//连接没有空闲的，就5分钟后再尝试清理.</span></span><br><span class="line">       <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 没有连接，不清理</span></span><br><span class="line">       cleanupRunning = <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//关闭移除的连接</span></span><br><span class="line">   closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">   <span class="comment">//关闭移除后 立刻 进行下一次的 尝试清理</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>思路还是很清晰的：      </p>
<ol>
<li>在将连接加入连接池时就会启动定时任务       </li>
<li>有空闲连接的话，如果最长的空闲时间大于5分钟 或 空闲数 大于5，就移除关闭这个最长空闲连接；如果 空闲数 不大于5 且 最长的空闲时间不大于5分钟，就返回到5分钟的剩余时间，然后等待这个时间再来清理。</li>
<li>没有空闲连接就等5分钟后再尝试清理。</li>
<li>没有连接不清理。</li>
</ol>
<p>流程如下图所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p7.png" alt>    </p>
<h2 id="7-OKHttp有哪些优点"><a href="#7-OKHttp有哪些优点" class="headerlink" title="7. OKHttp有哪些优点?"></a>7. <code>OKHttp</code>有哪些优点?</h2><ol>
<li>使用简单，在设计时使用了外观模式，将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端<code>OkHttpClient</code>统一暴露出来。     </li>
<li>扩展性强，可以通过自定义应用拦截器与网络拦截器，完成用户各种自定义的需求            </li>
<li>功能强大，支持<code>Spdy</code>、<code>Http1.X</code>、<code>Http2</code>、以及<code>WebSocket</code>等多种协议        </li>
<li>通过连接池复用底层<code>TCP</code>(<code>Socket</code>)，减少请求延时</li>
<li>无缝的支持<code>GZIP</code>减少数据流量        </li>
<li>支持数据缓存,减少重复的网络请求</li>
<li>支持请求失败自动重试主机的其他<code>ip</code>，自动重定向</li>
</ol>
<h2 id="8-OKHttp框架中用到了哪些设计模式"><a href="#8-OKHttp框架中用到了哪些设计模式" class="headerlink" title="8. OKHttp框架中用到了哪些设计模式?"></a>8. <code>OKHttp</code>框架中用到了哪些设计模式?</h2><ol>
<li>构建者模式：<code>OkHttpClient</code>与<code>Request</code>的构建都用到了构建者模式   </li>
<li>外观模式： <code>OkHttp</code>使用了外观模式,将整个系统的复杂性给隐藏起来，将子系统接口通过一个客户端<code>OkHttpClient</code>统一暴露出来。    </li>
<li>责任链模式: <code>OKHttp</code>的核心就是责任链模式，通过5个默认拦截器构成的责任链完成请求的配置    </li>
<li>享元模式: 享元模式的核心即池中复用,<code>OKHttp</code>复用<code>TCP</code>连接时用到了连接池，同时在异步请求中也用到了线程池     </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要梳理了<code>OKHttp</code>原理相关知识点，并回答了以下问题:    </p>
<ol>
<li><code>OKHttp</code>请求的整体流程是怎样的?    </li>
<li><code>OKHttp</code>分发器是怎样工作的?     </li>
<li><code>OKHttp</code>拦截器是如何工作的?    </li>
<li>应用拦截器和网络拦截器有什么区别?      </li>
<li><code>OKHttp</code>如何复用<code>TCP</code>连接?    </li>
<li><code>OKHttp</code>空闲连接如何清除?     </li>
<li><code>OKHttp</code>有哪些优点?    </li>
<li><code>OKHttp</code>框架中用到了哪些设计模式?     </li>
</ol>
<p>如果对您有所帮助，欢迎点赞，谢谢~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844904087788453896#heading-5" target="_blank" rel="noopener">面试官：听说你熟悉OkHttp原理？</a><br><a href="https://juejin.cn/post/7015532404785807397" target="_blank" rel="noopener">OkHttp源码剖析（二） 设计模式下的okhttp</a><br><a href="https://juejin.cn/post/6844904191123685389#heading-5" target="_blank" rel="noopener">你想要的系列：网络请求框架OkHttp3全解系列 - （四）拦截器详解2：连接、请求服务（重点）</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【辨析】Compose 完全脱离 View 系统了吗?</title>
    <url>/blog/2021/10/is-compose-view.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Compose</code>正式发布1.0已经相当一段时间了，但相信很多同学对<code>Compose</code>还是有很多迷惑的地方<br><code>Compose</code>跟原生的<code>View</code>到底是什么关系？是跟<code>Flutter</code>一样完全基于<code>Skia</code>引擎渲染，还是说还是<code>View</code>的那老一套?<br>相信很多同学都会有下面的疑问     </p>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p10.jpg" alt><br>下面我们就一起来看下下面这个问题</p>
<h2 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h2><p>我们先看这样一个简单布局<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> : <span class="type">ComponentActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        setContent &#123;        	</span><br><span class="line">        	ComposeBody()              </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposeBody</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(text = <span class="string">"这是一行测试数据"</span>, color = Color.Black, style = MaterialTheme.typography.h6)</span><br><span class="line">        Row() &#123;</span><br><span class="line">            Text(text = <span class="string">"测试数据1!"</span>, color = Color.Black, style = MaterialTheme.typography.h6)</span><br><span class="line">            Text(text = <span class="string">"测试数据2!"</span>, color = Color.Black, style = MaterialTheme.typography.h6)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，就是一个简单的布局，包含<code>Column</code>,<code>Row</code>与<code>Text</code><br>然后我们打开开发者选项中的<code>显示布局边界</code>，效果如下图所示：    </p>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p11.jpg" alt><br>我们可以看到<code>Compose</code>的组件显示了布局边界，我们知道，<code>Flutter</code>与<code>WebView H5</code>内的组件都是不会显示布局边界的，难道<code>Compose</code>的布局渲染其实还是<code>View</code>的那一套?      </p>
<p>我们下面再在<code>onResume</code>时尝试遍历一下<code>View</code>的层级,看一下<code>Compose</code>到底会不会转化成<code>View</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    window.decorView.postDelayed(&#123;</span><br><span class="line">        (window.decorView <span class="keyword">as</span>? ViewGroup)?.let &#123; transverse(it, <span class="number">1</span>) &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">transverse</span><span class="params">(view: <span class="type">View</span>, index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    Log.e(<span class="string">"debug"</span>, <span class="string">"第<span class="subst">$&#123;index&#125;</span>层："</span> + view)</span><br><span class="line">    <span class="keyword">if</span> (view <span class="keyword">is</span> ViewGroup) &#123;</span><br><span class="line">        view.children.forEach &#123; transverse(it, index + <span class="number">1</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过以上方式打印页面的层级，输出结果如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">E/debug: 第1层：DecorView@c2f703f[RallyActivity]</span><br><span class="line">E/debug: 第2层：android.widget.LinearLayout&#123;4202d0c V.E...... ........ 0,0-1080,2340&#125;</span><br><span class="line">E/debug: 第3层：android.view.ViewStub&#123;2b50655 G.E...... ......I. 0,0-0,0 #10201b1 android:id/action_mode_bar_stub&#125;</span><br><span class="line">E/debug: 第3层：android.widget.FrameLayout&#123;9bfc86a V.E...... ........ 0,90-1080,2340 #1020002 android:id/content&#125;</span><br><span class="line">E/debug: 第4层：androidx.compose.ui.platform.ComposeView&#123;1b4d15b V.E...... ........ 0,0-1080,2250&#125;</span><br><span class="line">E/debug: 第5层：androidx.compose.ui.platform.AndroidComposeView&#123;a8ec543 VFED..... ........ 0,0-1080,2250&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，我们写的<code>Column</code>,<code>Row</code>,<code>Text</code>并没有出现在布局层级中，跟<code>Compose</code>相关的只有<code>ComposeView</code>与<code>AndroidComposeView</code>两个<code>View</code><br>而<code>ComposeView</code>与<code>AndroidComposeView</code>都是在<code>setContent</code>时添加进去的<code>Compose</code>的容器，我们后面再分析，这里先给出结论       </p>
<blockquote>
<p><code>Compose</code>在渲染时并不会转化成<code>View</code>，而是只有一个入口<code>View</code>，即<code>AndroidComposeView</code><br>我们声明的<code>Compose</code>布局在渲染时会转化成<code>NodeTree</code>,<code>AndroidComposeView</code>中会触发<code>NodeTree</code>的布局与绘制<br>总得来说，<code>Compose</code>会有一个<code>View</code>的入口，但它的布局与渲染还是在<code>LayoutNode</code>上完成的，基本脱离了<code>View</code>       </p>
</blockquote>
<p>总得来说，纯<code>Compose</code>页面的页面层级如下图所示：    </p>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p13.png" alt>   </p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>我们知道，在<code>View</code>系统中会有一棵<code>ViewTree</code>,通过一个树的数据结构来描述整个<code>UI</code>界面<br>在<code>Compose</code>中，我们写的代码在渲染时也会构建成一个<code>NodeTree</code>,每一个组件就是一个<code>ComposeNode</code>,作为<code>NodeTree</code>上的一个节点    </p>
<p><code>Compose</code> 对 <code>NodeTree</code> 管理涉及 <code>Applier</code>、<code>Composition</code> 和 <code>ComposeNode</code>：<br><code>Composition</code> 作为起点，发起首次的 <code>composition</code>，通过 <code>Compose</code> 的执行，填充 <code>Slot Table</code>，并基于 <code>Table</code> 创建 <code>NodeTree</code>。渲染引擎基于 <code>Compose Nodes</code> 渲染 <code>UI</code>， 每当 <code>recomposition</code> 发生时，都会通过 <code>Applier</code> 对 <code>NodeTree</code> 进行更新。 因此</p>
<blockquote>
<p><code>Compose</code> 的执行过程就是创建 <code>Node</code> 并构建 <code>NodeTree</code> 的过程。 </p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e512fa77b2744b68291b7b1847097c3~tplv-k3u1fbpfcp-watermark.awebp" alt><br>为了了解<code>NodeTree</code>的构建过程，我们来介绍下面几个概念  </p>
<h4 id="Applier：增删-NodeTree-的节点"><a href="#Applier：增删-NodeTree-的节点" class="headerlink" title="Applier：增删 NodeTree 的节点"></a><code>Applier</code>：增删 <code>NodeTree</code> 的节点</h4><p>简单来说,<code>Applier</code>的作用就是增删<code>NodeTree</code>的节点，每个<code>NodeTree</code>的运算都需要配套一个<code>Applier</code>。<br>同时,<code>Applier</code> 会提供回调，基于回调我们可以对 <code>NodeTree</code> 进行自定义修改：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Applier</span>&lt;<span class="type">N</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> current: N <span class="comment">// 当前处理的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onBeginChanges</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onEndChanges</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">down</span><span class="params">(node: <span class="type">N</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertTopDown</span><span class="params">(index: <span class="type">Int</span>, instance: <span class="type">N</span>)</span></span> <span class="comment">// 添加节点（自顶向下）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">insertBottomUp</span><span class="params">(index: <span class="type">Int</span>, instance: <span class="type">N</span>)</span></span><span class="comment">// 添加节点（自底向上）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">remove</span><span class="params">(index: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> <span class="comment">//删除节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">move</span><span class="params">(from: <span class="type">Int</span>, to: <span class="type">Int</span>, count: <span class="type">Int</span>)</span></span> <span class="comment">// 移动节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">clear</span><span class="params">()</span></span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，节点增删时会回调到<code>Applier</code>中，我们可以在回调的方法中自定义节点添加或删除时的逻辑，后面我们可以一起看下在<code>Android</code>平台<code>Compose</code>是怎样处理的    </p>
<h4 id="Composition-Compose执行的起点"><a href="#Composition-Compose执行的起点" class="headerlink" title="Composition: Compose执行的起点"></a><code>Composition</code>: <code>Compose</code>执行的起点</h4><p><code>Composition</code>是<code>Compose</code>执行的起点,我们来看下如何创建一个<code>Composition</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> composition = Composition(</span><br><span class="line">    applier = NodeApplier(node = Node()),</span><br><span class="line">    parent = Recomposer(Dispatchers.Main)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">composition.setContent &#123;</span><br><span class="line">    <span class="comment">// Composable function calls</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示     </p>
<ol>
<li><code>Composition</code>中需要传入两个参数，<code>Applier</code>与<code>Recomposer</code>    </li>
<li><code>Applier</code>上面已经介绍过了，<code>Recomposer</code>非常重要，他负责<code>Compose</code>的重组，当重组后，<code>Recomposer</code> 通过调用 <code>Applier</code> 完成 <code>NodeTree</code> 的变更     </li>
<li><code>Composition#setContent</code> 为后续 <code>Compose</code> 的调用提供了容器   </li>
</ol>
<p>通过上面的介绍，我们了解了<code>NodeTree</code>构建的基本流程，下面我们一起来分析下<code>setContent</code>的源码    </p>
<h3 id="setContent过程分析"><a href="#setContent过程分析" class="headerlink" title="setContent过程分析"></a><code>setContent</code>过程分析</h3><h4 id="setContent入口"><a href="#setContent入口" class="headerlink" title="setContent入口"></a><code>setContent</code>入口</h4><p><code>setContent</code>的源码其实比较简单，我们一起来看下:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> ComponentActivity.<span class="title">setContent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    parent: <span class="type">CompositionContext</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//判断ComposeView是否存在，如果存在则不创建</span></span><br><span class="line">    <span class="keyword">if</span> (existingComposeView != <span class="literal">null</span>) with(existingComposeView) &#123;</span><br><span class="line">        setContent(content)</span><br><span class="line">    &#125; <span class="keyword">else</span> ComposeView(<span class="keyword">this</span>).apply &#123;</span><br><span class="line">        <span class="comment">//将Compose content添加到ComposeView上</span></span><br><span class="line">        setContent(content)</span><br><span class="line">        <span class="comment">// 将ComposeView添加到DecorView上</span></span><br><span class="line">        setContentView(<span class="keyword">this</span>, DefaultActivityContentLayoutParams)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面就是<code>setContent</code>的入口，主要作用就是创建了一个<code>ComposeView</code>并添加到<code>DecorView</code>上      </p>
<h4 id="Composition的创建"><a href="#Composition的创建" class="headerlink" title="Composition的创建"></a><code>Composition</code>的创建</h4><p>下面我们来看下<code>AndroidComposeView</code>与<code>Composition</code>是怎样创建的<br>通过<code>ComposeView#setContent</code>-&gt;<code>AbstractComposeView#createComposition</code>-&gt;<code>AbstractComposeView#ensureCompositionCreated</code>-&gt;<code>ViewGroup#setContent</code><br>最后会调用到<code>doSetContent</code>方法，这里就是<code>Compose</code>的入口：<code>Composition</code>创建的地方<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetContent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    owner: <span class="type">AndroidComposeView</span>, <span class="comment">//AndroidComposeView是owner</span></span></span></span><br><span class="line"><span class="function"><span class="params">    parent: <span class="type">CompositionContext</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    content: @<span class="type">Composable</span> () -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Composition &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="comment">//创建Composition,并传入Applier与Recomposer</span></span><br><span class="line">    <span class="keyword">val</span> original = Composition(UiApplier(owner.root), parent)</span><br><span class="line">    <span class="keyword">val</span> wrapped = owner.view.getTag(R.id.wrapped_composition_tag)</span><br><span class="line">        <span class="keyword">as</span>? WrappedComposition</span><br><span class="line">        ?: WrappedComposition(owner, original).also &#123;</span><br><span class="line">            owner.view.setTag(R.id.wrapped_composition_tag, it)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//将Compose内容添加到Composition中   </span></span><br><span class="line">    wrapped.setContent(content)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，主要就是创建一个<code>Composition</code>并传入<code>UIApplier</code>与<code>Recomposer</code>,并将<code>Compose content</code>传入<code>Composition</code>中    </p>
<h4 id="UiApplier的实现"><a href="#UiApplier的实现" class="headerlink" title="UiApplier的实现"></a><code>UiApplier</code>的实现</h4><p>上面已经创建了<code>Composition</code>并传入了<code>UIApplier</code>，后续添加了<code>Node</code>都会回调到<code>UIApplier</code>中<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">UiApplier</span></span>(</span><br><span class="line">    root: LayoutNode</span><br><span class="line">) : AbstractApplier&lt;LayoutNode&gt;(root) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertBottomUp</span><span class="params">(index: <span class="type">Int</span>, instance: <span class="type">LayoutNode</span>)</span></span> &#123;</span><br><span class="line">        current.insertAt(index, instance)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，在插入节点时，会调用<code>current.insertAt</code>方法，那么这个<code>current</code>到底是什么呢？<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSetContent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    owner: <span class="type">AndroidComposeView</span>, <span class="comment">//AndroidComposeView是owner</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Composition &#123;</span><br><span class="line">    <span class="comment">//UiApplier传入的参数即为AndroidComposeView.root</span></span><br><span class="line">    <span class="keyword">val</span> original = Composition(UiApplier(owner.root), parent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplier</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">val</span> root: T) : Applier&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> stack = mutableListOf&lt;T&gt;()</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> current: T = root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，<code>UiApplier</code>中传入的参数其实就是<code>AndroidComposeView</code>的<code>root</code>，即<code>current</code>就是<code>AndroidComposeView</code>的<code>root</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"># AndroidComposeView</span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> root = LayoutNode().also &#123;</span><br><span class="line">       it.measurePolicy = RootMeasurePolicy</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，<code>root</code>其实就是一个<code>LayoutNode</code>,通过上面我们知道，所有的节点都会通过<code>Applier</code>插入到<code>root</code>下    </p>
<h4 id="布局与绘制入口"><a href="#布局与绘制入口" class="headerlink" title="布局与绘制入口"></a>布局与绘制入口</h4><p>上面我们已经在<code>AndroidComposeView</code>中拿到<code>NodeTree</code>的根结点了，那<code>Compose</code>的布局与测量到底是怎么触发的呢?<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"># AndroidComposeView</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispatchDraw</span><span class="params">(canvas: <span class="type">android</span>.<span class="type">graphics</span>.<span class="type">Canvas</span>)</span></span> &#123;</span><br><span class="line">   	<span class="comment">//Compose测量与布局入口</span></span><br><span class="line">       measureAndLayout()</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//Compose绘制入口</span></span><br><span class="line">       canvasHolder.drawInto(canvas) &#123; root.draw(<span class="keyword">this</span>) &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">measureAndLayout</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">val</span> rootNodeResized = measureAndLayoutDelegate.measureAndLayout()</span><br><span class="line">       measureAndLayoutDelegate.dispatchOnPositionedCallbacks()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，<code>AndroidComposeView</code>会通过<code>root</code>,向下遍历它的子节点进行测量布局与绘制，这里就是<code>LayoutNode</code>绘制的入口    </p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><code>Compose</code>在构建<code>NodeTree</code>的过程中主要通过<code>Composition</code>,<code>Applier</code>,<code>Recomposer</code>构建,<code>Applier</code>会将所有节点添加到<code>AndroidComposeView</code>中的<code>root</code>节点下      </li>
<li>在<code>setContent</code>的过程中，会创建<code>ComposeView</code>与<code>AndroidComposeView</code>,其中<code>AndroidComposeView</code>是<code>Compose</code>的入口     </li>
<li><code>AndroidComposeView</code>在<code>dispatchDraw</code>中会通过<code>root</code>向下遍历子节点进行测量布局与绘制，这里是<code>LayoutNode</code>绘制的入口    </li>
<li>在<code>Android</code>平台上，<code>Compose</code>的布局与绘制已基本脱离<code>View</code>体系，但仍然依赖于<code>Canvas</code>      </li>
</ol>
<h2 id="Compose与跨平台"><a href="#Compose与跨平台" class="headerlink" title="Compose与跨平台"></a><code>Compose</code>与跨平台</h2><p>上面说到，<code>Compose</code>的绘制仍然依赖于<code>Canvas</code>，但既然这样，<code>Compose</code>是怎么做到跨平台的呢?<br><strong>这主要是通过良好的分层设计</strong>    </p>
<p><code>Compose</code> 在代码上自下而上依次分为6层：    </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cc64a9871164d2e94f1f654c8490945~tplv-k3u1fbpfcp-watermark.awebp" alt><br>其中<code>compose.runtime</code>和<code>compose.compiler</code>最为核心，它们是支撑声明式UI的基础。     </p>
<p>而我们上面分析的<code>AndroidComposeView</code>这一部分，属于<code>compose.ui</code>部分，它主要负责<code>Android</code>设备相关的基础<code>UI</code>能力，例如 <code>layout</code>、<code>measure</code>、<code>drawing</code>、<code>input</code> 等<br>但这一部分是可以被替换的，<code>compose.runtime</code> 提供了 <code>NodeTree</code> 管理等基础能力，此部分与平台无关，在此基础上各平台只需实现<code>UI</code>的渲染就是一套完整的声明式<code>UI</code>框架       </p>
<p>基于<code>compose.runtime</code>可以实现任意一套声明式<code>UI</code>框架,关于<code>compose.runtime</code>的详细介绍可参考<code>fundroid</code>大佬写的：<a href="https://juejin.cn/post/6976435919666544653" target="_blank" rel="noopener">Jetpack Compose Runtime : 声明式 UI 的基础
</a></p>
<h2 id="Button的特殊情况"><a href="#Button的特殊情况" class="headerlink" title="Button的特殊情况"></a><code>Button</code>的特殊情况</h2><p>上面我们介绍了在纯<code>Compose</code>项目下，<code>AndroidComposeView</code>不会有子<code>View</code>,而是遍历<code>LayoutnNode</code>来布局测量绘制<br>但如果我们在代码中加入一个<code>Button</code>，结果可能就不太一样了<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ComposeBody</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Column &#123;</span><br><span class="line">        Text(text = <span class="string">"这是一行测试数据"</span>, color = Color.Black, style = MaterialTheme.typography.h6)</span><br><span class="line">        Row() &#123;</span><br><span class="line">            Text(text = <span class="string">"测试数据1!"</span>, color = Color.Black, style = MaterialTheme.typography.h6)</span><br><span class="line">            Text(text = <span class="string">"测试数据2!"</span>, color = Color.Black, style = MaterialTheme.typography.h6)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Button(onClick = &#123;&#125;) &#123;</span><br><span class="line">            Text(text = <span class="string">"这是一个Button"</span>,color = Color.White)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们再看看页面的层级结构<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">E/debug: 第1层：DecorView@182e858[RallyActivity]</span><br><span class="line">E/debug: 第2层：android.widget.LinearLayout&#123;397edb1 V.E...... ........ 0,0-1080,2340&#125;</span><br><span class="line">E/debug: 第3层：android.widget.FrameLayout&#123;e2b0e17 V.E...... ........ 0,90-1080,2340 #1020002 android:id/content&#125;</span><br><span class="line">E/debug: 第4层：androidx.compose.ui.platform.ComposeView&#123;36a3204 V.E...... ........ 0,0-1080,2250&#125;</span><br><span class="line">E/debug: 第5层：androidx.compose.ui.platform.AndroidComposeView&#123;a8ec543 VFED..... ........ 0,0-1080,2250&#125;</span><br><span class="line">E/debug: 第6层：androidx.compose.material.ripple.RippleContainer&#123;28cb3ed V.E...... ......I. 0,0-0,0&#125;</span><br><span class="line">E/debug: 第7层：androidx.compose.material.ripple.RippleHostView&#123;b090222 V.ED..... ......I. 0,0-0,0&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，很明显，<code>AndroidComposeView</code>下多了两层子<code>View</code>，这是为什么呢?    </p>
<p>我们一起来看下<code>RippleHostView</code>的注释   </p>
<blockquote>
<p>Empty View that hosts a RippleDrawable as its background. This is needed as RippleDrawables cannot currently be drawn directly to a android.graphics.RenderNode (b/184760109),<br>so instead we rely on View’s internal implementation to draw to the background android.graphics.RenderNode.<br>A RippleContainer is used to manage and assign RippleHostViews when needed - see RippleContainer.getRippleHostView.</p>
</blockquote>
<p>意思也很简单，<code>Compose</code>目前还不能直接绘制水波纹效果，因此需要将水波纹效果设置为<code>View</code>的背景，这里利用<code>View</code>做了一个中转<br>然后<code>RippleHostView</code>与<code>RippleContainer</code>自然会添加到<code>AndroidComposeView</code>中，如果我们在<code>Compose</code>中使用了<code>AndroidView</code>，效果也是一样的<br>但是这种情况并没有违背我们上面说的，纯<code>Compose</code>项目下，<code>AndroidComposeView</code>下没有子<code>View</code>,因为<code>Button</code>并不是纯<code>Compose</code>的    </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要分析回答了<code>Compose</code>到底有没有完全脱离<code>View</code>系统这个问题,总结如下：   </p>
<ol>
<li><code>Compose</code>在渲染时并不会转化成<code>View</code>，而是只有一个入口<code>View</code>，即<code>AndroidComposeView</code>,纯<code>Compose</code>项目下，<code>AndroidComposeView</code>没有子<code>View</code>         </li>
<li>我们声明的<code>Compose</code>布局在渲染时会转化成<code>NodeTree</code>,<code>AndroidComposeView</code>中会触发<code>NodeTree</code>的布局与绘制,<code>AndroidComposeView#dispatchDraw</code>是绘制的入口        </li>
<li>在<code>Android</code>平台上，<code>Compose</code>的布局与绘制已基本脱离<code>View</code>体系，但仍然依赖于<code>Canvas</code>        </li>
<li>由于良好的分层体系，<code>Compose</code>可通过 <code>compose.runtime</code>和<code>compose.compiler</code>实现跨平台    </li>
<li>在使用<code>Button</code>时，<code>AndroidComposeView</code>会有两层子<code>View</code>，这是因为<code>Button</code>中使用了<code>View</code>来实现水波纹效果    </li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6976435919666544653" target="_blank" rel="noopener">Jetpack Compose Runtime : 声明式 UI 的基础</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM 进阶版：MVI 架构了解一下~</title>
    <url>/blog/2021/10/mvvm-and-mvi.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Android</code>开发发展到今天已经相当成熟了，各种架构大家也都耳熟能详，如<code>MVC</code>,<code>MVP</code>,<code>MVVM</code>等，其中<code>MVVM</code>更是被官方推荐，成为<code>Android</code>开发中的显学。<br>不过软件开发中没有银弹，<code>MVVM</code>架构也不是尽善尽美的，在使用过程中也会有一些不太方便之处，而<code>MVI</code>可以很好的解决一部分<code>MVVM</code>的痛点。<br>本文主要包括以下内容    </p>
<ol>
<li><code>MVC</code>,<code>MVP</code>,<code>MVVM</code>等经典架构介绍    </li>
<li><code>MVI</code>架构到底是什么?    </li>
<li><code>MVI</code>架构实战    </li>
</ol>
<blockquote>
<p>需要重点指出的是,标题中说<code>MVI</code>架构是<code>MVVM</code>的进阶版是指<code>MVI</code>在<code>MVVM</code>非常相似，并在其基础上做了一定的改良，并不是说<code>MVI</code>架构一定比<code>MVVM</code>适合你的项目<br>各位同学可以在分析比较各个架构后，选择合适项目场景的架构   </p>
</blockquote>
<h2 id="经典架构介绍"><a href="#经典架构介绍" class="headerlink" title="经典架构介绍"></a>经典架构介绍</h2><h3 id="MVC架构介绍"><a href="#MVC架构介绍" class="headerlink" title="MVC架构介绍"></a><code>MVC</code>架构介绍</h3><p><code>MVC</code>是个古老的<code>Android</code>开发架构，随着<code>MVP</code>与<code>MVVM</code>的流行已经逐渐退出历史舞台，我们在这里做一个简单的介绍,其架构图如下所示：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/2/1645b73891134b78~tplv-t2oaga2asx-watermark.awebp" alt><br><code>MVC</code>架构主要分为以下几部分     </p>
<ol>
<li>视图层（<code>View</code>）：对应于<code>xml</code>布局文件和<code>java</code>代码动态<code>view</code>部分           </li>
<li>控制层（<code>Controller</code>）：主要负责业务逻辑，在<code>android</code>中由<code>Activity</code>承担，同时因为<code>XML</code>视图功能太弱，所以<code>Activity</code>既要负责视图的显示又要加入控制逻辑，承担的功能过多。       </li>
<li>模型层（<code>Model</code>）：主要负责网络请求，数据库处理，<code>I/O</code>的操作，即页面的数据来源     </li>
</ol>
<p>由于<code>android</code>中<code>xml</code>布局的功能性太弱,<code>Activity</code>实际上负责了<code>View</code>层与<code>Controller</code>层两者的工作，所以在<code>android</code>中<code>mvc</code>更像是这种形式：<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/7/2/1645b7389d014b6f~tplv-t2oaga2asx-watermark.awebp" alt><br>因此<code>MVC</code>架构在<code>android</code>平台上的主要存在以下问题：   </p>
<ol>
<li><code>Activity</code>同时负责<code>View</code>与<code>Controller</code>层的工作，违背了单一职责原则    </li>
<li><code>Model</code>层与<code>View</code>层存在耦合，存在互相依赖，违背了最小知识原则    </li>
</ol>
<h3 id="MVP架构介绍"><a href="#MVP架构介绍" class="headerlink" title="MVP架构介绍"></a><code>MVP</code>架构介绍</h3><p>由于<code>MVC</code>架构在<code>Android</code>平台上的一些缺陷，<code>MVP</code>也就应运而生了,其架构图如下所示<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/993bec0ee3ad477a93f3b03c3b35732f~tplv-k3u1fbpfcp-watermark.awebp" alt><br><code>MVP</code>架构主要分为以下几个部分       </p>
<ol>
<li><code>View</code>层：对应于<code>Activity</code>与<code>XML</code>,只负责显示<code>UI</code>,只与<code>Presenter</code>层交互，与<code>Model</code>层没有耦合      </li>
<li><code>Presenter</code>层： 主要负责处理业务逻辑，通过接口回调<code>View</code>层     </li>
<li><code>Model</code>层：主要负责网络请求，数据库处理等操作，这个没有什么变化    </li>
</ol>
<p>我们可以看到，<code>MVP</code>解决了<code>MVC</code>的两个问题，即<code>Activity</code>承担了两层职责与<code>View</code>层与<code>Model</code>层耦合的问题     </p>
<p>但<code>MVP</code>架构同样有自己的问题    </p>
<ol>
<li><code>Presenter</code>层通过接口与<code>View</code>通信，实际上持有了<code>View</code>的引用    </li>
<li>但是随着业务逻辑的增加，一个页面可能会非常复杂，这样就会造成<code>View</code>的接口会很庞大。      </li>
</ol>
<h3 id="MVVM架构介绍"><a href="#MVVM架构介绍" class="headerlink" title="MVVM架构介绍"></a><code>MVVM</code>架构介绍</h3><p><code>MVVM</code> 模式将 <code>Presenter</code> 改名为 <code>ViewModel</code>，基本上与 <code>MVP</code> 模式完全一致。<br>唯一的区别是，它采用双向数据绑定（<code>data-binding</code>）：<code>View</code>的变动，自动反映在 <code>ViewModel</code>，反之亦然<br><code>MVVM</code>架构图如下所示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/623a288804004cd5b89754d45592b431~tplv-k3u1fbpfcp-watermark.awebp" alt><br>可以看出<code>MVVM</code>与<code>MVP</code>的主要区别在于,你不用去主动去刷新<code>UI</code>了，只要<code>Model</code>数据变了，会自动反映到<code>UI</code>上。换句话说，<code>MVVM</code>更像是自动化的<code>MVP</code>。        </p>
<p><code>MVVM</code>的双向数据绑定主要通过<code>DataBinding</code>实现，不过相信有很多人跟我一样，是不喜欢用<code>DataBinding</code>的，这样架构就变成了下面这样<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8485b8fe71dc44a088832bc63e1abb50~tplv-k3u1fbpfcp-watermark.awebp" alt>      </p>
<ol>
<li><code>View</code>观察<code>ViewModle</code>的数据变化并自我更新,这其实是单一数据源而不是双向数据绑定，所以其实<code>MVVM</code>的这一大特性我其实并没有用到     </li>
<li><code>View</code>通过调用<code>ViewModel</code>提供的方法来与<code>ViewMdoel</code>交互      </li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li><code>MVC</code>架构的主要问题在于<code>Activity</code>承担了<code>View</code>与<code>Controller</code>两层的职责，同时<code>View</code>层与<code>Model</code>层存在耦合    </li>
<li><code>MVP</code>引入<code>Presenter</code>层解决了<code>MVC</code>架构的两个问题，<code>View</code>只能与<code>Presenter</code>层交互，业务逻辑放在<code>Presenter</code>层    </li>
<li><code>MVP</code>的问题在于随着业务逻辑的增加，<code>View</code>的接口会很庞大，<code>MVVM</code>架构通过双向数据绑定可以解决这个问题     </li>
<li><code>MVVM</code>与<code>MVP</code>的主要区别在于,你不用去主动去刷新<code>UI</code>了，只要<code>Model</code>数据变了，会自动反映到<code>UI</code>上。换句话说，<code>MVVM</code>更像是自动化的<code>MVP</code>。      </li>
<li><code>MVVM</code>的双向数据绑定主要通过<code>DataBinding</code>实现，但有很多人(比如我)不喜欢用<code>DataBinding</code>，而是<code>View</code>通过<code>LiveData</code>等观察<code>ViewModle</code>的数据变化并自我更新,这其实是单一数据源而不是双向数据绑定     </li>
</ol>
<h2 id="MVI架构到底是什么"><a href="#MVI架构到底是什么" class="headerlink" title="MVI架构到底是什么?"></a><code>MVI</code>架构到底是什么?</h2><h3 id="MVVM架构有什么不足"><a href="#MVVM架构有什么不足" class="headerlink" title="MVVM架构有什么不足?"></a><code>MVVM</code>架构有什么不足?</h3><p>要了解<code>MVI</code>架构，我们首先来了解下<code>MVVM</code>架构有什么不足<br>相信使用<code>MVVM</code>架构的同学都有如下经验，为了保证数据流的单向流动，<code>LiveData</code>向外暴露时需要转化成<code>immutable</code>的，这需要添加不少模板代码并且容易遗忘，如下所示<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _pageState: MutableLiveData&lt;PageState&gt; = MutableLiveData()</span><br><span class="line">    <span class="keyword">val</span> pageState: LiveData&lt;PageState&gt; = _pageState</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _state1: MutableLiveData&lt;String&gt; = MutableLiveData()</span><br><span class="line">    <span class="keyword">val</span> state1: LiveData&lt;String&gt; = _state1</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，如果页面逻辑比较复杂，<code>ViewModel</code>中将会有许多全局变量的<code>LiveData</code>,并且每个<code>LiveData</code>都必须定义两遍，一个可变的，一个不可变的。这其实就是我通过<code>MVVM</code>架构写比较复杂页面时最难受的点。<br>其次就是<code>View</code>层通过调用<code>ViewModel</code>层的方法来交互的，<code>View</code>层与<code>ViewModel</code>的交互比较分散，不成体系    </p>
<p>小结一下，在我的使用中，<code>MVVM</code>架构主要有以下不足     </p>
<ol>
<li>为保证对外暴露的<code>LiveData</code>是不可变的，需要添加不少模板代码并且容易遗忘    </li>
<li><code>View</code>层与<code>ViewModel</code>层的交互比较分散零乱，不成体系    </li>
</ol>
<h3 id="MVI架构是什么"><a href="#MVI架构是什么" class="headerlink" title="MVI架构是什么?"></a><code>MVI</code>架构是什么?</h3><p><code>MVI</code> 与 <code>MVVM</code> 很相似，其借鉴了前端框架的思想，更加强调数据的单向流动和唯一数据源,架构图如下所示<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ecd46797c084f08b9efc8fb5246a5db~tplv-k3u1fbpfcp-watermark.awebp" alt><br>其主要分为以下几部分   </p>
<ol>
<li><code>Model</code>: 与<code>MVVM</code>中的<code>Model</code>不同的是，<code>MVI</code>的<code>Model</code>主要指<code>UI</code>状态（<code>State</code>）。例如页面加载状态、控件位置等都是一种<code>UI</code>状态      </li>
<li><code>View</code>: 与其他<code>MVX</code>中的<code>View</code>一致，可能是一个<code>Activity</code>或者任意<code>UI</code>承载单元。<code>MVI</code>中的<code>View</code>通过订阅<code>Intent</code>的变化实现界面刷新（注意：这里不是<code>Activity</code>的<code>Intent</code>）     </li>
<li><code>Intent</code>: 此<code>Intent</code>不是<code>Activity</code>的<code>Intent</code>，用户的任何操作都被包装成<code>Intent</code>后发送给<code>Model</code>层进行数据请求    </li>
</ol>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p><code>MVI</code>强调数据的单向流动，主要分为以下几步：   </p>
<ol>
<li>用户操作以<code>Intent</code>的形式通知<code>Model</code>       </li>
<li><code>Model</code>基于<code>Intent</code>更新<code>State</code>      </li>
<li><code>View</code>接收到<code>State</code>变化刷新UI。         </li>
</ol>
<p>数据永远在一个环形结构中单向流动，不能反向流动：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/october/p17.png" alt>      </p>
<p>上面简单的介绍了下<code>MVI</code>架构，下面我们一起来看下具体是怎么使用<code>MVI</code>架构的   </p>
<h2 id="MVI架构实战"><a href="#MVI架构实战" class="headerlink" title="MVI架构实战"></a><code>MVI</code>架构实战</h2><h3 id="总体架构图"><a href="#总体架构图" class="headerlink" title="总体架构图"></a>总体架构图</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/765d1d45817744728c78ceb1e2566b9a~tplv-k3u1fbpfcp-watermark.awebp" alt><br>我们使用<code>ViewModel</code>来承载<code>MVI</code>的<code>Model</code>层，总体结构也与<code>MVVM</code>类似,主要区别在于<code>Model</code>与<code>View</code>层交互的部分    </p>
<ol>
<li><code>Model</code>层承载<code>UI</code>状态，并暴露出<code>ViewState</code>供<code>View</code>订阅，<code>ViewState</code>是个<code>data class</code>,包含所有页面状态       </li>
<li><code>View</code>层通过<code>Action</code>更新<code>ViewState</code>，替代<code>MVVM</code>通过调用<code>ViewModel</code>方法交互的方式     </li>
</ol>
<h3 id="MVI实例介绍"><a href="#MVI实例介绍" class="headerlink" title="MVI实例介绍"></a><code>MVI</code>实例介绍</h3><h4 id="添加ViewState与ViewEvent"><a href="#添加ViewState与ViewEvent" class="headerlink" title="添加ViewState与ViewEvent"></a>添加<code>ViewState</code>与<code>ViewEvent</code></h4><p><code>ViewState</code>承载页面的所有状态，<code>ViewEvent</code>则是一次性事件，如<code>Toast</code>等,如下所示<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MainViewState</span></span>(<span class="keyword">val</span> fetchStatus: FetchStatus, <span class="keyword">val</span> newsList: List&lt;NewsItem&gt;)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">MainViewEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowSnackbar</span></span>(<span class="keyword">val</span> message: String) : MainViewEvent()</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowToast</span></span>(<span class="keyword">val</span> message: String) : MainViewEvent()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>我们这里<code>ViewState</code>只定义了两个，一个是请求状态，一个是页面数据    </li>
<li><code>ViewEvent</code>也很简单，一个简单的密封类，显示<code>Toast</code>与<code>Snackbar</code>   </li>
</ol>
<h4 id="ViewState更新"><a href="#ViewState更新" class="headerlink" title="ViewState更新"></a><code>ViewState</code>更新</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _viewStates: MutableLiveData&lt;MainViewState&gt; = MutableLiveData()</span><br><span class="line">    <span class="keyword">val</span> viewStates = _viewStates.asLiveData()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _viewEvents: SingleLiveEvent&lt;MainViewEvent&gt; = SingleLiveEvent()</span><br><span class="line">    <span class="keyword">val</span> viewEvents = _viewEvents.asLiveData()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        emit(MainViewState(fetchStatus = FetchStatus.NotFetched, newsList = emptyList()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fabClicked</span><span class="params">()</span></span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        emit(MainViewEvent.ShowToast(message = <span class="string">"Fab clicked count <span class="variable">$count</span>"</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(state: <span class="type">MainViewState</span>?)</span></span> &#123;</span><br><span class="line">        _viewStates.value = state</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">emit</span><span class="params">(event: <span class="type">MainViewEvent</span>?)</span></span> &#123;</span><br><span class="line">        _viewEvents.value = event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示   </p>
<ol>
<li>我们只需定义<code>ViewState</code>与<code>ViewEvent</code>两个<code>State</code>,后续增加状态时在<code>data class</code>中添加即可，不需要再写模板代码    </li>
<li><code>ViewEvents</code>是一次性的，通过<code>SingleLiveEvent</code>实现，当然你也可以用<code>Channel</code>当来实现     </li>
<li>当状态更新时，通过<code>emit</code>来更新状态     </li>
</ol>
<h4 id="View监听ViewState"><a href="#View监听ViewState" class="headerlink" title="View监听ViewState"></a><code>View</code>监听<code>ViewState</code></h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initViewModel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModel.viewStates.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">        renderViewState(it)</span><br><span class="line">    &#125;</span><br><span class="line">    viewModel.viewEvents.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">        renderViewEvent(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，<code>MVI</code> 使用 <code>ViewState</code> 对 <code>State</code> 集中管理，只需要订阅一个 <code>ViewState</code> 便可获取页面的所有状态，相对 <code>MVVM</code> 减少了不少模板代码。  </p>
<h4 id="View通过Action更新State"><a href="#View通过Action更新State" class="headerlink" title="View通过Action更新State"></a><code>View</code>通过<code>Action</code>更新<code>State</code></h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initView</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fabStar.setOnClickListener &#123;</span><br><span class="line">            viewModel.dispatch(MainViewAction.FabClicked)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">dispatch</span><span class="params">(action: <span class="type">MainViewAction</span>)</span></span> =</span><br><span class="line">        reduce(viewStates.value, action)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">reduce</span><span class="params">(state: <span class="type">MainViewState</span>?, viewAction: <span class="type">MainViewAction</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">when</span> (viewAction) &#123;</span><br><span class="line">            <span class="keyword">is</span> MainViewAction.NewsItemClicked -&gt; newsItemClicked(viewAction.newsItem)</span><br><span class="line">            MainViewAction.FabClicked -&gt; fabClicked()</span><br><span class="line">            MainViewAction.OnSwipeRefresh -&gt; fetchNews(state)</span><br><span class="line">            MainViewAction.FetchNews -&gt; fetchNews(state)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，<code>View</code>通过<code>Action</code>与<code>ViewModel</code>交互，通过 <code>Action</code> 通信，有利于 <code>View</code> 与 <code>ViewModel</code> 之间的进一步解耦，同时所有调用以 <code>Action</code> 的形式汇总到一处，也有利于对行为的集中分析和监控  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了<code>MVC</code>,<code>MVP</code>,<code>MVVM</code>与<code>MVI</code>架构，目前<code>MVVM</code>是官方推荐的架构，但仍然有以下几个痛点     </p>
<ol>
<li><code>MVVM</code>与<code>MVP</code>的主要区别在于双向数据绑定，但由于很多人(比如我)并不喜欢使用<code>DataBindg</code>，其实并没有使用<code>MVVM</code>双向绑定的特性，而是单一数据源     </li>
<li>当页面复杂时，需要定义很多<code>State</code>,并且需要定义可变与不可变两种,状态会以双倍的速度膨胀，模板代码较多且容易遗忘     </li>
<li><code>View</code>与<code>ViewModel</code>通过<code>ViewModel</code>暴露的方法交互，比较零乱难以维护    </li>
</ol>
<p>而<code>MVI</code>可以比较好的解决以上痛点，它主要有以下优势    </p>
<ol>
<li>强调数据单向流动，很容易对状态变化进行跟踪和回溯   </li>
<li>使用<code>ViewState</code>对<code>State</code>集中管理，只需要订阅一个 <code>ViewState</code> 便可获取页面的所有状态，相对 <code>MVVM</code> 减少了不少模板代码       </li>
<li><code>ViewModel</code>通过<code>ViewState</code>与<code>Action</code>通信，通过浏览<code>ViewState</code> 和 <code>Aciton</code> 定义就可以理清 <code>ViewModel</code> 的职责，可以直接拿来作为接口文档使用。        </li>
</ol>
<p>当然<code>MVI</code>也有一些缺点，比如   </p>
<ol>
<li>所有的操作最终都会转换成<code>State</code>，所以当复杂页面的<code>State</code>容易膨胀     </li>
<li><code>state</code>是不变的，因此每当<code>state</code>需要更新时都要创建新对象替代老对象，这会带来一定内存开销      </li>
</ol>
<p>软件开发中没有银弹，所有架构都不是完美的，有自己的适用场景,读者可根据自己的需求选择使用。<br>但通过以上的分析与介绍，我相信使用<code>MVI</code>架构代替没有使用<code>DataBinding</code>的<code>MVVM</code>是一个比较好的选择~       </p>
<h3 id="Sample代码"><a href="#Sample代码" class="headerlink" title="Sample代码"></a><code>Sample</code>代码</h3><p><a href="https://github.com/shenzhen2017/android-architecture" target="_blank" rel="noopener">https://github.com/shenzhen2017/android-architecture</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6920427168749060110" target="_blank" rel="noopener">基于Android的MVI架构：从双向绑定到单向数据流</a><br><a href="https://juejin.cn/post/6969382803112722446" target="_blank" rel="noopener">Jetpack Compose 架构如何选？ MVP, MVVM, MVI</a><br><a href="https://juejin.cn/post/6998093259893407757" target="_blank" rel="noopener">站在思想层面看MVX架构</a><br><a href="https://proandroiddev.com/best-architecture-for-android-mvi-livedata-viewmodel-71a3a5ac7ee3" target="_blank" rel="noopener">Best Architecture For Android : MVI + LiveData + ViewModel = ❤️</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose + MVI + Navigation 快速实现 wanAndroid 客户端</title>
    <url>/blog/2021/10/wan-android-compose.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今年七月底，<code>Google</code> 正式发布了 <code>Jetpack Compose</code> 的 <code>1.0</code> 稳定版本，这说明<code>Google</code>认为<code>Compose</code>已经可以用于生产环境了。相信<code>Compose</code>的广泛应用就在不远的将来，现在应该是学习<code>Compose</code>的一个比较好的时机<br>在了解了<code>Compose</code>的基本知识与原理之后，通过一个完整的项目继续学习<code>Compose</code>应该是一个比较好的方式。本文主要基于<code>Compose</code>，<code>MVI</code>架构，单<code>Activity</code>架构等，快速实现一个<code>wanAndroid</code>客户端,如果对您有所帮助可以点个<code>Star</code>: <a href="https://github.com/shenzhen2017/wanandroid-compose" target="_blank" rel="noopener">wanAndroid-compose</a></p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首先看下效果图   </p>
<table>
<thead>
<tr>
<th><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p13.png" alt="请添加图片描述"></th>
<th><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p14.png" alt="在这里插入图片描述"></th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p15.png" alt="请添加图片描述"></td>
<td><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p16.png" alt="在这里插入图片描述"></td>
</tr>
<tr>
<td>————————————————————</td>
<td>————————————————————</td>
</tr>
<tr>
<td><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p17.png" alt="请添加图片描述"></td>
<td><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p18.png" alt="请添加图片描述"></td>
</tr>
</tbody>
</table>
<h2 id="主要实现介绍"><a href="#主要实现介绍" class="headerlink" title="主要实现介绍"></a>主要实现介绍</h2><p>各个页面的具体实现可以查看源码，这里主要介绍一些主要的实现与原理    </p>
<h3 id="使用MVI架构"><a href="#使用MVI架构" class="headerlink" title="使用MVI架构"></a>使用<code>MVI</code>架构</h3><p><code>MVI</code> 与 <code>MVVM</code> 很相似，其借鉴了前端框架的思想，更加强调数据的单向流动和唯一数据源,架构图如下所示<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb3fe9361e244430bd2f69b70c7b0e75~tplv-k3u1fbpfcp-watermark.awebp" alt><br>其主要分为以下几部分    </p>
<ol>
<li><code>Model</code>: 与<code>MVVM</code>中的<code>Model</code>不同的是，<code>MVI</code>的<code>Model</code>主要指<code>UI</code>状态（<code>State</code>）。例如页面加载状态、控件位置等都是一种<code>UI</code>状态       </li>
<li><code>View</code>: 与其他<code>MVX</code>中的<code>View</code>一致，可能是一个<code>Activity</code>或者任意<code>UI</code>承载单元。<code>MVI</code>中的<code>View</code>通过订阅<code>Model</code>的变化实现界面刷新     </li>
<li><code>Intent</code>: 此<code>Intent</code>不是<code>Activity</code>的<code>Intent</code>，用户的任何操作都被包装成<code>Intent</code>后发送给<code>Model</code>层进行数据请求      </li>
</ol>
<p>例如登录页面的<code>Model</code>与<code>Intent</code>定义如下<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 页面所有状态</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">data class LoginViewState(</span></span><br><span class="line"><span class="comment">    val account: String = "",</span></span><br><span class="line"><span class="comment">    val password: String = "",</span></span><br><span class="line"><span class="comment">    val isLogged: Boolean = false</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一次性事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginViewEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">object</span> PopBack : LoginViewEvent()</span><br><span class="line">    <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorMessage</span></span>(<span class="keyword">val</span> message: String) : LoginViewEvent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 页面Intent,即用户的操作</span></span><br><span class="line"><span class="comment">/</span></span><br><span class="line"><span class="comment">sealed class LoginViewAction &#123;</span></span><br><span class="line"><span class="comment">    object Login : LoginViewAction()</span></span><br><span class="line"><span class="comment">    object ClearAccount : LoginViewAction()</span></span><br><span class="line"><span class="comment">    object ClearPassword : LoginViewAction()</span></span><br><span class="line"><span class="comment">    data class UpdateAccount(val account: String) : LoginViewAction()</span></span><br><span class="line"><span class="comment">    data class UpdatePassword(val password: String) : LoginViewAction()</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如上所示   </p>
<ol>
<li>通过<code>ViewState</code>定义页面所有状态        </li>
<li><code>ViewEvent</code>定义一次性事件如<code>Toast</code>，页面关闭事件等    </li>
<li>通过<code>ViewAction</code>定义所有用户操作    </li>
</ol>
<p><code>MVI</code>架构与<code>MVVM</code>架构的主要区别在于：   </p>
<ol>
<li><code>MVVM</code>并没有约束<code>View</code>层与<code>ViewModel</code>的交互方式，具体来说就是<code>View</code>层可以随意调用<code>ViewModel</code>中的方法，而<code>MVI</code>架构下<code>ViewModel</code>的实现对<code>View</code>层屏蔽，只能通过发送<code>Intent</code>来驱动事件。</li>
<li><code>MVVM</code> 的 <code>ViewModle</code> 中分散定义了多个 <code>State</code> ，<code>MVI</code> 使用 <code>ViewState</code> 对 <code>State</code> 集中管理，只需要订阅一个 <code>ViewState</code> 便可获取页面的所有状态，相对 <code>MVVM</code> 减少了不少模板代码</li>
</ol>
<p><code>Compose</code> 的声明式<code>UI</code>思想来自 <code>React</code>，理论上同样来自 <code>Redux</code> 思想的 <code>MVI</code> 应该是 <code>Compose</code> 的最佳伴侣<br>但是<code>MVI</code>也只是在<code>MVVM</code>的基础上做了一定的改良，<code>MVVM</code> 也可以很好地配合 <code>Compose</code> 使用,各位可根据自己的需要选择合适的架构      </p>
<p>关于<code>Compose</code>的架构选择可参考：<a href="https://juejin.cn/post/6969382803112722446" target="_blank" rel="noopener">Jetpack Compose 架构如何选？ MVP, MVVM, MVI</a></p>
<h3 id="单Activity架构"><a href="#单Activity架构" class="headerlink" title="单Activity架构"></a>单<code>Activity</code>架构</h3><p>早在<code>View</code>时代，就有不少推荐单<code>Activity</code>+多<code>Fragment</code>架构的文章，<code>Google</code>也推出了<code>Jetpack Navigation</code>库来支持这种单<code>Activity</code>架构<br>对于<code>Compose</code>来说，因为<code>Activity</code>与<code>Compose</code>是通过<code>AndroidComposeView</code>来中转的，<code>Activity</code>越多，就需要创建出越多的<code>AndroidComposeView</code>,对性能有一定影响<br>而使用单<code>Activity</code>架构，所有变换页面跳转都在<code>Compose</code>内部完成，可能也是出于这个原因，目前<code>Google</code>的示例项目都是基于单<code>Activity</code>+<code>Navigation</code>+多<code>Compose</code>架构的    </p>
<p>但是使用单<code>Activity</code>架构也需要解决一些问题     </p>
<ol>
<li>所有的<code>viewModel</code>都在一个<code>Activity</code>的<code>ViewModelStoreOwner</code>中，那么当一个页面销毁了，此页面用过的<code>viewModel</code>应该什么时候销毁呢？      </li>
<li>有时候页面需要监听自己这个页面的<code>onResume</code>，<code>onPause</code>等生命周期，单<code>Activity</code>架构下如何监听生命周期呢?    </li>
</ol>
<p>我们下面就一起来看下如何解决单<code>Activity</code>架构下的这两个问题    </p>
<h3 id="页面ViewModel何时销毁"><a href="#页面ViewModel何时销毁" class="headerlink" title="页面ViewModel何时销毁?"></a>页面<code>ViewModel</code>何时销毁?</h3><p>在<code>Compose</code>中一般可以通过以下两种方式获取<code>ViewModel</code><br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1   </span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LoginPage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    loginViewModel: <span class="type">LoginViewModel</span> = viewModel()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2   </span></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LoginPage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    loginViewModel: <span class="type">LoginViewModel</span> = hiltViewModel()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示：  </p>
<ol>
<li>方式1将返回一个与<code>ViewModelStoreOwner</code>(一般是<code>Activity</code>或<code>Fragment</code>)绑定的<code>ViewModel</code>，如果不存在则创建，已存在则直接返回。很明显通过这种方式创建的<code>ViewModel</code>的生命周期将与<code>Activity</code>一致，在单<code>Activity</code>架构中将一直存在，不会释放。   </li>
<li>方式2通过<code>Hilt</code>实现，可以在<code>Composable</code>中获取<code>NavGraph Scope</code>或<code>Destination Scope</code> 的 <code>ViewModel</code>，并自动依赖 <code>Hilt</code> 构建。<code>Destination Scope</code> 的 <code>ViewModel</code> 会跟随 <code>BackStack</code> 的弹出自动 <code>Clear</code> ，避免泄露。</li>
</ol>
<p>总得来说，通过<code>hiltViewModel</code>与<code>Navigation</code>配合，是一个更好的选择    </p>
<h3 id="Compose如何获取生命周期"><a href="#Compose如何获取生命周期" class="headerlink" title="Compose如何获取生命周期?"></a><code>Compose</code>如何获取生命周期?</h3><p>为了在<code>Compose</code>中获取生命周期，我们需要先了解下<a href="https://developer.android.google.cn/jetpack/compose/side-effects?hl=zh-cn" target="_blank" rel="noopener">副作用</a><br>用一句话概括副作用：一个函数的执行过程中，除了返回函数值之外，对调用方还会带来其他附加影响，例如修改全局变量或修改参数等。      </p>
<p>副作用必须在合适的时机执行，我们首先需要明确一下<code>Composable</code>的生命周期：     </p>
<ol>
<li><code>onActive（or onEnter）</code>：当<code>Composable</code>首次进入组件树时      </li>
<li><code>onCommit（or onUpdate）</code>：<code>UI</code>随着<code>recomposition</code>发生更新时        </li>
<li><code>onDispose（or onLeave）</code>：当<code>Composable</code>从组件树移除时          </li>
</ol>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07432c8e4f5c4492baff11f3f1fb4802~tplv-k3u1fbpfcp-watermark.awebp" alt>      </p>
<p>了解了<code>Compose</code>的生命周期后，我们可以发现，如果我们在<code>onActive</code>时监听<code>Activity</code>的生命周期，在<code>onDispose</code>时取消监听，不就可以实现在<code>Compose</code>中获取生命周期了吗?<br><code>DisposableEffect</code>可以帮助我们实现这个需求，<code>DisposableEffect</code>在其监听的<code>Key</code>发生变化，或<code>onDispose</code>时会执行<br>我们还可以通过添加参数，让其仅在<code>onActive</code>与<code>onDispose</code>时执行：例如<code>DisposableEffect(true)</code>或<code>DisposableEffect(Unit)</code>          </p>
<p>通过以下方式，就可以实现在<code>Compose</code>中监听页面生命周期<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">LoginPage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    loginViewModel: <span class="type">LoginViewModel</span> = hiltViewModel()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> lifecycleOwner = LocalLifecycleOwner.current</span><br><span class="line">    DisposableEffect(key1 = <span class="built_in">Unit</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> observer = <span class="keyword">object</span> : LifecycleObserver &#123;</span><br><span class="line">            <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">                viewModel.dispatch(Action.Resume)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">            <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">                viewModel.dispatch(Action.Pause)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lifecycleOwner.lifecycle.addObserver(observer)</span><br><span class="line">        onDispose &#123;</span><br><span class="line">            lifecycleOwner.lifecycle.removeObserver(observer)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然有时也不需要这么复杂，比如我们需要在进入或返回<code>ProfilePage</code>页面时刷新登录状态，并根据登录状态确认页面<code>UI</code>，就可以通过以下方式实现<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ProfilePage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    navCtrl: <span class="type">NavHostController</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    scaffoldState: <span class="type">ScaffoldState</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    viewModel: <span class="type">ProfileViewModel</span> = hiltViewModel()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    DisposableEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        Log.i(<span class="string">"debug"</span>, <span class="string">"onStart"</span>)</span><br><span class="line">        viewModel.dispatch(ProfileViewAction.OnStart)</span><br><span class="line">        onDispose &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，每当进入页面或返回该页面时，我们就可以刷新页面登录状态了     </p>
<h3 id="Compose如何保存LazyColumn列表状态"><a href="#Compose如何保存LazyColumn列表状态" class="headerlink" title="Compose如何保存LazyColumn列表状态"></a><code>Compose</code>如何保存<code>LazyColumn</code>列表状态</h3><p>相信使用过<code>LazyColumn</code>的同学都碰到过下面的问题     </p>
<blockquote>
<p>使用<code>Paging3</code>加载分页数据，并显示到页面<code>A</code>的<code>LazyColumn</code>上，向下滑动<code>LazyColumn</code>，然后<code>navigation.navigate</code>跳转到页面<code>B</code>，接着再<code>navigatUp</code>回到页面<code>A</code>，页面<code>A</code>的<code>LazyColumn</code>又回到了列表顶部    </p>
</blockquote>
<p>但是我们可以看到，<code>LazyListState</code>其实是通过<code>rememberLazyListState</code>做了持久化保存的，如下图所示<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/291ab6de0d274da2bb1d875faa3c7d7e~tplv-k3u1fbpfcp-watermark.awebp?" alt>      </p>
<p>既然做了持久化保存，那为什么返回时的位置还有问题呢？其实纯粹使用 <code>Paging</code> + <code>LazyColumn</code>，当页面切换时，会记录当前页面位置，但如果通过<code>item</code>加上<code>Header</code>或<code>Footer</code>就不行了<br>这是因为<code>rememberLazyListState</code>会在列表中至少有一项时<code>restore</code>滚动位置，同时<code>Paging</code>是通过<code>Flow</code>获取数据的，当返回到页面重组时并不能马上获取到<code>Paging</code>数据，第一帧时<code>Paging</code>的<code>itemCount</code>为0<br>但同时因为<code>LazyColumn</code>中已经有了一个<code>Header</code>，这时便会还原保存的位置，但因为这时<code>Paging</code>中的数据还为空，不能滚动到正确的位置，于是便又滚动到顶部了<br>而当<code>LazyColumn</code>中没有<code>Header</code>时，列表中至少有一项时便是<code>Paging</code>数据成功填充的时候，这个时候还原的位置就是对的,所以没有问题    </p>
<p>既然原因在于<code>LazyListState</code>没有在正确的时机被还原，那我们将<code>LazyListSate</code>保存在<code>ViewModel</code>中,并且在<code>Paging</code>中有数据时再还原<code>listState</code>，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@HiltViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareViewModel</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> service: HttpService,</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> pager <span class="keyword">by</span> lazy &#123; simplePager &#123; service.getSquareData(it) &#125;.cachedIn(viewModelScope) &#125;</span><br><span class="line">    <span class="keyword">val</span> listState: LazyListState = LazyListState()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SquarePage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    navCtrl: <span class="type">NavHostController</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    scaffoldState: <span class="type">ScaffoldState</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    viewModel: <span class="type">SquareViewModel</span> = hiltViewModel()</span></span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">val</span> squareData = viewStates.pagingData.collectAsLazyPagingItems()</span><br><span class="line">    <span class="comment">// 当`Paging`有数据时，返回`ViewModel`中的`listState`</span></span><br><span class="line">    <span class="keyword">val</span> listState = <span class="keyword">if</span> (squareData.itemCount &gt; <span class="number">0</span>) viewStates.listState <span class="keyword">else</span> LazyListState()</span><br><span class="line"></span><br><span class="line">    RefreshList(squareData, listState = listState) &#123;</span><br><span class="line">        itemsIndexed(squareData) &#123; _, item -&gt;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总得来说，对于一般的页面，<code>rememberLazyListState</code>已经足够，但是对于有<code>Header</code>或<code>Footer</code>的<code>Paging</code>页面，需要一些特殊处理<br>关于<code>LazyColumn</code>滚动丢失的问题，更详细的讨论可参考：<a href="https://issuetracker.google.com/issues/177245496?pli=1" target="_blank" rel="noopener">Scroll position of LazyColumn built with collectAsLazyPagingItems is lost when using Navigation
</a>   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shenzhen2017/wanandroid-compose" target="_blank" rel="noopener">https://github.com/shenzhen2017/wanandroid-compose</a><br>开源不易，如果项目对你有所帮助，欢迎点赞,<code>Star</code>,收藏~    </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/manqianzhuang/HamApp" target="_blank" rel="noopener">https://github.com/manqianzhuang/HamApp</a><br><a href="https://github.com/linxiangcheer/PlayAndroid" target="_blank" rel="noopener">https://github.com/linxiangcheer/PlayAndroid</a><br><a href="https://juejin.cn/post/7030986229512404999" target="_blank" rel="noopener">从零到一写一个完整的 Compose 版本的天气</a>        </p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>MVI 架构更佳实践：支持 LiveData 属性监听</title>
    <url>/blog/2021/10/mvi-better-practice.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们介绍了<code>MVI</code>架构的基本原理与使用：<a href="https://juejin.cn/post/7022624191723601928" target="_blank" rel="noopener">MVVM 进阶版：MVI 架构了解一下~</a><br><code>MVI</code>架构为了解决<code>MVVM</code>在逻辑复杂时需要写多个<code>LiveData</code>(可变+不可变)的问题,使用<code>ViewState</code>对<code>State</code>集中管理，只需要订阅一个 <code>ViewState</code> 便可获取页面的所有状态<br>通过集中管理<code>ViewState</code>，只需对外暴露一个<code>LiveData</code>，解决了<code>MVVM</code>模式下<code>LiveData</code>膨胀的问题       </p>
<p>但页面的所有状态都通过一个<code>LiveData</code>来管理，也带来了一个严重的问题，即<strong>页面不支持局部刷新</strong><br>虽说如果是<code>RecyclerView</code>可以通过<code>DifferUtil</code>来解决，但毕竟不是所有页面都是通过<code>RecyclerView</code>写的，支持<code>DifferUtil</code>也有一定的开发成本<br>因此直接使用<code>MVI</code>架构会带来一定的性能损耗，相信这是很多人不愿意用<code>MVI</code>架构的原因之一          </p>
<p><strong>本文主要介绍如何通过监听<code>LiveData</code>的属性，来实现<code>MVI</code>架构下的局部刷新</strong>    </p>
<h2 id="Mavericks框架介绍"><a href="#Mavericks框架介绍" class="headerlink" title="Mavericks框架介绍"></a><code>Mavericks</code>框架介绍</h2><p><a href="https://airbnb.io/mavericks/#/README" target="_blank" rel="noopener">Mavericks</a>框架是<code>Airbnb</code>开源的一个<code>MVI</code>框架，<code>Mavericks</code>基于<code>Android Jetpack</code>与<code>Kotlin Coroutines</code>，<br>主要目标是使页面开发更高效，更容易，更有趣，目前已经在<code>Airbnb</code>的数百个页面上使用     </p>
<p>下面我们来看下<code>Mavericks</code>是怎么使用的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 包含页面所有状态的data class</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterState</span></span>(<span class="keyword">val</span> count: <span class="built_in">Int</span> = <span class="number">0</span>) : MavericksState</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.负责处理业务逻辑的ViewModel,易于单元测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterViewModel</span></span>(initialState: CounterState) : MavericksViewModel&lt;CounterState&gt;(initialState) &#123;</span><br><span class="line">	<span class="comment">// 通过setState更新页面状态</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">incrementCount</span><span class="params">()</span></span> = setState &#123; copy(count = count + <span class="number">1</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. View层，必须实现MavericksView接口   </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterFragment</span> : <span class="type">Fragment</span></span>(R.layout.counter_fragment), MavericksView &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModel: CounterViewModel <span class="keyword">by</span> fragmentViewModel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        counterText.setOnClickListener &#123;</span><br><span class="line">            viewModel.incrementCount()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 页面刷新回调，每当状态刷新时会回调这里</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invalidate</span><span class="params">()</span></span> = withState(viewModel) &#123; state -&gt;</span><br><span class="line">        counterText.text = <span class="string">"Count: <span class="subst">$&#123;state.count&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，看上去也很简单，主要包括几个模块    </p>
<ol>
<li>包括页面所有状态的<code>Model</code>层，其中的状态全都是不可变的，并且有默认值    </li>
<li>负责处理业务逻辑的<code>ViewModel</code>，在其中通过<code>setState</code>来更新页面状态   </li>
<li><code>View</code>层，必须实现<code>MavericksView</code>接口，每当状态刷新时都会回调<code>invalidate</code>函数,在这里渲染<code>UI</code>     </li>
</ol>
<p>可以看出，<code>Mavericks</code>中<code>View</code>层与<code>Model</code>层的交互，也并没有包装成<code>Action</code>，而是直接暴露的方法<br>上篇文章也的确有很多同学说使用<code>Action</code>交互比较麻烦，看起来<code>Action</code>这层的确可要可不要,<code>Airbnb</code>也没有使用，主要看个人开发习惯吧    </p>
<h3 id="支持局部刷新"><a href="#支持局部刷新" class="headerlink" title="支持局部刷新"></a>支持局部刷新</h3><p>上面介绍了<code>Mavericks</code>的简单使用，下面我们来看下<code>Mavericks</code>是怎么实现局部刷新的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserState</span></span>(</span><br><span class="line">    <span class="keyword">val</span> score: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> previousHighScore: <span class="built_in">Int</span> = <span class="number">150</span>,</span><br><span class="line">    <span class="keyword">val</span> livesLeft: <span class="built_in">Int</span> = <span class="number">99</span>,</span><br><span class="line">) : MavericksState &#123;</span><br><span class="line">    <span class="keyword">val</span> pointsUntilHighScore = (previousHighScore - score).coerceAtLeast(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> isHighScore = score &gt;= previousHighScore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterFragment</span> : <span class="type">Fragment</span></span>(R.layout.counter_fragment), MavericksView &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    	<span class="comment">//直接监听State的属性,并且支持设置监听模式  </span></span><br><span class="line">        viewModel.onEach(UserState::pointsUntilHighScore,deliveryMode = uniqueOnly()) &#123;</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> 		viewModel.onEach(UserState::score) &#123; </span><br><span class="line">        	<span class="comment">//...</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如上所示，<code>Mavericks</code>可以只监听<code>State</code>的其中一个属性来实现局部刷新，只有当这个属性发生变化时才触发回调     </li>
<li><code>onEach</code>也可以设置监听模式，主要是为了防止数据倒灌，例如<code>Toast</code>这些只需要弹一次，页面重建时不应该恢复的状态，就适合使用<code>uniqueOnly</code>的监听模式    </li>
</ol>
<p><code>Mavericks</code>实现属性监听的原理也很简单，我们一起来看下源码<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;VM : MavericksViewModel&lt;S&gt;</span>, S : MavericksState, A&gt; VM.<span class="title">_internal1</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    owner: <span class="type">LifecycleOwner</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    prop1: <span class="type">KProperty1</span>&lt;<span class="type">S</span>, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    deliveryMode: <span class="type">DeliveryMode</span> = RedeliverOnStart,</span></span></span><br><span class="line"><span class="function"><span class="params">    action: <span class="type">suspend</span> (<span class="type">A</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> = stateFlow</span><br><span class="line">    <span class="comment">// 通过对象取出属性的值</span></span><br><span class="line">    .map &#123; MavericksTuple1(prop1.<span class="keyword">get</span>(it)) &#125;</span><br><span class="line">    <span class="comment">// 值发生变化了才会触发回调  </span></span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .resolveSubscription(owner, deliveryMode.appendPropertiesToId(prop1)) &#123; (a) -&gt;</span><br><span class="line">        action(a)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>主要是通过<code>map</code>将<code>State</code>转化为它的属性值   </li>
<li>通过<code>distinctUntilChanged</code>方法开启防抖，相同的值不会回调，只有值修改了才会回调   </li>
<li>需要注意的是因为使用了<code>KProperty1</code>，因此<code>State</code>的承载数据类必须避免混淆     </li>
</ol>
<p>如上，就是<code>Mavericks</code>的基本介绍，想了解更多的同学可参考：<a href="https://github.com/airbnb/mavericks" target="_blank" rel="noopener">https://github.com/airbnb/mavericks</a>   </p>
<h2 id="LiveData实现属性监听"><a href="#LiveData实现属性监听" class="headerlink" title="LiveData实现属性监听"></a><code>LiveData</code>实现属性监听</h2><p>上面介绍了<code>Mavericks</code>是怎么实现局部刷新的，但直接使用它主要有两个问题   </p>
<ol>
<li>接入起来略微有点麻烦，例如<code>Fragment</code>必须实现<code>MavericksView</code>，有一定接入成本   </li>
<li><code>Mavericks</code>的局部刷新是通过<code>Flow</code>实现的,但相信大多数人用的还是<code>LiveData</code>，有一定学习成本    </li>
</ol>
<p>下面我们就来看下<code>LiveData</code>怎么实现属性监听<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听一个属性</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, A&gt;</span> LiveData<span class="type">&lt;T&gt;</span>.<span class="title">observeState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    prop1: <span class="type">KProperty1</span>&lt;<span class="type">T</span>, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    action: (<span class="type">A</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.map &#123;</span><br><span class="line">        StateTuple1(prop1.<span class="keyword">get</span>(it))</span><br><span class="line">    &#125;.distinctUntilChanged().observe(lifecycleOwner) &#123; (a) -&gt;</span><br><span class="line">        action.invoke(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听两个属性</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, A, B&gt;</span> LiveData<span class="type">&lt;T&gt;</span>.<span class="title">observeState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    lifecycleOwner: <span class="type">LifecycleOwner</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    prop1: <span class="type">KProperty1</span>&lt;<span class="type">T</span>, A&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    prop2: <span class="type">KProperty1</span>&lt;<span class="type">T</span>, B&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    action: (<span class="type">A</span>, <span class="type">B</span>) -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.map &#123;</span><br><span class="line">        StateTuple2(prop1.<span class="keyword">get</span>(it), prop2.<span class="keyword">get</span>(it))</span><br><span class="line">    &#125;.distinctUntilChanged().observe(lifecycleOwner) &#123; (a, b) -&gt;</span><br><span class="line">        action.invoke(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTuple1</span>&lt;<span class="type">A</span>&gt;</span>(<span class="keyword">val</span> a: A)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">StateTuple2</span>&lt;<span class="type">A, B</span>&gt;</span>(<span class="keyword">val</span> a: A, <span class="keyword">val</span> b: B)</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新State</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableLiveData<span class="type">&lt;T&gt;</span>.<span class="title">setState</span><span class="params">(reducer: <span class="type">T</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.value?.reducer()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如上所示，主要是添加一个扩展方法，也是通过<code>distinctUntilChanged</code>来实现防抖   </li>
<li>如果需要监听多个属性，例如两个属性有其中一个变化了就触发刷新，也支持传入两个属性     </li>
<li>需要注意的是<code>LiveData</code>默认是不防抖的，这样改造后就是防抖的了，所以传入相同的值是不会回调的   </li>
<li>同时需要注意下承载<code>State</code>的数据类需要防混淆   </li>
</ol>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>上面介绍了<code>LiveData</code>如何实现属性监听，下面看下简单的使用<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//页面状态，需要避免混淆</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">MainViewState</span></span>(</span><br><span class="line">    <span class="keyword">val</span> fetchStatus: FetchStatus = FetchStatus.NotFetched,</span><br><span class="line">    <span class="keyword">val</span> newsList: List&lt;NewsItem&gt; = emptyList()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewModel</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _viewStates: MutableLiveData&lt;MainViewState&gt; = MutableLiveData(MainViewState())</span><br><span class="line">    <span class="comment">//只需要暴露一个LiveData，包括页面所有状态</span></span><br><span class="line">    <span class="keyword">val</span> viewStates = _viewStates.asLiveData()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	<span class="comment">//更新页面状态</span></span><br><span class="line">        _viewStates.setState &#123;</span><br><span class="line">            copy(fetchStatus = FetchStatus.Fetching)</span><br><span class="line">        &#125;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            <span class="keyword">when</span> (<span class="keyword">val</span> result = repository.getMockApiResponse()) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">is</span> PageState.Success -&gt; &#123;</span><br><span class="line">                    _viewStates.setState &#123;</span><br><span class="line">                        copy(fetchStatus = FetchStatus.Fetched, newsList = result.<span class="keyword">data</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View层</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initViewModel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModel.viewStates.run &#123;</span><br><span class="line">        	<span class="comment">//监听newsList</span></span><br><span class="line">            observeState(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, MainViewState::newsList) &#123;</span><br><span class="line">                newsRvAdapter.submitList(it)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//监听网络状态</span></span><br><span class="line">            observeState(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, MainViewState::fetchStatus) &#123;</span><br><span class="line">                <span class="comment">//..</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，其实使用起来也很简单方便     </p>
<ol>
<li><code>ViewModel</code>只需对外暴露一个<code>ViewState</code>，避免了定义多个可变不可变<code>LiveData</code>的问题    </li>
<li><code>View</code>层支持监听<code>LiveData</code>的一个属性或多个属性，支持局部刷新   </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了<code>MVI</code>架构下如何实现局部刷新，并重点介绍了<code>Mavericks</code>的基本使用与原理，并在其基础上使用<code>LiveData</code>实现了属性监听与局部刷新<br>通过以上方式，解决了<code>MVI</code>架构的性能问题，实现了<code>MVI</code>架构的更佳实践    </p>
<p>如果你的<code>ViewModel</code>中定义了多个可变与不可变的<code>LiveData</code>，就算你不使用<code>MVI</code>架构，支持监听<code>LiveData</code>属性相信也可以帮助你精简一定的代码<br>如果本文对你有所帮助，欢迎点赞关注<code>Star</code>~   </p>
<h3 id="Sample代码"><a href="#Sample代码" class="headerlink" title="Sample代码"></a><code>Sample</code>代码</h3><p>本文所有代码可见：<a href="https://github.com/shenzhen2017/android-architecture" target="_blank" rel="noopener">https://github.com/shenzhen2017/android-architecture</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>MVI 架构封装：快速优雅地实现网络请求</title>
    <url>/blog/2021/11/mvi-network-architecture.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网络请求可以说是<code>Android</code>开发中最常见的需求之一，基本上每个页面都需要发起几个网络请求。<br>因此大家通常都会对网络请求进行一定的封装，解决模板代码过多,重复代码，异常捕获等一些问题    </p>
<p>前面我们介绍了<code>MVI</code>架构的主要原理与更佳实践<br><a href="https://juejin.cn/post/7022624191723601928" target="_blank" rel="noopener">MVVM 进阶版：MVI 架构了解一下~</a><br><a href="https://juejin.cn/post/7025222741322121223" target="_blank" rel="noopener">MVI 架构更佳实践：支持 LiveData 属性监听</a><br>我们这次一起来看下<code>MVI</code>架构下如何对网络请求进行封装，以及相对于<code>MVVM</code>架构有什么优势    </p>
<p>本文主要包括以下内容     </p>
<ol>
<li><code>MVVM</code>架构下的网络请求封装与问题    </li>
<li><code>MVI</code>架构下封装网络请求   </li>
<li><code>MVI</code>架构与<code>Flow</code>结合实现网络请求   </li>
</ol>
<h2 id="MVVM架构下的网络请求封装与问题"><a href="#MVVM架构下的网络请求封装与问题" class="headerlink" title="MVVM架构下的网络请求封装与问题"></a><code>MVVM</code>架构下的网络请求封装与问题</h2><p>相信大家都看过不少<code>MVVM</code>架构下的网络请求封装，一般是这样写的    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"># MainViewModel</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> userLiveData = StateLiveData&lt;User?&gt;()</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(username: <span class="type">String</span>, password: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123;</span><br><span class="line">            userLiveData.value = repository.login(username, password)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">initViewModel</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 请求网络</span></span><br><span class="line">		mViewModel.login(<span class="string">"username"</span>, <span class="string">"password"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注册监听</span></span><br><span class="line">		mViewModel.userLiveData.observeState(<span class="keyword">this</span>) &#123;</span><br><span class="line">			onLoading &#123;</span><br><span class="line">				showLoading()</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		    onSuccess &#123;<span class="keyword">data</span> -&gt;</span><br><span class="line">		        mBinding.tvContent.text = <span class="keyword">data</span>.toString()</span><br><span class="line">		    &#125;</span><br><span class="line">		</span><br><span class="line">		    onError &#123;</span><br><span class="line">		        dismissLoading()</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，就是最常见的<code>MVVM</code>架构下网络请求封装，主要思路如是    </p>
<ol>
<li>添加一个<code>StateLiveData</code>,一个<code>LiveData</code>支持多种状态，例如加载中，加载成功，加载失败等    </li>
<li>在页面中监听<code>StateLiveData</code>，在页面中处理<code>onLoading</code>，<code>onSuccess</code>,<code>onError</code>等逻辑    </li>
</ol>
<p><strong>这种封装的本质其实就是将请求的回调逻辑处理迁移到<code>View</code>层了</strong><br>这其实并不是我们想要的，我们的理想状况应该是逻辑尽量放在<code>ViewModel</code>中，<code>View</code>层只需要监听<code>ViewModel</code>层并更新<code>UI</code>      </p>
<p>既然这种封装其实违背了不在<code>View</code>层写逻辑的原则，那么为什么还有那么多人用呢?<br><strong>本质上是因为<code>ViewModel</code>层与<code>View</code>层的通信成本比较高</strong><br>想象一下，如果我们不使用<code>StateLiveData</code>，针对每个请求就需要新建一个<code>LiveData</code>来表示请求状态，如果成功或失败后需要弹<code>Toast</code>或者<code>Dialog</code>，或者页面中有多个请求，就需要定义更多的<code>LiveData</code>，<br>同时为了保证对外暴露的<code>LiveData</code>不可变，每个状态都需要定义两遍<code>LiveData</code>        </p>
<p>这就是为什么这种封装其实违背了不在<code>View</code>层写逻辑但仍然流行的原因，因为在<code>MVVM</code>架构中每处理一种状态，就需要添加两个<code>LiveData</code>，成本较高，大多数人并不愿意支付这个成本<br>而<code>MVI</code>架构正解决了这个问题    </p>
<h2 id="MVI架构下封装网络请求"><a href="#MVI架构下封装网络请求" class="headerlink" title="MVI架构下封装网络请求"></a><code>MVI</code>架构下封装网络请求</h2><p>之前已经介绍过了<code>MVI</code>架构，<code>MVI</code>架构使用方面我们就不再多说，我们直接来看下<code>MVI</code>架构下怎么发起一个简单网络请求    </p>
<h3 id="简单的网络请求"><a href="#简单的网络请求" class="headerlink" title="简单的网络请求"></a>简单的网络请求</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkViewModel</span> : <span class="type">ViewModel</span></span>() &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面请求，通常包括刷新页面loading状态等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">pageRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModelScope.rxLaunch&lt;String&gt; &#123;</span><br><span class="line">            onRequest = &#123;</span><br><span class="line">                _viewStates.setState &#123; copy(pageStatus = PageStatus.Loading) &#125;</span><br><span class="line">                delay(<span class="number">2000</span>)</span><br><span class="line">                <span class="string">"页面请求成功"</span></span><br><span class="line">            &#125;</span><br><span class="line">            onSuccess = &#123;</span><br><span class="line">                _viewStates.setState &#123; copy(content = it, pageStatus = PageStatus.Success) &#125;</span><br><span class="line">                _viewEvents.setEvent(NetworkViewEvent.ShowToast(<span class="string">"请求成功"</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            onError = &#123;</span><br><span class="line">                _viewStates.setState &#123; copy(pageStatus = PageStatus.Error(it)) &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># Activity层</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initViewModel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModel.viewStates.let &#123; state -&gt;</span><br><span class="line">        	<span class="comment">//监听网络请求状态</span></span><br><span class="line">            state.observeState(<span class="keyword">this</span>, NetworkViewState::pageStatus) &#123;</span><br><span class="line">                <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                    <span class="keyword">is</span> PageStatus.Success -&gt; state_layout.showContent()</span><br><span class="line">                    <span class="keyword">is</span> PageStatus.Loading -&gt; state_layout.showLoading()</span><br><span class="line">                    <span class="keyword">is</span> PageStatus.Error -&gt; state_layout.showError()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//监听页面数据</span></span><br><span class="line">            state.observeState(<span class="keyword">this</span>, NetworkViewState::content) &#123;</span><br><span class="line">                tv_content.text = it</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//监听一次性事件，如Toast,ShowDialog等   </span></span><br><span class="line">        viewModel.viewEvents.observe(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">when</span> (it) &#123;</span><br><span class="line">                <span class="keyword">is</span> NetworkViewEvent.ShowToast -&gt; toast(it.message)</span><br><span class="line">                <span class="keyword">is</span> NetworkViewEvent.ShowLoadingDialog -&gt; showLoadingDialog()</span><br><span class="line">                <span class="keyword">is</span> NetworkViewEvent.DismissLoadingDialog -&gt; dismissLoadingDialog()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，代码很简单   </p>
<ol>
<li>页面的所有状态都存储在<code>NetworkViewState</code>中，后面如果需要添加状态不需要添加<code>LiveData</code>，添加属性即可，<code>NetworkViewEvent</code>中存储了所有一次事件，同理     </li>
<li><code>ViewModel</code>中发起网络请求并监听网络请求回调，其中<code>viewModelScope.rxLaunch</code>是我们自定义的扩展方法，后面会再介绍    </li>
<li><code>ViewModel</code>中在请求的<code>onRequest</code>，<code>onSuccess</code>,<code>onError</code>时会通过<code>_viewStates</code>更新页面,通过<code>_viewEvents</code>添加一次性事件，如<code>Toast</code>    </li>
<li><code>View</code>层只需要监听<code>ViewState</code>与<code>ViewEvent</code>并更新<code>UI</code>,页面的逻辑全都在<code>ViewModel</code>中写   </li>
</ol>
<p>通过使用<code>MVI</code>架构，所有的逻辑都在<code>ViewModel</code>中处理，同时添加新状态时不需要添加<code>LiveData</code>,降低了<code>View</code>与<code>ViewModel</code>的通信成本，解决了<code>MVVM</code>架构下的一些问题   </p>
<h3 id="局部网络请求"><a href="#局部网络请求" class="headerlink" title="局部网络请求"></a>局部网络请求</h3><p>我们页面中通常会有一些局部网络请求，例如点赞，收藏等，这些网络请求不需要刷新整个页面，只需要处理单个<code>View</code>的状态或者弹出<code>Toast</code><br>下面我们来看下<code>MVI</code>架构下是如何实现的<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页面局部请求，例如点赞收藏等，通常需要弹dialog或toast</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">partRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModelScope.rxLaunch&lt;String&gt; &#123;</span><br><span class="line">        onRequest = &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.ShowLoadingDialog)</span><br><span class="line">            delay(<span class="number">2000</span>)</span><br><span class="line">            <span class="string">"点赞成功"</span></span><br><span class="line">        &#125;</span><br><span class="line">        onSuccess = &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.DismissLoadingDialog)</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.ShowToast(it))</span><br><span class="line">            _viewStates.setState &#123; copy(content = it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onError = &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.DismissLoadingDialog)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，针对局部网络请求，我们也是通过<code>_viewStates</code>与<code>_viewEvents</code>更新<code>UI</code>，并不需要添加额外的<code>LiveData</code>，使用起来比较方便   </p>
<h3 id="多数据源请求"><a href="#多数据源请求" class="headerlink" title="多数据源请求"></a>多数据源请求</h3><p>页面中通常也会有一些多数据源的请求，我们可以利用协程的<code>async</code>操作符处理<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">multiSourceRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModelScope.rxLaunch&lt;String&gt; &#123;</span><br><span class="line">        onRequest = &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.ShowLoadingDialog)</span><br><span class="line">            coroutineScope &#123;</span><br><span class="line">                <span class="keyword">val</span> source1 = async &#123; source1() &#125;</span><br><span class="line">                <span class="keyword">val</span> source2 = async &#123; source2() &#125;</span><br><span class="line">                <span class="keyword">val</span> result = source1.await() + <span class="string">","</span> + source2.await()</span><br><span class="line">                result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onSuccess = &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.DismissLoadingDialog)</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.ShowToast(it))</span><br><span class="line">            _viewStates.setState &#123; copy(content = it) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onError = &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.DismissLoadingDialog)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>我们的<code>APP</code>中通常需要一些通用的异常处理,我们可以封装在<code>rxLaunch</code>扩展方法中<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoroutineScopeHelper</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> coroutineScope: CoroutineScope) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rxLaunch</span><span class="params">(<span class="keyword">init</span>: <span class="type">LaunchBuilder</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span>: Job &#123;</span><br><span class="line">        <span class="keyword">val</span> result = LaunchBuilder&lt;T&gt;().apply(<span class="keyword">init</span>)</span><br><span class="line">        <span class="keyword">val</span> handler = NetworkExceptionHandler &#123;</span><br><span class="line">            result.onError?.invoke(it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coroutineScope.launch(handler) &#123;</span><br><span class="line">            <span class="keyword">val</span> res: T = result.onRequest()</span><br><span class="line">            result.onSuccess?.invoke(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上:    </p>
<ol>
<li><code>rxLaunch</code>就是我们定义的扩展方法，本质就是将协程转化为类<code>RxJava</code>的回调     </li>
<li>通用的异常处理可写在自定义的<code>NetworkExceptionHandler</code>中,如果请求错误则会自动处理     </li>
<li>处理后的异常将传递到<code>onError</code>中，供我们进一步处理     </li>
</ol>
<h2 id="MVI架构与Flow结合实现网络请求"><a href="#MVI架构与Flow结合实现网络请求" class="headerlink" title="MVI架构与Flow结合实现网络请求"></a><code>MVI</code>架构与<code>Flow</code>结合实现网络请求</h2><p>我们上面通过自定义扩展函数实现了<code>rxLaunch</code>，其实是将协程转化为类<code>RXJava</code>的写法，但其实<code>kotin</code>协程已经有了自己的<code>RXJava</code> : <code>Flow</code><br>我们完全可以利用<code>Flow</code>来实现同样的功能，不需要自己自定义    </p>
<h3 id="简单的网络请求-1"><a href="#简单的网络请求-1" class="headerlink" title="简单的网络请求"></a>简单的网络请求</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页面请求，通常包括刷新页面loading状态等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">pageRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModelScope.launch &#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            delay(<span class="number">2000</span>)</span><br><span class="line">            emit(<span class="string">"页面请求成功"</span>)</span><br><span class="line">        &#125;.onStart &#123;</span><br><span class="line">            _viewStates.setState &#123; copy(pageStatus = PageStatus.Loading) &#125;</span><br><span class="line">        &#125;.onEach &#123;</span><br><span class="line">            _viewStates.setState &#123; copy(content = it, pageStatus = PageStatus.Success) &#125;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.ShowToast(it))</span><br><span class="line">        &#125;.commonCatch &#123;</span><br><span class="line">            _viewStates.setState &#123; copy(pageStatus = PageStatus.Error(it)) &#125;</span><br><span class="line">        &#125;.collect()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在<code>flow</code>中发起网络请求并将结果通过<code>emit</code>回调   </li>
<li><code>onStart</code>是请求的开始，这里触发<code>Activity</code>中的<code>showLoading</code>     </li>
<li>在<code>onEach</code>中获取<code>flow</code>中<code>emit</code>的结果，即成功回调，在这里更新请求状态与页面数据    </li>
<li>在<code>commonCatch</code>中捕获异常   </li>
<li>局部的网络请求与这里类似，并且不需要添加额外的<code>LiveData</code>，这里就不缀述了     </li>
</ol>
<h3 id="多数据源网络请求"><a href="#多数据源网络请求" class="headerlink" title="多数据源网络请求"></a>多数据源网络请求</h3><p><code>Flow</code>中提供了多个操作符，可以将多个<code>Flow</code>的结果组合起来<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多数据源请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">multiSourceRequest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModelScope.launch &#123;</span><br><span class="line">        <span class="keyword">val</span> flow1 = flow &#123;</span><br><span class="line">            delay(<span class="number">1000</span>)</span><br><span class="line">            emit(<span class="string">"数据源1"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> flow2 = flow &#123;</span><br><span class="line">            delay(<span class="number">2000</span>)</span><br><span class="line">            emit(<span class="string">"数据源2"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        flow1.zip(flow2) &#123; a, b -&gt;</span><br><span class="line">            <span class="string">"<span class="variable">$a</span>,<span class="variable">$b</span>"</span></span><br><span class="line">        &#125;.onStart &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.ShowLoadingDialog)</span><br><span class="line">        &#125;.onEach &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.DismissLoadingDialog)</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.ShowToast(it))</span><br><span class="line">            _viewStates.setState &#123; copy(content = it) &#125;</span><br><span class="line">        &#125;.commonCatch &#123;</span><br><span class="line">            _viewEvents.setEvent(NetworkViewEvent.DismissLoadingDialog)</span><br><span class="line">        &#125;.collect()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上，我们通过<code>zip</code>操作符组合两个<code>Flow</code>，它将合并两个<code>Flow</code>的结果并回调,我们在<code>onEach</code>中将得到<code>数据源1,数据源2</code>              </p>
<h3 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h3><p>跟上面一样，有时我们需要配置一些能用的异常处理，可以看到，我们在上面调用了<code>commonCatch</code>，这其实也是我们自定义的一个扩展函数<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Flow<span class="type">&lt;T&gt;</span>.<span class="title">commonCatch</span><span class="params">(action: <span class="type">suspend</span> <span class="type">FlowCollector</span>&lt;<span class="type">T</span>&gt;.(<span class="type">cause</span>: <span class="type">Throwable</span>) -&gt; <span class="type">Unit</span>)</span></span>: Flow&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (it <span class="keyword">is</span> UnknownHostException || it <span class="keyword">is</span> SocketTimeoutException) &#123;</span><br><span class="line">            MyApp.<span class="keyword">get</span>().toast(<span class="string">"发生网络错误，请稍后重试"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            MyApp.<span class="keyword">get</span>().toast(<span class="string">"请求失败，请重试"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        action(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，其实是对<code>Flow.catch</code>的一个封装，读者可以根据自己的需求封装处理     </p>
<h2 id="关于Repository"><a href="#关于Repository" class="headerlink" title="关于Repository"></a>关于<code>Repository</code></h2><p>可以看到，我上面都没有使用到<code>Repository</code>，都是直接在<code>ViewModel</code>层中处理<br>平常在项目开发中也可以发现，一般的页面并没有写<code>Repository</code>的需要，直接在<code>ViewModel</code>中处理即可    </p>
<p>但如果数据获取比较复杂，比如同时从网络与本地数据获取，或者需要复用网络请求等时，也可以添加一个<code>Repository</code><br>我们可以通过<code>Repository</code>获取数据后，再通过<code>_viewState</code>更新页面状态，如下所示<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchNews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModelScope.launch &#123;</span><br><span class="line">        flow &#123;</span><br><span class="line">            emit(repository.getMockApiResponse())</span><br><span class="line">        &#125;.onStart &#123;</span><br><span class="line">            _viewStates.setState &#123; copy(fetchStatus = FetchStatus.Fetching) &#125;</span><br><span class="line">        &#125;.onEach &#123;</span><br><span class="line">            _viewStates.setState &#123; copy(fetchStatus = FetchStatus.Fetched, newsList = it.<span class="keyword">data</span>)&#125;</span><br><span class="line">        &#125;.commonCatch &#123;</span><br><span class="line">            _viewStates.setState &#123; copy(fetchStatus = FetchStatus.Fetched) &#125;</span><br><span class="line">        &#125;.collect()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在<code>MVVM</code>架构下一般使用<code>StateLiveData</code>来进行网络架构封装,并在<code>View</code>层监听回调，这种封装方式的问题在于将网络请求回调处理逻辑转移到了<code>View</code>层，违背了尽量不在<code>View</code>层写逻辑的原则<br>但这种写法流行的原因在于<code>MVVM</code>架构下<code>View</code>与<code>ViewModel</code>交互成本较高，如果每个请求的回调都在<code>ViewModel</code>中处理，则需要定义很多<code>LiveData</code>，这是很多人不愿意做的    </p>
<p>而<code>MVI</code>架构解决了这个问题，将页面所有状态放在一个<code>ViewState</code>中，对外也只需要暴露一个<code>LiveData</code><br><code>MVI</code>配合<code>Flow</code>或者自定义扩展函数，可以将页面逻辑全部放在<code>ViewModel</code>中，<code>View</code>层只需要监听<code>LiveData</code>的属性并刷新<code>UI</code>即可<br>当页面需要添加状态时，只需要给<code>ViewState</code>添加一个属性而不是添加两个<code>LiveData</code>,降低了<code>View</code>与<code>ViewModel</code>的交互成本     </p>
<p>如果你也觉得在<code>View</code>层监听网络请求回调不是一个很好的设计的话，那么可以尝试使用一下<code>MVI</code>架构       </p>
<p>如果本文对你有所帮助，欢迎点赞关注<code>Star</code>~</p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p>本文所有代码可见：<a href="https://github.com/shenzhen2017/android-architecture" target="_blank" rel="noopener">https://github.com/shenzhen2017/android-architecture</a>    </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>那些容易混淆的设计模式，了解一下~</title>
    <url>/blog/2021/11/confuse-design-pattern.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>了解过设计模式的同学都知道，设计模式家族成员非常多，具体可以分为3类共23种设计模式<br>对我们来说，设计模式在种类上实在是有些多了，而且很多设计模式非常类似，让人傻傻分不清<br>本文主要介绍一些容易混淆的设计模式，以加深对设计模式的理解      </p>
<p>本文主要包括以下内容  </p>
<ol>
<li>六大设计原则的介绍     </li>
<li>简单工厂、工厂方法与抽象工厂模式的区别    </li>
<li>代理，装饰与适配器模式的区别     </li>
<li>策略、状态与命令模式的区别       </li>
</ol>
<h2 id="设计原则介绍"><a href="#设计原则介绍" class="headerlink" title="设计原则介绍"></a>设计原则介绍</h2><p>众所周知，5大设计原则一般有6个          </p>
<ul>
<li>单一职责原则(<code>Single Responsibility Principle, SRP</code>)</li>
<li>开闭原则(<code>Open Close Principle, OCP</code>)</li>
<li>里氏替换原则(<code>Liskov Substitution Principle, LSP</code>)</li>
<li>依赖倒置原则(<code>Dependence Inversion Principle, DIP</code>)</li>
<li>接口隔离原则(<code>Interface Segregation Principle, ISP</code>)</li>
<li>迪米特法则(<code>Law of Demeter, LoD</code>),又称最少知识原则(<code>Principle of Least Knowledge</code>)</li>
</ul>
<blockquote>
<p>其中，前5个原则称为<code>SOLID</code>原则</p>
</blockquote>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则很简单也很好理解：类的职责应该单一，一个方法只做一件事,这里就不多说了   </p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则是说程序对扩展开放，对修改关闭：当你的程序需要扩展时，不应该修改原来的代码，而是可以添加一个类来扩展。<br>比如商品打折，可以更改原来的商品类的<code>getPrice</code> 方法，也可以增加一个子类，重写<code>getPrice</code>方法，通过高层模块，在打折时使用子类。      </p>
<p>开闭原则的思想其实是将不变的地方封装起来，将可变的部分暴露出去，这样它们就不会混淆，还可以复用不变的部分，增加扩展性<br>开闭原则的优点就在于：原来的代码不用更改，而且还可以复用原来的代码     </p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则用一句话描述就是：所有引用基类的地方，必须能够使用其子类直接替换，换句话说，所有引用基类的地方必须透明地使用其子类对象。<br>但是这看起来有点奇怪，因为在<code>Java</code>中，引用基类的地方，本来就可以用子类替换，为什么要提出个原则?<br>这是因为子类可以重写父类的方法，如果父类中有个加法方法，在子类中重写成减法后，如果使用子类替换父类，会导致意料之外的问题      </p>
<p>里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在子类中尽量不要重写父类得方法，在适当的情况下，可以通过聚合，组合，依赖来解决问题<br>通用的做法是：如果子类需要重写父类的方法，则可以将原有的继承关系去掉，原来的父类<code>A</code>和子类<code>B</code>都继承一个更通俗的基类，如果<code>B</code>需要使用到<code>A</code>的方法，可以使用组合的方式实现<br>具体示例可参见:<a href="https://juejin.cn/post/6931267443876691976" target="_blank" rel="noopener">设计模式之里氏替换原则</a>  </p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>所谓依赖倒置就是：高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口<br>比如一个<code>Person</code>类需要实现收取信息，需要依赖于<code>Message</code>类，这里的<code>Person</code>就是高层次模块，<code>Message</code>就是低层次模块<br>依赖倒置其实是说,<code>Person</code>不应该依赖于<code>Message</code>的具体实现，而是应该依赖于一个抽象的接口，方便后续扩展        </p>
<p>所以说所谓依赖倒置就是面向接口编程，但这个名字的确不是很好理解      </p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则简单来说就是：类不应该依赖它不需要的接口,即一个类对另一个类的依赖应该建立在最小的接口上<br>这与单一职责原则比较像，单一职责原则针对职责，从业务逻辑划分，而接口隔离原则则要求接口的方法尽量少<br>感觉这跟最小知识原则又比较像，一个类不应该知道它不需要的东西   </p>
<h3 id="最小知识原则"><a href="#最小知识原则" class="headerlink" title="最小知识原则"></a>最小知识原则</h3><p>最小知识原则也很容易理解：一个对象应该对其他对象有最少的了解。最小知识原则对类的低耦合提出了明确的要求</p>
<h2 id="简单工厂、工厂方法与抽象工厂模式的区别"><a href="#简单工厂、工厂方法与抽象工厂模式的区别" class="headerlink" title="简单工厂、工厂方法与抽象工厂模式的区别"></a>简单工厂、工厂方法与抽象工厂模式的区别</h2><p>工厂模式是我们经常用的模式之一，但是由于它可以细分为3种，很容易让人混淆<br>我们首先列出他们的定义:    </p>
<ol>
<li>简单工厂模式：又称为静态方法工厂模式，是由一个工厂对象决定创建哪一个产品类的实例。</li>
<li>工厂方法模式：创建一个用户创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的初始化延迟到其子类。</li>
<li>抽象工厂模式：为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定它们的具体类。</li>
</ol>
<p>三种模式的<code>UML</code>图如下<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p3.png" alt><br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p4.png" alt><br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p5.png" alt>       </p>
<p>可以看出它们的主要区别就在于   </p>
<ol>
<li>简单工厂模式：一个工厂方法创建不同类型的对象         </li>
<li>工厂方法模式：一个具体的工厂类负责创建一个具体对象类型        </li>
<li>抽象工厂模式：一个具体的工厂类负责创建一系列相关的对象     </li>
</ol>
<h2 id="代理，装饰与适配器模式的区别"><a href="#代理，装饰与适配器模式的区别" class="headerlink" title="代理，装饰与适配器模式的区别"></a>代理，装饰与适配器模式的区别</h2><p>在结构型设计模式中，结构相似且比较容易混淆的模式有代理、装饰、适配器模式。首先，我们还是列出它们的定义以及<code>UML</code>图。       </p>
<ol>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问      </li>
<li>装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更加灵活       </li>
<li>适配器模式：把一个类的接口变换成客户端所期待的另一个接口，从而使原本因接口不匹配而无法工作的两个类能够在一起工作     </li>
</ol>
<p>三种模式的<code>UML</code>图分别如下：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p6.png" alt><br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p7.png" alt><br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p8.png" alt>       </p>
<p>它们的主要区别在于：  </p>
<ol>
<li><strong>代理模式的特点在于隔离</strong>，隔离调用类和被调用类的关系，通过一个代理类去调用，因此代理模式不需要传入原有的对象，内部会持有原有对象的实现      </li>
<li><strong>装饰器模式特点在于增强</strong>，他的特点是被装饰类和所有的装饰类必须实现同一个接口，而且必须持有被装饰的对象，可以无限装饰,被装饰对象通过构造函数传入   </li>
<li><strong>适配器的特点在于兼容</strong>, 适配器模式需要实现新的接口，代理，装饰器模式是与原对象实现同一个接口，而适配器类则是匹配新接口         </li>
</ol>
<p>总的来说就是如下三句话：</p>
<ol>
<li>代理模式是将一个类(<code>a</code>)转换成具体的操作类(<code>b</code>).</li>
<li>装饰模式是在一个原有类(<code>a</code>)的基础之上增加了某些新的功能变成另一个类(<code>b</code>).         </li>
<li>适配器模式是将一个类(<code>a</code>)通过某种方式转换成另一个类(<code>b</code>).         </li>
</ol>
<h2 id="策略、状态与命令模式的区别"><a href="#策略、状态与命令模式的区别" class="headerlink" title="策略、状态与命令模式的区别"></a>策略、状态与命令模式的区别</h2><p>策略，状态与命令模式，这三种设计模式都是行为型设计模式，在结构上又都很像，容易让人混淆，我们也首先来看下它们的定义与<code>UML</code>图     </p>
<ol>
<li>策略模式：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换</li>
<li>状态模式：状态模式中的行为是由状态来决定的，不同的状态下有不同的行为。允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。     </li>
<li>命令模式：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能</li>
</ol>
<p>其<code>UML</code>图如下所示<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p9.png" alt><br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p10.png" alt><br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p11.png" alt>       </p>
<p>我们可以看到，策略与状态模式，它们的类图居然是一样的.虽然它们类型接口一样，但是它们的本质不一样。<br>区分这三种模式不要关注在结构上，这三种模式最主要是在使用意图上有区别：    </p>
<ol>
<li>策略模式：策略模式关注的是算法替换的问题，用一个新的算法替换旧算法，或者提供多种算法由调用者选择，算法的自由替换是它实现的重点    </li>
<li>状态模式：状态模式策略模式很相似，也是将类的”状态”封装了起来，在执行动作时进行相应的替换，从而实现，类在不同状态下的同一动作显示出不同结果。它与策略模式的区别在于，这种转换是”自动”，”无意识”的。策略模式会控制对象使用什么策略，而状态模式会自动改变状态。状态模式内部维护一个状态，会随着<code>public api</code>的调用进行相应的状态转移。外界不需要知道状态及其变化情况。       </li>
<li>命令模式：命令模式则关注的是解耦问题，如何让请求者和执行者解耦是它首先需要解决的，解耦的要求就是把请求的内容封装为一个个命令，由接收者执行。由于封装成了命令，就同时可以对命令进行多种处理，例如通过统一的<code>execute</code>接口执行命令,或者将命令存储起来，后续做撤销或者恢复功能      </li>
</ol>
<p>关于策略模式与状态模式对比的具体示例，可参见：<a href="https://www.runoob.com/w3cnote/state-vs-strategy.html" target="_blank" rel="noopener">策略模式 VS 状态模式</a>   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了设计模式六大原则，以及几种类似的容易让人混淆的设计模式。<br>希望可以通过分析比较这几种容易混淆的设计模式，更加深入地了解它们的异同与适用场景，加深对设计模式的了解<br>如果本文对你有所帮助，欢迎点赞关注收藏~    </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6847902225717854215" target="_blank" rel="noopener">设计模式概览：六大设计原则</a><br><a href="https://blog.yorek.xyz/design-pattern/confusing-design-pattern/" target="_blank" rel="noopener">易混淆的设计模式</a><br><a href="https://www.jianshu.com/p/c156b5e23e30" target="_blank" rel="noopener">适配器模式，装饰模式，代理模式异同</a><br><a href="https://www.runoob.com/w3cnote/state-vs-strategy.html" target="_blank" rel="noopener">策略模式 VS 状态模式</a>    </p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【2021年终总结】战胜拖延症的4种实用方法</title>
    <url>/blog/2021/11/2021-year-summary.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又到了一年一度的年终总结，每到这个时间点,都是大家总结盘点一年的收获并立下新的一年的<code>Flag</code>的时候~<br>但相信大家也有经验，年初定好的计划，往往不了了之，毕竟定下目标简单，而实现起来却有些困难<br>本文主要介绍一下我2020年立下的<code>Flag</code>与2021年的实现情况，并分享一些实现目标，战胜拖延症的实用方法，希望对大家有所帮助      </p>
<h2 id="2020年立下的Flag与完成情况"><a href="#2020年立下的Flag与完成情况" class="headerlink" title="2020年立下的Flag与完成情况"></a>2020年立下的<code>Flag</code>与完成情况</h2><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p21.jpg" alt><br><code>Flag</code>就立在这里，下面我们来看下完成情况  </p>
<ul>
<li>[x] <del>掘金升级到<code>LV4</code></del></li>
<li>[x] <del>做一个100以上<code>star</code>的<code>Github</code>开源项目</del>      </li>
<li>[x] <del>读几本计算机原理，计算机网络，数据结构等基础领域的书</del>     </li>
<li>[ ] 掌握<code>flutter</code>的使用与相关原理</li>
<li>[ ] 掌握<code>android</code>性能监控与优化的原理与使用</li>
<li>[x] <del>继续坚持<code>ARTS</code>打卡</del></li>
<li>[x] <del>继续坚持每周的总结与下周规划</del>   </li>
</ul>
<p>可以看出，有些计划如期完成了，有些则不然,我感觉对于一年的长期计划来说，完成得还算不错<br>其中<code>Flutter</code>的学习由于决定先学习<code>Compose</code>于是被搁置了，而性能监控与优化，今年主要学习总结了布局优化，启动优化，内存优化等.<br>但还有不少内容如稳定性优化，网络优化等没有涉及到，同时感觉还有深入的空间，所以不能算完成。   </p>
<h2 id="2021年的收获"><a href="#2021年的收获" class="headerlink" title="2021年的收获"></a>2021年的收获</h2><p>说实话，其实在2020年立下的<code>Flag</code>到底能不能实现，其实当时心里也是没什么底的，但今年一步一步走来,积少成多，的确有了一些小收获~     </p>
<ul>
<li>参加了掘金不少活动，集齐了衬衣，卫衣，搪瓷杯，抱枕等掘金周边（掘金<code>yyds</code>）</li>
<li>成功升级到掘金<code>LV4</code>（去年这个时候我还是个卑微的<code>LV2</code>）</li>
<li><code>Github</code>拿到了大概400个<code>Star</code>(超预期完成)     </li>
<li>学习并掌握了<code>Compose</code>的基本原理与使用，开源了多个<code>Compose</code>项目</li>
<li>读完了《图解<code>Http</code>》,《<code>HeadFirst</code>设计模式》,《深入理解<code>Kotlin</code>协程》等书    </li>
<li>坚持了<code>ARTS</code>打卡与每周总结与下周规划     </li>
</ul>
<p>顺便打个广告，今年主要完成了以下几个开源项目，如果对你有所帮助，欢迎<code>Star</code>:    </p>
<ul>
<li><a href="https://github.com/shenzhen2017/android-architecture" target="_blank" rel="noopener">基于 MVI 探索 Android 开发架构更佳实践</a>     </li>
<li><a href="https://github.com/shenzhen2017/wanandroid-compose" target="_blank" rel="noopener">Compose + MVI + Navigation 实现 wanAndroid 客户端</a></li>
<li><a href="https://github.com/shenzhen2017/compose-refreshlayout" target="_blank" rel="noopener">Compose 版 SmartRefreshLayout</a></li>
<li><a href="https://github.com/shenzhen2017/EasyFloat" target="_blank" rel="noopener">不需要权限的悬浮窗方案</a></li>
</ul>
<h2 id="战胜拖延症的实用方法"><a href="#战胜拖延症的实用方法" class="headerlink" title="战胜拖延症的实用方法"></a>战胜拖延症的实用方法</h2><p>上面介绍了去年立的<code>Flag</code>与今年的完成情况，下面介绍一些战胜拖延症的实用方法，希望对你有所帮助   </p>
<h3 id="ARTS打卡"><a href="#ARTS打卡" class="headerlink" title="ARTS打卡"></a><code>ARTS</code>打卡</h3><p>还是再介绍一下<code>ARTS</code>打卡,<code>ARTS</code> 源于极客时间《左耳听风》专栏组织的一个学习打卡活动，四个字母对应着四个行动准则：       </p>
<ul>
<li><code>Algorithm</code>：每周至少做一个 <code>leetcode</code> 的算法题</li>
<li><code>Review</code>: 阅读并点评一篇英文技术文章</li>
<li><code>Tip</code>：学习至少一个技术技巧</li>
<li><code>Share</code>：[撰写并]分享一篇有观点和思考的技术文章</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c876d09da9a4009ad5b36bd39865e10~tplv-k3u1fbpfcp-watermark.awebp" alt>      </p>
<p>相信大家都有经验，拖延往往是因为任务太大无从下手，或者不知道该做什么，不了了之<br><code>ARTS</code>打卡相当于每周要完成的功课，拆解成一个一个任务，并设置了一个<code>DeadLine</code>,为了提高坚持下去的动力，可以组建一个打卡群，或者发给朋友之类的，提高坚持下去的概率。<br>我大概坚持了<code>ARTS</code>打卡1年左右，感觉还是挺实用的    </p>
<h3 id="敏捷开发思想的应用"><a href="#敏捷开发思想的应用" class="headerlink" title="敏捷开发思想的应用"></a>敏捷开发思想的应用</h3><p>我们在年初制定的计划，往往不了了之，难以实现，究竟是什么原因呢？可以如何改进呢？<br>我感觉我们可以借鉴下企业如何是保证项目交付的，企业的项目交付，和我们的新年计划，其实本质不都是一样的吗？即长期计划的执行问题      </p>
<p>我们公司主要采用<code>SCRUM</code>敏捷开发的模式,这个模式难道不可以用于个人计划的管理吗？     </p>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p22.png" alt="PDCA循环"><br>如上所示，<code>SCRUM</code>一般就是通过一个又一个<code>Sprint</code>(迭代)，一个迭代完成一个<code>PDCA</code>循环，最终完成长期目标     </p>
<p>一般一个<code>Sprint</code>(迭代)可以分为以下几步    </p>
<ol>
<li>拟定和评估待办事项清单，即确定需求列表     </li>
<li>冲刺启动会,一般是将需求按照优先级排序，并将本周要完成的需求拆解成子任务      </li>
<li>每日立会,即每天开一个简短的立会，目标是同步进度，及时更新任务状态    </li>
<li>成果展示和评估,即开发完成后的成果展示   </li>
<li>冲刺回顾和新冲刺规划,即回顾已完成的事项，看看哪些比较顺利，哪些有改进的空间，回顾完成后即开始下个<code>Sprint</code>的规划    </li>
</ol>
<p>这样看来，其实敏捷开发就是一套保证项目进度的方法论，这样好的方法不仅可以用于公司项目的规划，也可以用于个人计划的规划与完成    </p>
<p>目前敏捷开发的模式已经得到了广泛的应用，并且有了不少支撑敏捷开发的工具，比如<a href="https://www.atlassian.com/software/jira" target="_blank" rel="noopener">Jira</a><br><code>Jira</code>支持<code>Backlog</code>(需求列表)与敏捷看板，需求列表承载所有需求，敏捷看板则承载本次迭代进行中的需求<br>通常一个敏捷看板至少包含：<code>ToDo</code>（待办事项）、<code>InProgress</code>（处理中的事项）、<code>Done</code>（已完成事项）三个部分。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c21c903742497496f34365f698c80f~tplv-k3u1fbpfcp-watermark.awebp" alt>    </p>
<p>如上，每个任务的状态都可以实时跟踪，并且可以通过拖动更新，并且可以划分为子任务，极大地方便了我们对任务状态进行管理，我感觉比起<code>TODO</code>列表是有一定优势的，<code>Jira</code>目前个人用户也可以注册并且是免费的，感兴趣的同学可以尝试下    </p>
<p>敏捷开发的思想可以帮助我们把长期任务拆解成一个一个的子任务，并且通过一个又一个迭代来完成它，我相信这对于我们完成目标应该有所帮助。       毕竟任务拖延的原因，一般要么就是任务太大无从下手，要么就是计划的时间太长，没有机制保证结果。<br>将长期目标拆解成每周一个迭代，进而拆解成一个一个小任务，相信可以帮助你更好地完成目标~    </p>
<h3 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h3><p>手机是当代人集中注意力的大敌，相信大家闲下来时，可能都会过一会儿就忍不住去看下手机，番茄工作法就是一种思想非常朴素的时间管理疗法。<br>其基本思想就是，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后进行短暂休息一下（5分钟就行），然后再开始下一个番茄。每4个番茄时段多休息一会儿。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c939a18f0274c619a4249535a9c0ebd~tplv-k3u1fbpfcp-watermark.awebp" alt>    </p>
<p>当然番茄工作法看起来简单，但实现起来却有点困难，因为一般番茄钟<code>APP</code>是应用级别的，在你打开番茄钟后，很容易因为一条推送，或者因为松懈，就切换到其他<code>APP</code>了<br>所以我一般使用手机系统自带的专注模式，专注模式开启后在30分钟或1个小时内，手机仅可使用紧急呼叫，并且不能中途退出，不给自己留退路。       </p>
<p>同时<strong>根据惯性定律:改变物体状态时需要的力最大</strong>，当我们想要从拖延状态切换到工作状态时，这个切换过程是最困难的。<br>每当你感觉自己开始拖延的时候，想都不要想地放下当下手里所有的事，立刻开始做你最不想做却不得不做的那件事                </p>
<p>因此我一般将开启专注模式，切断与手机的联系作为状态切换的开关，今年我总共使用专注模式大概300小时，如下所示:<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p24.jpg" alt>     </p>
<h3 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h3><p>相信大家都听过一句话，能教会别人才是真正的懂了，这句话背后的原理其实就是费曼学习法<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2021/november/p25.jpg" alt><br>当我们学习一个知识点时，并不是学过了就算学完了，一定要有一定的输出，这个输出可以是博客，视频，或者是在代码中使用<br>在输出过程中，我们肯定也会遇到新的问题，然后继续学习、分享，循环这样一个过程，最终更全面的掌握知识，最终触类旁通，举一反三。<br><strong>通过输出的方式可以帮助我们更加深入的掌握知识点</strong>       </p>
<p>同时输出的过程对我来说也是一个得到激励的过程，你的每一个赞，每一条评论，对我来说都是一个激励，这样的激励反过来会鼓励我们输出，形成正向循环，从而帮助我们战胜拖延症.    </p>
<h2 id="2022的展望"><a href="#2022的展望" class="headerlink" title="2022的展望"></a>2022的展望</h2><p>接下来再立下2022年的<code>Flag</code>吧,看看明年能实现多少~      </p>
<ul>
<li>持续输出，掘金升级到<code>LV5</code></li>
<li>坚持开源，<code>Github</code>的<code>Star</code>数突破1000    </li>
<li>维护一个技术公众号，并突破500粉丝</li>
<li>计算机基础巩固，继续学习操作系统,计算机网络,数据结构等知识</li>
<li>继续深入学习<code>Compose</code>原理并输出,继续开源<code>Compose</code>项目</li>
<li>深入掌握一种跨平台技术，<code>Flutter</code>或者前端技术     </li>
<li>继续坚持<code>ARTS</code>打卡，坚持每周总结与下周规划</li>
<li>最后，希望以上都能实现</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们常常在年初时雄心壮志，信心满满，在年尾时又感叹时间怎么过得这么快。<br>本文主要介绍了战胜拖延症的几种实用方法，如果你也有相同的困扰，希望会有所帮助。<br>希望我们都能实现自己的目标，成为一个长期主义者，成为时间的朋友，随着时间一起成长~     </p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Google 推荐使用 MVI 架构？卷起来了~</title>
    <url>/blog/2022/01/google-recommend-mvi.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间写了一些介绍<code>MVI</code>架构的文章，不过软件开发上没有最好的架构，只有最合适的架构，同时众所周知，<code>Google</code>推荐的是<code>MVVM</code>架构。相信很多人都会有疑问，我为什么不使用官方推荐的<code>MVVM</code>，而要用你说的这个什么<code>MVI</code>架构呢？<br>不过我这几天查看<code>Android</code>的<a href="https://developer.android.com/jetpack/guide" target="_blank" rel="noopener">应用架构指南</a>，发现谷歌推荐的最佳实践已经变成了<code>单向数据流动</code> + <code>状态集中管理</code>，这不就是<code>MVI</code>架构吗？<br>看起来<code>Google</code>已经开始推荐使用<code>MVI</code>架构了，大家也有必要开始了解一下<code>Android</code>应用架构指南的最新版本了~     </p>
<p>本文主要基于<a href="https://developer.android.com/jetpack/guide" target="_blank" rel="noopener">Android应用架构指南</a>，感兴趣的也可以直接查看原文</p>
<h2 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h2><h3 id="两个架构原则"><a href="#两个架构原则" class="headerlink" title="两个架构原则"></a>两个架构原则</h3><p><code>Android</code>的架构设计原则主要有两个     </p>
<h4 id="分离关注点"><a href="#分离关注点" class="headerlink" title="分离关注点"></a>分离关注点</h4><p>要遵循的最重要的原则是分离关注点。一种常见的错误是在一个 <code>Activity</code> 或 <code>Fragment</code> 中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。<br>总得来说，<code>Activity</code>或<code>Fragment</code>中的代码应该尽量精简，尽量将业务逻辑迁移到其它层</p>
<h4 id="通过数据驱动界面"><a href="#通过数据驱动界面" class="headerlink" title="通过数据驱动界面"></a>通过数据驱动界面</h4><p>另一个重要原则是您应该通过数据驱动界面（最好是持久性模型）。数据模型独立于应用中的界面元素和其他组件。<br>这意味着它们与界面和应用组件的生命周期没有关联，但仍会在操作系统决定从内存中移除应用的进程时被销毁。<br>数据模型与界面元素，生命周期解耦，因此方便复用，同时便于测试，更加稳定可靠。      </p>
<h3 id="推荐的应用架构"><a href="#推荐的应用架构" class="headerlink" title="推荐的应用架构"></a>推荐的应用架构</h3><p>基于上一部分提到的常见架构原则，每个应用应至少有两个层：        </p>
<ul>
<li>界面层 - 在屏幕上显示应用数据。</li>
<li>数据层 - 提供所需要的应用数据。</li>
</ul>
<p>您可以额外添加一个名为“网域层”的架构层，以简化和复用使用界面层与数据层之间的交互<br><img src="https://developer.android.com/topic/libraries/architecture/images/mad-arch-overview.png" alt>     </p>
<p>如上所示，各层之间的依赖关系是单向依赖的，网域层，数据层不依赖于界面层   </p>
<h2 id="界面层"><a href="#界面层" class="headerlink" title="界面层"></a>界面层</h2><p>界面的作用是在屏幕上显示应用数据，并响应用户的点击。每当数据发生变化时，无论是因为用户互动（例如按了某个按钮），还是因为外部输入（例如网络响应），界面都应随之更新，以反映这些变化。<br>不过，从数据层获取的应用数据的格式通常不同于<code>UI</code>需要展示的数据的格式，因此我们需要将数据层数据转化为页面的状态<br>因此界面层一般分为两部分，即<code>UI</code>层与<code>State Holder</code>，<code>State Holder</code>的角色一般由<code>ViewModel</code>承担<br><img src="https://developer.android.com/topic/libraries/architecture/images/mad-arch-ui-overview.png" alt>    </p>
<p>数据层的作用是存储和管理应用数据，以及提供对应用数据的访问权限，因此界面层必须执行以下步骤：       </p>
<ol>
<li>获取应用数据，并将其转换为<code>UI</code>可以轻松呈现的<code>UI State</code>。     </li>
<li>订阅<code>UI State</code>，当页面状态发生改变时刷新<code>UI</code>       </li>
<li>接收用户的输入事件，并根据相应的事件进行处理，从而刷新<code>UI State</code>   </li>
<li>根据需要重复第 1-3 步。     </li>
</ol>
<p>主要是一个单向数据流动，如下图所示：<br><img src="https://developer.android.com/topic/libraries/architecture/images/mad-arch-ui-udf.png" alt>    </p>
<p>因此界面层主要需要做以下工作：  </p>
<ol>
<li>如何定义<code>UI State</code>。</li>
<li>如何使用单向数据流 (<code>UDF</code>)，作为提供和管理<code>UI State</code>的方式。</li>
<li>如何暴露与更新<code>UI State</code></li>
<li>如何订阅<code>UI State</code>    </li>
</ol>
<h3 id="如何定义UI-State"><a href="#如何定义UI-State" class="headerlink" title="如何定义UI State"></a>如何定义<code>UI State</code></h3><p>如果我们要实现一个新闻列表界面，我们该怎么定义<code>UI State</code>呢?我们将界面需要的所有状态都封装在一个<code>data class</code>中。<br>与之前的<code>MVVM</code>模式的主要区别之一也在这里，即之前通常是一个<code>State</code>对应一个<code>LiveData</code>，而<code>MVI</code>架构则强调对<code>UI State</code>的集中管理<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsUiState</span></span>(</span><br><span class="line">    <span class="keyword">val</span> isSignedIn: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">val</span> isPremium: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">val</span> newsItems: List&lt;NewsItemUiState&gt; = listOf(),</span><br><span class="line">    <span class="keyword">val</span> userMessages: List&lt;Message&gt; = listOf()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsItemUiState</span></span>(</span><br><span class="line">    <span class="keyword">val</span> title: String,</span><br><span class="line">    <span class="keyword">val</span> body: String,</span><br><span class="line">    <span class="keyword">val</span> bookmarked: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>以上示例中的<code>UI State</code>定义是不可变的。这样的主要好处是，不可变对象可保证即时提供应用的状态。这样一来，<code>UI</code>便可专注于发挥单一作用：读取<code>UI State</code>并相应地更新其<code>UI</code>元素。因此，切勿直接在<code>UI</code>中修改<code>UI State</code>。违反这个原则会导致同一条信息有多个可信来源，从而导致数据不一致的问题。</p>
<p>例如，如上中来自<code>UI State</code>的<code>NewsItemUiState</code>对象中的<code>bookmarked</code>标记在<code>Activity</code>类中已更新，那么该标记会与数据层展开竞争，从而产生多数据源的问题。     </p>
<h4 id="UI-State集中管理的优缺点"><a href="#UI-State集中管理的优缺点" class="headerlink" title="UI State集中管理的优缺点"></a><code>UI State</code>集中管理的优缺点</h4><p>在<code>MVVM</code>中我们通常是多个数据流，即一个<code>State</code>对应一个<code>LiveData</code>，而<code>MVI</code>中则是单个数据流。两者各有什么优缺点？<br>单个数据流的优点主要在于方便，减少模板代码，添加一个状态只需要给<code>data class</code>添加一个属性即可，可以有效地降低<code>ViewModel</code>与<code>View</code>的通信成本<br>同时<code>UI State</code>集中管理可以轻松地实现类似<code>MediatorLiveData</code>的效果，比如可能只有在用户已登录并且是付费新闻服务订阅者时，您才需要显示书签按钮。您可以按如下方式定义<code>UI State</code>：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsUiState</span></span>(</span><br><span class="line">    <span class="keyword">val</span> isSignedIn: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">val</span> isPremium: <span class="built_in">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">val</span> newsItems: List&lt;NewsItemUiState&gt; = listOf()</span><br><span class="line">)&#123;</span><br><span class="line">	<span class="keyword">val</span> canBookmarkNews: <span class="built_in">Boolean</span> <span class="keyword">get</span>() = isSignedIn &amp;&amp; isPremium</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，书签的可见性是其它两个属性的派生属性，其它两个属性发生变化时，<code>canBookmarkNews</code>也会自动变化，当我们需要实现书签的可见与隐藏逻辑，只需要订阅<code>canBookmarkNews</code>即可，这样可以轻松实现类似<code>MediatorLiveData</code>的效果，但是远比<code>MediatorLiveData</code>要简单    </p>
<p>当然，<code>UI State</code>集中管理也会有一些问题：   </p>
<ul>
<li>不相关的数据类型：<code>UI</code>所需的某些状态可能是完全相互独立的。在此类情况下，将这些不同的状态捆绑在一起的代价可能会超过其优势，尤其是当其中某个状态的更新频率高于其他状态的更新频率时。</li>
<li><code>UiState diffing</code>：<code>UiState</code> 对象中的字段越多，数据流就越有可能因为其中一个字段被更新而发出。由于视图没有 <code>diffing</code> 机制来了解连续发出的数据流是否相同，因此每次发出都会导致视图更新。当然，我们可以对 <code>LiveData</code> 或<code>Flow</code>使用 <code>distinctUntilChanged()</code> 等方法来实现局部刷新，从而解决这个问题  </li>
</ul>
<h3 id="使用单向数据流管理UI-State"><a href="#使用单向数据流管理UI-State" class="headerlink" title="使用单向数据流管理UI State"></a>使用单向数据流管理<code>UI State</code></h3><p>上文提到，为了保证<code>UI</code>中不能修改状态，<code>UI State</code>中的元素都是不可变的，那么如何更新<code>UI State</code>呢？<br>我们一般使用<code>ViewModel</code>作为<code>UI State</code>的容器，因此响应用户输入更新<code>UI State</code>主要分为以下几步：    </p>
<ol>
<li><code>ViewModel</code> 会存储并公开<code>UI State</code>。<code>UI State</code>是经过<code>ViewModel</code>转换的应用数据。</li>
<li><code>UI</code>层会向<code>ViewModel</code>发送用户事件通知。        </li>
<li><code>ViewModel</code>会处理用户操作并更新<code>UI State</code>。</li>
<li>更新后的状态将反馈给<code>UI</code>以进行呈现。</li>
<li>系统会对导致状态更改的所有事件重复上述操作。</li>
</ol>
<p>举个例子，如果用户需要给新闻列表加个书签，那么就需要将事件传递给<code>ViewModel</code>，然后<code>ViewModel</code>更新<code>UI State</code>(中间可能有数据层的更新)，<code>UI</code>层订阅<code>UI State</code>订响应刷新，从而完成页面刷新，如下图所示：<br><img src="https://developer.android.com/topic/libraries/architecture/images/mad-arch-ui-udf-in-action.png" alt>       </p>
<h4 id="为什么使用单向数据流动？"><a href="#为什么使用单向数据流动？" class="headerlink" title="为什么使用单向数据流动？"></a>为什么使用单向数据流动？</h4><p>单向数据流动可以实现关注点分离原则，它可以将状态变化来源位置、转换位置以及最终使用位置进行分离。<br>这种分离可让<code>UI</code>只发挥其名称所表明的作用：通过观察<code>UI State</code>变化来显示页面信息，并将用户输入传递给<code>ViewModel</code>以实现状态刷新。     </p>
<p>换句话说，单向数据流动有助于实现以下几点：         </p>
<ol>
<li>数据一致性。界面只有一个可信来源。</li>
<li>可测试性。状态来源是独立的，因此可独立于界面进行测试。</li>
<li>可维护性。状态的更改遵循明确定义的模式，即状态更改是用户事件及其数据拉取来源共同作用的结果。</li>
</ol>
<h2 id="暴露与更新UI-State"><a href="#暴露与更新UI-State" class="headerlink" title="暴露与更新UI State"></a>暴露与更新<code>UI State</code></h2><p>定义好<code>UI State</code>并确定如何管理相应状态后，下一步是将提供的状态发送给界面。我们可以使用<code>LiveData</code>或者<code>StateFlow</code>将<code>UI State</code>转化为数据流并暴露给<code>UI</code>层<br>为了保证不能在<code>UI</code>中修改状态，我们应该定义一个可变的<code>StateFlow</code>与一个不可变的<code>StateFlow</code>，如下所示：<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsViewModel</span></span>(...) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _uiState = MutableStateFlow(NewsUiState())</span><br><span class="line">    <span class="keyword">val</span> uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，<code>UI</code>层可以订阅状态，而<code>ViewModel</code>也可以修改状态,以需要执行异步操作的情况为例，可以使用<code>viewModelScope</code>启动协程，并且可以在操作完成时更新状态。     </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsViewModel</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> repository: NewsRepository,</span><br><span class="line">    ...</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> _uiState = MutableStateFlow(NewsUiState())</span><br><span class="line">    <span class="keyword">val</span> uiState: StateFlow&lt;NewsUiState&gt; = _uiState.asStateFlow()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> fetchJob: Job? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">fetchArticles</span><span class="params">(category: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        fetchJob?.cancel()</span><br><span class="line">        fetchJob = viewModelScope.launch &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> newsItems = repository.newsItemsForCategory(category)</span><br><span class="line">                _uiState.update &#123;</span><br><span class="line">                    it.copy(newsItems = newsItems)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ioe: IOException) &#123;</span><br><span class="line">                <span class="comment">// Handle the error and notify the notify the UI when appropriate.</span></span><br><span class="line">                _uiState.update &#123;</span><br><span class="line">                    <span class="keyword">val</span> messages = getMessagesFromThrowable(ioe)</span><br><span class="line">                    it.copy(userMessages = messages)</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>NewsViewModel</code> 类会尝试进行网络请求，然后更新<code>UI State</code>，然后<code>UI</code>层可以对其做出适当反应</p>
<h3 id="订阅UI-State"><a href="#订阅UI-State" class="headerlink" title="订阅UI State"></a>订阅<code>UI State</code></h3><p>订阅<code>UI State</code>很简单，只需要在<code>UI</code>层观察并刷新<code>UI</code>即可<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            repeatOnLifecycle(Lifecycle.State.STARTED) &#123;</span><br><span class="line">                viewModel.uiState.collect &#123;</span><br><span class="line">                    <span class="comment">// Update UI elements</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="UI-State实现局部刷新"><a href="#UI-State实现局部刷新" class="headerlink" title="UI State实现局部刷新"></a><code>UI State</code>实现局部刷新</h4><p>因为<code>MVI</code>架构下实现了<code>UI State</code>的集中管理，因此更新一个属性就会导致<code>UI State</code>的更新，那么在这种情况下怎么实现局部刷新呢？<br>我们可以利用<code>distinctUntilChanged</code>实现，<code>distinctUntilChanged</code>只有在值发生变化了之后才会回调刷新，相当于对属性做了一个防抖，因此我们可以实现局部刷新，使用方式如下所示<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewsActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        lifecycleScope.launch &#123;</span><br><span class="line">            repeatOnLifecycle(Lifecycle.State.STARTED) &#123;</span><br><span class="line">                <span class="comment">// Bind the visibility of the progressBar to the state</span></span><br><span class="line">                <span class="comment">// of isFetchingArticles.</span></span><br><span class="line">                viewModel.uiState</span><br><span class="line">                    .map &#123; it.isFetchingArticles &#125;</span><br><span class="line">                    .distinctUntilChanged()</span><br><span class="line">                    .collect &#123; progressBar.isVisible = it &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然我们也可以对其进行一定的封装，给<code>Flow</code>或者<code>LiveData</code>添加一个扩展函数，令其支持监听属性即可，使用方式如下所示<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initViewModel</span><span class="params">()</span></span> &#123;</span><br><span class="line">        viewModel.viewStates.run &#123;</span><br><span class="line">            <span class="comment">//监听newsList</span></span><br><span class="line">            observeState(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, MainViewState::newsList) &#123;</span><br><span class="line">                newsRvAdapter.submitList(it)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//监听网络状态</span></span><br><span class="line">            observeState(<span class="keyword">this</span><span class="symbol">@MainActivity</span>, MainViewState::fetchStatus) &#123;</span><br><span class="line">                <span class="comment">//..</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于<code>MVI</code>架构下支持属性监听，更加详细地内容可见：<a href="https://juejin.cn/post/7025222741322121223" target="_blank" rel="noopener">MVI 架构更佳实践：支持 LiveData 属性监听</a></p>
<h2 id="网域层"><a href="#网域层" class="headerlink" title="网域层"></a>网域层</h2><p>网域层是位于界面层和数据层之间的可选层。<br><img src="https://developer.android.com/topic/libraries/architecture/images/mad-arch-domain-overview.png" alt><br>网域层负责封装复杂的业务逻辑，或者由多个<code>ViewModel</code>重复使用的简单业务逻辑。此层是可选的，因为并非所有应用都有这类需求。因此，您应仅在需要时使用该层。<br>网域层具有以下优势：   </p>
<ol>
<li>避免代码重复。</li>
<li>改善使用网域层类的类的可读性。</li>
<li>改善应用的可测试性。</li>
<li>让您能够划分好职责，从而避免出现大型类。    </li>
</ol>
<p>我感觉对于常见的<code>APP</code>，网域层似乎并没有必要，对于<code>ViewModel</code>重复的逻辑，使用<code>util</code>来说一般就已足够<br>或许网域层适用于特别大型的项目吧，各位可根据自己的需求选用，关于网域层的详细信息可见：<a href="https://developer.android.com/jetpack/guide/domain-layer" target="_blank" rel="noopener">https://developer.android.com/jetpack/guide/domain-layer</a></p>
<h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>数据层主要负责获取与处理数据的逻辑，数据层由多个<code>Repository</code>组成，其中每个<code>Repository</code>可包含零到多个<code>Data Source</code>。您应该为应用处理的每种不同类型的数据创建一个<code>Repository</code>类。例如，您可以为与电影相关的数据创建 <code>MoviesRepository</code> 类，或者为与付款相关的数据创建 <code>PaymentsRepository</code> 类。当然为了方便，针对只有一个数据源的<code>Repository</code>，也可以将数据源的代码也写在<code>Repository</code>，后续有多个数据源时再做拆分   </p>
<p><img src="https://developer.android.com/topic/libraries/architecture/images/mad-arch-data-overview.png" alt><br>数据层跟之前的<code>MVVM</code>架构下的数据层并没用什么区别，这里就不多介绍了，关于数据层的详细信息可见：<a href="https://developer.android.com/jetpack/guide/data-layer" target="_blank" rel="noopener">https://developer.android.com/jetpack/guide/data-layer</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相比老版的架构指南，新版主要是增加了网域层并修改了界面层，其中网域层是可选的，各位各根据自己的项目需求使用。<br>而界面层则从<code>MVVM</code>架构变成了<code>MVI</code>架构，强调了数据的<code>单向数据流动</code>与<code>状态的集中管理</code>。相比<code>MVVM</code>架构，<code>MVI</code>架构主要有以下优点    </p>
<ol>
<li>强调数据单向流动，很容易对状态变化进行跟踪和回溯，在数据一致性，可测试性，可维护性上都有一定优势    </li>
<li>强调对<code>UI State</code>的集中管理，只需要订阅一个<code>ViewState</code>便可获取页面的所有状态，相对 <code>MVVM</code> 减少了不少模板代码    </li>
<li>添加状态只需要添加一个属性，降低了<code>ViewModel</code>与<code>View</code>层的通信成本，将业务逻辑集中在<code>ViewModel</code>中，<code>View</code>层只需要订阅状态然后刷新即可     </li>
</ol>
<p>当然在软件开发中没有最好的架构，只有最合适的架构，各位可根据情况选用适合项目的架构，实际上在我看来<code>Google</code>在指南中推荐使用<code>MVI</code>而不再是<code>MVVM</code>，很可能是为了统一<code>Android</code>与<code>Compose</code>的架构。因为在<code>Compose</code>中并没有双向数据绑定，只有单向数据流动，因此<code>MVI</code>是最适合<code>Compose</code>的架构。       </p>
<p>当然如果你的项目中没有使用<code>DataBinding</code>，或许也可以开始尝试一下使用<code>MVI</code>，不使用<code>DataBinding</code>的<code>MVVM</code>架构切换为<code>MVI</code>成本不高，切换起来也比较简单，在易用性，数据一致性，可测试性，可维护性等方面都有一定优势，后续也可以无缝切换到<code>Compose</code>。</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p><a href="https://juejin.cn/post/7022624191723601928" target="_blank" rel="noopener">MVVM 进阶版：MVI 架构了解一下~</a><br><a href="https://juejin.cn/post/7025222741322121223" target="_blank" rel="noopener">MVI 架构更佳实践：支持 LiveData 属性监听</a><br><a href="https://juejin.cn/post/7027815347281477645" target="_blank" rel="noopener">MVI 架构封装：快速优雅地实现网络请求</a><br><a href="https://developer.android.com/jetpack/guide" target="_blank" rel="noopener">Android应用架构指南</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose 实现手写春联效果</title>
    <url>/blog/2022/01/compose-write-spring.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又是一年新春，在这里先给大家拜个早年了。每逢春节，写春联贴春联都是一项必不可少的活动。本次主要使用<code>Compose</code>，实现手写春联的效果。如果对你有所帮助，欢迎点个赞或者评论鼓励一下~ </p>
<blockquote>
<p>爆竹声中一岁除<br>春风送暖入屠苏<br>千门万户曈曈日<br>总把新桃换旧符</p>
</blockquote>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/january/p1.gif" alt>     </p>
<h3 id="生成的春联"><a href="#生成的春联" class="headerlink" title="生成的春联"></a>生成的春联</h3><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/january/p12.jpg" alt>     </p>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>我们需要实现手写春联效果，首先就是要做事件监听，<code>Android</code>中自然是监听<code>Action_Down</code>，<code>Action_Move</code>，<code>Action_UP</code>，<code>Compose</code>中应该如何处理呢?<br>其实<code>Compose</code>中也可以利用<code>pointerInteropFilter</code>监听<code>Action_Down</code>，<code>Action_Move</code>，<code>Action_UP</code>,如下所示     </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Column(modifier = Modifier.pointerInteropFilter &#123;</span><br><span class="line">    <span class="keyword">when</span> (it.action) &#123;</span><br><span class="line">        MotionEvent.ACTION_DOWN -&gt; &#123;&#125;</span><br><span class="line">        MotionEvent.ACTION_MOVE -&gt; &#123;&#125;</span><br><span class="line">        MotionEvent.ACTION_UP -&gt; &#123;&#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt;  <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="路径绘制"><a href="#路径绘制" class="headerlink" title="路径绘制"></a>路径绘制</h3><p>当我们手写春联的时候，实际上就是把我们触摸过的点连接起来，最直接的想法当然是通过<code>Path</code>来绘制，即把各个点连接成<code>Path</code>,然后通过<code>drawPath</code>来绘制<br>但是问题在于春联是毛笔效果，在写的过程中路径的粗细会发生变化，而<code>drawPath</code>只支持固定的宽度，因此不符合我们的要求。      </p>
<p>所以我们换个思路，<code>drawPath</code>其实也是将各个点连接起来，如果我们将触摸过程中的点记录下来，然后在这一系列的点上画圆不就行了吗？每个圆的半径可以自定义，但这样会带来以下问题<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/january/p11.jpg" alt>      </p>
<p>可以看出:<code>android</code>触摸中的<code>MOVE</code>时间取点的频率不是非常高，会隔一定的像素取点。当轻触滑动时会出现不连续圆的情况，明显不符合笔锋效果     </p>
<h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>上面的问题在于<code>MOVE</code>过程中回调的次数有限，因此只会产生一系列不连续的点，而不是一条线，该如何解决呢？<br>我们可以想一下<code>Path</code>，其实它也只是定义了一系列的点，然后通过贝塞尔曲线将这些点连接起来，从而实现了曲线效果，我们是不是也可以通过类似的方式，将上面这些点连成线呢?    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActionMove</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> lastPoint = viewStates.value.curPoint</span><br><span class="line">    <span class="keyword">val</span> curPoint = ControllerPoint(event.x, event.y)</span><br><span class="line">    <span class="keyword">val</span> lineWidth = calWidth(event = event)</span><br><span class="line">    curPoint.width = lineWidth</span><br><span class="line">    <span class="keyword">if</span> (viewStates.value.pointList.size &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    	<span class="comment">//初始化贝塞尔曲线</span></span><br><span class="line">        bezier.<span class="keyword">init</span>(lastPoint, curPoint)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">//添加下一个点</span></span><br><span class="line">        bezier.addNode(curPoint)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> curDis = getDistance(event)</span><br><span class="line">    <span class="comment">//在两个点之间插入10个点，它们都在两个点连接的贝塞尔曲线上</span></span><br><span class="line">    <span class="keyword">val</span> steps: <span class="built_in">Int</span> = <span class="number">1</span> + (curDis / STEP_FACTOR).toInt()</span><br><span class="line">    <span class="keyword">val</span> step = <span class="number">1.0</span> / steps</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf&lt;ControllerPoint&gt;()</span><br><span class="line">    <span class="keyword">var</span> t = <span class="number">0.0</span></span><br><span class="line">    <span class="comment">// 插入10个点</span></span><br><span class="line">    <span class="keyword">while</span> (t &lt; <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> point: ControllerPoint = bezier.getPoint(t)</span><br><span class="line">        list.add(point)</span><br><span class="line">        t += step</span><br><span class="line">    &#125;</span><br><span class="line">    addPoints(list)</span><br><span class="line">    _viewStates.value = _viewStates.value.copy(curPoint = curPoint)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，主要做了以下工作：   </p>
<ol>
<li>当目前列表中只有1个点时，初始化贝塞尔曲线，即以上一个点为起始点，当前点为终点    </li>
<li>当列表中已经有2个点时，往贝塞尔曲线中加入当前点，将原来的终点变为起点，当前点变为新的终点     </li>
<li>在贝塞尔曲线的起点与终点之间插入多个点，它们的位置都在贝塞尔曲线上，具体的数量由<code>STEP_FACTOR</code>决定，我们目前暂定为10个    </li>
<li>当我们在2个点之间，插入了多个点之后，它们之间的空白就会被填补，看起来不像一条线一样       </li>
</ol>
<h3 id="可变的宽度"><a href="#可变的宽度" class="headerlink" title="可变的宽度"></a>可变的宽度</h3><p>上文说到毛笔的路径粗细是不断变化的，一般来说是越慢的地方笔划越粗，越快的地方笔划越细，同时两个相邻的点之间的宽度应该是渐变的，而不是突变的，计算笔画宽度的代码如下：   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calWidth</span><span class="params">(event: <span class="type">MotionEvent</span>)</span></span>: <span class="built_in">Float</span> &#123;</span><br><span class="line">	<span class="comment">// 滑动距离</span></span><br><span class="line">    <span class="keyword">val</span> distance = getDistance(event)</span><br><span class="line">    <span class="comment">// 滑动距离加个影响系数定义为速度</span></span><br><span class="line">    <span class="keyword">val</span> calVel = distance * <span class="number">0.002</span></span><br><span class="line">    <span class="comment">// 速度越大宽度越小，速度越小宽度越大</span></span><br><span class="line">    <span class="keyword">val</span> width = NORMAL_WIDTH * maxOf(exp(-calVel), <span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> width.toFloat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，主要做了以下工作：      </p>
<ol>
<li>虽然决定笔划粗细的是速度，但我们可以假定两次<code>MOVE</code>的间隔是大致相同的，因此计算出滑动距离即可   </li>
<li>因为我们希望笔划粗细有个最大值与最小值，因此我们需要给滑动距离加个影响系数，使<code>exp(-calVel)</code>的结果尽量在0.2与1之间   </li>
<li>速度越大宽度越小，速度越小宽度越大，当滑动速度为0时，<code>exp(-calVel)</code>即为1，而滑动速度越快，<code>exp(-calVel)</code>越接近于0    </li>
</ol>
<p>上面主要是<code>MOVE</code>回调的点的宽度计算，除了<code>MOVE</code>回调的点，贝塞尔曲线加入的点的宽度也应该在起点与终点的宽度之间渐变<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getW</span><span class="params">(<span class="keyword">double</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getWidth(mSource.width, mDestination.width, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getWidth</span><span class="params">(<span class="keyword">double</span> w0, <span class="keyword">double</span> w1, <span class="keyword">double</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w0 + (w1 - w0) * t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="绘制性能优化"><a href="#绘制性能优化" class="headerlink" title="绘制性能优化"></a>绘制性能优化</h3><p>上面我们通过保存<code>MOVE</code>过程中的点的方式实现绘制，当随着笔划越来越多，需要绘制的点也越来越多，在<code>onDraw</code>中对列表进行遍历然后绘制是比较耗性能的，同时每当列表更新，列表都会重新遍历<br>我们可以建立一个缓冲<code>bitmap</code>，<code>ACTION_UP</code>事件中将当前所有点绘制到缓冲<code>bitmap</code>中。在<code>draw</code>时直接将缓冲<code>bitmap</code>绘制到<code>canvas</code>中，如下所示：    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SpringBoard</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义内存图片</span></span><br><span class="line">	<span class="keyword">val</span> bitmap = remember &#123;</span><br><span class="line">        Bitmap.createBitmap(itemSize.toInt(), itemSize.toInt(), Bitmap.Config.ARGB_8888)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> newCanvas = remember &#123; android.graphics.Canvas(bitmap) &#125;</span><br><span class="line">    <span class="keyword">val</span> paint = remember &#123; Paint().apply &#123; color = android.graphics.Color.BLACK &#125; &#125;</span><br><span class="line">    BoxWithConstraints()&#123;</span><br><span class="line">        Canvas(</span><br><span class="line">            modifier = Modifier</span><br><span class="line">                .fillMaxSize()</span><br><span class="line">                .pointerInteropFilter(onTouchEvent = &#123;</span><br><span class="line">                    <span class="keyword">when</span> (it.action) &#123;</span><br><span class="line">                        MotionEvent.ACTION_UP -&gt; &#123;</span><br><span class="line">                        	<span class="comment">//绘制到Bitmap上</span></span><br><span class="line">                            states.pointList.forEach &#123; point -&gt;</span><br><span class="line">                                newCanvas.drawCircle(point.x, point.y, point.width, paint)</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//清空当前列表</span></span><br><span class="line">                            viewModel.dispatch(SpringBoardViewAction.ActionUp(it))</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="literal">true</span></span><br><span class="line">                &#125;)</span><br><span class="line">        ) &#123;</span><br><span class="line">        	<span class="comment">//绘制Bitmap，即之前的笔划</span></span><br><span class="line">            drawImage(bitmap.asImageBitmap())</span><br><span class="line">            <span class="comment">//绘制当前列表，即当前笔划</span></span><br><span class="line">            states.pointList.forEach &#123;</span><br><span class="line">                drawCircle(Color.Black, it.width, Offset(it.x, it.y))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，主要做了以下工作：  </p>
<ol>
<li>定义内存图片<code>bitmap</code>,并通过<code>bitmap</code>获取<code>newCanvas</code>   </li>
<li>在<code>ACTION_UP</code>时将当前点的列表绘制到<code>bitmap</code>中并且清空当前点的列表    </li>
<li>在<code>onDraw</code>中绘制<code>bitmap</code>，即绘制之前的笔划，同时绘制当前的<code>pointList</code>，即当前的笔划    </li>
</ol>
<h3 id="长按保存到本地"><a href="#长按保存到本地" class="headerlink" title="长按保存到本地"></a>长按保存到本地</h3><p>我们在长按时，需要将春联保存到本地，这需要我们把<code>Compose</code>代码转化成<code>Bitmap</code>，这个在<code>View</code>中比较成熟，但是在<code>Compose</code>中我没有找到相关方法<br>我们可以仿照上面的实现，把内容绘制在一个<code>bitmap</code>上，然后直接保存这个<code>bitmap</code>上就好了<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SpringPreview</span><span class="params">()</span></span> &#123;</span><br><span class="line">    BoxWithConstraints(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .pointerInput(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">                detectTapGestures(</span><br><span class="line">                    onLongPress = &#123;</span><br><span class="line">                    	<span class="comment">//长按时保存bitmap到本地</span></span><br><span class="line">                        BitmapUtils.saveBitmapToGallery(context, bitmap, <span class="string">"春联"</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">    	<span class="comment">//将背景与图片列表绘制到bitmap上</span></span><br><span class="line">        newCanvas.drawColor(android.graphics.Color.RED)</span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> states.bitmapList.indices) &#123;</span><br><span class="line">            newCanvas.drawBitmap(states.bitmapList[i], <span class="number">0f</span>, itemSize * i, paint)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Canvas(modifier = Modifier.fillMaxSize()) &#123;</span><br><span class="line">        	<span class="comment">//绘制bitmap</span></span><br><span class="line">            drawImage(bitmap.asImageBitmap(), Offset.Zero)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>上面提到我们会将笔划绘制到<code>bitmap</code>中，一个字即是一个<code>bitmap</code>    </li>
<li>我们的春联的内容即为上面的<code>bitmap</code>的列表，再加上一个红色的背景    </li>
<li>我们将红色背景与<code>bitmap</code>列表都绘制到一个<code>bitmap</code>中，再将这个<code>bitmap</code>中绘制到<code>Compose</code>中   </li>
<li>上面这个<code>bitmap</code>就是我们想要的图片，长按时将其保存到本地即可</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/6746d68ef2c3" target="_blank" rel="noopener">安卓画笔笔锋的实现探索（一）</a><br><a href="https://juejin.cn/post/7051345154413690911" target="_blank" rel="noopener">过年了！开发一套纸笔系统，随时随地在线写春联</a>     </p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/shenzhen2017/compose-handwriting" target="_blank" rel="noopener">https://github.com/shenzhen2017/compose-handwriting</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Gradle 你应该知道的知识点</title>
    <url>/blog/2022/02/groovy-knowlege-sum.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于<code>Android</code>开发者来说，<code>Gradle</code>也可以说是熟悉的陌生人了，可以说天天会用到<code>Gradle</code>，但对于<code>Gradle</code>的一些原理与细节又往往不太了解<br>本文主要介绍<code>Gradle</code>的一些基础知识与原理，如果对你有所帮助，欢迎点赞    </p>
<p>本文主要包括以下内容：   </p>
<ol>
<li><code>Gradle</code>到底是什么?   </li>
<li><code>Gradle Wrapper</code>是什么？</li>
<li><code>AGP</code>到底是什么?   </li>
<li><code>gradle.properties</code>是什么?</li>
<li><code>settings.gradle</code>是什么?         </li>
<li><code>build.gradle</code>是什么？      </li>
<li><code>Gradle</code>生命周期是怎样的?  </li>
</ol>
<h2 id="1-Gradle到底是什么"><a href="#1-Gradle到底是什么" class="headerlink" title="1. Gradle到底是什么?"></a>1. <code>Gradle</code>到底是什么?</h2><p><code>Gradle</code>也用了这么久了，如果要用一句话来描述<code>Gradle</code>，该如何回答呢？一个依赖管理框架？一个构建框架？       </p>
<p><strong><code>Gradle</code> 是一个 运行在 <code>JVM</code> 的通用构建工具</strong>,其核心模型是一个由 <code>Task</code> 组成的有向无环图(<code>Directed Acyclic Graphs</code>).<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e5125271fcf4b5893ada25e4a2e0547~tplv-k3u1fbpfcp-watermark.awebp" alt>    </p>
<h2 id="2-Gradle-Wrapper是什么？"><a href="#2-Gradle-Wrapper是什么？" class="headerlink" title="2. Gradle Wrapper是什么？"></a>2. <code>Gradle Wrapper</code>是什么？</h2><p>说起来我们一直在使用<code>Gradle</code>，但仔细想想我们在项目中其实没有用<code>gradle</code>命令，而一般是使用<code>gradlew</code>命令，同时如下图所示，找遍整个项目，与<code>gradle</code>有关的就这两个文件夹，却只发现<code>gradle-wrapper.jar</code>。<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/february/p1.png" alt>    </p>
<p>那么问题来了，<code>gradlew</code>是什么，<code>gradle-wrapper.jar</code>又是什么?          </p>
<p><strong><code>wrapper</code>的意思：包装。</strong><br>那么可想而已，这是<code>gradle</code>的包装。其实是这样的，因为<code>gradle</code>处于快速迭代阶段，经常发布新版本，如果我们的项目直接去引用，那么更改版本等会变得无比麻烦。而且每个项目又有可能用不一样的<code>gradle</code>版本，这样去手动配置每一个项目对应的<code>gradle</code>版本就会变得麻烦，<code>gradle</code>的引入本来就是想让大家构建项目变得轻松，如果这样的话，岂不是又增加了新的麻烦？<br>所以<code>android</code>想到了包装，引入<code>gradle-wrapper</code>，通过读取配置文件中<code>gradle</code>的版本，为每个项目自动的下载和配置<code>gradle</code>，就是这么简单。我们便不用关心如何去下载<code>gradle</code>,如何配置到项目中。  </p>
<p>至于<code>gradlew</code>也是一样的道理，它共有两个文件，<code>gradlew</code>是在<code>linux</code>,<code>mac</code>下使用的，<code>gradlew.bat</code>是在<code>window</code>下使用的，提供在命令行下执行<code>gradle</code>命令的功能<br>至于为什么不直接执行<code>Gradle</code>，而是执行<code>Gradlew</code>命令呢?<br>因为就像<code>wrapper</code>本身的意义，<code>gradle</code>命令行也是善变的，所以<code>wrapper</code>对命令行也进行了一层封装，使用同一的<code>gradlew</code>命令，<code>wrapper</code>会自动去执行具体版本对应的<code>gradle</code>命令。<br>同时如果我们配置了全局的<code>gradle</code>命令，在项目中如果也用<code>gradle</code>容易造成混淆，而<code>gradlew</code>明确就是项目中指定的<code>gradle</code>版本，更加清晰与明确  </p>
<h2 id="3-AGP到底是什么"><a href="#3-AGP到底是什么" class="headerlink" title="3. AGP到底是什么?"></a>3. <code>AGP</code>到底是什么?</h2><p><code>AGP</code>即<code>Android Gradle Plugin</code>，即<code>android</code>官方开发的<code>Gradle</code>插件，在了解<code>AGP</code>之前，我们先介绍一下什么是插件?    </p>
<p><code>Gradle</code> 本身是一个通用的构建系统, 它并不知道你要编译的是 <code>Java</code> 还是 <code>C</code>. 如果是在<code>Java</code> 中需要调用 <code>javac</code> 将 <code>.java</code> 文件编译为 <code>.class</code> 文件, 而 <code>C</code> 则需要调用 <code>gcc</code> 将 <code>.c</code> 文件编译为 <code>.o</code> 文件. 那么这些构建流程如果让每个开发者自己去管理就太麻烦了. 所谓插件, 就是将某种类型的编译的模板.       </p>
<p>而<code>AGP</code>也就是是一系列适合<code>Android</code>开发的<code>Gradle</code>插件的集合，比如<code>com.android.application</code>,<code>com.android.library</code>等<br><code>AGP</code> 插件提供了<code>compileKotlin</code>,<code>compileJava</code>,<code>processResource</code>等一系列<code>Task</code>, 并设置了<code>Task</code>之间的依赖关系. 同时还提供了很多可配置属性. 而使用者只需要在 <code>build script</code> 中通过 <code>plugins {...}</code> 引入插件, 根据项目情况配置几个属性, 即可实现自定义的 <code>Android</code> 构建. 通过<code>AGP</code>插件可以快速实现<code>Android</code>项目的构建，这就是<code>AGP</code>插件的意义，其执行过程中的<code>task</code>列表如下所示      </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d64b4bc166aa46b4a1fc530cc8eaa039~tplv-k3u1fbpfcp-watermark.awebp" alt></p>
<h2 id="4-gradle-properties是什么"><a href="#4-gradle-properties是什么" class="headerlink" title="4. gradle.properties是什么?"></a>4. <code>gradle.properties</code>是什么?</h2><p>除了<code>Gradlew</code>与<code>AGP</code>，我们也经常会用到<code>gradle.properties</code>，我们经常在<code>gradle.peoperties</code>中定义一些统一的版本号，如<code>minSdkVersion</code>,<code>targetSdkVersion</code>等，然后再在各个<code>module</code>中通过<code>rootProject.minSdkVersion</code>获取以实现复用       </p>
<p>那么问题来了,<code>rootProject</code>是如何获取<code>gradle.properties</code>中定义的值的呢?<br>答案其实很简单，<code>Gradle</code> 启动时会默认读取<code>gradle.properties</code>, 并加载其中的参数。这跟我们在运行<code>Gradle</code>的时候通过命令行向其传递参数，效果是一样的<br>当然不同的方式有不同的优先级，指定参数的优先级: 命令行参数 &gt; <code>GRADLE_USER_HOME gradle.properties</code> 文件 &gt; 项目根目录 <code>gradle.properties</code> 文件.         </p>
<blockquote>
<p><code>Gradle</code> 使用的两个目录:<br><code>Gradle</code> 在执行过程中会涉及到两个目录, 一个是 <code>Gradle User Home</code> 另一个是 <code>Project Root Directory</code>.<br><code>Gradle User Home</code><br><code>User Home</code> 中主要保存全局配置, 全局初始化脚本以及依赖的缓存和日志等文件. 如果开启 <code>build cache</code> 的话, 构建缓存也会存在这里共所有项目共享.<br>默认为: <code>$USER_HOME/.gradle</code>.<br><code>Project Root Directory</code><br><code>Project</code> 目录则存储与当前项目构建相关的内容. 例如用于增量编译缓存.</p>
</blockquote>
<p>总得来说，<code>gradle.properties</code>其实就是一个参数的配置文件，与在命令行传递参数是一样的效果，因此在<code>Project</code>中可以读取到       </p>
<h2 id="5-settings-gradle是什么"><a href="#5-settings-gradle是什么" class="headerlink" title="5. settings.gradle是什么?"></a>5. <code>settings.gradle</code>是什么?</h2><p>当我们在某个目录执行<code>gradle</code>命令时, 约定的会从当前目录查找以下两个文件:           </p>
<ol>
<li><code>settings.gradle(.kts)</code>          </li>
<li><code>build.gradle(.kts)</code>       </li>
</ol>
<p>我们常常会在<code>settings.gradle</code>中配置<code>module</code>,那么<code>settings.gradle</code>究竟是什么？起什么作用?<br>所有需要被构建的模块都需要在<code>settings.gradle</code> 中注册, 因此它的作用是描述 “当前构建所参与的模块”.      </p>
<p><code>settings.gradle</code>查找顺序为: 从前目录开始, 如果找到<code>settings.gradle(.kts)</code>则停止, 否则向父目录递归查找.<br><code>setting script</code>承担了统筹所有模块的重任, 因此<code>api</code>主要是在操作所参与构建的模块以及管理构建过程需要的插件.<br>可以通过如下方式注册需要参与构建的模块，项目名称中 <code>:</code> 代表项目的分隔符, 类似路径中的 <code>/</code>. 如果以 <code>:</code> 开头则表示相对于 <code>root project</code><br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">include(<span class="string">":app"</span>, <span class="string">":libs:someLibrary"</span>)</span><br><span class="line"></span><br><span class="line">include(<span class="string">":anotherLibrary"</span>)</span><br><span class="line">project(<span class="string">":anotherLibrary"</span>).projectDir = File(rootDir, <span class="string">"../another-library"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="6-build-gradle是什么？"><a href="#6-build-gradle是什么？" class="headerlink" title="6. build.gradle是什么？"></a>6. <code>build.gradle</code>是什么？</h2><p>到了我们最熟悉也是最常用的<code>build.gradle</code>了，每个模块都会有一个<code>build.gradle</code>来配置当前模块的构建信息, 根目录模块的<code>build.gradle</code>叫做 <code>root build script</code>, 其他子模块的 <code>build script</code> 叫做 <code>module build script</code>.</p>
<p>项目构建的流程大致如下所示，其中的<code>init script</code>指<code>$GRADLE_USER_HOME</code>目录下的<code>init.gradle</code>文件，主要做一些初始化配置<br>单模块构建的执行流程大致为: <code>init script</code> -&gt; <code>setting script</code> -&gt; <code>build script</code><br>而多模块的构建流程, 比单模块多了一步: <code>init script</code> -&gt; <code>setting script</code> -&gt; <code>root build script</code> -&gt; <code>build script</code>       </p>
<p>一般而言, <code>root build script</code> 并不是一个实际的模块, 而是用于对子模块进行统一的配置, 所以 <code>root build script</code> 一般不会有太多的内容.       </p>
<p><code>Gradle</code> 在 <code>Initialization</code> 阶段还没有执行 <code>build.gradle(.kts)</code> 文件, 真正解析 <code>build script</code> 是在 <code>Configuration</code> 阶段. 但是 <code>build script</code> 的执行比较特殊, 它并不是简单执行所有代码, 其本质是 <strong>用代码描述和配置构建规则, 然后按规则执行任务</strong>. <code>Build script</code> 作为整个 <code>Gradle</code> 中配置最复杂的脚本, 实际上仅仅做了两件事: 一个是引入插件, 另一个是配置属性</p>
<p>所谓引入插件如下所示，<code>plugins</code> 闭包中还可以通过 <code>version</code> 指定插件的版本, 以及 <code>apply</code> 来决定是否立刻应用插件:<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">	id(<span class="string">"com.android.application"</span>)</span><br><span class="line">    id(<span class="string">"com.dorongold.task-tree"</span>)   version <span class="string">"1.4"</span></span><br><span class="line">    id(<span class="string">"com.dorongold.task-tree"</span>)   version <span class="string">"1.4"</span>   apply <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而所谓配置属性, 实际上是对引入的插件进行配置. 原本 <code>build script</code> 中并没有 <code>android {...}</code> 这个 <code>dsl</code> 属性, 这是 <code>plugin</code> 提供的. 一旦应用了某个插件, 就可以使用插件提供的 <code>dsl</code> 对其进行配置, 从而影响该模块的构建过程. 换个角度看, 这些插件提供的属性配置 <code>dsl</code> 就相当于插件 <code>init</code> 函数的参数, 最终传入到插件中. 当构建执行的时候就会根据配置对当前模块进行编译.<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">"com.android.application"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion(<span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<h2 id="7-Gradle生命周期是怎样的"><a href="#7-Gradle生命周期是怎样的" class="headerlink" title="7. Gradle生命周期是怎样的?"></a>7. <code>Gradle</code>生命周期是怎样的?</h2><p>在了解了上面这些知识后，我们可以开始了解一下<code>Gradle</code>的生命周期。在了解了<code>Gradle</code>的生命周期后，我们可以对<code>Gradle</code>执行的总体流程有一个了解，也可以利用这些生命周期做一些<code>Hook</code>的操作    </p>
<p>不同于传统脚本的自上而下执行, 一次 <code>Gradle</code> 构建涉及到多个文件, 主体流程如下:<br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/30/16e1c9dc26469187~tplv-t2oaga2asx-watermark.awebp" alt>           </p>
<p>总体来说, <code>Gradle</code> 的执行分为三大阶段: <code>Initialization</code> -&gt; <code>Configuration</code> -&gt; <code>Execution</code>. 每个阶段都有自己的职责.       </p>
<h2 id="7-1-Initialization阶段"><a href="#7-1-Initialization阶段" class="headerlink" title="7.1 Initialization阶段"></a>7.1 <code>Initialization</code>阶段</h2><p><code>Initialization</code> 阶段主要目的是初始化构建, 它又分为两个子过程, 一个是执行 <code>Init Script</code>, 另一个是执行 <code>Setting Script</code>.<br><code>Init script</code> 会读取全局脚本, 主要作用是初始化一些全局通用的属性, 例如获取 <code>Gradle User Home</code> 目录, <code>Gradle version</code> 等<br>而<code>Setting Script</code>就是我们上面提到的<code>settings.gradle</code>          </p>
<h2 id="7-2-Configuration阶段"><a href="#7-2-Configuration阶段" class="headerlink" title="7.2 Configuration阶段"></a>7.2 <code>Configuration</code>阶段</h2><p>当构建完成 <code>Initialization</code> 阶段后, 将进入 <code>Configuration</code> 阶段. 这个阶段开始加载项目中所有模块的 <code>Build Script</code>. 所谓 “加载” 就是执行 <code>build.gradle(.kts)</code> 中的语句, 根据脚本代码创建对应的 <code>task</code>, 最终根据所有 <code>task</code> 生成对应的依赖图. 我们上面说过”<code>Gradle</code>核心模型是一个 <code>Task</code> 组成的有向无环图(<code>Directed Acyclic Graphs</code>)” 吗? 这个任务依赖图就是在这个阶段生成的.         </p>
<p>需要注意的是，<code>Configuration</code>阶段各个模块的加载顺序是无序的，跟依赖关系与加入顺序都没有关系      </p>
<h2 id="7-3-Execution阶段"><a href="#7-3-Execution阶段" class="headerlink" title="7.3 Execution阶段"></a>7.3 <code>Execution</code>阶段</h2><p>当完成任务依赖图后, <code>Gradle</code> 就做好了一切准备, 然后进入 <code>Execution</code> 阶段. 这个阶段才真正进行编译和打包动作. 对于 <code>Java</code> 而言是调用 <code>javac</code> 编译源码, 然后打包成 <code>jar</code>. 对于 <code>Android</code> 而言则更加复杂些. 这些差异来源于我们应用的插件. 总得来说，就是开始执行<code>task</code>了        </p>
<h2 id="7-4-生命周期-Hook"><a href="#7-4-生命周期-Hook" class="headerlink" title="7.4 生命周期 Hook"></a>7.4 生命周期 <code>Hook</code></h2><p><code>Gradle</code> 提供了丰富的生命周期 <code>Hook</code>，我们可以根据我们的需要添加各种<code>HooK</code><br><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/30/16e1c9dc26330d6a~tplv-t2oaga2asx-watermark.awebp" alt>           </p>
<p>根据图中生命周期的位置, 可以清楚地了解到 “生命周期的最晚注册时机”. 比如, <code>settingsEvaluated</code> 是在 <code>setting script</code> 被 <code>evaluated</code> 完毕后回调, 那么在 <code>init script</code> 和 <code>setting script</code> 中注册都是没问题的. 但是如果注册在 <code>build script</code> 中, 则无法发挥作用.     </p>
<p>同时关于生命周期<code>Hook</code>，还有下面几点需要注意      </p>
<ol>
<li><code>projectsLoaded</code>之前<code>Project</code>还没有创建，因此只能使用<code>gradle</code> 和 <code>settings</code> 对象        </li>
<li><code>projectsLoaded</code> 回调时已经根据 <code>setting script</code> 创建了各个模块的 <code>Project</code> 对象, 我们可以引用 <code>project</code> 对象从而设置一些 <code>hook</code>，便是<code>build script</code>还没有被配置，因此拿不到配置信息    </li>
<li>每当一个 <code>build.gradle(.kts)</code> 被执行完毕, 都会产生 <code>afterEvaluate</code> 回调, 代表着 <code>project</code> 被 <code>evaluate</code> 完成. 从此, <code>project</code> 对象内容完整了, 即: 当前 <code>build.gradle(.kts)</code> 中所有的配置项都能够被访问. </li>
<li>所有的<code>Project</code>配置结束，会回调<code>projectsEvaluated</code>         </li>
<li><code>Gradle</code> 的核心逻辑就是根据 <code>task</code> 的依赖关系生成有向无环图, 然后依次执行图中的 <code>task</code>，<code>task graph</code>生成后会回调<code>graphPopulated</code>       </li>
<li>当所有<code>task</code>都执行完毕, 整个构建也宣告结束，这个时候会回调<code>buildFinished</code>   </li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要本文主要介绍<code>Gradle</code>的一些基础知识与原理，包括<code>Gradle</code>各个文件的作用，以及生命周期，构建总体流程，以及生命周期<code>Hook</code>方法等<br>了解<code>Gradle</code>的这些基础原理，可以帮助我们更好的了解<code>Android</code>构建打包的过程，也方便我们利用<code>Gradle</code>生命周期做一些<code>Hook</code>工作，提升开发效率。<br>如果本文对你有所帮助，欢迎点赞，收藏，评论~       </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/book/6844733819363262472" target="_blank" rel="noopener">Mastering Gradle</a><br><a href="https://blog.csdn.net/sinat_31311947/article/details/81084689" target="_blank" rel="noopener">一篇文章讲清楚Gradle与Gradle Wrapper的区别</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle 7.0都有哪些新特性?</title>
    <url>/blog/2022/02/gradle-new-seven.html</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://gradle.org/whats-new/gradle-7/" target="_blank" rel="noopener">https://gradle.org/whats-new/gradle-7/</a></p>
</blockquote>
<p><code>Gradle 7.0</code>的发布已经一段时间了，我们来看下从Gradle 6.0到7.0，都有哪些有趣的特性。           </p>
<ul>
<li>加快增量编译速度</li>
<li>通过验证构建依赖项的完整性，使您的构建更安全。</li>
<li>支持使用<code>Java 16</code>开发      </li>
<li>使用<code>included builds</code>简化构建   </li>
<li>通过新的依赖管理特性降低了<code>Multi-Project</code>构建的维护成本     </li>
<li>使用最新版本的<code>Groovy</code>和<code>Kotlin</code>开发</li>
</ul>
<h2 id="性能方面的优化"><a href="#性能方面的优化" class="headerlink" title="性能方面的优化"></a>性能方面的优化</h2><h3 id="更快的up-to-date检查"><a href="#更快的up-to-date检查" class="headerlink" title="更快的up-to-date检查"></a>更快的<code>up-to-date</code>检查</h3><p>本地增量编译的快速反馈对于提高开发效率至关重要。文件系统监视通过减少判断哪些文件发生了变化的<code>IO</code>操作，来提高增量编译速度<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/147a658ea6664b8d9e6df9662267d8c6~tplv-k3u1fbpfcp-zoom-1.image" alt><br>截至<code>Gradle 7.0</code>，在包括最近版本的<code>Windows</code>，<code>Linux</code>和<code>MacOS</code>的所有支持的操作系统上，默认情况下启用此优化。        </p>
<p>关于文件系统监视的更多细节与原理，可参见：<a href="https://blog.gradle.org/introducing-file-system-watching" target="_blank" rel="noopener">Introducing file system watching</a>     </p>
<h3 id="加快kotlin-DSL脚本编译速度"><a href="#加快kotlin-DSL脚本编译速度" class="headerlink" title="加快kotlin DSL脚本编译速度"></a>加快<code>kotlin DSL</code>脚本编译速度</h3><p><code>Gradle 7.0</code>可以以更快的速度，更小的内存编译<code>Kotlin DSL</code>构建脚本，即<code>KTS</code><br>此前当我们修改<code>buildsrc</code>中的代码时，会使大多数缓存失效，从而触发完全的重新编译<br>而在<code>Gradle 7.0</code>之后，修改<code>buildsrc</code>中的<code>kts</code>插件可以完全跳过未受影响的构建脚本文件的编译。<br>因此当修改<code>buildsrc</code>时，在<code>Gradle7.0</code>中，<code>kts</code>插件编译会远比<code>gradle</code>插件要快       </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28ce5dff2e124384ac4e763174795973~tplv-k3u1fbpfcp-zoom-1.image" alt>     </p>
<h3 id="提高build-cache命中率"><a href="#提高build-cache命中率" class="headerlink" title="提高build cache命中率"></a>提高<code>build cache</code>命中率</h3><p><code>Gradle7.0</code>通过有选择的忽略不会影响系统行为的一些更改，从而提高<code>build cache</code>的命中率<br>例如空的文件目录，属性文件中的空格和注释等，这些更改都会被忽略        </p>
<h3 id="支持configuration-cache-实验性质"><a href="#支持configuration-cache-实验性质" class="headerlink" title="支持configuration cache(实验性质)"></a>支持<code>configuration cache</code>(实验性质)</h3><p><code>Gradle</code>已经支持了<code>build cache</code>，但是在执行任何<code>Task</code>之前，<code>Gradle</code>需要经过<code>configuration</code>阶段。目前<code>configuration</code>在每次构建时都会执行，并且可能导致明显的延迟，特别是在大型项目中。     </p>
<p><code>configuration cache</code>通过缓存<code>configuration</code>阶段的结果来提高构建性能。使用<code>configuration cache</code>，当没有影响<code>configuration</code>的更改时，<code>Gradle</code>可以完全跳过<code>configuration</code>阶段，以加快构建速度。</p>
<p>此外，使用<code>configuration cache</code>时，更多的工作是并行执行的，也可以加速构建的<code>execution</code>阶段。<br>请注意，此功能目前是实验性的，默认情况下未启用，并且自 <code>Gradle 7.0</code> 起也并非所有核心插件都支持。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb567df501064f83ad573e224a27666c~tplv-k3u1fbpfcp-zoom-1.image" alt>     </p>
<p>关于<code>configuration cache</code>的更多细节与原理,可参见：<a href="https://docs.gradle.org/7.0/userguide/configuration_cache.html" target="_blank" rel="noopener">Configuration cache</a>      </p>
<h3 id="更快的临时构建速度"><a href="#更快的临时构建速度" class="headerlink" title="更快的临时构建速度"></a>更快的临时构建速度</h3><p>有时我们会进行一些临时的构建，临时构建机器需要重新下载所有依赖，这会付出比较大的代价。 <code>Gradle 7.0</code>可以通过跨机器重用<code>dependency cache</code>来加快临时构建的速度。      </p>
<h4 id="重定向dependency-cache"><a href="#重定向dependency-cache" class="headerlink" title="重定向dependency cache"></a>重定向<code>dependency cache</code></h4><p><code>dependency cache</code>的默认位置为：<code>$GRADLE_HOME/caches/modules-2</code>，缓存目录可以重新定位到另一个目录或主机以缓存依赖项。<br>当重定向到新位置或新主机时，如果已下载依赖项，则使用<code>dependency cache</code>的构建将不需要访问网络来下载依赖      </p>
<p>值得注意的是，应该使用兼容的 <code>Gradle</code> 版本来创建和使用缓存。可以浏览<a href="https://docs.gradle.org/7.0/userguide/dependency_resolution.html#sub:cache_copy" target="_blank" rel="noopener">文档</a>以了解更多细节   </p>
<h4 id="共享只读的dependency-cache"><a href="#共享只读的dependency-cache" class="headerlink" title="共享只读的dependency cache"></a>共享只读的<code>dependency cache</code></h4><p><code>Gradle</code>提供了在多个<code>Gradle</code>实例之间共享<code>dependency cache</code>的能力。<br>这使得我们可以创建一个共享目录，其中包含所有构建所需的依赖项。      </p>
<ul>
<li>每个<code>Gradle</code>实例都可以访问共享只读依赖性缓存，这避免了构建之间的冗余下载。</li>
<li>可以在<code>Gradle</code>实例之间安全地共享此高速缓存，而无需创建其单独的副本。</li>
</ul>
<h2 id="易用性与新特性优化"><a href="#易用性与新特性优化" class="headerlink" title="易用性与新特性优化"></a>易用性与新特性优化</h2><h3 id="JVM项目的工具链支持"><a href="#JVM项目的工具链支持" class="headerlink" title="JVM项目的工具链支持"></a><code>JVM</code>项目的工具链支持</h3><p>默认情况下，<code>Gradle</code>使用相同的<code>Java</code>版本来运行<code>Gradle</code>本身并构建<code>JVM</code>项目，但这并不总是适用的。<br>在不同的开发机和 <code>CI</code> 服务器上构建，可能会使用不同的<code>Java</code>版本，这可能会导致预料之外的问题。此外，您可能希望使用与运行 <code>Gradle</code> 不兼容的 <code>Java</code> 版本来构建项目。     </p>
<p><code>Gradle</code> 提供了可以设置项目构建的<code>Java</code>版本的工具链：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">java &#123;</span><br><span class="line">    toolchain &#123;</span><br><span class="line">        languageVersion = JavaLanguageVersion.of(<span class="number">14</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Gradle</code>将检查本地<code>Java</code>的安装情况，如果本地没有与构建要求匹配的 <code>Java</code> 版本，<code>Gradle</code> 将从 <code>AdoptOpenJDK</code> 的网站下载匹配的 <code>JDK</code>。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b277113bf4464ca69b1e9000165aba9f~tplv-k3u1fbpfcp-zoom-1.image" alt>      </p>
<p>关于<code>JVM</code>项目工具链支持的具体使用，可参见：<a href="https://docs.gradle.org/7.0/userguide/toolchains.html" target="_blank" rel="noopener">Toolchains for JVM projects</a>    </p>
<h3 id="处理用户凭据"><a href="#处理用户凭据" class="headerlink" title="处理用户凭据"></a>处理用户凭据</h3><p>构建有时需要用户提供凭据。 例如，为了发布<code>aar</code>，<code>Maven</code>库可能需要身份验证，而将凭据保存在构建脚本之外是一种很好的做法。        </p>
<p><code>Gradle</code> 提供了一个 <code>API</code>，提供了一个 <code>Gradle</code> 属性来提供凭据，方便我们更轻松地使用凭据，这些属性可以作为命令行参数、环境变量或 <code>gradle.properties</code> 文件中的键值对，然后在构建脚本中可以读取这些值。 当 <code>Gradle</code> 知道构建在某些时候需要凭据并且缺少凭据时，它还会引入快速失败行为。       </p>
<p>关于<code>Gradle</code>用户凭据的使用示例，可参考：<a href="https://docs.gradle.org/7.0/samples/sample_publishing_credentials.html" target="_blank" rel="noopener">Publishing Credentials Sample</a></p>
<h3 id="支持执行included-builds中的task"><a href="#支持执行included-builds中的task" class="headerlink" title="支持执行included builds中的task"></a>支持执行<code>included builds</code>中的task</h3><p><code>Gradle</code> 允许用户直接从命令行从<code>included builds</code>中执行<code>Task</code>。 例如，如果您的构建<code>included build</code>了 <code>my-other-project</code>，并且它有一个带有<code>Task foo</code>的子项目 <code>sub</code>，那么您可以使用以下命令执行 <code>foo</code>：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">gradle :</span>my-other-<span class="string">project:</span><span class="string">sub:</span>foo</span><br></pre></td></tr></table></figure></p>
<h3 id="依赖锁定文件只保留一个"><a href="#依赖锁定文件只保留一个" class="headerlink" title="依赖锁定文件只保留一个"></a>依赖锁定文件只保留一个</h3><p>依赖锁定是一种在使用动态依赖版本时确保可重现构建的机制。<code>Gradle 7.0</code> 使用单个锁定文件将动态依赖项锁定到其解析的版本。而以前版本的 <code>Gradle</code> 每个<code>Configuration</code>使用一个文件, 在<code>Gradle7.0</code>中 会自动迁移到单锁文件。</p>
<h2 id="安全性优化"><a href="#安全性优化" class="headerlink" title="安全性优化"></a>安全性优化</h2><h3 id="依赖验证"><a href="#依赖验证" class="headerlink" title="依赖验证"></a>依赖验证</h3><p>我们的项目中常常会使用大量外部依赖项，这使他们面临使用不受信任代码的风险。 例如，有人可能会通过传递依赖意外引入恶意代码。同样，您的构建脚本本身也可能通过执行被感染插件的恶意代码，从而受到攻击。<br>为了减轻这些风险，<code>Gradle</code> 提供了依赖关系验证。 依赖项验证可以验证校验和以及构建期间使用的依赖项和插件的签名。</p>
<p>如果启用依赖项验证，<code>Gradle</code> 将：      </p>
<ul>
<li>确保依赖项没有被篡改（通过验证它们的校验和）</li>
<li>确保您使用的依赖项和插件的出处（通过验证它们的签名）</li>
<li>从而降低将恶意代码发送到生产环境的风险。</li>
</ul>
<p>关于依赖验证的更多细节和使用，可以参见：<a href="https://docs.gradle.org/7.0/userguide/dependency_verification.html" target="_blank" rel="noopener">Verifying dependencies</a></p>
<h3 id="声明专有存储库依赖"><a href="#声明专有存储库依赖" class="headerlink" title="声明专有存储库依赖"></a>声明专有存储库依赖</h3><p><code>Gradle</code> 允许您声明应在哪些存储库中搜索特定依赖项。<br><code>Gradle</code> 还允许您声明只能在一个存储库中找到且不应在任何其他存储库中搜索的专有依赖。</p>
<p>关于存储库专有依赖的具体细节，可以参见：<a href="https://docs.gradle.org/7.0/userguide/declaring_repositories.html#declaring_content_exclusively_found_in_one_repository" target="_blank" rel="noopener">user manual</a></p>
<h3 id="验证-Gradle-Wrappers-的完整性"><a href="#验证-Gradle-Wrappers-的完整性" class="headerlink" title="验证 Gradle Wrappers 的完整性"></a>验证 <code>Gradle Wrappers</code> 的完整性</h3><p><code>Gradle Wrapper</code> 是一个可执行代码的二进制文件，在数百万个 <code>GitHub</code> 存储库中使用。如果这个文件发生改变，可能存在一定的安全隐患<br>我们创建了一个官方 <code>GitHub Action</code>，它允许 <code>GitHub</code> 上的项目自动验证其存储库中的 <code>gradle-wrapper.jar</code> 是否由 <code>Gradle</code> 发布。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e39eb76e4c2f442b99f9fe5359ee4e25~tplv-k3u1fbpfcp-zoom-1.image" alt>         </p>
<p>当然，你也可以通过<a href="https://docs.gradle.org/7.0/userguide/gradle_wrapper.html#sec:wrapper_checksum_verification" target="_blank" rel="noopener">user manual</a>中的步骤，手动检验<code>Gradle Wrapper</code>文件的合法性    </p>
<h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="依赖解析一致性"><a href="#依赖解析一致性" class="headerlink" title="依赖解析一致性"></a>依赖解析一致性</h3><p><code>configurations</code>之间的依赖关系是独立解析的。这可能会导致一个问题，即测试的运行时<code>classpath</code>可能使用与生产代码的运行时<code>classpath</code>不同的版本。    </p>
<p>为了缓解这个问题，<code>Gradle</code> 允许您<a href="https://docs.gradle.org/7.0/userguide/resolution_strategy_tuning.html#resolution_consistency" target="_blank" rel="noopener">声明依赖项<code>configurations</code>之间的一致性</a>，以便保证两个<code>classpath</code>的公共依赖项的版本是一致的。    </p>
<h3 id="存储库统一声明"><a href="#存储库统一声明" class="headerlink" title="存储库统一声明"></a>存储库统一声明</h3><p>此前我们一般是在根目录的<code>build.gradle</code>中声明存储库，现在也可以在 <code>settings.gradle (.kts)</code> 中方便地为整个构建定义存储库：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这允许 <code>Gradle</code> 确保您使用相同的存储库来解决构建的所有项目中的依赖关系。 了解更多，可以参考<a href="https://docs.gradle.org/7.0/userguide/declaring_repositories.html#sub:centralized-repository-declaration" target="_blank" rel="noopener">如何为整个构建声明存储库</a>     </p>
<h3 id="组件元数据规则的统一声明"><a href="#组件元数据规则的统一声明" class="headerlink" title="组件元数据规则的统一声明"></a>组件元数据规则的统一声明</h3><p>从存储库中提取的每个模块都有与之关联的元数据，例如其组、名称、版本以及它提供的不同变体及其工件和依赖项。有时元数据不完整或不正确。为了在构建脚本中操作这些不完整的元数据，<code>Gradle</code> 提供了一个 <code>API</code> 来编写组件元数据规则。 这些规则在模块的元数据下载后，并且在用于依赖解析之前生效。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencyResolutionManagement &#123;</span><br><span class="line">    components &#123;</span><br><span class="line">        withModule (<span class="string">'com.google.guava: guava'</span>, GuavaRule)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于组件元数据规则统一声明的具体细节，可参见：<a href="https://docs.gradle.org/7.0/userguide/component_metadata_rules.html" target="_blank" rel="noopener">Fixing metadata with component metadata rules</a></p>
<h3 id="依赖统一管理的新特性"><a href="#依赖统一管理的新特性" class="headerlink" title="依赖统一管理的新特性"></a>依赖统一管理的新特性</h3><p>我们有多种方法可以在多项目构建中的项目之间共享依赖版本。 例如，用户可以直接在构建脚本的<code>ext</code> 块、外部文件（例如 <code>dependencies.gradle</code>）、<code>buildSrc</code> 甚至专用插件中声明版本或依赖坐标。     然而，没有任何标准机制可以结合每种方法的优点来做到这一点。</p>
<p><code>Gradle</code> 引入了<code>Version Catalog</code>，使构建者能够将其第三方依赖项的依赖坐标（组、工件、版本）集中在常规配置文件中，并以类型安全的方式声明实际依赖项。        </p>
<p>关于<code>Version Catalog</code>的具体使用，之前也写过一篇介绍，感兴趣的同学可以参见：<a href="https://juejin.cn/post/6997396071055900680" target="_blank" rel="noopener">【Gradle7.0】依赖统一管理的全新方式，了解一下~</a></p>
<h3 id="类型安全的Project访问器"><a href="#类型安全的Project访问器" class="headerlink" title="类型安全的Project访问器"></a>类型安全的<code>Project</code>访问器</h3><p><code>Gradle</code> 为类型安全的<code>Project</code>访问器提供了一个实验性功能，它可以在 <code>IDE</code> 中完成代码自动补全地声明对其它<code>Project</code>的依赖<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d66f8cc20579410ca42c5b8824a26b4a~tplv-k3u1fbpfcp-watermark.image?" alt="1_Tf11L05IMeC1Y0u42zsPqw.gif"><br>这比较大地解决了我们此前添加依赖的痛点，但目前似乎只对<code>kts</code>有效，了解更多细节可参见：<a href="https://docs.gradle.org/7.0/userguide/declaring_dependencies.html#sec:type-safe-project-accessors" target="_blank" rel="noopener">Type-safe project dependencies</a></p>
<h2 id="如何升级"><a href="#如何升级" class="headerlink" title="如何升级"></a>如何升级</h2><p>可以直接查看<code>Gradle</code>文档：<a href="https://docs.gradle.org/7.0/userguide/upgrading_version_6.html" target="_blank" rel="noopener">Upgrading your build from Gradle 6.x to the latest</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>相比 Groovy 脚本, KTS 性能到底怎么样？</title>
    <url>/blog/2022/02/kts-performance-evaluate.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家肯定也都或多或少的写过一些<code>Groovy</code>代码，但由于不支持代码提示及编译时检查，使用<code>Groovy</code>开发的体验并不太好<br><code>Android Gradle</code>插件<code>4.0</code>之后支持在<code>Gradle</code>构建配置中使用<code>Kotlin</code> 脚本 (<code>KTS</code>)，用于替代 <code>Groovy</code>（过去在 <code>Gradle</code> 配置文件中使用的编程语言）。<br><code>KTS</code> 比 <code>Groovy</code> 更适合用于编写 <code>Gradle</code> 脚本，因为采用 <code>Kotlin</code> 编写的代码可读性更高，并且 <code>Kotlin</code> 提供了更好的编译时检查和 <code>IDE</code> 支持。      </p>
<p>但是文档中也提到了，虽然与 <code>Groovy</code> 相比，<code>KTS</code> 当前能更好地在 <code>Android Studio</code> 的代码编辑器中集成，但采用 <code>KTS</code> 的构建速度往往比采用 <code>Groovy</code> 慢，因此在迁移到 <code>KTS</code> 时应考虑构建性能。       </p>
<p>那么我们今天就来看下相比<code>Groovy</code>，<code>KTS</code>性能到底怎么样？为大家决定是否迁移到<code>KTS</code>提供一定的参考       </p>
<h2 id="KTS性能分析"><a href="#KTS性能分析" class="headerlink" title="KTS性能分析"></a><code>KTS</code>性能分析</h2><h3 id="性能分析工具"><a href="#性能分析工具" class="headerlink" title="性能分析工具"></a>性能分析工具</h3><p>要分析<code>KTS</code>的性能，我们首先需要稳定的测量编译的时间，编译速度可能受<code>build cache</code>等多种因素的影响，所以很难测量<code>kts</code>插件对性能的影响到底有多大     </p>
<p>我们可以使用<a href="https://github.com/gradle/gradle-profiler" target="_blank" rel="noopener"><code>Gradle</code> 性能剖析器</a>来准确测量性能，这是一款用于收集 <code>Gradle</code> 构建的性能分析和基准化分析信息的工具。借助 <code>Gradle</code>性能剖析器，您可以创建构建场景并多次运行这些场景，以防止结果出现过大差异，并确保结果的可重现性。         </p>
<p>基准化分析的部分项目设置配置包括：      </p>
<ul>
<li>插件版本</li>
<li><code>Gradle</code> 版本</li>
<li><code>JVM</code> 设置（堆大小、永久代大小、垃圾回收等）</li>
<li><code>Gradle</code> 工作器数量 (<code>org.gradle.workers.max</code>)</li>
<li>按插件选项进一步优化性能</li>
</ul>
<p>比如我们需要对<code>clean build</code>进行基准化分析，您可以创建一个<code>gradle-profiler</code>执行的场景：<br><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &lt;root-project&gt;/scenarios.txt</span></span><br><span class="line"><span class="section">clean_build</span> &#123;</span><br><span class="line">    <span class="attribute">tasks</span> = [<span class="string">":app:assembleDebug"</span>]</span><br><span class="line">    cleanup-tasks = [<span class="string">"clean"</span>]</span><br><span class="line">&#125;</span><br><span class="line">```      </span><br><span class="line">如需运行此场景，请使用以下命令：</span><br></pre></td></tr></table></figure></p>
<p>gradle-profiler –benchmark –project-dir <root-project> –scenario-file scenarios.txt<br><code>`</code></root-project></p>
<p>通过以上命令，就可以多次运行<code>clean build</code>，并生成<code>clean build</code>性能报告。除了<code>clan build</code>，<code>gradle-profiler</code>还可以针对增量编译，不同的 <code>Gradle</code> 插件版本，以及不同的<code>内存/CPU</code> 等执行性能分析。<br>通过<code>gradle-profile</code>命令，可以创建构建场景并多次运行，可以防止结果出现过大差异，并确保结果的可重现性，以帮助我们更好地分析性能。<br>关于<code>gradle-profile</code>的具体使用，可以参考文档：<a href="https://developer.android.google.cn/studio/build/profile-your-build?hl=zh-cn#gradle-profiler" target="_blank" rel="noopener">分析构建性能</a>           </p>
<h3 id="Gradle-6-8-版本性能分析"><a href="#Gradle-6-8-版本性能分析" class="headerlink" title="Gradle 6.8 版本性能分析"></a><code>Gradle 6.8</code> 版本性能分析</h3><p>针对<code>Gradle 6.8</code>版本，我们从以下4个用例来分析<code>KTS</code>性能    </p>
<ul>
<li>首次运行(即清除所有<code>build cache</code>)</li>
<li><code>buildSrc abi</code> 更改(支持的<code>abi</code>发生变化，可以理解为大多数缓存失效，大部分代码需要重新编译)</li>
<li><code>buildSrc</code> 非 <code>abi</code> 更改(即<code>buildSrc</code>中的普通修改)</li>
<li>无改动</li>
</ul>
<p>以下数据来自在<code>Gradle CI</code>上运行的性能测试。这些测试运行在一个包含大量<code>subProject</code>的大型项目中，并且它们在 <code>Groovy</code> 和 <code>Kotlin DSL</code> 上运行以进行比较。<br>| Use case                      | Groovy  | Kotlin  | Differences               |<br>| —————————– | ——- | ——- | ————————- |<br>| <strong>First use</strong>                 | 🟢 33.5s | 🔴 76.2s | Groovy DSL is 2.2x faster |<br>| <strong><code>buildSrc</code> abi change</strong>     | 🟢 13.2s | 🔴 42.3s | Groovy DSL is 3.2x faster |<br>| <strong><code>buildSrc</code> non-abi change</strong> | 🔴 13s   | 🟢 5.2s  | Kotlin DSL is 2.5x faster |<br>| <strong>Nothing changes</strong>           | 🔵 1.7s  | 🔵 1.8s  | Similar performance       |</p>
<p>可以看出，<code>Groovy</code>脚本在性能上还是有一定优势    </p>
<ol>
<li>在首次运行时，<code>Groovy DSL</code>比<code>KTS</code>快<code>2.2</code>倍     </li>
<li>在<code>buildSrc abi</code>更改时，<code>Groovy DSL</code>比<code>KTS</code>快<code>3.2</code>倍    </li>
<li>在<code>buildSrc</code>非<code>abi</code>更改时，<code>KTS</code>比<code>Groovy</code>快<code>2.5</code>倍    </li>
<li>在代码没有发生更改时，两者性能类似    </li>
</ol>
<p>可以看出，<code>KTS</code>只有在<code>buildSrc</code>非<code>abi</code>更改时有性能优势，这是因为<code>buildSrc</code>中的<code>groovy</code>的更改会导致整个项目过时，导致项目重新编译<br>而<code>buildSrc</code>中的<code>kts</code>修改可以跳过未受影响的构建脚本文件的编译，因此当修改<code>buildsrc</code>时，<code>kts</code>编译会远比<code>groovy</code>插件要快              </p>
<p>以上数据来源于：<a href="https://builds.gradle.org/buildConfiguration/Gradle_Master_Check_PerformanceTestSlowLinux_Trigger?branch=master&amp;buildTypeTab=overview&amp;mode=builds" target="_blank" rel="noopener">https://builds.gradle.org/buildConfiguration/Gradle_Master_Check_PerformanceTestSlowLinux_Trigger?branch=master&amp;buildTypeTab=overview&amp;mode=builds</a>，可以使用访客模式登录查看       </p>
<h3 id="Gradle-7-4-版本性能分析"><a href="#Gradle-7-4-版本性能分析" class="headerlink" title="Gradle 7.4 版本性能分析"></a><code>Gradle 7.4</code> 版本性能分析</h3><p>针对<code>Gradle 7.4</code>版本，我们通过以下3个用例来分析<code>KTS</code>性能    </p>
<ul>
<li>首次运行(即清除所有<code>build cache</code>)</li>
<li><code>buildSrc abi</code> 更改(支持的<code>abi</code>发生变化，可以理解为大多数缓存失效，大部分代码需要重新编译)</li>
<li><code>buildSrc</code> 非 <code>abi</code> 更改(即<code>buildSrc</code>中的普通修改)</li>
</ul>
<table>
<thead>
<tr>
<th>Use Case</th>
<th>Groovy</th>
<th>Kotlin</th>
<th>Difference</th>
</tr>
</thead>
<tbody>
<tr>
<td>First use</td>
<td>🟢 <a href="https://builds.gradle.org/repository/download/Gradle_Master_Check_PerformanceTestSlowLinux_Trigger/49307028:id/performance-test-results.zip!/report/index.html?redirectSupported=false#scenario70" target="_blank" rel="noopener">38.855s</a></td>
<td>🔴 <a href="https://builds.gradle.org/repository/download/Gradle_Master_Check_PerformanceTestSlowLinux_Trigger/49307028:id/performance-test-results.zip!/report/index.html?redirectSupported=false#scenario65" target="_blank" rel="noopener">63.54s</a></td>
<td>Groovy DSL is 1.6x faster</td>
</tr>
<tr>
<td><code>buildSrc</code> abi change</td>
<td>🟢 <a href="https://builds.gradle.org/repository/download/Gradle_Master_Check_PerformanceTestSlowLinux_Trigger/49307028:id/performance-test-results.zip!/report/index.html?redirectSupported=false#scenario72" target="_blank" rel="noopener">25.307</a></td>
<td>🔴 <a href="https://builds.gradle.org/repository/download/Gradle_Master_Check_PerformanceTestSlowLinux_Trigger/49307028:id/performance-test-results.zip!/report/index.html?redirectSupported=false#scenario76" target="_blank" rel="noopener">35.014s</a></td>
<td>Groovy DSL is 1.4x faster</td>
</tr>
<tr>
<td><code>buildSrc</code> non-abi change</td>
<td>🔴 <a href="https://builds.gradle.org/repository/download/Gradle_Master_Check_PerformanceTestSlowLinux_Trigger/49307028:id/performance-test-results.zip!/report/index.html?redirectSupported=false#scenario6" target="_blank" rel="noopener">24.526s</a></td>
<td>🟢 <a href="https://builds.gradle.org/repository/download/Gradle_Master_Check_PerformanceTestSlowLinux_Trigger/49307028:id/performance-test-results.zip!/report/index.html?redirectSupported=false#scenario38" target="_blank" rel="noopener">4.732s</a></td>
<td>Kotlin DSL is 5x faster</td>
</tr>
</tbody>
</table>
<p>可以看出，针对<code>Gradle 7.4</code>版本，<code>KTS</code>的编译性能有一定改善，性能差距减少到了<code>1.5</code>倍左右   </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得来说，<code>KTS</code>在可读性，易用性，编译时检查与<code>IDE</code>支持等方面比起<code>Groovy</code>都有巨大的优势，但是在性能方面存在一定劣势，具体如下：       </p>
<ul>
<li>针对<code>Gradle 6.8</code>版本，如果缓存大部分失效或者没有缓存，<code>Groovy DSL</code>比<code>KTS</code>快<code>2</code>到<code>3</code>倍</li>
<li><code>Gradle 7.4</code>版本<code>KTS</code>性能有一定改善，如果缓存大部分失效或者没有缓存，<code>Groovy DSL</code>比<code>KTS</code>快<code>1.5</code>倍左右。      </li>
<li>当<code>buildSrc</code>中发生非<code>abi</code>更改时，<code>kts</code>脚本编译比<code>Groovy DSL</code>快<code>4</code>到<code>5</code>倍，这是因为<code>buildSrc</code>中的<code>kts</code>可以跳过未受影响的构建脚本的编译，而<code>groovy</code>暂不支持</li>
<li>当项目没有发生更改时，<code>KTS</code>与<code>Groovy DSL</code>的编译速度相差不大       </li>
</ul>
<p>由上可知，<code>KTS</code>目前的优缺点都非常明显，在易用性上非常突出，在性能方面有一定劣势，<code>Gradle</code>官方也一直在优化中，读者可以根据自己的项目情况决定是否将构建配置从 <code>Groovy</code> 迁移到 <code>KTS</code></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/gradle/gradle/issues/15886" target="_blank" rel="noopener">The Kotlin and Groovy DSLs should have similar performance characteristics</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>单线程的 JavaScript 是怎么实现异步的?</title>
    <url>/blog/2022/03/js-single-thread.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，<code>JavaScript</code>是单线程的，但是不可避免的，<code>JavaScript</code>也需要进行一些异步任务，比如下面这个例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"first"</span>);</span><br><span class="line">    setTimeout(( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'second'</span> );</span><br><span class="line">    &#125;),<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个例子，执行结果会首先全部输出<code>first</code>，然后全部输出<code>second</code>，而不是交替执行<br>在这个过程中，很明显发生了并发的异步任务，那么问题来了，单线程的<code>JavaScript</code>是怎么实现异步的?     </p>
<h2 id="JavaScript为什么是单线程的"><a href="#JavaScript为什么是单线程的" class="headerlink" title="JavaScript为什么是单线程的?"></a><code>JavaScript</code>为什么是单线程的?</h2><p>作为一个<code>Java</code>程序员，在知道了<code>JavaScript</code>是单线程之后，首先的反应就是不解，为什么一种语言会被设计成单线程的呢? 它为什么不能使用多线程来提高效率呢?</p>
<p><code>JavaScript</code>的单线程，与它的用途有关。作为浏览器脚本语言，<code>JavaScript</code>的主要用途是与用户互动，以及操作<code>DOM</code>。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定<code>JavaScript</code>同时有两个线程，一个线程在某个<code>DOM</code>节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>所以，为了避免复杂性，从一诞生，<code>JavaScript</code>就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<h2 id="JavaScript怎么实现异步"><a href="#JavaScript怎么实现异步" class="headerlink" title="JavaScript怎么实现异步?"></a><code>JavaScript</code>怎么实现异步?</h2><p>现在我们已经了解了<code>JavaScript</code>为什么是单线程的了，那么它又是怎么实现异步的呢?<br><code>JavaScript</code>的异步能力主要是由运行环境提供的      </p>
<h3 id="JavaScript的运行环境"><a href="#JavaScript的运行环境" class="headerlink" title="JavaScript的运行环境"></a><code>JavaScript</code>的运行环境</h3><p><code>JavaScript Runtime</code>也就是<code>JavaScript</code>代码运行的地方。比如<code>JavaScript</code> 可以在 <code>chrome</code> 中执行，也可以在<code>node</code>中执行，<code>chrome</code>与<code>node</code>都是<code>JavaScript Runtime</code><br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/march/p1.png" alt>           </p>
<p>由上图可知，<code>JavaScript Runtime</code>主要包括<code>Js Engine</code>与<code>WebAPI</code>等内容<br><code>Js Engine</code>将我们编写的 <code>JavaScript</code> 转换为更高效的机器码，以实现更好的性能。<br><code>chrome</code> 浏览器中的 <code>JavaScript</code> 由 <code>V8</code> 引擎处理。<code>V8</code>引擎主要包括内存堆与执行栈两个部分      </p>
<ul>
<li>内存堆：用于分配 <code>JavaScript</code> 程序使用的内存。</li>
<li>执行栈：在执行栈中，您的 <code>JS</code> 代码被读取并逐行执行。</li>
</ul>
<p>除了引擎，<code>JavaScript Runtime</code>也提供了<code>WebAPI</code>供<code>JS</code>代码调用，<code>WebAPI</code>提供了网络请求，定时器，事件监听等多种能力<br>因为<code>JS Runtime</code>并不是单线程的，而是持有一个线程池，因此<code>WebAPI</code>中的代码是运行在其他线程的，自然也就提供了异步的能力    </p>
<h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><ul>
<li><code>JS</code>分为同步任务和异步任务，同步任务都在主线程上执行，形成一个执行栈</li>
<li>栈中的代码调用<code>WebAPI</code>时也就异步任务，异步任务执行完成后，它们会在事件队列中添加各种事件</li>
<li>而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调</li>
<li>执行栈与任务队列如此循环，也就是事件循环机制</li>
</ul>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/march/p2.jpg" alt>    </p>
<p>需要注意的是，一旦执行栈中的所有同步任务执行完毕（此时<code>JS</code>引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中<br>因此<code>setTimeout</code>设置的时间并不是准确的，可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，因此存在误差。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>JavaScript</code>本质上是运行在浏览器里的脚本语言，为了简单与避免操作<code>DOM</code>时引入同步问题，所以<code>JavaScript</code>被设计成了单线程的语言。<br><code>JavaScript</code>的异步能力是由运行环境提供的，通过<code>WebAPI</code>与事件循环机制，单线程的<code>JS</code>也可以执行异步任务。    </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a><br><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a><br><a href="https://theflyingmantis.medium.com/javascript-single-threaded-non-blocking-asynchronous-concurrent-language-ffae97c57bef" target="_blank" rel="noopener">Javascript — single threaded, non-blocking, asynchronous, concurrent language</a></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue的双向绑定和单向数据流冲突吗?</title>
    <url>/blog/2022/04/vue-single-two.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知，<code>Vue</code>中更加推荐单向数据流的状态管理模式(比如<code>Vuex</code>)，但<code>Vue</code>同时支持通过<code>v-model</code>实现双向数据绑定。<br>那么问题来了，单项数据流和双向数据绑定的概念，这两种不是相互冲突的吗？即然能用<code>v-model</code>双向数据绑定，不应该就是双向数据流了吗？       </p>
<p>本文主要包括以下内容    </p>
<ol>
<li>单向绑定 <code>vs</code> 双向绑定         </li>
<li>单向数据流 <code>vs</code> 双向数据流</li>
<li>为什么说<code>v-model</code>只是语法糖          </li>
</ol>
<h2 id="单向绑定-vs-双向绑定"><a href="#单向绑定-vs-双向绑定" class="headerlink" title="单向绑定 vs 双向绑定"></a>单向绑定 <code>vs</code> 双向绑定</h2><p>单双向绑定，指的是<code>View</code>层和<code>Model</code>层之间的映射关系。<br><code>react</code>采取单向绑定，如图所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p1.jpg" alt><br>在<code>React</code>中，当<code>View</code>层发生更改时，用户通过发出<code>Actions</code>进行处理，<code>Actions</code>中通过<code>setState</code>对<code>State</code>进行更新，<code>State</code>更新后触发<code>View</code>更新。可以看出，<code>View</code>层不能直接修改<code>State</code>，必须要通过<code>Actions</code>来进行操作，这样更加清晰可控      </p>
<p>单向绑定的方式的优点在于清晰可控，缺点则在于会有一些模板代码，<code>Vue</code>则同时支持单向绑定和双向绑定         </p>
<ul>
<li>单向绑定：插值形式<code></code>，<code>v-bind</code>也是单向绑定</li>
<li>双向绑定：表单的<code>v-model</code>，用户对<code>View</code>层的更改会直接同步到<code>Model</code>层</li>
</ul>
<p>实际上<code>v-model</code>只是<code>v-bind:value</code> 和 <code>v-on:input</code>的语法糖，我们也可以采取类似<code>react</code>的单向绑定。两者各有利弊，单向绑定清晰可控，但是模板代码过多，双向绑定可以简化开发，但是也会导致数据变化不透明，优缺点共存，大家可以根据情况使用。</p>
<h2 id="单向数据流-vs-双向数据流"><a href="#单向数据流-vs-双向数据流" class="headerlink" title="单向数据流 vs 双向数据流"></a>单向数据流 <code>vs</code> 双向数据流</h2><p>数据流指的是组件之间的数据流动。<br><code>Vue</code>与<code>React</code>都是单向数据流的模型，虽然<code>vue</code>有双向绑定<code>v-model</code>，但是<code>vue</code>和<code>react</code>父子组件之间数据传递，仍然还是遵循单向数据流的，父组件可以向子组件传递<code>props</code>，但是子组件不能修改父组件传递来的<code>props</code>，子组件只能通过事件通知父组件进行数据更改，如图所示：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p2.jpg" alt><br>通过单向数据流的模型，所有状态的改变可记录、可跟踪，相比于双向数据流可加容易维护与定位问题       </p>
<h2 id="为什么说v-model只是语法糖"><a href="#为什么说v-model只是语法糖" class="headerlink" title="为什么说v-model只是语法糖"></a>为什么说<code>v-model</code>只是语法糖</h2><blockquote>
<p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</p>
</blockquote>
<p>正如上面所述，<code>Vue</code>文档中说<code>v-model</code>只是语法糖<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=“phoneInfo.phone”/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在组件中使用时，实际相当于下面的简写</span></span><br><span class="line">&lt;input :value=<span class="string">"PhoneInfo.phone"</span> @input=<span class="string">"val =&gt; &#123; PhoneInfo.phone = val &#125;"</span></span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，为什么说<code>v-model</code>不是真正的双向数据流呢？按照这道理，是不是可以认为<code>model-&gt;view</code>的单向数据流也是语法糖啊，也是<code>vue</code>作者通过一定方法实现的而已<br>真正的原因上面已经说了，<strong>数据绑定是<code>View</code>与<code>Model</code>之间的映射关系，数据流指的是组件之间的数据流动</strong><br><code>v-model</code>不是真正的双向数据流，是因为它不能直接修改父组件的值，比如你在<code>v-model</code>中绑定<code>props</code>中的值是会报错的，它只能绑定组件的值<br>而真正的双向数据流，比如<code>AngularJs</code>，是允许在子组件中直接更新父组件的值的，这就是为什么说<code>v-model</code>只是语法糖的原因     </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得来说，单双向数据绑定与数据流是两个不同维度的概念，数据绑定是<code>View</code>与<code>Model</code>之间的映射关系，数据流指的是组件之间的数据流动。因此，单向数据流也可有双向绑定，双向数据流也可以有双向绑定，两者不应该混为一谈<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p3.jpg" alt>     </p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://segmentfault.com/q/1010000019491720" target="_blank" rel="noopener">Vue的单向数据流和双向数据绑定不是冲突的吗？</a><br><a href="https://juejin.cn/post/6844903834599292936" target="_blank" rel="noopener">Vue的双向绑定和单向数据流</a>    </p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 实现 Chrome 小恐龙游戏</title>
    <url>/blog/2022/04/vue-chrome-rex.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>几年前，Google 给 Chrome 浏览器加了一个有趣的彩蛋：如果你在未联网的情况下访问网页，会看到 “Unable to connect to the Internet” 或 “No internet” 的提示，旁边是一只像素恐龙。<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p8.png" alt><br>许多人可能觉得这只恐龙只是一个可爱的小图标，在断网的时候陪伴用户。但是后来有人按下空格键，小恐龙开始奔跑！<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p9.png" alt><br>这只可爱的小恐龙是设计师 Sebastien Gabriel 的作品。他在一次访谈中说，他觉得没有 wifi 的年代就像是史前时代，很多人都已经忘记那个只能在公司、学校或者网吧才能上网的年代，所以他就以史前时代的代表——恐龙，作为断网的图标。   </p>
<p>本文的主要内容就是如何使用Vue实现这个小彩蛋游戏，感兴趣的同学可以直接看下效果：<a href="https://shenzhen2017.github.io/vue-rex/" target="_blank" rel="noopener">游戏地址</a></p>
<h2 id="复刻画面"><a href="#复刻画面" class="headerlink" title="复刻画面"></a>复刻画面</h2><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p10.png" alt><br>我们首先把这个小游戏的样式摆出来，可以看出，主要包括下面几种元素    </p>
<ol>
<li>恐龙  </li>
<li>路面</li>
<li>云彩</li>
<li>障碍物</li>
<li>积分</li>
</ol>
<p>主要就是这些内容，我们通过css将其放在合适的位置即可</p>
<h2 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h2><h3 id="路面动画"><a href="#路面动画" class="headerlink" title="路面动画"></a>路面动画</h3><p>在初步将小游戏的画面复刻了之后，我们需要把画面动起来，可以看出，其实在游戏过程中，小恐龙水平方向是不动的，只是路面一直在平移，看起来小恐龙在移动了，因此我们需要给路面添加动画效果    </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get</span> roadStyle() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">transform</span>: <span class="string">`translateX(<span class="subst">$&#123;<span class="keyword">this</span>.roadTranslate&#125;</span>px)`</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startGamerInterval() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">  <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.gameStatus === GameStatus.RUNNING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateGameStatus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateGameStatus() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.roadTranslate &lt;= <span class="number">-600</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.roadTranslate = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.roadTranslate -= GameConfig.ROAD_VELOCITY;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，主要是通过<code>setInterval</code>启动一个定时任务，然后在其中修改<code>roadTranslate</code>即可     </p>
<h3 id="障碍物动画"><a href="#障碍物动画" class="headerlink" title="障碍物动画"></a>障碍物动画</h3><p>障硬物同样会随着路面一起做水平移动，这部分跟路面的动画部分基本一样，不同的部分在于，障碍物可能有1棵树或者多棵树，这其实是通过雪碧图和<code>background-position</code>实现的，通过雪碧图可以有效的减少我们的切图数量<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateGameStatus() &#123;</span><br><span class="line">  <span class="keyword">this</span>.treeItems.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.treeTranslateX &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> isBigTree = GetRandomNum(<span class="number">0</span>, <span class="number">100</span>) % <span class="number">2</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">const</span> itemWidth = isBigTree ? <span class="number">25</span> : <span class="number">17</span>;</span><br><span class="line">      <span class="keyword">const</span> itemHeight = isBigTree ? <span class="number">50</span> : <span class="number">35</span>;</span><br><span class="line">      <span class="keyword">const</span> itemCount = GetRandomNum(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">      <span class="keyword">const</span> offsetPosition = GetRandomNum(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">      item.treeTranslateX = GetRandomNum(<span class="number">600</span>, <span class="number">1200</span>);</span><br><span class="line">      item.isBigTree = isBigTree;</span><br><span class="line">      item.width = itemWidth * itemCount;</span><br><span class="line">      item.height = itemHeight;</span><br><span class="line">      item.backgroundPosition = -itemWidth * offsetPosition;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      item.treeTranslateX -= GameConfig.TREE_VELOCITY;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样是定时在<code>updateGameStatus</code>中修改障碍物的<code>treeTranslateX</code>，不同之处在于障碍物还需要通过随机树设置宽度与<code>backgroundPosition</code>。<br>同时当<code>treeTranslateX &lt; 0</code>时，说明障碍物已经运行过去了，这时还需要重置状态   </p>
<h3 id="恐龙动画"><a href="#恐龙动画" class="headerlink" title="恐龙动画"></a>恐龙动画</h3><p>除了路面背景在移动之外，为了让恐龙看起来在移动，我们还需要给恐龙添加动画效果，其实就是通过切换图片，让恐龙看起来在跑步，这也是通过雪碧图实现的。<br>除此之外，还有就是当我们按下空格键时，恐龙需要做一个跳跃动画     </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">updateGameStatus() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.rexItem.isInJump) &#123;</span><br><span class="line">    <span class="comment">//跳跃动画	</span></span><br><span class="line">    <span class="keyword">this</span>.rexItem.rexTranslateY -= <span class="keyword">this</span>.rexItem.rexVelocity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rexItem.rexTranslateY &lt;= -GameConfig.REX_MAX_JUMP) &#123;</span><br><span class="line">      <span class="keyword">this</span>.rexItem.rexVelocity = -GameConfig.REX_VELOCITY;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.rexItem.rexTranslateY &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.rexItem.isInJump = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">this</span>.rexItem.rexTranslateY = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.rexItem.rexVelocity = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//跳步动画	</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rexItem.rexBackgroundPostion &lt;= <span class="number">-220</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.rexItem.rexBackgroundPostion = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.rexItem.rexBackgroundPostion -= <span class="number">44</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，主要就是跑步与跳跃动画，其中跳跃动画在达到最大高度后，需要修改速度的方向    </p>
<h2 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h2><p>在这个小游戏中，我们还需要响应键盘事件    </p>
<ol>
<li>游戏未开始时，按空格键开始      </li>
<li>游戏中，按空格键跳跃         </li>
<li>游戏结束后，按空格键重新开始     </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"keyup"</span>, <span class="keyword">this</span>.submit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">submit(event: KeyboardEvent) &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.code === <span class="string">"Space"</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      <span class="keyword">this</span>.gameStatus === GameStatus.WAIT ||</span><br><span class="line">      <span class="keyword">this</span>.gameStatus === GameStatus.END</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.gameStatus = GameStatus.RUNNING;</span><br><span class="line">      <span class="keyword">this</span>.initGame();</span><br><span class="line">      <span class="keyword">this</span>.startGame();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.gameStatus === GameStatus.RUNNING) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.rexItem.rexTranslateY === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.rexItem.isInJump === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.rexItem.isInJump = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">this</span>.rexItem.rexVelocity = GameConfig.REX_VELOCITY;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2><p>在完成画面复刻与让画面动起来之后，接下来要做的就是恐龙与障碍物的碰撞检测了，这其实就是判断两个矩形有没有相交。我们可以通过判断不重叠的情况，然后取反就可以了<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p11.jpeg" alt>   </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">isOverlap(rect1: Rect, <span class="attr">rect2</span>: Rect) &#123;</span><br><span class="line">  <span class="keyword">const</span> startX1 = rect1.x;</span><br><span class="line">  <span class="keyword">const</span> startY1 = rect1.y;</span><br><span class="line">  <span class="keyword">const</span> endX1 = startX1 + rect1.width;</span><br><span class="line">  <span class="keyword">const</span> endY1 = startY1 + rect1.height;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> startX2 = rect2.x;</span><br><span class="line">  <span class="keyword">const</span> startY2 = rect2.y;</span><br><span class="line">  <span class="keyword">const</span> endX2 = startX2 + rect2.width;</span><br><span class="line">  <span class="keyword">const</span> endY2 = startY2 + rect2.height;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !(</span><br><span class="line">    endY2 &lt; startY1 ||</span><br><span class="line">    endY1 &lt; startY2 ||</span><br><span class="line">    startX1 &gt; endX2 ||</span><br><span class="line">    startX2 &gt; endX1</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>通过以上步骤，我们的小游戏就基本开发完成了，接下来就是部署了，在没有自己的服务器的情况下，我们可以利用GitHub Pages来部署我们的项目<br>我们将打包出来的dist目录作为Github Pages的根目录，从而实现发布与部署。关于Vue项目打包部署到GitHub Pages的具体步骤，可以参考：<a href="https://blog.csdn.net/weixin_44670973/article/details/107130231" target="_blank" rel="noopener">Vue项目打包部署到GitHub Pages</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>代码地址：<a href="https://github.com/shenzhen2017/vue-rex" target="_blank" rel="noopener">https://github.com/shenzhen2017/vue-rex</a><br>游戏地址：<a href="https://shenzhen2017.github.io/vue-rex/" target="_blank" rel="noopener">https://shenzhen2017.github.io/vue-rex/</a></p>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Compose 渲染性能到底怎么样?</title>
    <url>/blog/2022/04/compose-render-performance.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年曾经写过一篇文章调研<code>Compose</code>的性能：<a href="https://juejin.cn/post/7008522702835154980" target="_blank" rel="noopener">相比 XML , Compose 性能到底怎么样？</a><br>不过这篇文章主要是从包体积，页面首次打开时间来分析<code>Compose</code>的性能，而<code>Compose</code>作为一个<code>UI</code>框架，相信大家更关注它的渲染性能比如<code>FPS</code>，本文主要就是从<code>FPS</code>的角度来分析<code>Compose</code>的性能      </p>
<p>本文主要包括以下内容:    </p>
<ol>
<li>如何测量<code>Compose</code>的<code>FPS</code></li>
<li><code>Compose</code>列表渲染性能分析    </li>
<li><code>Compose</code>粒子动画渲染性能分析 </li>
</ol>
<h2 id="如何测量Compose的FPS"><a href="#如何测量Compose的FPS" class="headerlink" title="如何测量Compose的FPS"></a>如何测量<code>Compose</code>的<code>FPS</code></h2><p>所谓<code>FPS</code>也就是每秒显示的帧数，<code>Android</code> 设备的 <code>FPS</code> 一般是 60，也即每秒要刷新 60 帧，所以留给每一帧的绘制时间最多只有 1000/60 = 16.67ms 。一旦某一帧的绘制时间超过了限制，就会发生 掉帧，用户在连续两帧会看到同样的画面。     </p>
<p>监测<code>Android</code>应用的<code>FPS</code>，其实已经是相当成熟了，主要就是利用<code>Choreographer.getInstance().postFrameCallback()</code>方法，在这里就不缀述了。<br>那么，我们该怎么监听<code>Compose</code>的<code>FPS</code>呢？利用<code>Choreographer</code>监测仍然适用于<code>Compose</code>吗？<br>其实<code>Choreographer</code>依然可以用来监测<code>Compose</code>的<code>FPS</code>，不过<code>Compose</code>提供了更加方便的<code>API</code>供我们使用:<code>withFrameMillis</code>      </p>
<p><code>withFrameMillis</code>本质上是对<code>Choreographer</code>代码的封装，它会在下一帧到来时回调，并且会返回下一帧开始绘制的时间<br>下面我们来看下如何利用<code>withFrameMillis</code>来监测<code>Compose</code>的<code>FPS</code>     </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">FpsMonitor</span><span class="params">(modifier: <span class="type">Modifier</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fpsCount <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> fps <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">    <span class="keyword">var</span> lastUpdate <span class="keyword">by</span> remember &#123; mutableStateOf(<span class="number">0L</span>) &#125;</span><br><span class="line">    Text(</span><br><span class="line">        text = <span class="string">"Fps: <span class="variable">$fps</span>"</span>, modifier = modifier</span><br><span class="line">            .size(<span class="number">60</span>.dp), color = Color.Red, style = MaterialTheme.typography.body1</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    LaunchedEffect(<span class="built_in">Unit</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            withFrameMillis &#123; ms -&gt;</span><br><span class="line">                fpsCount++</span><br><span class="line">                <span class="keyword">if</span> (fpsCount == <span class="number">5</span>) &#123;</span><br><span class="line">                    fps = (<span class="number">5000</span> / (ms - lastUpdate)).toInt()</span><br><span class="line">                    lastUpdate = ms</span><br><span class="line">                    fpsCount = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码逻辑很简单：     </p>
<ol>
<li><code>withFrameMillis</code>会返回每一帧开始绘制的时间，两帧开始绘制时间的差值就是一帧绘制的时间       </li>
<li><code>1000/(ms-lastUpdate)</code>就是1秒内可以绘制的帧数，也就是<code>FPS</code>        </li>
<li>为了避免帧数抖动过快，我们每5帧计算一次平均<code>FPS</code>，也就是<code>fps = (5000 / (ms - lastUpdate)).toInt()</code>          </li>
</ol>
<h2 id="Compose列表渲染性能分析"><a href="#Compose列表渲染性能分析" class="headerlink" title="Compose列表渲染性能分析"></a><code>Compose</code>列表渲染性能分析</h2><p>关于<code>Compose</code>的列表的性能问题也是老生常谈了，很多人都说<code>Compose</code>的<code>LazyColumn</code>在低端手机上会卡顿，那么我们就来分析比较一下同一个页面用<code>LazyColumn</code>与<code>RecyclerView</code>分别实现，在性能上有什么差距?     </p>
<p>首先来看下页面的样式<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p13.jpg" alt>        </p>
<p>如上，这个页面整体是一个列表，共有4种类型    </p>
<ol>
<li>可左右滑动的<code>Banner</code>   </li>
<li>包含文字与一张图片的<code>item</code>         </li>
<li>包含3张图片的复杂<code>item</code>   </li>
<li>作为视频封面的大图<code>item</code>        </li>
</ol>
<p>然后我们用<code>LazyColumn</code>与<code>RecyclerView</code>分别实现以上页面，然后在不同手机上分别测量其快速滑动时的<code>FPS</code>，结果如下：     </p>
<table>
<thead>
<tr>
<th style="text-align:left">Compose vs View</th>
<th style="text-align:left">Android 5.1</th>
<th style="text-align:left">Android 7.1</th>
<th style="text-align:left">Android 11</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LazyColumn</td>
<td style="text-align:left">21 FPS</td>
<td style="text-align:left">43 FPS</td>
<td style="text-align:left">60 FPS</td>
</tr>
<tr>
<td style="text-align:left">RecyclerView</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">60 FPS</td>
</tr>
</tbody>
</table>
<p>同时在<code>debug</code>包与<code>release</code>包都进行了以上测试，结果基本一致。可以看出，<code>LazyColumn</code>与<code>RecyclerView</code>在性能上的确有一定差距，尤其在低端手机上，<code>LazyColumn</code>快速滑动时掉帧明显，而<code>RecyclerView</code>则都很流畅<br>只能说<code>RecyclerView</code>太强了~     </p>
<h2 id="Compose粒子动画渲染性能分析"><a href="#Compose粒子动画渲染性能分析" class="headerlink" title="Compose粒子动画渲染性能分析"></a><code>Compose</code>粒子动画渲染性能分析</h2><p>除了列表，我们也可以通过粒子动画的方式来测量<code>Compose</code>的性能，通过粒子动画我们可以评估在极端情况下<code>Compose</code>与<code>View</code>的渲染性能     </p>
<p>首先来看下粒子动画效果：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p14.jpg" alt>    </p>
<p>如上，我们可以在画布上生成随机粒子并且做动画，随着粒子数量的增长，观察应用的<code>FPS</code>，以此评估<code>Compose</code>的渲染性能，我们同时也实现了一个<code>View</code>版本以进行对比，结果如下：   </p>
<table>
<thead>
<tr>
<th style="text-align:left">Compose VS View</th>
<th style="text-align:left">100</th>
<th style="text-align:left">1000</th>
<th style="text-align:left">3000</th>
<th style="text-align:left">10000</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Android 5.1 Compose</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">23 FPS</td>
<td style="text-align:left">8 FPS</td>
<td style="text-align:left">2 FPS</td>
</tr>
<tr>
<td style="text-align:left">Android 5.1 View</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">25 FPS</td>
<td style="text-align:left">8 FPS</td>
<td style="text-align:left">2 FPS</td>
</tr>
<tr>
<td style="text-align:left">Android 7.1 Compose</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">49 FPS</td>
<td style="text-align:left">21 FPS</td>
<td style="text-align:left">8 FPS</td>
</tr>
<tr>
<td style="text-align:left">Android 7.1 View</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">52 FPS</td>
<td style="text-align:left">22 FPS</td>
<td style="text-align:left">8 FPS</td>
</tr>
<tr>
<td style="text-align:left">Android 11 Compose</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">60 FPS</td>
</tr>
<tr>
<td style="text-align:left">Android 11 View</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">60 FPS</td>
<td style="text-align:left">60 FPS</td>
</tr>
</tbody>
</table>
<p>可以看出，随着粒子数从<code>100</code>增长到<code>10000</code>，应用的<code>FPS</code>逐渐降低，在低端手机上尤其明显<br>而与列表不同的是，<code>Compose</code>与<code>View</code>在粒子动画中的渲染性能几乎一致，可以说是几乎没有区别      </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要从<code>FPS</code>的角度分析介绍了<code>Compose</code>的渲染性能，可以看出在画布中随机生成粒子动画时，<code>Compose</code>与<code>View</code>的渲染性能几乎一致。<br>而对于复杂列表，<code>LazyColumn</code>与<code>RecyclerView</code>在性能上有一定差距，在低端手机上尤其明显，在快速滑动时会有明显卡顿。<br>结合两个实验，看起来应该是<code>LazyColumn</code>组件存在一定性能问题，而<code>Compose</code>本身的渲染性能已经基本与<code>View</code>一致了~     </p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p>本文所有代码可见：<a href="https://github.com/shenzhen2017/compose-fps" target="_blank" rel="noopener">https://github.com/shenzhen2017/compose-fps</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 Android 渲染你应该了解的知识点</title>
    <url>/blog/2022/04/android-ui-render.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>谈到<code>Android</code>的渲染，大家可能会想到<code>onMeasure</code>、<code>onLayout</code>、<code>onDraw</code>三大流程。但我们的<code>View</code>到底是如何一步一步显示到屏幕上的？<code>onDraw</code>之后到<code>View</code>显示到屏幕上，具体又做了哪些工作?<br>带着这些问题，我们今天就深入学习一下<code>Android</code>渲染的流程吧，本文主包括以下内容：    </p>
<ol>
<li><code>Android</code>渲染的整体架构是怎样的?     </li>
<li><code>Android</code>渲染的生产者包括哪些？<code>Skia</code>与<code>OpenGl</code>的区别是什么？        </li>
<li>什么是硬件加速？硬件绘制与软件绘制的区别   </li>
<li><code>Android</code>渲染缓冲区是什么？什么是黄油计划?     </li>
<li><code>Android</code>渲染的消费者是什么? 什么是<code>SurfaceFlinger</code>?     </li>
</ol>
<h2 id="Android渲染整体架构"><a href="#Android渲染整体架构" class="headerlink" title="Android渲染整体架构"></a><code>Android</code>渲染整体架构</h2><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c7d1a3a14454fb9889aeaed21aca744~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt><br>我们先来看一下<code>Android</code>渲染的整体架构，具体可分为以下几个部分   </p>
<ul>
<li><code>image stream produceers</code>:  渲染数据的生产者，如<code>App</code>的<code>draw</code>方法会把绘制指令通过<code>canvas</code>传递给<code>framework</code>层的<code>RenderThread</code>线程。       </li>
<li><code>native Framework</code>: <code>RenderThread</code>线程通过<code>surface.dequeue</code>得到缓冲区<code>graphic bufer</code>，然后在上面通过<code>OpenGL</code>来完成真正的渲染命令。在把缓冲区交还给<code>BufferQueue</code>队列中。</li>
<li><code>image stream consumers</code>: <code>surfaceFlinger</code>从队列中获取数据，同时和<code>HAL</code>完成<code>layer</code>的合成工作，最终交给<code>HAL</code>展示。</li>
<li><code>HAL</code>:  硬件抽象层。把图形数据展示到设备屏幕</li>
</ul>
<p>可以看出，这其实是个很典型的生产者消费者模式<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7cca766f07f24867803853984b9fe4fc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt>     </p>
<ul>
<li>图像生产者： 也就是我们的<code>APP</code>，再深入点就是<code>canvas-&gt;surface</code>。      </li>
<li>图像消费者：<code>SurfaceFlinger</code></li>
<li>图像缓冲区：<code>BufferQueue</code>，一般是3缓冲区</li>
</ul>
<p>下面我们就从生产者，消费者，缓冲区三个部分来详细了解下<code>Android</code>渲染的过程   </p>
<h2 id="图像生产者"><a href="#图像生产者" class="headerlink" title="图像生产者"></a>图像生产者</h2><p>从上面的架构图可知，图像的生产者主要有<code>MediaPlayer</code>，<code>CameraPreview</code>，<code>NDK(Skia)</code>，<code>OpenGl ES</code>。<br>其中<code>MediaPlayer</code>和<code>Camera Preview</code>是通过直接读取图像源来生成图像数据，<code>NDK（Skia）</code>，<code>OpenGL ES</code>是通过自身的绘制能力生产的图像数据             </p>
<h3 id="OpenGL、Vulkan、Skia的区别"><a href="#OpenGL、Vulkan、Skia的区别" class="headerlink" title="OpenGL、Vulkan、Skia的区别"></a><code>OpenGL</code>、<code>Vulkan</code>、<code>Skia</code>的区别</h3><ul>
<li><code>OpenGL</code>： 是一种跨平台的<code>3D</code>图形绘制规范接口。<code>OpenGL EL</code>则是专门针对嵌入式设备，如手机做了优化。</li>
<li><code>Skia</code>： <code>skia</code>是图像渲染库，<code>2D</code>图形绘制自己就能完成。<code>3D</code>效果（依赖硬件）由<code>OpenGL</code>、<code>Vulkan</code>、<code>Metal</code>支持。它不仅支持<code>2D</code>、<code>3D</code>，同时支持<code>CPU</code>软件绘制和<code>GPU</code>硬件加速。<code>Android</code>、<code>flutter</code>都是使用它来完成绘制。</li>
<li><code>Vulkan</code>: <code>Android</code>引入了<code>Vulkan</code>支持。<code>VulKan</code>是用来替换<code>OpenGL</code>的。它不仅支持<code>3D</code>，也支持<code>2D</code>，同时更加轻量级</li>
</ul>
<h3 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h3><p>关于硬件加速，相信大家也经常听到，尤其是有些<code>API</code>不支持硬件加速，因此需要我们手动关闭，那么硬件加速到底是什么呢?     </p>
<h4 id="CPU-与-GPU的区别"><a href="#CPU-与-GPU的区别" class="headerlink" title="CPU 与 GPU的区别"></a><code>CPU</code> 与 <code>GPU</code>的区别</h4><p>除了屏幕，<code>UI</code> 渲染还要依赖另外两个核心的硬件：<code>CPU</code> 和 <code>GPU</code>。     </p>
<ul>
<li><code>CPU</code>（<code>Central Processing Unit</code>，中央处理器），是计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元；</li>
<li><code>GPU</code>（<code>Graphics Processin Unit</code>，图形处理器），是一种专门用于图像运算的处理器，在计算机系统中通常被称为 “显卡”的核心部件就是 <code>GPU</code>。</li>
</ul>
<p><code>UI</code> 组件在绘制到屏幕之前，都需要经过 <code>Rasterization</code>（栅格化）操作，而栅格化又是一个非常耗时的操作。<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p4.jpg" alt><br><code>Rasterization</code> 栅格化是绘制那些 <code>Button</code>、<code>Shape</code>、<code>Path</code>、<code>String</code>、<code>Bitmap</code> 等显示组件最基础的操作。栅格化将这些 <code>UI</code> 组件拆分到显示器的不同像素上进行显示。这是一个非常耗时的操作，<code>GPU</code> 的引入就是为了加快栅格化。       </p>
<h4 id="硬件绘制与软件绘制"><a href="#硬件绘制与软件绘制" class="headerlink" title="硬件绘制与软件绘制"></a>硬件绘制与软件绘制</h4><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p5.jpg" alt>     </p>
<ul>
<li>从图中可以看到，软件绘制使用 <code>Skia</code> 库，它是一款能在低端设备，如手机呈现高质量的 <code>2D</code> 跨平台图形框架，类似 <code>Chrome</code>、<code>Flutter</code> 内部使用的都是 <code>Skia</code> 库。        </li>
<li>硬件绘制的思想就是通过底层软件代码，将 <code>CPU</code> 不擅长的图形计算转换成 <code>GPU</code> 专用指令，由 <code>GPU</code> 完成绘制任务。      </li>
</ul>
<p>所以说硬件加速的本质就是使用<code>GPU</code>代替<code>CPU</code>完成<code>Graphic Buffer</code>绘制工作，以实现更好的性能，<code>Android</code>从4.0开始默认开启了硬件加速，但还有一些<code>API</code>不支持硬件加速，因此需要手动关闭硬件加速。<br>需要注意的是，软件绘制使用的<code>Skia</code>库，但这不代表<code>Skia</code>不支持硬件加速，从<code>Android 8</code>开始，我们可以选择使用<code>Skia</code>进行硬件加速，<code>Android 9</code>开始就默认使用<code>Skia</code>来进行硬件加速。<code>Skia</code>的硬件加速主要是通过 <code>copybit</code> 模块调用<code>OpenGL</code>或者<code>SKia</code>来实现。</p>
<h2 id="图像缓冲区"><a href="#图像缓冲区" class="headerlink" title="图像缓冲区"></a>图像缓冲区</h2><p><code>Android</code>中的图像生产者<code>OpenGL</code>，<code>Skia</code>，<code>Vulkan</code>将绘制的数据存放在图像缓冲区中，<code>Android</code>中的图像消费<code>SurfaceFlinger</code>从图像缓冲区将数据取出，进行加工及合成<br>那么图像缓冲区我们又需要注意哪些内容呢?      </p>
<h3 id="黄油计划"><a href="#黄油计划" class="headerlink" title="黄油计划"></a>黄油计划</h3><p>优化是无止境的，<code>Google</code> 在 2012 年的 <code>I/O</code> 大会上宣布了 <code>Project Butter</code> 黄油计划，并且在 <code>Android 4.1</code> 中正式开启了这个机制。</p>
<h4 id="VSYNC信号"><a href="#VSYNC信号" class="headerlink" title="VSYNC信号"></a><code>VSYNC</code>信号</h4><p><code>VSYNC（Vertical Synchronization）</code>是理解 <code>Project Butter</code> 的核心。对于 <code>Android 4.0</code>，<code>CPU</code> 可能会因为在忙其他的事情，导致没来得及处理 <code>UI</code> 绘制。<br>为了解决这个问题，系统在收到<code>VSync</code>信号后，将马上开始下一帧的渲染。即一旦收到<code>VSync</code>通知（<code>16ms</code>触发一次），<code>CPU</code>和<code>GPU</code> 才立刻开始计算然后把数据写入<code>buffer</code>。如下图<br><img src="https://img-blog.csdnimg.cn/20200819212951194.png#pic_center" alt>      </p>
<p><code>CPU/GPU</code>根据<code>VSYNC</code>信号同步处理数据，可以让<code>CPU/GPU</code>有完整的16ms时间来处理数据，减少了<code>jank</code>。<br>一句话总结，<code>VSync</code>同步使得<code>CPU/GPU</code>充分利用了16.6ms时间，减少<code>jank</code>。     </p>
<h4 id="三缓冲机制"><a href="#三缓冲机制" class="headerlink" title="三缓冲机制"></a>三缓冲机制</h4><p>在<code>Android 4.0</code>之前，<code>Android</code>采用双缓冲机制，让绘制和显示器拥有各自的<code>buffer</code>：<code>GPU</code> 始终将完成的一帧图像数据写入到 <code>Back Buffer</code>，而显示器使用 <code>Frame Buffer</code>，当屏幕刷新时，<code>Frame Buffer</code> 并不会发生变化，当<code>Back buffer</code>准备就绪后，它们才进行交换。                   </p>
<p>但是如果界面比较复杂，<code>CPU/GPU</code>的处理时间较长 超过了16.6ms呢，双缓冲机制会带来什么问题？如下图：<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p6.jpg" alt>   </p>
<ul>
<li>在第二个时间段内，但却因 <code>GPU</code> 还在处理 <code>B</code> 帧，缓存没能交换，导致 <code>A</code> 帧被重复显示。</li>
<li>而<code>B</code>完成后，又因为缺乏<code>VSync</code>信号，它只能等待下一个<code>signal</code>的来临。于是在这一过程中，有一大段时间是被浪费的。</li>
<li>当下一个<code>VSync</code>出现时，<code>CPU/GPU</code>马上执行操作（<code>A</code>帧），且缓存交换，相应的显示屏对应的就是<code>B</code>。这时看起来就是正常的。只不过由于执行时间仍然超过16ms，导致下一次应该执行的缓冲区交换又被推迟了——如此循环反复，便出现了越来越多的“Jank”。</li>
</ul>
<p>三缓冲就是在双缓冲机制基础上增加了一个<code>Graphic Buffer</code>缓冲区，这样可以最大限度的利用空闲时间，带来的坏处是多使用的一个<code>Graphic Buffer</code>所占用的内存。<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/april/p7.jpg" alt><br>三缓冲机制有效利用了等待vysnc的时间，可以帮助我们减少了<code>jank</code>     </p>
<h4 id="RenderThread"><a href="#RenderThread" class="headerlink" title="RenderThread"></a><code>RenderThread</code></h4><p>经过 <code>Android 4.1</code> 的 <code>Project Butter</code> 黄油计划之后，<code>Android</code> 的渲染性能有了很大的改善。不过你有没有注意到这样一个问题，虽然利用了 <code>GPU</code> 的图形高性能运算，但是从计算 <code>DisplayList</code>，到通过 <code>GPU</code> 绘制到 <code>Frame Buffer</code>，整个计算和绘制都在 <code>UI</code> 主线程中完成。</p>
<p><code>UI</code> 线程任务过于繁重。如果整个渲染过程比较耗时，可能造成无法响应用户的操作，进而出现卡顿的情况。<code>GPU</code> 对图形的绘制渲染能力更胜一筹，如果使用 <code>GPU</code> 并在不同线程绘制渲染图形，那么整个流程会更加顺畅。</p>
<p>正因如此，在 <code>Android 5.0</code> 引入两个比较大的改变。一个是引入了 <code>RenderNode</code> 的概念，它对 <code>DisplayList</code> 及一些 <code>View</code> 显示属性都做了进一步封装。另一个是引入了 <code>RenderThread</code>，所有的 <code>GL</code> 命令执行都放到这个线程上，渲染线程在 <code>RenderNode</code> 中存有渲染帧的所有信息，可以做一些属性动画，这样即便主线程有耗时操作的时候也可以保证动画流程。</p>
<h2 id="图像消费者"><a href="#图像消费者" class="headerlink" title="图像消费者"></a>图像消费者</h2><p><code>SurfaceFlinger</code>是<code>Android</code>系统中最重要的一个图像消费者，<code>Activity</code>绘制的界面图像，都会传递到<code>SurfaceFlinger</code>来，<code>SurfaceFlinger</code>的作用主要是接收<code>GraphicBuffer</code>，然后交给<code>HWComposer</code>或者<code>OpenGL</code>做合成，合成完成后，<code>SurfaceFlinger</code>会把最终的数据提交给<code>FrameBuffer</code>。</p>
<p><code>SurfaceFlinger</code>是图像数据的消费者。在应用程序请求创建<code>surface</code>的时候，<code>SurfaceFlinger</code>会创建一个<code>Layer</code>。<code>Layer</code>是<code>SurfaceFlinger</code>操作合成的基本单元。所以，一个<code>surface</code>对应一个<code>Layer</code>。<br>当应用程序把绘制好的<code>GraphicBuffer</code>数据放入<code>BufferQueue</code>后，接下来的工作就是<code>SurfaceFlinger</code>来完成了。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3fc0b6af1d44b139cd9a177aba0c92d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt>   </p>
<p>系统会有多个应用程序，一个程序有多个<code>BufferQueue</code>队列。<code>SurfaceFlinger</code>就是用来决定何时以及怎么去管理和显示这些队列的。<br><code>SurfaceFlinger</code>请求<code>HAL</code>硬件层，来决定这些<code>Buffer</code>是硬件来合成还是自己通过<code>OpenGL</code>来合成。<br>最终把合成后的<code>buffer</code>数据，展示在屏幕上。       </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得来说，<code>Android</code>图像渲染机制是一个生产者消费者的模型，如下图所示：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43b1bf02b22b460ab46b6113cf640f00~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt>     </p>
<ul>
<li><code>onMeasure</code>、<code>onLayout</code>计算出<code>view</code>的大小和摆放的位置，这都是<code>UI</code>线程要做的事情，在<code>draw</code>方法中进行绘制，但此时是没有真正去绘制。而是把绘制的指令封装为<code>displayList</code>,进一步封装为<code>RenderNode</code>，在同步给<code>RenderThread</code>。</li>
<li><code>RenderThread</code>通过<code>dequeue</code>拿到<code>graphic buffer</code>（<code>surfaceFlinger</code>的缓冲区），根据绘制指令直接操作<code>OpenGL</code>的绘制接口，最终通过<code>GPU</code>设备把绘制指令渲染到了离屏缓冲区<code>graphic buffer</code>。</li>
<li>完成渲染后，把缓冲区交还给<code>SurfaceFlinger</code>的<code>BufferQueue</code>。<code>SurfaceFlinger</code>会通过硬件设备进行<code>layer</code>的合成，最终展示到屏幕。</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/279f727b00bc" target="_blank" rel="noopener">关于 UI 渲染，你需要了解什么？</a><br><a href="https://juejin.cn/post/6863756420380196877" target="_blank" rel="noopener">“终于懂了” 系列：Android屏幕刷新机制—VSync、Choreographer 全面理解！</a><br><a href="https://juejin.cn/post/6876049821187358728" target="_blank" rel="noopener">掌握Android图像显示原理上</a><br><a href="https://juejin.cn/post/6993123390231937031" target="_blank" rel="noopener">Android 渲染系列-App整个渲染流程全解析</a>    </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>【从入门到了解】Android稳定性优化深入解析</title>
    <url>/blog/2022/05/android-crash-optimize.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Android</code>的稳定性是<code>Android</code>性能的一个重要指标，它也是<strong>App质量构建体系中最基本和最关键的一环</strong>。如果应用经常崩溃率，或者关键功能不可用，那显然会对我们的留存产生重大影响。<br>为了保障应用的稳定性，我们首先应该树立对稳定性的正确认识，本文主要包括以下内容：  </p>
<ol>
<li>稳定性优化的正确认识   </li>
<li><code>Crash</code>处理的一般步骤</li>
<li><code>Crash</code>长效治理</li>
<li>业务高可用方案建设</li>
<li>稳定性优化常见面试题</li>
</ol>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/may/p9.jpg" alt></p>
<h2 id="稳定性优化的正确认识"><a href="#稳定性优化的正确认识" class="headerlink" title="稳定性优化的正确认识"></a>稳定性优化的正确认识</h2><h3 id="稳定性优化的关键指标"><a href="#稳定性优化的关键指标" class="headerlink" title="稳定性优化的关键指标"></a>稳定性优化的关键指标</h3><p>要做稳定性优化，首先一个问题就是，要做成什么效果？<code>Crash</code>率多少算优秀呢?在明确了目标之后，我们才能正确认识我们的工作到底有什么作用    </p>
<p>要计算<code>Crash</code>率，我们首先应该明白稳定性优化的一些关键指标    </p>
<h4 id="UV-Crash率与PV-Crash率"><a href="#UV-Crash率与PV-Crash率" class="headerlink" title="UV Crash率与PV Crash率"></a><code>UV Crash</code>率与<code>PV Crash</code>率</h4><p><code>PV（Page View）</code>即访问量， <code>UV（Unique Visitor）</code>即独立访客，0 - 24小时内的同一终端只计算一次</p>
<ul>
<li><code>UV Crash</code>率：针对用户使用量的统计，统计一段时间内所有用户发生崩溃的占比，用于评估<code>Crash</code>率的影响范围。 </li>
<li><code>PV Crash</code>率：针对用户使用次数的统计，评估相关<code>Crash</code>影响的严重程度。</li>
</ul>
<p>大家可以根据自己的需要选择合适的指标，需要注意的是，需要确保一直使用同一种衡量方式。</p>
<h4 id="Crash率评价"><a href="#Crash率评价" class="headerlink" title="Crash率评价"></a><code>Crash</code>率评价</h4><p>那么，我们<code>App</code>的<code>Crash</code>率降低多少才能算是一个正常水平或优秀的水平呢？    </p>
<ul>
<li><code>Java</code>与<code>Native</code>的总崩溃率必须在千分之二以下。</li>
<li><code>Crash</code>率万分位为优秀</li>
</ul>
<p>注意，以上说的都是<code>UV</code>崩溃率</p>
<h3 id="稳定性优化的维度"><a href="#稳定性优化的维度" class="headerlink" title="稳定性优化的维度"></a>稳定性优化的维度</h3><p>很多人都会认为稳定性优化就是降低<code>Crash</code>率，但如果你的<code>APP</code>没有崩溃，但是关键功能却不可用，这又怎么算是稳定的呢?<br>因此应用的稳定性可以分为三个纬度，如下所示：      </p>
<ul>
<li>1、<code>Crash</code>纬度：最重要的指标就是应用的<code>Crash</code>率。</li>
<li>2、性能纬度：包括启动速度、内存、绘制等等优化方向，相对于<code>Crash</code>来说是次要的，但也是应用稳定性的一部分。</li>
<li>3、业务高可用纬度：它是非常关键的一步，我们需要采用多种手段来保证我们<code>App</code>的主流程以及核心路径的稳定性。</li>
</ul>
<h2 id="Crash处理的一般步骤"><a href="#Crash处理的一般步骤" class="headerlink" title="Crash处理的一般步骤"></a><code>Crash</code>处理的一般步骤</h2><p>下面我们来看下应该如何处理<code>Crash</code>,即如果应用崩溃了，你应该如何去分析？<br>主要从崩溃现场和崩溃分析两个角度来分析    </p>
<h3 id="崩溃现场"><a href="#崩溃现场" class="headerlink" title="崩溃现场"></a>崩溃现场</h3><p>崩溃现场是我们的“第一案发现场”，它保留着很多有价值的线索。在这里我们挖掘到的信息越多，下一步分析的方向就越清晰，而不是去靠盲目猜测。<br>接下来我们具体来看看在崩溃现场应该采集哪些信息。    </p>
<h4 id="崩溃信息"><a href="#崩溃信息" class="headerlink" title="崩溃信息"></a>崩溃信息</h4><p>从崩溃的基本信息，我们可以对崩溃有初步的判断。       </p>
<ul>
<li>进程名、线程名。崩溃的进程是前台进程还是后台进程，崩溃是不是发生在 UI 线程。</li>
<li>崩溃堆栈和类型。崩溃是属于 <code>Java</code> 崩溃、<code>Native</code> 崩溃，还是 <code>ANR</code>，对于不同类型的崩溃我们关注的点也不太一样。特别需要看崩溃堆栈的栈顶，看具体崩溃在系统的代码，还是我们自己的代码里面。</li>
</ul>
<h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h4><p>除了崩溃的信息之外，系统的信息有时候会带有一些关键的线索，对我们解决问题有非常大的帮助。      </p>
<ul>
<li><code>Logcat</code>输出。这里包括应用、系统的运行日志。有时从堆栈中看不出什么信息，反而可以从<code>Logcat</code>中获得意外收获</li>
<li>机型、系统、厂商、<code>CPU</code>、<code>ABI</code>、<code>Linux</code> 版本等。我们会采集多达几十个维度，这对后面讲到寻找共性问题会很有帮助。</li>
<li>设备状态：是否 <code>root</code>、是否是模拟器。一些问题是由 <code>Xposed</code> 或多开软件造成，对这部分问题我们要区别对待。</li>
</ul>
<h4 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h4><p><code>OOM</code>、<code>ANR</code>、虚拟内存耗尽等，很多崩溃都跟内存有直接关系。如果我们把用户的手机内存分为“2GB 以下”和“2GB 以上”两个桶，会发现“2GB 以下”用户的崩溃率是“2GB 以上”用户的几倍。</p>
<ul>
<li>系统剩余内存。关于系统内存状态，可以直接读取文件 <code>/proc/meminfo</code>。当系统可用内存很小（低于 <code>MemTotal</code> 的 10%）时，<code>OOM</code>、大量 <code>GC</code>、系统频繁自杀拉起等问题都非常容易出现。</li>
<li>应用使用内存。包括 <code>Java</code> 内存、<code>RSS</code>（<code>Resident Set Size</code>）、<code>PSS</code>（<code>Proportional Set Size</code>），我们可以得出应用本身内存的占用大小和分布。     </li>
<li>虚拟内存。虚拟内存可以通过 <code>/proc/self/status</code> 得到，通过 <code>/proc/self/maps</code> 文件可以得到具体的分布情况。有时候我们一般不太重视虚拟内存，但是很多类似 <code>OOM</code>、<code>tgkill</code> 等问题都是虚拟内存不足导致的。</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">Name:</span>     com.sample.name   <span class="comment">// 进程名</span></span><br><span class="line"><span class="symbol">FDSize:</span>   <span class="number">800</span>               <span class="comment">// 当前进程申请的文件句柄个数</span></span><br><span class="line"><span class="symbol">VmPeak:</span>   <span class="number">3004628</span> kB        <span class="comment">// 当前进程的虚拟内存峰值大小</span></span><br><span class="line"><span class="symbol">VmSize:</span>   <span class="number">2997032</span> kB        <span class="comment">// 当前进程的虚拟内存大小</span></span><br><span class="line"><span class="symbol">Threads:</span>  <span class="number">600</span>               <span class="comment">// 当前进程包含的线程个数</span></span><br></pre></td></tr></table></figure>
<p>一般来说，对于 32 位进程，如果是 32 位的 <code>CPU</code>，虚拟内存达到 3GB 就可能会引起内存申请失败的问题。如果是 64 位的 <code>CPU</code>，虚拟内存一般在 3～4GB 之间。当然如果我们支持 64 位进程，虚拟内存就不会成为问题。因此我们的应用应该尽量适配64位</p>
<h4 id="资源信息"><a href="#资源信息" class="headerlink" title="资源信息"></a>资源信息</h4><p>有的时候我们会发现应用堆内存和设备内存都非常充足，还是会出现内存分配失败的情况，这跟资源泄漏可能有比较大的关系。</p>
<ul>
<li>文件句柄 <code>fd</code>。一般单个进程允许打开的最大文件句柄个数为 <code>1024</code>。但是如果文件句柄超过 <code>800</code> 个就比较危险，需要将所有的 <code>fd</code> 以及对应的文件名输出到日志中，进一步排查是否出现了有文件或者线程的泄漏     </li>
<li>线程数。一个线程可能就占 <code>2MB</code> 的虚拟内存，过多的线程会对虚拟内存和文件句柄带来压力。根据我的经验来说，如果线程数超过 400 个就比较危险。需要将所有的线程 <code>id</code> 以及对应的线程名输出到日志中，进一步排查是否出现了线程相关的问题。</li>
</ul>
<h4 id="应用信息"><a href="#应用信息" class="headerlink" title="应用信息"></a>应用信息</h4><p>除了系统，其实我们的应用更懂自己，可以留下很多相关的信息。</p>
<ul>
<li>崩溃场景。崩溃发生在哪个 <code>Activity</code> 或 <code>Fragment</code>，发生在哪个业务中。</li>
<li>关键操作路径。不同于开发过程详细的打点日志，我们可以记录关键的用户操作路径，这对我们复现崩溃会有比较大的帮助。</li>
<li>其他自定义信息。不同的应用关心的重点可能不太一样，比如网易云音乐会关注当前播放的音乐，QQ 浏览器会关注当前打开的网址或视频。此外例如运行时间、是否加载了补丁、是否是全新安装或升级等信息也非常重要。</li>
</ul>
<p>上面介绍了在崩溃现场应该采集的信息，当然开发一个这样的采集平台还是很复杂的，大多数情况我们只需要接入一些第三方的平台比如<code>bugly</code>和<code>Sentry</code>即可。但是通过上述介绍，我们可以知道在分析崩溃的时候应该重点关注哪些信息，同时如果平台能力有缺失，我们也可以添加自定义的上报</p>
<h3 id="崩溃分析"><a href="#崩溃分析" class="headerlink" title="崩溃分析"></a>崩溃分析</h3><p>在崩溃现场上报了足够的信息之后，我们就可以开始分析崩溃了，下面我们介绍崩溃分析“三部曲”     </p>
<h4 id="第一步：确定重点"><a href="#第一步：确定重点" class="headerlink" title="第一步：确定重点"></a>第一步：确定重点</h4><p>确认和分析重点，关键在于在日志中找到重要的信息，对问题有一个大致判断。一般来说，我建议在确定重点这一步可以关注以下几点。</p>
<ol>
<li><p><strong>确认严重程度与优先级</strong>。解决崩溃也要看性价比，我们优先解决 <code>Top</code> 崩溃或者对业务有重大影响，</p>
</li>
<li><p><strong>崩溃基本信息</strong>。确定崩溃的类型以及异常描述，对崩溃有大致的判断。一般来说，大部分的简单崩溃经过这一步已经可以得到结论。</p>
</li>
</ol>
<ul>
<li><code>Java</code> 崩溃。<code>Java</code> 崩溃类型比较明显，比如 <code>NullPointerException</code> 是空指针，<code>OutOfMemoryError</code> 是资源不足，这个时候需要去进一步查看日志中的 “内存信息”和“资源信息”。</li>
<li><code>Native</code> 崩溃。需要观察 <code>signal</code>、<code>code</code>、<code>fault addr</code> 等内容，以及崩溃时 <code>Java</code> 的堆栈。关于各 <code>signal</code> 含义的介绍，你可以查看<a href="http://www.mkssoftware.com/docs/man5/siginfo_t.5.asp" target="_blank" rel="noopener">崩溃信号介绍</a>。比较常见的是有 <code>SIGSEGV</code> 和 <code>SIGABRT</code>，前者一般是由于空指针、非法指针造成，后者主要因为 <code>ANR</code> 和调用 <code>abort()</code> 退出所导致。</li>
<li><code>ANR</code>。我的经验是，先看看主线程的堆栈，是否是因为锁等待导致。接着看看 <code>ANR</code> 日志中 <code>iowait</code>、<code>CPU</code>、<code>GC</code>、<code>system server</code> 等信息，进一步确定是 <code>I/O</code> 问题，或是 <code>CPU</code> 竞争问题，还是由于大量 <code>GC</code> 导致卡死</li>
</ul>
<ol start="3">
<li><p><code>Logcat</code>。<code>Logcat</code> 一般会存在一些有价值的线索，日志级别是 <code>Warning</code>、<code>Error</code> 的需要特别注意。从 <code>Logcat</code> 中我们可以看到当时系统的一些行为跟手机的状态，例如出现 <code>ANR</code> 时，会有“am_anr”；<code>App</code> 被杀时，会有“am_kill”。不同的系统、厂商输出的日志有所差别，<strong>当从一条崩溃日志中无法看出问题的原因，或者得不到有用信息时，不要放弃，建议查看相同崩溃点下的更多崩溃日志</strong>。</p>
</li>
<li><p>各个资源情况。结合崩溃的基本信息，我们接着看看是不是跟 “内存信息” 有关，是不是跟“资源信息”有关。比如是物理内存不足、虚拟内存不足，还是文件句柄 <code>fd</code> 泄漏了。</p>
</li>
</ol>
<p>无论是资源文件还是 <code>Logcat</code>，内存与线程相关的信息都需要特别注意，很多崩溃都是由于它们使用不当造成的。</p>
<h4 id="第二步：查找共性"><a href="#第二步：查找共性" class="headerlink" title="第二步：查找共性"></a>第二步：查找共性</h4><p>如果使用了上面的方法还是不能有效定位问题，我们可以尝试查找这类崩溃有没有什么共性。找到了共性，也就可以进一步找到差异，离解决问题也就更进一步。</p>
<p>机型、系统、<code>ROM</code>、厂商、<code>ABI</code>，这些采集到的系统信息都可以作为维度聚合，共性问题例如是不是因为安装了 <code>Xposed</code>，是不是只出现在 <code>x86</code> 的手机，是不是只有三星这款机型，是不是只在 <code>Android 5.0</code> 的系统上。应用信息也可以作为维度来聚合，比如正在打开的链接、正在播放的视频、国家、地区等。找到了共性，可以对你下一步复现问题有更明确的指引。</p>
<h4 id="第三步：尝试复现"><a href="#第三步：尝试复现" class="headerlink" title="第三步：尝试复现"></a>第三步：尝试复现</h4><p>如果我们已经大概知道了崩溃的原因，为了进一步确认更多信息，就需要尝试复现崩溃。如果我们对崩溃完全没有头绪，也希望通过用户操作路径来尝试重现，然后再去分析崩溃原因。</p>
<p>“只要能本地复现，我就能解”，相信这是很多开发跟测试说过的话。有这样的底气主要是因为在稳定的复现路径上面，我们可以采用增加日志或使用 <code>Debugger</code>、<code>GDB</code> 等各种各样的手段或工具做进一步分析。</p>
<h3 id="系统崩溃解决"><a href="#系统崩溃解决" class="headerlink" title="系统崩溃解决"></a>系统崩溃解决</h3><p>有时有些崩溃并不是我们应用的问题，而是系统的问题，系统崩溃系统崩溃常常令我们感到非常无助，它可能是某个 <code>Android</code> 版本的 <code>bug</code>，也可能是某个厂商修改 <code>ROM</code> 导致。<br>这种情况下的崩溃堆栈可能完全没有我们自己的代码，很难直接定位问题。</p>
<p>针对这种疑难问题，我们可以尝试通过以下方法解决。      </p>
<ol>
<li>查找可能的原因。通过上面的共性归类，我们先看看是某个系统版本的问题，还是某个厂商特定 <code>ROM</code> 的问题。虽然崩溃日志可能没有我们自己的代码，但通过操作路径和日志，我们可以找到一些怀疑的点。</li>
<li>尝试规避。查看可疑的代码调用，是否使用了不恰当的 <code>API</code>，是否可以更换其他的实现方式规避。</li>
<li><code>Hook</code> 解决。在了解了原因之后，最后可以通过<code>Hook</code>的方式修改系统代码的逻辑来处理</li>
</ol>
<p>比如我们发现线上出现一个 <code>Toast</code> 相关的系统崩溃，它只出现在 <code>Android 7.0</code> 的系统中，看起来是在 <code>Toast</code> 显示的时候窗口的 <code>token</code> 已经无效了。这有可能出现在 <code>Toast</code> 需要显示时，窗口已经销毁了。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">android<span class="selector-class">.view</span>.WindowManager<span class="variable">$BadTokenException</span>: </span><br><span class="line">  at android<span class="selector-class">.view</span><span class="selector-class">.ViewRootImpl</span>.setView(ViewRootImpl.java)</span><br><span class="line">  at android<span class="selector-class">.view</span><span class="selector-class">.WindowManagerGlobal</span>.addView(WindowManagerGlobal.java)</span><br><span class="line">  at android<span class="selector-class">.view</span><span class="selector-class">.WindowManagerImpl</span>.addView(WindowManagerImpl.java4)</span><br><span class="line">  at android<span class="selector-class">.widget</span>.Toast<span class="variable">$TN</span>.handleShow(Toast.java)</span><br></pre></td></tr></table></figure></p>
<p>为什么 <code>Android 8.0</code> 的系统不会有这个问题？在查看 <code>Android 8.0</code> 的源码后我们发现有以下修改：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  mWM.addView(mView, mParams);</span><br><span class="line">  trySendAccessibilityEvent();</span><br><span class="line">&#125; <span class="keyword">catch</span> (WindowManager.BadTokenException e) &#123;</span><br><span class="line">  <span class="comment">/* ignore */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此我们可以参考 <code>Android 8.0</code> 的做法，直接 <code>catch</code> 住这个异常。这里的关键在于寻找 <code>Hook</code> 点，<code>Toast</code> 里面有一个变量叫 <code>mTN</code>，它的类型为 <code>handler</code>，我们只需要代理它就可以实现捕获。</p>
<h2 id="Crash长效治理"><a href="#Crash长效治理" class="headerlink" title="Crash长效治理"></a><code>Crash</code>长效治理</h2><p>上面介绍了处理线上<code>Crash</code>的一般步骤，但是<code>Crash</code>治理真正重要的阶段在上线之前,我们需要从开发阶段开始，系统性的进行<code>Crash</code>长效治理</p>
<h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p><code>Crash</code>的长效治理需要从开发阶段抓起，从长远来说，更好的代码质量将带来更好的稳定性，我们可以从以下两个角度来提升代码质量</p>
<ul>
<li>统一编码规范、增强编码功底、技术评审、增强<code>CodeReview</code>机制</li>
<li>架构优化，能力收敛(即将一些常见的操作进行封装)，统一容错：如在网络库utils中统一对返回信息进行预校验，如不合法就直接不走接下来的流程。</li>
</ul>
<h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><p>除了功能测试、自动化测试、回归测试、覆盖安装等常规测试流程之外，还需要针对特殊场景、机型等边界进行测试：如服务端返回异常数据、服务端宕机等情况</p>
<h3 id="合码阶段"><a href="#合码阶段" class="headerlink" title="合码阶段"></a>合码阶段</h3><ul>
<li>在我们的功能开发完毕，即将合并到主分支时，首先要进行编译检测、静态扫描，来发现可能存在的问题。     </li>
<li>在扫描完成后也不能直接合入，因为多个分支可能会冲突，因此我们先进行一个预编译流程，即合入一个与主分支一样的分支、然后打包进行主流程自动化回归测试，流程通过后再合入主分支。当然这样做可能比较麻烦，但这些步骤应该都是自动化的</li>
</ul>
<h3 id="发布阶段"><a href="#发布阶段" class="headerlink" title="发布阶段"></a>发布阶段</h3><ul>
<li>在发布阶段，我们应该进行多轮灰度，灰度量级应逐渐由小变大，用最小的代价提前暴露问题</li>
<li>灰度发布同样应该分场景、多纬度全面覆盖，可以针对特别的版本，机型等进行专门的灰度，看下那些更有可能出现问题的用户是否出现问题</li>
</ul>
<h3 id="运维阶段"><a href="#运维阶段" class="headerlink" title="运维阶段"></a>运维阶段</h3><ul>
<li>在上线之后，稳定性问题同样需要关注，因此特别依赖于<code>APM</code>的灵敏监控，发现问题及时报警</li>
<li>如果出现了异常情况，也需要根据情况进行回滚或者降级策略</li>
<li>如果不能回滚或降级的话，也可以采用热修复的方式来修复、如果热修复也失效的话，只能依赖于本地容灾方案来恢复</li>
</ul>
<h2 id="业务高可用方案建设"><a href="#业务高可用方案建设" class="headerlink" title="业务高可用方案建设"></a>业务高可用方案建设</h2><p>很多人认为稳定性优化就是降低<code>Crash</code>率，但其实稳定性优化还有一个重要的维度就是业务的高可用。<br>业务的不可用可能不会导致崩溃，但是会降低用户的体验，从而直接影响我们的收入    </p>
<h3 id="业务高可用方案建设-1"><a href="#业务高可用方案建设-1" class="headerlink" title="业务高可用方案建设"></a>业务高可用方案建设</h3><ol>
<li>业务高可用不像<code>Crash</code>，需要我们自己打点做数据采集。我们需要梳理项目主流程、核心路径、关键节点，并添加打点</li>
<li>数据采集我们也可以采用<code>AOP</code>方式采集，减少手动打点的成本。</li>
<li>数据上报之后，我们可以建立数据大盘，统计每个步骤的转化率。</li>
<li>在数据之报之后，我们也可以建立报警策略，比如阈值报警、趋势报警(相比同期减少)、特定指标报警(比如支付失败)</li>
<li>同时我们可以做一些异常监控的工作，比如<code>Catch</code>住的异常与异常逻辑的上报，这些异常虽然不会崩溃，但也是我们需要关注的</li>
<li>针对一些难以解决的问题，我们可以针对特定用户采用全量日志回捞的方式来采集更多信息，</li>
<li>在发现了异常之后，我们可以通过一些兜底策略来解决问题，比如支持通过配置中心配置功能开关是否打开，当发现某个新功能有问题时，我们可以直接隐藏该功能，或者通过配置路由的方式跳转到另一个方式</li>
</ol>
<h3 id="客户端容灾方案"><a href="#客户端容灾方案" class="headerlink" title="客户端容灾方案"></a>客户端容灾方案</h3><p>在性能或者业务异常发生了之后，我们该如何解决呢？传统的流程需要经过用户反馈，重新打包，渠道更新等多个步骤，可以看出其实比较麻烦，对用户的响应度也比较低<br>我们可以从以下角度来进行客户端的容灾方案建设</p>
<ol>
<li>对于新加的功能或者代码重构，支持通过配置中心配置开关，如果发生问题可以及时关闭</li>
<li>同时如果我们的<code>App</code>所有的页面都是通过路由跳转的，可以通过动态配置路由的方式跳转到统一错误处理页面，或者跳转到临时h5页面</li>
<li>通过热修复技术修复<code>BUG</code>，比如接入腾讯的<code>Tinker</code>或者美团的<code>Robust</code>等</li>
<li>如果你的项目使用了<code>RN</code>或者<code>Weex</code>，可直接实现增量更新</li>
<li>如果崩溃发生在刚启动<code>APP</code>时，这时候动态更新动态配置就都失效了，这个时候就需要用到安全模式。安全模式根据<code>Crash</code>信息自动恢复，多次启动失败重置应用为安装初始状态。如果是特别严重的<code>Bug</code>，也可以通过阻塞性热修复的方式来解决，即热修成功了才能进入<code>APP</code>。安全模式不仅可以用于<code>APP</code>，也可用于组件，如果某个组件多次报错，就可以进入兜底页面</li>
</ol>
<h2 id="稳定性优化常见面试题"><a href="#稳定性优化常见面试题" class="headerlink" title="稳定性优化常见面试题"></a>稳定性优化常见面试题</h2><p>下面介绍一下稳定性优化的模拟面试题</p>
<h3 id="你们做了哪些稳定性方面的优化？"><a href="#你们做了哪些稳定性方面的优化？" class="headerlink" title="你们做了哪些稳定性方面的优化？"></a>你们做了哪些稳定性方面的优化？</h3><p>参考答案：</p>
<p>随着项目的逐渐成熟，用户基数逐渐增多，<code>DAU</code>持续升高，我们遇到了很多稳定性方面的问题，对于我们技术同学遇到了很多的挑战，用户经常使用我们的<code>App</code>卡顿或者是功能不可用，因此我们就针对稳定性开启了专项的优化，我们主要优化了三项：</p>
<ul>
<li><code>Crash</code>专项优化</li>
<li>性能稳定性优化</li>
<li>业务稳定性优化</li>
</ul>
<p>通过这三方面的优化我们搭建了移动端的高可用平台。同时，也做了很多的措施来让<code>App</code>真正地实现了高可用。</p>
<h3 id="性能稳定性是怎么做的？"><a href="#性能稳定性是怎么做的？" class="headerlink" title="性能稳定性是怎么做的？"></a>性能稳定性是怎么做的？</h3><p>参考答案：</p>
<ul>
<li>全面的性能优化：启动速度、内存优化、绘制优化</li>
<li>线下发现问题、优化为主</li>
<li>线上监控为主</li>
<li><code>Crash</code>专项优化</li>
</ul>
<p>我们针对启动速度，内存、布局加载、卡顿、瘦身、流量、电量等多个方面做了多维的优化。</p>
<p>我们的优化主要分为了两个层次，即线上和线下，针对于线下呢，我们侧重于发现问题，直接解决，将问题尽可能在上线之前解决为目的。而真正到了线上呢，我们最主要的目的就是为了监控，对于各个性能纬度的监控呢，可以让我们尽可能早地获取到异常情况的报警。</p>
<p>同时呢，对于线上最严重的性能问题性问题：<code>Crash</code>，我们做了专项的优化，不仅优化了<code>Crash</code>的具体指标，而且也尽可能地获取了<code>Crash</code>发生时的详细信息，结合后端的聚合、报警等功能，便于我们快速地定位问题。</p>
<h3 id="业务稳定性如何保障？"><a href="#业务稳定性如何保障？" class="headerlink" title="业务稳定性如何保障？"></a>业务稳定性如何保障？</h3><p>参考答案:</p>
<ul>
<li>数据采集 + 报警</li>
<li>需要对项目的主流程与核心路径进行埋点监控，</li>
<li>同时还需知道每一步发生了多少异常，这样，我们就知道了所有业务流程的转换率以及相应界面的转换率</li>
<li>结合大盘，如果转换率低于某个值，进行报警</li>
<li>异常监控 + 单点追查</li>
<li>兜底策略，如天猫安全模式</li>
</ul>
<p>移动端业务高可用它侧重于用户功能完整可用，主要是为了解决一些线上一些异常情况导致用户他虽然没有崩溃，也没有性能问题，但是呢，只是单纯的功能不可用的情况，我们需要对项目的主流程、核心路径进行埋点监控，来计算每一步它真实的转换率是多少，同时呢，还需要知道在每一步到底发生了多少异常。这样我们就知道了所有业务流程的转换率以及相应界面的转换率，有了大盘的数据呢，我们就知道了，如果转换率或者是某些监控的成功率低于某个值，那很有可能就是出现了线上异常，结合了相应的报警功能，我们就不需要等用户来反馈了，这个就是业务稳定性保障的基础。</p>
<p>同时呢，对于一些特殊情况，比如说，开发过程当中或代码中出现了一些<code>catch</code>代码块，捕获住了异常，让程序不崩溃，这其实是不合理的，程序虽然没有崩溃，当时程序的功能已经变得不可用，所以呢，这些被<code>catch</code>的异常我们也需要上报上来，这样我们才能知道用户到底出现了什么问题而导致的异常。此外，线上还有一些单点问题，比如说用户点击登录一直进不去，这种就属于单点问题，其实我们是无法找出其和其它问题的共性之处的，所以呢，我们就必须要找到它对应的详细信息。</p>
<p>最后，如果发生了异常情况，我们还采取了一系列措施进行快速止损。</p>
<h3 id="如果发生了异常情况，怎么快速止损？"><a href="#如果发生了异常情况，怎么快速止损？" class="headerlink" title="如果发生了异常情况，怎么快速止损？"></a>如果发生了异常情况，怎么快速止损？</h3><p>参考答案：</p>
<ul>
<li>功能开关</li>
<li>统跳中心</li>
<li>动态修复：热修复、资源包更新</li>
<li>自主修复：安全模式</li>
</ul>
<p>首先，需要让<code>App</code>具备一些高级的能力，我们对于任何要上线的新功能，要加上一个功能的开关，通过配置中心下发的开关呢，来决定是否要显示新功能的入口。如果有异常情况，可以紧急关闭新功能的入口，那就可以让这个<code>App</code>处于可控的状态了。</p>
<p>然后，我们需要给<code>App</code>设立路由跳转，所有的界面跳转都需要通过路由来分发，如果我们匹配到需要跳转到有<code>bug</code>的这样一个新功能时，那我们就不跳转了，或者是跳转到统一的异常正处理中的界面。如果这两种方式都不可以，那就可以考虑通过热修复的方式来动态修复，目前热修复的方案其实已经比较成熟了，我们完全可以低成本地在我们的项目中添加热修复的能力，当然，如果有些功能是由<code>RN</code>或<code>WeeX</code>来实现就更好了，那就可以通过更新资源包的方式来实现动态更新。而这些如果都不可以的话呢，那就可以考虑自己去给应用加上一个自主修复的能力，如果<code>App</code>启动多次的话，那就可以考虑清空所有的缓存数据，将<code>App</code>重置到安装的状态，到了最严重的等级呢，可以阻塞主线程，此时一定要等<code>App</code>热修复成功之后才允许用户进入。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了<code>Android</code>稳定性的正确认识，如何处理<code>Crash</code>，<code>Crash</code>的长效治理，业务高可用方案建设等内容，给大家介绍了一些稳定性优化的思路与方案。<br>不过大部分内容其实还是理论性的，具体的稳定性优化，<code>Crash</code>治理还是依赖于具体问题的分析与修复，所以本文名为<strong>从入门到了解</strong><br>后续应该还会给大家带来稳定性优化之<code>ANR</code>处理，<code>OOM</code>处理等内容，敬请期待~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844903972587716621" target="_blank" rel="noopener">深入探索Android稳定性优化</a><br><a href="https://time.geekbang.org/column/article/70966" target="_blank" rel="noopener">Android开发高手课之崩溃优化</a><br><a href="https://coding.imooc.com/class/308.html" target="_blank" rel="noopener">国内Top团队大牛带你玩转Android性能分析与优化</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack Compose 中常见的性能问题</title>
    <url>/blog/2022/05/compose-general-performance.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Jetpack Compose</code>的应用也逐渐广泛起来，由于声明式<code>UI</code>的特点，<code>Compose</code>在开发的易用性方面有较大优势，但相信很多人对于<code>Compose</code>的性能问题有一些疑问。<br>这些问题有些是因为<code>Compose</code>还是个新生事物，不够成熟导致的，有些则是因为开发者的使用不当导致的。<br>本文主要介绍如何编写和配置应用程序以获得最佳性能，并指出了一些要避免的问题。        </p>
<h2 id="正确配置应用"><a href="#正确配置应用" class="headerlink" title="正确配置应用"></a>正确配置应用</h2><p>如果您的<code>Compose</code>应用性能不佳，则可能意味着存在配置问题。 首先应该检查以下配置项       </p>
<h3 id="使用Release模式构建并且使用R8"><a href="#使用Release模式构建并且使用R8" class="headerlink" title="使用Release模式构建并且使用R8"></a>使用<code>Release</code>模式构建并且使用<code>R8</code></h3><p>如果您发现性能问题，请确保尝试在<code>Release</code>模式下运行您的应用。<code>Debug</code>模式对于发现许多问题很有用，但它会带来显着的性能成本，并且很难发现可能影响性能的其他代码的问题。<br>同时您还应该使用 <code>R8</code> 编译器从您的应用程序中删除不必要的代码。 默认情况下，在<code>Release</code>模式下构建会自动使用 <code>R8</code> 编译器。</p>
<h3 id="使用baseline-profile"><a href="#使用baseline-profile" class="headerlink" title="使用baseline profile"></a>使用<code>baseline profile</code></h3><p><code>Compose</code> 作为一个单独的库分发，而不是作为 <code>Android</code> 平台的一部分。这种方法让我们可以经常更新 <code>Compose</code> 并支持较旧的 <code>Android</code> 版本。但是，将 <code>Compose</code> 作为库分发也会产生一定的成本。 <code>Android</code> 平台代码已编译并安装在设备上。另一方面，库需要在应用程序启动时加载，并在需要功能时及时解释(即<code>JIT</code>)。这可能会在启动时减慢应用程序的速度，并且每当它首次使用库功能时。</p>
<p>您可以通过定义<code>baseline profile</code>来提高性能。这些配置文件定义了用户主流程所需的类和方法，并与您应用的 <code>APK</code> 一起分发。在应用程序安装期间，<code>ART</code> 会提前编译该关键代码(即<code>AOT</code>)，以便在应用程序启动时准备好使用。</p>
<p>定义一个好的<code>baseline profile</code>并不总是那么容易，因此 <code>Compose</code> 默认附带一个。因此默认情况下你不需要做任何额外工作。<br>同时，如果您选择定义自己的配置文件，您可能会生成一个实际上不会提高应用程序性能的配置文件。您应该测试配置文件以验证它是否有帮助。一个很好的方法是为您的应用程序编写 <a href="https://developer.android.com/studio/profile/macrobenchmark-overview" target="_blank" rel="noopener">Macrobenchmark</a> 测试，并在您编写和修改<code>baseline profile</code>时检查测试结果。有关如何为 <code>Compose UI</code> 编写 <code>Macrobenchmark</code> 测试的示例，请参阅 <a href="https://github.com/android/performance-samples/tree/main/MacrobenchmarkSample" target="_blank" rel="noopener">Macrobenchmark Compose</a> 示例。</p>
<p>总得来说，使用<code>baseline profile</code>即通过<code>AOT</code>取代<code>JIT</code>，加快<code>Compose</code>首次运行的速度。<br>在默认情况下<code>Compose</code>已经自带了一个默认的<code>baseline profile</code>，你不需要做什么额外工作就可以支持。<br>但如果你要自定义<code>baseline profile</code>的话，需要做好测试用例，验证自定义的配置是否有效。       </p>
<p>自定义<code>baseline profile</code>比较麻烦，不过根据<code>Google I/O</code>上给出的数据，可以达到20%到30%的启动性能提升，大家可以根据情况决定是否使用<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/may/p1.jpg" alt>      </p>
<h2 id="关于Compose的一些最佳实践"><a href="#关于Compose的一些最佳实践" class="headerlink" title="关于Compose的一些最佳实践"></a>关于<code>Compose</code>的一些最佳实践</h2><p>在编写<code>Compose</code>代码时你可能会碰到一些常见的错误。这些错误不影响运行，但会损害您的 <code>UI</code> 性能。本节列出了一些最佳实践来帮助您避免它们。      </p>
<h3 id="使用remember减少计算"><a href="#使用remember减少计算" class="headerlink" title="使用remember减少计算"></a>使用<code>remember</code>减少计算</h3><p><code>Compose</code>函数可以非常频繁地运行，就像动画的每一帧一样频繁。 出于这个原因，你应该尽可能少地在<code>Compose</code>中做计算。<br>最常见的就是使用<code>remember</code>， 这样，计算只运行一次，并且可以在需要时获取结果。<br>例如，这里有一些代码显示排序的名称列表，其中排序操作比较耗时   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ContactList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    contacts: <span class="type">List</span>&lt;<span class="type">Contact</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    comparator: <span class="type">Comparator</span>&lt;<span class="type">Contact</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    LazyColumn(modifier) &#123;</span><br><span class="line">        <span class="comment">// DON’T DO THIS</span></span><br><span class="line">        items(contacts.sortedWith(comparator)) &#123; contact -&gt;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题在于，每次重组 <code>ContactsList</code> 时，整个联系人列表都会重新排序，即使列表没有更改。 如果用户滚动列表，只要出现新行，<code>Composable</code> 就会重新组合。<br>为了解决这个问题，在<code>LazyColumn</code> 之外对列表进行排序，并使用 <code>remember</code> 存储排序后的列表：      </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ContactList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    contacts: <span class="type">List</span>&lt;<span class="type">Contact</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    comparator: <span class="type">Comparator</span>&lt;<span class="type">Contact</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sortedContacts = remember(contacts, sortComparator) &#123;</span><br><span class="line">        contacts.sortedWith(sortComparator)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LazyColumn(modifier) &#123;</span><br><span class="line">        items(sortedContacts) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，当第一次组成 <code>ContactList</code> 时，列表被排序一次。 如果联系人或比较器更改，则重新生成排序列表。 否则，可组合项可以继续使用缓存的排序列表。<br>当然：如果可能，最好将计算完全移到<code>Compose</code>之外，比如<code>ViewModel</code>       </p>
<h3 id="Lazy-Layout使用Key"><a href="#Lazy-Layout使用Key" class="headerlink" title="Lazy Layout使用Key"></a><code>Lazy Layout</code>使用<code>Key</code></h3><p><code>Lazy Layout</code>使用智能重组，仅在必要时才会发生重组。 同时，我们可以帮助它做出最佳决策。<br>假设用户操作导致<code>item</code>在列表中移动。 例如，假设您显示按修改时间排序的笔记列表，最近修改的笔记在最上面。      </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">NotesList</span><span class="params">(notes: <span class="type">List</span>&lt;<span class="type">Note</span>&gt;)</span></span> &#123;</span><br><span class="line">    LazyColumn &#123;</span><br><span class="line">        items(</span><br><span class="line">            items = notes</span><br><span class="line">        ) &#123; note -&gt;</span><br><span class="line">            NoteRow(note)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过，这段代码存在一定的问题。 假设底部的<code>note</code>发生了变化。 它现在是最近修改的<code>note</code>，所以它应该排在列表的顶部，而其他每个<code>note</code>都向下移动一个位置。</p>
<p>这里的问题是，没有您的帮助，<code>Compose</code> 不会意识到未更改的项目只是在列表中移动。 相反，<code>Compose</code> 认为旧的“第 2 项”被删除并创建了一个新的，依此类推，第 3 项、第 4 项一直如此。 结果是，<code>Compose</code> 会重新组合列表中的每一项，即使其中只有一项实际发生了变化。</p>
<p>解决方案是提供<code>item key</code>。 为每个<code>item</code>提供一个稳定的<code>key</code>可以让 <code>Compose</code> 避免不必要的重组。 在这种情况下，<code>Compose</code> 可以看到现在位于第 3 项和<code>item</code>过去位于第 2 的<code>item</code>相同。由于该项目的数据都没有更改，因此 <code>Compose</code> 不必重新组合它。       </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">NotesList</span><span class="params">(notes: <span class="type">List</span>&lt;<span class="type">Note</span>&gt;)</span></span> &#123;</span><br><span class="line">    LazyColumn &#123;</span><br><span class="line">        items(</span><br><span class="line">            items = notes,</span><br><span class="line">             key = &#123; note -&gt;</span><br><span class="line">                <span class="comment">// Return a stable, unique key for the note</span></span><br><span class="line">                note.id</span><br><span class="line">            &#125;</span><br><span class="line">        ) &#123; note -&gt;</span><br><span class="line">            NoteRow(note)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-derivedStateOf-限制重组"><a href="#使用-derivedStateOf-限制重组" class="headerlink" title="使用 derivedStateOf 限制重组"></a>使用 <code>derivedStateOf</code> 限制重组</h3><p>在重组中使用状态的一个风险是，如果状态快速变化，你的 <code>UI</code> 可能会比你预期的发生更多的重组。<br>例如，假设您正在显示一个可滚动的列表。 您检查列表的状态以查看哪个<code>item</code>是列表中的第一个可见<code>item</code>：                   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listState = rememberLazyListState()</span><br><span class="line"></span><br><span class="line">LazyColumn(state = listState) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> showButton = listState.firstVisibleItemIndex &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">AnimatedVisibility(visible = showButton) &#123;</span><br><span class="line">    ScrollToTopButton()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的问题在于，如果用户滚动列表，<code>listState</code> 会随着用户拖动手指而不断变化。 这意味着该列表不断被重新组合，而<code>showButton</code>的结果也会被不断计算。<br>但是，您只有在<code>firstVisibleItemIndex</code>发生变化时才需要计算<code>showButton</code>。 所以，这里多了很多额外的计算，会影响您的<code>UI</code>性能     </p>
<p>解决方案是使用<code>derivedStateOf</code>。 <code>derivedStateOf</code>告诉<code>Compose</code>只有当我们关心的状态发生变化时，才需要重组。<br>在这种情况下，当<code>firstVisibleItemIndex</code>发生变化时才需要重组。但如果用户还没有滚动到足以将新<code>item</code>带到顶部的程度，则不需要重新组合。     </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listState = rememberLazyListState()</span><br><span class="line"></span><br><span class="line">LazyColumn(state = listState) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> showButton <span class="keyword">by</span> remember &#123;</span><br><span class="line">    derivedStateOf &#123;</span><br><span class="line">        listState.firstVisibleItemIndex &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AnimatedVisibility(visible = showButton) &#123;</span><br><span class="line">    ScrollToTopButton()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果把状态都放在<code>ViewModel</code>里，也就不用考虑这个了</p>
<h3 id="尽可能延迟读取State"><a href="#尽可能延迟读取State" class="headerlink" title="尽可能延迟读取State"></a>尽可能延迟读取<code>State</code></h3><p>您应该尽可能推迟读取<code>State</code>。 延迟读取<code>State</code>有助于确保 <code>Compose</code> 在重组时重新运行尽可能少的代码。 例如，如果您的 <code>UI</code> 具有在<code>composable</code>树中高高提升的状态，并且您在子<code>composable</code>中读取状态，则可以将读取的状态包装在 <code>lambda</code> 函数中。 这样做会使读取仅在实际需要时发生。 </p>
<p>我们来看一段<code>Jetsnack</code>在列表滚动时实现<code>Title</code>折叠展开的代码，为了达到这个效果，<code>Title composable</code>需要知道滚动偏移量，以便使用修饰符来偏移自己。 在进行优化之前，这是<code>Jetsnack</code>代码的简化版本：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SnackDetail</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    Box(Modifier.fillMaxSize()) &#123; <span class="comment">// Recomposition Scope Start</span></span><br><span class="line">        <span class="keyword">val</span> scroll = rememberScrollState(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Title(snack, scroll.value)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="comment">// Recomposition Scope End</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Title</span><span class="params">(snack: <span class="type">Snack</span>, scroll: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">val</span> offset = with(LocalDensity.current) &#123; scroll.toDp() &#125;</span><br><span class="line"></span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .offset(y = offset)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当滚动状态发生变化时，<code>Compose</code> 会寻找最近的父重组作用域并使其无效。 在这种情况下，最近的父级是可组合的是<code>Box</code>。 因此 <code>Compose</code> 重组了 <code>Box</code>，并且还重组了 <code>Box</code> 内的任何可组合项。     如果您将代码重构为仅读取您需要的<code>State</code>，那么您可以减少需要重组的元素数量。     </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SnackDetail</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    Box(Modifier.fillMaxSize()) &#123; <span class="comment">// Recomposition Scope Start</span></span><br><span class="line">        <span class="keyword">val</span> scroll = rememberScrollState(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Title(snack) &#123; scroll.value &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="comment">// Recomposition Scope End</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Title</span><span class="params">(snack: <span class="type">Snack</span>, scrollProvider: () -&gt; <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">val</span> offset = with(LocalDensity.current) &#123; scrollProvider().toDp() &#125;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .offset(y = offset)</span><br><span class="line">    ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滚动参数现在是一个 <code>lambda</code>。 这意味着 <code>Title</code> 仍然可以引用被提升的状态，但该值只能在 <code>Title</code> 内部读取，也就是实际需要的地方。 这样一来，当滚动值发生变化时，最近的重组范围现在是 <code>Title composable</code>，因此<code>Compose</code> 不再需要重组整个 <code>Box</code>。</p>
<p>这是一个很好的改进，但我们还可以做得更好。 因为我们所做的只是更改可组合标题的偏移量，这可以在布局阶段完成，而不必经过组合阶段。</p>
<h4 id="Compose的阶段"><a href="#Compose的阶段" class="headerlink" title="Compose的阶段"></a><code>Compose</code>的阶段</h4><p>与大多数其他界面工具包一样，<code>Compose</code> 会通过几个不同的“阶段”来渲染帧。如果我们观察一下 <code>Android View</code> 系统，就会发现它有 3 个主要阶段：测量、布局和绘制。<code>Compose</code> 和它非常相似，但开头多了一个叫做“组合”的重要阶段。</p>
<p><code>Compose</code> 有 3 个主要阶段：</p>
<ul>
<li>组合：要显示什么样的界面。<code>Compose</code> 运行可组合函数并创建界面说明。</li>
<li>布局：要放置界面的位置。该阶段包含两个步骤：测量和放置。对于布局树中的每个节点，布局元素都会根据 <code>2D</code> 坐标来测量并放置自己及其所有子元素。</li>
<li>绘制：渲染的方式。界面元素会绘制到画布（通常是设备屏幕）中。</li>
</ul>
<p><img src="https://developer.android.com/images/jetpack/compose/phases-3-phases.svg" alt></p>
<h4 id="优化状态读取"><a href="#优化状态读取" class="headerlink" title="优化状态读取"></a>优化状态读取</h4><p>知道了<code>Compose</code>的3个阶段，<code>Compose</code> 会执行局部状态读取跟踪，因此我们可以在适当阶段读取每个状态，从而尽可能降低需要执行的工作量<br>如果我们在布局阶段读取状态，就可以跳过组合阶段，如果我们在绘制阶段读取状态，就可以跳过组合和布局<br><img src="https://developer.android.com/images/jetpack/compose/phases-state-read-draw.svg" alt></p>
<p>因此我们可以将<code>offset</code>的读取推迟到布局阶段，这样可以避免组合阶段重新执行<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Title</span><span class="params">(snack: <span class="type">Snack</span>, scrollProvider: () -&gt; <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .offset &#123; IntOffset(y = scrollProvider()) &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之前代码使用了<code>Modifier.offset(x: Dp, y: Dp)</code>，它以偏移量为参数。 通过切换到修饰符的 <code>lambda</code> 版本，您可以确保函数在布局阶段读取滚动状态。 因此，当滚动状态发生变化时，<code>Compose</code> 可以完全跳过组合阶段，直接进入布局阶段。 当您将频繁更改的状态变量传递给<code>modifier</code>时，应尽可能使用<code>modifier</code>的 <code>lambda</code> 版本。</p>
<h4 id="绘制阶段读取状态的一个例子"><a href="#绘制阶段读取状态的一个例子" class="headerlink" title="绘制阶段读取状态的一个例子"></a>绘制阶段读取状态的一个例子</h4><p>上面我们看了一个在布局阶段读取状态的例子，下面来看一下绘制阶段读取状态的一个例子<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Here, assume animateColorBetween() is a function that swaps between</span></span><br><span class="line"><span class="comment">// two colors</span></span><br><span class="line"><span class="keyword">val</span> color <span class="keyword">by</span> animateColorBetween(Color.Cyan, Color.Magenta)</span><br><span class="line"></span><br><span class="line">Box(Modifier.fillMaxSize().background(color))</span><br></pre></td></tr></table></figure></p>
<p>这里盒子的背景颜色在两种颜色之间快速切换。 因此，这种状态变化非常频繁。 然后可组合项在背景<code>modifier</code>中读取此状态。 结果，盒子必须在每一帧上重新组合，因为每一帧的颜色都在变化。</p>
<p>为了改善这一点，我们可以使用基于 <code>lambda</code> 的<code>modifier</code>：在本例中为 <code>drawBehind</code>。这意味着仅在绘制阶段读取颜色状态。<br>因此，<code>Compose</code> 可以完全跳过组合和布局阶段，当颜色发生变化时，<code>Compose</code> 会直接进入绘制阶段。     </p>
<h3 id="避免反向写入"><a href="#避免反向写入" class="headerlink" title="避免反向写入"></a>避免反向写入</h3><p><code>Compose</code> 有一个核心假设，即您永远不会写入已读取的状态。 当你这样做时，它被称为反向写入，它会导致重组在每一帧上发生，无休止。<br>以下代码显示了此类错误的示例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun BadComposable() &#123;</span><br><span class="line">    var count by remember &#123; mutableStateOf(0) &#125;</span><br><span class="line"></span><br><span class="line">    // Causes recomposition on click</span><br><span class="line">    Button(onClick = &#123; count++ &#125;, Modifier.wrapContentSize()) &#123;</span><br><span class="line">        Text(&quot;Recompose&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Text(&quot;$count&quot;)</span><br><span class="line">    count++ // Backwards write, writing to state after it has been read</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在读取了状态之后在可组合项末尾的更新了状态。 如果您运行此代码，您会看到在单击导致重组的按钮后，随着 <code>Compose</code> 重组此 <code>Composable</code>，计数器会在无限循环中迅速增加，看到读取的状态已过期，因此会安排另一个重组 .</p>
<p>您可以通过从不在 <code>Composition</code> 中写入状态来完全避免向后写入。 如果可能，请始终响应事件来更新状态，并使用 <code>lambda</code> 表达式，就像前面的 <code>onClick</code> 示例一样。     </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍如何编写和配置<code>Compose</code>以获得最佳性能，并指出了一些要避免的问题。<br>想要了解更多的同学可参考<code>Google I/O</code>上相关的分享：<a href="https://io.google/2022/program/213421b6-9873-464f-9b36-38eeb232a854/intl/zh/" target="_blank" rel="noopener">Jetpack Compose 中常见的性能问题</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>【从入门到实用】Android卡顿优化深入解析</title>
    <url>/blog/2022/06/android-jank-optimize.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6973564044351373326" target="_blank" rel="noopener">卡顿、ANR、死锁，线上如何监控？</a>      </p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Baseline Profiles 优化启动性能</title>
    <url>/blog/2022/05/use-base-profile.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>应用的启动优化是<code>Android</code>性能优化中的一个常见问题，除了常规的一些优化手段，在本次<code>Google/IO</code>大会还介绍了通过<code>Baseline Profiles</code>来优化启动速度。<br>本文主要包括以下内容：     </p>
<ol>
<li><code>Baseline Profiles</code>是什么?</li>
<li>如何使用<code>Baseline Profiles</code>?</li>
<li>使用<code>Baseline Profiles</code>的效果怎么样?</li>
</ol>
<h2 id="Baseline-Profiles是什么"><a href="#Baseline-Profiles是什么" class="headerlink" title="Baseline Profiles是什么?"></a><code>Baseline Profiles</code>是什么?</h2><p><code>Android 9</code>在 <code>Play Cloud</code> 中引入了 <code>ART</code> 优化<code>Profiles</code>文件，以缩短应用启动时间。 平均而言，我们发现，当云<code>Profiles</code>文件可用时，应用程序的冷启动速度至少快 15%。</p>
<h3 id="Profiles文件如何工作"><a href="#Profiles文件如何工作" class="headerlink" title="Profiles文件如何工作?"></a><code>Profiles</code>文件如何工作?</h3><p>当应用程序在安装或更新后首次启动时，其代码在解释模式下运行(也就是<code>JIT</code>)。 在 <code>APK</code> 中，<code>Java</code> 和 <code>Kotlin</code> 代码被编译为 <code>dex</code> 字节码，但由于存储和加载完全编译的<code>App</code>的成本，并未完全编译为机器码。       应用程序中经常使用的类和方法，以及用于应用程序启动的类和方法，都记录在<code>Profiles</code>中。 一旦设备进入空闲模式，<code>ART</code> 就会根据这些<code>Profiles</code>编译应用程序。 这加快了后续应用程序的启动。</p>
<p>从 <code>Android 9</code>开始，<code>Google Play</code> 还提供 <code>Cloud Profiles</code>。 当应用在设备上运行时，由 <code>ART</code> 生成的配置文件由 <code>Play</code> 商店应用上传并在云端聚合。 一旦为应用程序上传了足够的配置文件，<code>Play</code> 应用程序就会使用汇总的配置文件进行后续安装。</p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>虽然<code>Cloud Profiles</code>在可用时很棒，但在安装应用程序时并不总是可以使用。 收集和汇总配置文件通常需要几天时间，如果你的<code>App</code>是每周更新时，就可能在<code>Cloud Profile</code>可用之前就发生更新了。 因此，<code>Google Android</code> 团队开始寻找其他方法来改善<code>Profiles</code>的延迟。     </p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>Baseline Profiles</code>是一种新的机制，可提供可在 <code>Android 7</code>及更高版本上使用的配置文件。 <code>Baseline Profiles</code>是由 <code>Android Gradle</code> 插件使用生成的 <code>ART</code> 配置文件，示例如下所示：   </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">HSPLandroidx/compose/runtime/ComposerImpl;-&gt;updateValue(Ljava/lang/Object;)V</span><br><span class="line">HSPLandroidx/compose/runtime/ComposerImpl;-&gt;updatedNodeCount(I)I</span><br><span class="line">HLandroidx/compose/runtime/ComposerImpl;-&gt;validateNodeExpected()V</span><br><span class="line">PLandroidx/compose/runtime/CompositionImpl;-&gt;applyChanges()V</span><br><span class="line">HLandroidx/compose/runtime/ComposerKt;-&gt;findLocation(Ljava/util/List;I)I</span><br></pre></td></tr></table></figure>
<p><code>Baseline Profiles</code>是在构建期间创建的，作为 <code>APK</code> 的一部分提供给 <code>Play Store</code>，然后在下载应用程序时从 <code>Play Store</code> 发送给用户。 当云配置文件尚不可用时，它们填补了 <code>ART</code> 云配置文件管道中的空白，并在它们可用时自动与云配置文件合并。</p>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/may/p7.png" alt></p>
<p><code>Baseline Profiles</code>的最大好处之一是它们可以在本地开发和测试，因此开发人员可以看到用户的实际体验。 同时从<code>Android 7</code>就已经支持了，而<code>Cloud Profiles</code>只支持<code>Android 9</code>以后的版本</p>
<h2 id="如何使用Baseline-Profiles"><a href="#如何使用Baseline-Profiles" class="headerlink" title="如何使用Baseline Profiles?"></a>如何使用<code>Baseline Profiles</code>?</h2><p>所有应用程序和库开发人员都可以从<code>Baseline Profiles</code>中受益。 理想情况下，开发人员为其最关键的用户路径创建配置文件，以确保这些关键路径具有始终如一的快速性能，无论云配置文件是否可用。<br>关于如何创建<code>Baseline Profiles</code>的详细步骤，可查看：<a href="https://developer.android.com/studio/profile/baselineprofiles#creating-profile-rules" target="_blank" rel="noopener">创建基准配置文件</a>   </p>
<p>在通过以上方式生成了配置文件之后，将生成的文件重命名为<code>baseline-prof.txt</code>，并将其复制到应用模块的 <code>src/main</code> 目录，就可以生效了</p>
<p>如果您现在还没有准备好为您的应用程序生成<code>Baseline Profiles</code>，您也可以通过更新依赖项来从中受益。 如果您使用<code>AGP 7.1.0-alpha05</code> 或更高版本进行构建，您将获得包含在您的 <code>APK</code> 中的<code>Baseline Profiles</code>，这些配置文件已经由库（例如 <code>Jetpack</code>）默认提供。 <code>Google Play</code> 在安装时使用这些配置文件编译您的应用程序。 </p>
<h2 id="使用Baseline-Profiles的效果怎么样"><a href="#使用Baseline-Profiles的效果怎么样" class="headerlink" title="使用Baseline Profiles的效果怎么样?"></a>使用<code>Baseline Profiles</code>的效果怎么样?</h2><p>第三方库的代码在默认情况下是没有完全编译的，如果它在启动的关键路径上做了大量工作，可能会带来一些性能问题。<br>比如<code>Jetpack Compose</code> 是一个 <code>UI</code> 库，它不是 <code>Android</code> 系统的一部分，因此在安装时并未完全编译，这与许多 <code>Android View</code> 工具包代码不同。这也是<code>Compose</code>在可能刚启动时比较慢的原因.<br>为了解决这个问题，<code>Compose</code> 默认提供了<code>Baseline Profiles</code>，可减少 <code>Compose</code> 应用程序的启动时间和卡顿。    </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2462df01870b4757a9fb1ba7f39f21d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p>
<p><code>Gogle</code>在<code>Google Map</code>与<code>Google Play</code>中都使用了<code>Baseline Profiles</code>，根据<code>Google I/O</code>上给出的数据，可以达到30%左右的启动性能提升</p>
<h3 id="测量性能提升"><a href="#测量性能提升" class="headerlink" title="测量性能提升"></a>测量性能提升</h3><p>由于<code>Jetpack</code>包和<code>Compose</code>都提供了默认的<code>Baseline Profiles</code>配置，因此你自定义的<code>Baseline Profiles</code>不一定会达到最佳效果，在自定义时必须也要编写相关性能测试用例   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStartupBenchmark</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> startupMode: StartupMode) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startupNoCompilation</span><span class="params">()</span></span> = startup(CompilationMode.None())</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startupBaselineProfileDisabled</span><span class="params">()</span></span> = startup(</span><br><span class="line">        CompilationMode.Partial(baselineProfileMode = Disable, warmupIterations = <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startupBaselineProfile</span><span class="params">()</span></span> = startup(CompilationMode.Partial(baselineProfileMode = Require))</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startupFullCompilation</span><span class="params">()</span></span> = startup(CompilationMode.Full())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，分别测试<code>CompilationMode.None</code>,<code>CompilationMode.Full</code>,<code>CompilationMode.Partial</code>等情况下的启动性能，根据结果分析是否需要自定义<code>Baseline Profiles</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<code>Baseline Profiles</code>，将应用启动时的关键路径相关代码提前进行编译，可以加快启动速度与首次加载速度。您可以更新到<code>AGP 7.1.0-alpha05</code> 或更高，来享受到<code>Jetpack</code>库提供的默认配置，也可以自定义<code>Baseline Profiles</code>，但是在自定义后需要通过<code>Macrobenchmark</code>库测量性能，以衡量自定义配置是否有效</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://io.google/2022/program/2cf473b7-113e-4332-a469-8dfd815eb45b/intl/zh/" target="_blank" rel="noopener">Google I/0 应用性能的新动态</a><br><a href="https://android-developers.googleblog.com/2022/01/improving-app-performance-with-baseline.html" target="_blank" rel="noopener">Improving App Performance with Baseline Profiles</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Transform 被废弃，ASM 如何适配?</title>
    <url>/blog/2022/06/gradle7-transform-learn.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Transform API</code> 是 <code>AGP1.5</code> 就引入的特性，主要用于在 <code>Android</code> 构建过程中，在 <code>Class</code>转<code>Dex</code>的过程中修改 <code>Class</code> 字节码。利用 <code>Transform API</code>，我们可以拿到所有参与构建的 <code>Class</code> 文件，然后可以借助<code>ASM</code> 等字节码编辑工具进行修改，插入自定义逻辑。    </p>
<p>国内很多团队都或多或少的用 <code>AGP</code> 的 <code>Transform API</code> 来搞点儿黑科技，比如无痕埋点，耗时统计，方法替换等。但是在<code>AGP7.0</code>中<code>Transform</code>已经被标记为废弃了，并且将在<code>AGP8.0</code>中移除。而<code>AGP8.0</code>应该会在今年内发布，可以说是已经近在眼前了。所以现在应该是时候了解一下，在<code>Transform</code>被废弃之后，该怎么适配了。</p>
<h2 id="Transform-Action介绍"><a href="#Transform-Action介绍" class="headerlink" title="Transform Action介绍"></a><code>Transform Action</code>介绍</h2><p><code>Transform API</code>是由<code>AGP</code>提供的，而<code>Transform Action</code>则是由<code>Gradle</code>提供。不光是 <code>AGP</code> 需要 <code>Transform</code>，<code>Java</code> 也需要，所以由 <code>Gradle</code> 来提供统一的 <code>Transform API</code> 也合情合理。<br>这应该也是<code>Transform API</code>被废弃的原因，既然<code>Gradle</code>已经统一提供了<code>API</code>，<code>AGP</code>也就没必要自定义一套了。   </p>
<p>关于 <code>TransformAction</code> 如何使用，<code>Gradle</code> 官方已经提供了很详细的文档–<a href="https://docs.gradle.org/current/userguide/artifact_transforms.html" target="_blank" rel="noopener">Transforming dependency artifacts on resolution</a>，具体使用可以直接参考文档</p>
<h2 id="AsmClassVisitorFactory介绍"><a href="#AsmClassVisitorFactory介绍" class="headerlink" title="AsmClassVisitorFactory介绍"></a><code>AsmClassVisitorFactory</code>介绍</h2><p>直接使用<code>Transform Action</code>的话还是有些麻烦，跟<code>Transform API</code>一样，需要手动处理增量编译的逻辑。<code>AGP</code>很贴心的为我们又做了一层封装，提供了<code>AsmClassVisitorFactory</code>来方便我们使用<code>Transform Action</code>进行<code>ASM</code>操作。<br>根据官方的说法，<code>AsmClassVisitoFactory</code>会带来约18%的性能提升，同时可以减少约5倍代码       </p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44e2f3d80f7847c1803c90f66a8c2bb5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt>     </p>
<h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><p>接下来我们利用<code>AGP</code> 的<code>AsmClassVisitorFactory API</code>,来实现方法执行耗时的插桩。     </p>
<h3 id="实现AsmClassVisitorFactory"><a href="#实现AsmClassVisitorFactory" class="headerlink" title="实现AsmClassVisitorFactory"></a>实现<code>AsmClassVisitorFactory</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeCostTransform</span>: <span class="type">AsmClassVisitorFactory</span>&lt;<span class="type">InstrumentationParameters.None</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createClassVisitor</span><span class="params">(classContext: <span class="type">ClassContext</span>, nextClassVisitor: <span class="type">ClassVisitor</span>)</span></span>: ClassVisitor &#123;</span><br><span class="line">        <span class="keyword">return</span> TimeCostClassVisitor(nextClassVisitor)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInstrumentable</span><span class="params">(classData: <span class="type">ClassData</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>AsmClassVisitorFactory</code>即创建<code>ClassVisitor</code>对象的工厂。此接口的实现必须是一个抽象类，</li>
<li><code>createClassVisitor</code>返回我们自定义的<code>ClassVisitor</code>，在自定义<code>Visitor</code>处理完成后，需要传内容传递给下一个<code>Visitor</code>，因此我们将其放在构造函数中传入      </li>
<li><code>isInstrumentable</code>用于控制我们的自定义<code>Visitor</code>是否需要处理这个类，通过这个方法可以过滤我们不需要的类，加快编译速度</li>
</ol>
<h3 id="自定义ClassVisitor"><a href="#自定义ClassVisitor" class="headerlink" title="自定义ClassVisitor"></a>自定义<code>ClassVisitor</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeCostClassVisitor</span></span>(nextVisitor: ClassVisitor) : ClassVisitor(Opcodes.ASM5, nextVisitor) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        access: <span class="type">Int</span>, name: <span class="type">String</span>?, descriptor: <span class="type">String</span>?, signature: <span class="type">String</span>?, exceptions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: MethodVisitor &#123;</span><br><span class="line">        <span class="keyword">val</span> methodVisitor = <span class="keyword">super</span>.visitMethod(access, name, descriptor, signature, exceptions)</span><br><span class="line">        <span class="keyword">val</span> newMethodVisitor =</span><br><span class="line">            <span class="keyword">object</span> : AdviceAdapter(Opcodes.ASM5, methodVisitor, access, name, descriptor) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodEnter</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 方法开始</span></span><br><span class="line">                    <span class="keyword">if</span> (isNeedVisiMethod(name)) &#123;</span><br><span class="line">                        mv.visitLdcInsn(name);</span><br><span class="line">                        mv.visitMethodInsn(</span><br><span class="line">                            INVOKESTATIC, <span class="string">"com/zj/android_asm/TimeCache"</span>, <span class="string">"putStartTime"</span>,<span class="string">"(Ljava/lang/String;)V"</span>, <span class="literal">false</span></span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">super</span>.onMethodEnter();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodExit</span><span class="params">(opcode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 方法结束</span></span><br><span class="line">                    <span class="keyword">if</span> (isNeedVisiMethod(name)) &#123;</span><br><span class="line">                        mv.visitLdcInsn(name);</span><br><span class="line">                        mv.visitMethodInsn(</span><br><span class="line">                            INVOKESTATIC, <span class="string">"com/zj/android_asm/TimeCache"</span>, <span class="string">"putEndTime"</span>,<span class="string">"(Ljava/lang/String;)V"</span>, <span class="literal">false</span></span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">super</span>.onMethodExit(opcode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> newMethodVisitor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isNeedVisiMethod</span><span class="params">(name: <span class="type">String</span>?)</span></span>:<span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="string">"putStartTime"</span> &amp;&amp; name != <span class="string">"putEndTime"</span> &amp;&amp; name != <span class="string">"&lt;clinit&gt;"</span> &amp;&amp; name != <span class="string">"printlnTime"</span> &amp;&amp; name != <span class="string">"&lt;init&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就跟普通的<code>ASM</code>操作没什么不同了，主要是通过<code>ASM</code>字节码插桩，在方法的前后插入如下代码，通过计算两者的时间差来得出方法的耗时</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">timeMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TimeCache.putStartTime(<span class="string">"timeMethod"</span>) <span class="comment">//方法开始插入的代码</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    TimeCache.putEndTime(<span class="string">"timeMethod"</span>) <span class="comment">//方法结束插入的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册Transform"><a href="#注册Transform" class="headerlink" title="注册Transform"></a>注册<code>Transform</code></h3><p>老版本的<code>Transform</code>是注册在<code>AppExtension</code>中的，新版本则是注册在<code>AndroidComponentsExtension</code>中      </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeCostPlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> androidComponents = project.extensions.getByType(AndroidComponentsExtension::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        androidComponents.onVariants &#123; variant -&gt;</span><br><span class="line">            variant.instrumentation.transformClassesWith(TimeCostTransform::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">                    InstrumentationScope.PROJECT) &#123;&#125;</span><br><span class="line">            variant.instrumentation.setAsmFramesComputationMode(</span><br><span class="line">                    FramesComputationMode.COMPUTE_FRAMES_FOR_INSTRUMENTED_METHODS</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>基于<code>variant</code>可实现不同的变种不同的处理逻辑    </li>
<li><code>transformClassesWith</code>通过<code>InstrumentationScope</code>控制是否需要扫描依赖库代码   </li>
<li><code>setAsmFramesComputationMode</code>可设置不同的栈帧计算模式，具体可查看源码</li>
</ol>
<h3 id="AsmClassVisitorFactory的优势"><a href="#AsmClassVisitorFactory的优势" class="headerlink" title="AsmClassVisitorFactory的优势"></a><code>AsmClassVisitorFactory</code>的优势</h3><p>通过以上步骤，一个简单的通过插桩计算方法执行耗时的功能就完成了，这比起老版的<code>Transform API</code>其实简化了不少，老版本处理增量更新就需要处理一大堆的逻辑。<br>可以看到我们这里并没有手动处理增量逻辑，这是因为调用<code>AsmClassVisitorFactory</code>的<code>TransformClassesWithAsmTask</code>继承自<code>NewIncrementalTask</code>，已经处理了增量逻辑，不需要我们再手动处理了</p>
<p>同时老版本的<code>Transform</code>每个<code>Transfrom</code>各自独立，如果每个<code>Transform</code>编译构建耗时<code>+10s</code>，各个<code>Transform</code>叠在一起，编译耗时就会呈线性增长<br>而新版本可以看出我们也没有手动进行<code>IO</code>操作，这是因为<code>AsmInstrumentationManager</code>中已经做了统一处理，只需要进行一次<code>IO</code>操作，然后交给<code>ClassVisitor</code>链表处理，完成后统一交给<code>ClassWriter</code>写入<br>通过这种方式，可以有效地减少<code>IO</code>操作，这也是新版本<code>API</code>性能提升的原因</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得来说，由于<code>Transform API</code>在<code>AGP7.0</code>已标记为废弃，并且将在<code>AGP8.0</code>中移除，是时候了解一下如何迁移<code>Transform API</code>了              </p>
<p>而<code>AsmClassVisitorFactory</code>相比<code>Transform API</code>，使用起来更加简单，不需要手动处理增量逻辑，可以专注于字节码插桩操作。同时<code>AsmClassVisitorFactory</code>通过减少<code>IO</code>的方式，可以得到约20%的性能提升，加快编译速度。 </p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有源码可见：<a href="https://github.com/shenzhen2017/Android-ASM" target="_blank" rel="noopener">https://github.com/shenzhen2017/Android-ASM</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/7098752199575994405" target="_blank" rel="noopener">其实 Gradle Transform 就是个纸老虎 —— Gradle 系列(4)</a><br><a href="https://juejin.cn/post/7016147287889936397" target="_blank" rel="noopener">现在准备好告别Transform了吗？ | 拥抱AGP7.0</a>     </p>
]]></content>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>ASM 插桩采集方法入参，出参及耗时信息</title>
    <url>/blog/2022/06/asm-method-record.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ASM</code>字节码插桩技术在<code>Android</code>开发中有着广泛的应用，但相信很多人会不知道怎么上手，不知道该拿<code>ASM</code>来做点什么。       </p>
<p>学习一门技术最好的方法就是动手实践，本文主要通过<code>ASM</code>插桩采集方法的入参，出参及耗时信息并打印，通过一个不大不小的例子快速上手<code>ASM</code>插桩开发。       </p>
<h2 id="技术目标"><a href="#技术目标" class="headerlink" title="技术目标"></a>技术目标</h2><p>我们先看下最终的效果</p>
<h3 id="插桩前代码"><a href="#插桩前代码" class="headerlink" title="插桩前代码"></a>插桩前代码</h3><p>首先来看下插桩前代码，就是一个<code>sum</code>方法         </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插桩后代码"><a href="#插桩后代码" class="headerlink" title="插桩后代码"></a>插桩后代码</h3><p>接下来看下插桩后的代码       </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(Integer.valueOf(i));</span><br><span class="line">    arrayList.add(Integer.valueOf(j));</span><br><span class="line">    MethodRecorder.onMethodEnter(<span class="string">"com.zj.android_asm.MainActivity"</span>, <span class="string">"sum"</span>, arrayList);</span><br><span class="line">    <span class="keyword">int</span> i2 = i + j;</span><br><span class="line">    MethodRecorder.onMethodExit(Integer.valueOf(i2), <span class="string">"com.zj.android_asm.MainActivity"</span>, <span class="string">"sum"</span>, <span class="string">"I,I"</span>, <span class="string">"I"</span>);</span><br><span class="line">    <span class="keyword">return</span> i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，方法所有参数都被添加到了一个<code>arrayList</code>中，并且调用了<code>MethodRecorder.onMethodEnter</code>方法<br>而在结果返回之前，则会调用<code>MethodRecorder.onMethodExit</code>方法，并将返回值，参数类型，返回值类型等作为参数传递过支。     </p>
<h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>在调用了<code>onMethodExit</code>之后，会计算出方法耗时并输出日志，如下所示<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">类名：<span class="selector-tag">com</span><span class="selector-class">.zj</span><span class="selector-class">.android_asm</span><span class="selector-class">.MainActivity</span> </span><br><span class="line">方法名：<span class="selector-tag">sum</span> </span><br><span class="line">参数类型：<span class="selector-attr">[I,I]</span> </span><br><span class="line">入参：<span class="selector-attr">[1,2]</span> </span><br><span class="line">返回类型：<span class="selector-tag">I</span> </span><br><span class="line">返回值：3 </span><br><span class="line">耗时：0 <span class="selector-tag">ms</span></span><br></pre></td></tr></table></figure></p>
<h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><p>上面我们介绍了最后要实现的效果，下面就来看下怎么一步一步实现，主要分为以下3步：    </p>
<ol>
<li>在方法开始时采集方法参数</li>
<li>在方法结束时采集返回值</li>
<li>调用帮助类计算耗时及打印结果</li>
</ol>
<h3 id="ASM采集方法参数"><a href="#ASM采集方法参数" class="headerlink" title="ASM采集方法参数"></a><code>ASM</code>采集方法参数</h3><p>采集方法参数的方法也很简单，主要就是读取出所有参数的值并存储在一个<code>List</code>中，主要问题在于我们需要用字节码来实现这些逻辑.   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodEnter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 方法开始</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedVisiMethod() &amp;&amp; descriptor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> parametersIdentifier = MethodRecordUtil.newParameterArrayList(mv, <span class="keyword">this</span>)   <span class="comment">//1. new一个List</span></span><br><span class="line">        MethodRecordUtil.fillParameterArray(methodDesc, mv, parametersIdentifier, access) <span class="comment">//2. 填充列表</span></span><br><span class="line">		MethodRecordUtil.onMethodEnter(mv, className, name, parametersIdentifier) <span class="comment">//3. 调用帮助类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onMethodEnter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，采集方法参数也分为3步，接下来我来一步步看下代码    </p>
<h4 id="ASM创建列表"><a href="#ASM创建列表" class="headerlink" title="ASM创建列表"></a><code>ASM</code>创建列表</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newParameterArrayList</span><span class="params">(mv: <span class="type">MethodVisitor</span>, localVariablesSorter: <span class="type">LocalVariablesSorter</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">	<span class="comment">// new一个ArrayList</span></span><br><span class="line">    mv.visitTypeInsn(AdviceAdapter.NEW, <span class="string">"java/util/ArrayList"</span>)</span><br><span class="line">    mv.visitInsn(AdviceAdapter.DUP)</span><br><span class="line">    mv.visitMethodInsn(</span><br><span class="line">        AdviceAdapter.INVOKESPECIAL,</span><br><span class="line">        <span class="string">"java/util/ArrayList"</span>,</span><br><span class="line">        <span class="string">"&lt;init&gt;"</span>,</span><br><span class="line">        <span class="string">"()V"</span>,</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 存储new出来的List</span></span><br><span class="line">    <span class="keyword">val</span> parametersIdentifier = localVariablesSorter.newLocal(Type.getType(List::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">    mv.visitVarInsn(AdviceAdapter.ASTORE, parametersIdentifier)</span><br><span class="line">    <span class="comment">// 返回parametersIdentifier，方便后续访问这个列表</span></span><br><span class="line">    <span class="keyword">return</span> parametersIdentifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑其实很简单，主要问题在于需要用<code>ASM</code>代码写，需要掌握一些字节码指令相关知识。不过我们也可以用<a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline" target="_blank" rel="noopener">asm-bytecode-outline</a>来自动生成这段代码，这样难度可以降低不少。关于代码中各个指令的具体含义，可查阅<a href="https://blog.csdn.net/qq_33589510/article/details/105285250" target="_blank" rel="noopener">Java虚拟机(JVM)字节码指令表</a>       </p>
<h4 id="ASM填充列表"><a href="#ASM填充列表" class="headerlink" title="ASM填充列表"></a><code>ASM</code>填充列表</h4><p>接下来要做的就是读出所有的参数并填充到上面创建的列表中<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fillParameterArray</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    methodDesc: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    mv: <span class="type">MethodVisitor</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    parametersIdentifier: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    access: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 判断是不是静态函数</span></span><br><span class="line">    <span class="keyword">val</span> isStatic = (access and Opcodes.ACC_STATIC) != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 静态函数与普通函数的cursor不同</span></span><br><span class="line">    <span class="keyword">var</span> cursor = <span class="keyword">if</span> (isStatic) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> methodType = Type.getMethodType(methodDesc)</span><br><span class="line">    <span class="comment">// 获取参数列表</span></span><br><span class="line">    methodType.argumentTypes.forEach &#123;</span><br><span class="line">    	<span class="comment">// 读取列表</span></span><br><span class="line">        mv.visitVarInsn(AdviceAdapter.ALOAD, parametersIdentifier)</span><br><span class="line">        <span class="comment">// 根据不同类型获取不同的指令，比如int是iload, long是lload</span></span><br><span class="line">        <span class="keyword">val</span> opcode = it.getOpcode(Opcodes.ILOAD)</span><br><span class="line">        <span class="comment">// 通过指令与cursor读取参数的值</span></span><br><span class="line">        mv.visitVarInsn(opcode, cursor)</span><br><span class="line">        <span class="keyword">if</span> (it.sort &gt;= Type.BOOLEAN &amp;&amp; it.sort &lt;= Type.DOUBLE) &#123;</span><br><span class="line">        	<span class="comment">// 基本类型转换为包装类型</span></span><br><span class="line">            typeCastToObject(mv, it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新cursor</span></span><br><span class="line">        cursor += it.size</span><br><span class="line">        <span class="comment">// 添加到列表中</span></span><br><span class="line">        mv.visitMethodInsn(</span><br><span class="line">            AdviceAdapter.INVOKEINTERFACE,</span><br><span class="line">            <span class="string">"java/util/List"</span>,</span><br><span class="line">            <span class="string">"add"</span>,</span><br><span class="line">            <span class="string">"(Ljava/lang/Object;)Z"</span>,</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line">        mv.visitInsn(AdviceAdapter.POP)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要代码如上所示，代码中都有注释，主要需要注意以下几点:    </p>
<ol>
<li>静态函数与普通函数的初始<code>cursor</code>不同，因此需要区分开来    </li>
<li>不同类型的参数加载的指令也不同，因此需要通过<code>Type.getOpcode</code>获取具体指令       </li>
<li>为了将参数放在一个列表中，需要将基本类型转换为包装类型，比如<code>int</code>转换为<code>Integer</code>        </li>
</ol>
<h4 id="ASM调用帮助类"><a href="#ASM调用帮助类" class="headerlink" title="ASM调用帮助类"></a><code>ASM</code>调用帮助类</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onMethodEnter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    mv: <span class="type">MethodVisitor</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    className: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    parametersIdentifier: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    mv.visitLdcInsn(className)</span><br><span class="line">    mv.visitLdcInsn(name)</span><br><span class="line">    mv.visitVarInsn(AdviceAdapter.ALOAD, parametersIdentifier)</span><br><span class="line">    mv.visitMethodInsn(</span><br><span class="line">        AdviceAdapter.INVOKESTATIC, <span class="string">"com/zj/android_asm/MethodRecorder"</span>, <span class="string">"onMethodEnter"</span>,</span><br><span class="line">        <span class="string">"(Ljava/lang/String;Ljava/lang/String;Ljava/util/List;)V"</span>, <span class="literal">false</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个比较简单，主要就是通过<code>ASM</code>调用<code>MethodRecorder.onMethodEnter</code>方法</p>
<h3 id="ASM采集返回值"><a href="#ASM采集返回值" class="headerlink" title="ASM采集返回值"></a><code>ASM</code>采集返回值</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodExit</span><span class="params">(opcode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 方法结束</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedVisiMethod()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((opcode <span class="keyword">in</span> IRETURN..RETURN) || opcode == ATHROW) &#123;</span><br><span class="line">            <span class="keyword">when</span> (opcode) &#123;</span><br><span class="line">            	<span class="comment">// 基本类型返回</span></span><br><span class="line">                <span class="keyword">in</span> IRETURN..DRETURN -&gt; &#123;</span><br><span class="line">                	<span class="comment">// 读取返回值</span></span><br><span class="line">                    MethodRecordUtil.loadReturnData(mv, methodDesc)</span><br><span class="line">                    MethodRecordUtil.onMethodExit(mv, className, name, methodDesc)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对象返回</span></span><br><span class="line">                ARETURN -&gt; &#123;</span><br><span class="line">                	<span class="comment">// 读取返回值</span></span><br><span class="line">                    mv.visitInsn(DUP)</span><br><span class="line">                    MethodRecordUtil.onMethodExit(mv, className, name, methodDesc)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 空返回</span></span><br><span class="line">                RETURN -&gt; &#123;</span><br><span class="line">                    mv.visitLdcInsn(<span class="string">"void"</span>)</span><br><span class="line">                    MethodRecordUtil.onMethodExit(mv, className, name, methodDesc)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onMethodExit(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采集返回值的逻辑也很简单，主要分为以下几步    </p>
<ol>
<li>判断当前指令，并且根据不同类型的返回添加不同的逻辑       </li>
<li>通过<code>DUP</code>指令复制栈顶数值并将复制值压入栈顶，以读取返回值    </li>
<li>读取方法参数类型与返回值类型，并调用<code>MethodRecorder.onMexthodExit</code>方法</li>
</ol>
<h3 id="帮助类实现"><a href="#帮助类实现" class="headerlink" title="帮助类实现"></a>帮助类实现</h3><p>由于<code>ASM</code>需要直接操作字节码，写起来终究不太方便，因此我们尽可能把代码转移到帮助类中，然后通过在<code>ASM</code>中调用帮助类来简化开发，帮助类的代码如下所示：   </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> MethodRecorder &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mMethodRecordMap = HashMap&lt;String, MethodRecordItem&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onMethodEnter</span><span class="params">(className: <span class="type">String</span>, methodName: <span class="type">String</span>, parameterList: <span class="type">List</span>&lt;<span class="type">Any</span>?&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> key = <span class="string">"<span class="subst">$&#123;className&#125;</span>,<span class="subst">$&#123;methodName&#125;</span>"</span></span><br><span class="line">        <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> list = parameterList?.filterNotNull() ?: emptyList()</span><br><span class="line">        mMethodRecordMap[key] = MethodRecordItem(startTime, list)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onMethodExit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        response: <span class="type">Any</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        className: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        methodName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        parameterTypes: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        returnType: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> key = <span class="string">"<span class="subst">$&#123;className&#125;</span>,<span class="subst">$&#123;methodName&#125;</span>"</span></span><br><span class="line">        mMethodRecordMap[key]?.let &#123;</span><br><span class="line">            <span class="keyword">val</span> parameters = it.parameterList.joinToString(<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">val</span> duration = System.currentTimeMillis() - it.startTime</span><br><span class="line">            <span class="keyword">val</span> result = <span class="string">"类名：<span class="variable">$className</span> \n方法名：<span class="variable">$methodName</span> \n参数类型：[<span class="variable">$parameterTypes</span>] \n入参：[<span class="variable">$parameters</span>] \n返回类型：<span class="variable">$returnType</span> \n返回值：<span class="variable">$response</span> \n耗时：<span class="variable">$duration</span> ms \n"</span></span><br><span class="line">            Log.i(<span class="string">"methodRecord"</span>, result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码其实也很简单，主要逻辑如下：   </p>
<ol>
<li>方法开始时调用<code>onMethodEnter</code>方法，传入参数列表，并记录下方法开始时间          </li>
<li>方法结束时调用<code>onMethodExit</code>方法，传入返回值，计算方法耗时并打印结果</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述步骤，我们就把<code>ASM</code>插桩实现记录方法入参，返回值以及方法耗时的功能完成了，通过插桩可以在方法执行的时候输出我们需要的信息。而这些信息的价值就是可以很好的让我们做一些程序的全链路监控以及工程质量验证。  </p>
<p>总得来说，逻辑上其实并不复杂，主要问题可能在于需要熟悉如何直接操作字节码，我们可以通过<a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline" target="_blank" rel="noopener">asm-bytecode-outline</a>等工具自动生成代码来简化开发，同时也可以通过尽量把逻辑迁移到帮助类中的方式来减少直接操作字节码的工作。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有源码可见：<a href="https://github.com/shenzhen2017/Android-ASM" target="_blank" rel="noopener">https://github.com/shenzhen2017/Android-ASM</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/qq_33589510/article/details/105285250" target="_blank" rel="noopener">Java虚拟机(JVM)字节码指令表</a><br><a href="https://bugstack.cn/md/bytecode/asm/2020-04-05-%5BASM%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B%5DJavaAgent+ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9%E9%87%87%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E4%BB%A5%E5%8F%8A%E5%85%A5%E5%8F%82%E5%92%8C%E5%87%BA%E5%8F%82%E7%BB%93%E6%9E%9C%E5%B9%B6%E8%AE%B0%E5%BD%95%E6%96%B9%E6%B3%95%E8%80%97%E6%97%B6.html#_4-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C" target="_blank" rel="noopener">ASM字节码编程 | JavaAgent+ASM字节码插桩采集方法名称以及入参和出参结果并记录方法耗时</a><br><a href="https://blog.51cto.com/lsieun/2955738" target="_blank" rel="noopener">Java ASM系列：（025）修改已有的方法（添加－进入和退出－打印方法参数和返回值）</a>            </p>
]]></content>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Android Apk 编译打包流程，了解一下~</title>
    <url>/blog/2022/06/how-apk-compile.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个<code>Android</code>开发，每天都会有相当一部分的时间花在编译打包上，如果项目比较大的话编译一次可能就要十几分钟。        </p>
<p>那么在编译打包的过程中<code>AGP</code>到底做了什么？为什么编译那么耗时，又该怎么优化？要解决这些问题，首先就需要我们对编译打包的流程有个总体的了解</p>
<p>本文主要包括以下内容    </p>
<ol>
<li>编译打包总体流程</li>
<li>编译打包主要步骤</li>
<li>编译打包过程中的<code>Task</code></li>
</ol>
<h2 id="编译打包总体流程"><a href="#编译打包总体流程" class="headerlink" title="编译打包总体流程"></a>编译打包总体流程</h2><p>首先看下<code>Android</code>官网给出的编译打包总体流程</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/679fae0479294940bcb9f136ebc5e7af~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
<p>典型 <code>Android</code> 应用的构建流程如图所示，主要分为以下几步：       </p>
<ol>
<li>编译器将您的源代码转换成 <code>DEX</code> 文件（<code>Dalvik</code> 可执行文件，其中包括在 <code>Android</code> 设备上运行的字节码），并将其他所有内容转换成编译后的资源。</li>
<li>打包器将 <code>DEX</code> 文件和编译后的资源组合成 <code>APK</code> 或 <code>AAB</code>（具体取决于所选的 <code>build</code> 目标）。 </li>
<li>打包器使用调试或发布密钥库为 <code>APK</code> 或 <code>AAB</code> 签名。</li>
<li>在生成最终 <code>APK</code> 之前，打包器会使用 <code>zipalign</code> 工具对应用进行优化，以减少其在设备上运行时所占用的内存</li>
</ol>
<h2 id="编译打包主要步骤"><a href="#编译打包主要步骤" class="headerlink" title="编译打包主要步骤"></a>编译打包主要步骤</h2><p>关于<code>Android</code>编译打包还有一张更加复杂的图</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23a4a87024042bcaaa226eee7ebbf57~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
<p>这个看起来是相当复杂的，但其实我们也可以把这些步骤做一个分类，跟总体流程的四个步骤做一个对应</p>
<h3 id="资源与代码编译"><a href="#资源与代码编译" class="headerlink" title="资源与代码编译"></a>资源与代码编译</h3><h4 id="资源文件编译"><a href="#资源文件编译" class="headerlink" title="资源文件编译"></a>资源文件编译</h4><p><code>apk</code>资源包含:     </p>
<ul>
<li>工程中<code>res</code>目录下的所有文件</li>
<li><code>assets</code>目录下的文件</li>
<li><code>AndroidManifest.xml</code></li>
</ul>
<p><code>apk</code>的资源编译是编译过程中的一项主要工作，<code>AGP3.0.0</code>之后默认通过<code>AAPT2</code>来编译资源。     </p>
<p><code>AAPT2</code>（<code>Android Asset Packaging Tool2</code>）是一种构建工具，<code>Android Studio</code> 和 <code>Android Gradle</code> 插件使用它来编译和打包应用的资源。<code>AAPT2</code> 会解析资源、为资源编制索引，并将资源编译为针对 <code>Android</code>平台进行过优化的二进制格式。</p>
<h5 id="AAPT2做了什么优化"><a href="#AAPT2做了什么优化" class="headerlink" title="AAPT2做了什么优化?"></a><code>AAPT2</code>做了什么优化?</h5><p>为什么<code>AGP3.0.0</code>之后默认通过<code>AAPT2</code>来编译资源呢？它又做了什么优化呢?     </p>
<p><code>AAPT2</code> 支持通过启用增量编译实现更快的资源编译。这是通过将资源处理拆分为两个步骤来实现的：     </p>
<ul>
<li><p>1、编译：将资源文件编译为二进制格式。<br>把所有的<code>Android</code>资源文件进行解析，生成扩展名为<code>.flat</code>的二进制文件。比如是<code>png</code>图片，那么就会被压缩处理，采用<code>.png.flat</code>的扩展名。可以在<code>build/intermediates/merged_res/</code>文件下查看生成的中间产物</p>
</li>
<li><p>2、链接：合并所有已编译的文件并将它们打包到一个软件包中。<br>首先，这一步会生成辅助文件，比如<code>R.java</code>与<code>resources.arsc</code>，<code>R</code>文件大家应该都比较熟悉，就是一个资源索引文件，我们平时引用也都是通过<code>R.</code>的方式引用资源<code>id</code>。而<code>resources.arsc</code>则是资源索引表，供在程序运行时根据id索引到具体的资源<br>最后，会将<code>R</code>文件，<code>ressources.arsc</code>文件和之前的二进制文件进行打包，打包到一个软件包中。       </p>
</li>
</ul>
<p><strong>这种拆分方式有助于提高增量编译的性能</strong>。例如，如果某个文件中有更改，您只需要重新编译该文件。</p>
<h4 id="AIDL文件编译"><a href="#AIDL文件编译" class="headerlink" title="AIDL文件编译"></a><code>AIDL</code>文件编译</h4><p>对于<code>AIDL</code>，大家应该都很熟悉，它是一种用于进程间通信的接口文件。</p>
<p>其实它是<code>Google</code>为了帮助我们进行进程间通信的简便写法，最后还是需要被解析编译为<code>java</code>文件，而做这个工作的就是<code>aidl</code>工具，存在于<code>sdk/build-tools</code>目录。</p>
<p><strong>这个阶段的主要的工作就是将项目中的<code>aidl</code>文件编译为<code>java</code>文件</strong>。</p>
<h4 id="Java与Kotlin文件编译"><a href="#Java与Kotlin文件编译" class="headerlink" title="Java与Kotlin文件编译"></a><code>Java</code>与<code>Kotlin</code>文件编译</h4><ul>
<li>通过<code>Java Compiler</code> 编译项目中所有的<code>Java</code>代码，包括<code>R.java</code>、<code>.aidl</code>文件生成的<code>.java</code>文件、<code>Java</code>源文件，生成<code>.class</code>文件。在对应的<code>build</code>目录下可以找到相关的代码</li>
<li>通过<code>Kotlin Compiler</code>编译项目中的所有<code>Kotlin</code>代码，生成<code>.class文件</code></li>
</ul>
<p>注解处理器(<code>APT</code>,<code>KAPT</code>)生成代码也是在这个阶段生成的。当注解的生命周期被设置为<code>CLASS</code>的时候，就代表该注解会在编译<code>class</code>文件的时候生效，并且生成<code>java</code>源文件和<code>Class</code>字节码文件。</p>
<h4 id="Class文件打包成DEX"><a href="#Class文件打包成DEX" class="headerlink" title="Class文件打包成DEX"></a><code>Class</code>文件打包成<code>DEX</code></h4><p>这一步就是将<code>.class</code>文件打包成<code>dex</code>文件。</p>
<p>有人可能会奇怪了，<code>.class</code>文件不就是<code>JVM</code>可以识别的二进制文件吗，为什么还要进行一次转化呢？</p>
<p>这就涉及到另一个问题：<code>JVM</code> 和 <code>Dalvik（ART</code> 的区别。</p>
<p>其中一个重要的区别就是<code>Dalvik（ART）</code>有自己的二进制文件，也就是<code>.dex</code>文件，所以需要将<code>class</code>文件进行再一次转换。</p>
<p>你可以把<code>dex</code>文件理解为一个<code>class</code>文件包，里面装着很多的<code>class</code>文件，让这些类能够共享数据，类似这种关系：</p>
<p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/june/p5.png" alt></p>
<h5 id="D8编译器与R8工具"><a href="#D8编译器与R8工具" class="headerlink" title="D8编译器与R8工具"></a><code>D8</code>编译器与<code>R8</code>工具</h5><p>在 <code>AGP 3.X</code> 以后，<code>Google</code> 分别引入 <code>D8</code> 编译器和 <code>R8</code> 工具作为默认的 <code>DEX</code> 编译器和混淆压缩工具。            </p>
<ul>
<li>在<code>AGP3.0.1</code>之后,<code>D8</code>编译器取代了<code>Dx</code>，用于将<code>class</code>文件打包成<code>DEX</code>，<code>D8</code>编译器编译更快、时间更短；<code>DEX</code> 编译时占用内容更小；生成的<code>dex</code>文件大小更小；同时拥有相同或者是更好的运行时性能；</li>
<li>在<code>AGP3.4.0</code>之后，默认开启<code>R8</code>，<code>R8</code> 是 <code>ProGuard</code> 的替代工具，用于代码的压缩（<code>shrinking</code>）和混淆（<code>obfuscation</code>）</li>
</ul>
<p>在 <code>AGP3.4.0</code>版本中，<code>R8</code> 把 <code>desugaring</code>、<code>shrinking</code>、<code>obfuscating</code>、<code>optimizing</code> 和 <code>dexing</code> 都合并到一步进行执行。在 <code>AGP3.4.0</code> 以前的版本编译流程如下：        </p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35cae24dd2a74099bae30d62ba636eca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
<p>在<code>AGP3.4.0</code>之后的编译流程如下：   </p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/926de7469e724d8c9d49bc87458451f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
<h3 id="生成APK包"><a href="#生成APK包" class="headerlink" title="生成APK包"></a>生成<code>APK</code>包</h3><p>在资源文件与代码文件都编译完成后，接下来就是生成<code>apk</code>包了，将<code>manifest</code>文件、<code>resources</code>文件、<code>dex</code>文件、<code>assets</code>文件等等打包成一个压缩包，也就是<code>apk</code>文件。</p>
<p>在老版本使用的工具是<code>apkbuilder</code>，但是在最新的版本我发现没有这个工具了，<code>sdk</code>目录下也找不到了。</p>
<p>在<code>AGP3.6.0</code>之后，使用<code>zipflinger</code>作为默认打包工具来构建<code>APK</code>，以提高构建速度</p>
<h3 id="zipalign（对齐处理）"><a href="#zipalign（对齐处理）" class="headerlink" title="zipalign（对齐处理）"></a><code>zipalign</code>（对齐处理）</h3><p><code>zipalign</code> 是一种归档对齐工具，可对 <code>Android</code> 应用 (<code>APK</code>) 文件提供重要的优化</p>
<p><code>zipalign</code>会对<code>apk</code>中未压缩的数据进行4字节对齐，对齐的主要过程是将<code>APK</code>包中所有的资源文件距离文件起始偏移为4字节整数倍，对齐后就可以使用<code>mmap</code>函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。</p>
<p>有的同学可能会有疑问，这个对齐处理不是应该放在签名之后吗？其实这里就涉及到了签名工具的不同带来的对齐处理的顺序不同：</p>
<ul>
<li>如果使用的是 <code>apksigner</code>，只能在为 <code>APK</code> 文件签名之前执行 <code>zipalign</code>。</li>
<li>如果使用的是 <code>jarsigner</code>，只能在为 <code>APK</code> 文件签名之后执行 <code>zipalign</code>。</li>
</ul>
<h3 id="对APK进行签名"><a href="#对APK进行签名" class="headerlink" title="对APK进行签名"></a>对<code>APK</code>进行签名</h3><p>在生成APK文件之后，必须对该<code>apk</code>文件进行签名，否则无法被安装。</p>
<p>之前大家比较熟知的签名工具是<code>JDK</code>提供的<code>jarsigner</code>，而<code>apksigner</code>是<code>Google</code>专门为<code>Android</code>提供的签名和签证工具。</p>
<p>其区别就在于<code>jarsigner</code>只能进行<code>v1</code>签名，而<code>apksigner</code>可以进行<code>v2</code>、<code>v3</code>、<code>v4</code>签名。下面我们简单介绍下<code>V1</code>签名和<code>V2</code>签名的区别，关于<code>V3</code>,<code>V4</code>签名的内容可参考：<a href="https://juejin.cn/post/7111116047960244254" target="_blank" rel="noopener">Android开发应该知道的签名知识！</a></p>
<h4 id="V1签名"><a href="#V1签名" class="headerlink" title="V1签名"></a><code>V1</code>签名</h4><p><code>v1</code>签名方式主要是利用<code>META-INFO</code>文件夹中以<code>MF</code>、<code>SF</code> 和 <code>RSA</code> 的三个文件，流程如下所示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43f200e494dc4cec8fee65f9e0bbea76~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt>      </p>
<p>首先，将<code>apk</code>中除了<code>META-INFO</code>文件夹中的所有文件进行进行摘要写到 <code>META-INFO/MANIFEST.MF</code>；然后计算<code>MANIFEST.MF</code>文件的摘要写到<code>CERT.SF</code>；最后计算<code>CERT.SF</code>的摘要，使用私钥计算签名，将签名和开发者证书写到<code>CERT.RSA</code>。</p>
<p>所以<code>META-INFO</code>文件夹中这三个文件就能保证<code>apk</code>不会被修改。但是<code>V1</code>签名方案主要有两个问题    </p>
<ul>
<li>一是签名校验慢，在签名校验时要针对 <code>Apk</code> 中所有的文件进行校验，这会拖累老设备的安装时间。</li>
<li>二是<code>META-INFO</code>文件夹不会被签名，存在一定安全隐患</li>
</ul>
<h4 id="V2签名"><a href="#V2签名" class="headerlink" title="V2签名"></a><code>V2</code>签名</h4><p><code>Android7.0</code>之后，<code>Google</code>推出了<code>V2</code>签名，解决<code>V1</code>签名速度慢以及签名不完整的问题。</p>
<p>apk本质上是一个压缩包，而压缩包文件格式一般分为三块：</p>
<p>文件数据区，中央目录，中央目录结束节。</p>
<p>而<code>V2</code>要做的就是，在文件中插入一个<code>APK</code>签名分块，位于中央目录部分之前，如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab68a4f6847a41ca983100b0c832af95~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt>   </p>
<p>这样处理之后，文件签名完成就无法修改了，这也是为什么<code>ZipAlign</code>对齐只能在<code>ApkSigner</code>签名之前执行的原因。</p>
<h2 id="编译打包过程中的Task"><a href="#编译打包过程中的Task" class="headerlink" title="编译打包过程中的Task"></a>编译打包过程中的<code>Task</code></h2><p>上面介绍了<code>Apk</code>编译打包过程的主要步骤，这些步骤也都是通过<code>AGP</code>插件实现的，那么这些主要步骤又对应<code>AGP</code>中的哪些<code>Task</code>呢</p>
<p>当我们在<code>Android Studio</code>中点击<code>Run</code>时，便可以在控制台看到一系列的<code>Task</code>执行</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">Executing <span class="string">tasks:</span> [:<span class="string">app:</span>assembleDebug] <span class="keyword">in</span> project</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>preBuild UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>preDebugBuild UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugNativeDebugMetadata NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugAidl NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugRenderscript NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dataBindingMergeDependencyArtifactsDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dataBindingMergeGenClassesDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugResValues UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>packageDebugResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>parseDebugLocalResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dataBindingGenBaseClassesDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugBuildConfig UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>checkDebugAarMetadata UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mapDebugSourceSetPaths UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>createDebugCompatibleScreenManifests UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>extractDeepLinksDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugMainManifest UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugManifest UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugManifestForPackage UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>javaPreCompileDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugShaders UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugShaders NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugAssets UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugAssets UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compressDebugAssets UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugJavaRes NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>checkDebugDuplicateClasses UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>desugarDebugFileDependencies UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeExtDexDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeLibDexDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugJniLibFolders UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugNativeLibs NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>stripDebugDebugSymbols NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>validateSigningDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>writeDebugAppMetadata UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>writeDebugSigningConfigVersions UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugKotlin</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugJavaWithJavac</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugJavaResource UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dexBuilderDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeProjectDexDebug</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>packageDebug</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>createDebugApkListingFileRedirect UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>assembleDebug</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> <span class="number">2</span>s</span><br><span class="line"><span class="number">35</span> actionable <span class="string">tasks:</span> <span class="number">4</span> executed, <span class="number">31</span> up-to-date</span><br></pre></td></tr></table></figure>
<p>上面就是点击运行过程中运行的所有<code>Task</code>，我们精简一下，列出上面主要步骤中提到的<code>Task</code>       </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//aidl 转换aidl文件为java文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugAidl</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成BuildConfig文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugBuildConfig</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取gradle中配置的资源文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugResValues</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge资源文件，AAPT2 编译阶段</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugResources</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge assets文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugAssets</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compressDebugAssets</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge所有的manifest文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugManifest</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成R文件 AAPT2 链接阶段</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugResources</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译kotlin文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugKotlin</span><br><span class="line"></span><br><span class="line"><span class="comment">//javac 编译java文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugJavaWithJavac</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换class文件为dex文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dexBuilderDebug</span><br><span class="line"></span><br><span class="line"><span class="comment">//打包成apk并签名</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>packageDebug</span><br></pre></td></tr></table></figure>
<p>上面这些<code>Task</code>就对应于上面说的编译过程中的主要步骤，比如<code>mergeDebugResources</code>就对应于<code>AAPT2</code>的编译阶段，在<code>Task</code>结束后，会在<code>build/intermediates/merged_res/</code>文件夹中生成<code>Flat</code>文件<br>而<code>processDebugResources</code>则对应于<code>AAPT2</code>的链接阶段，会生成<code>R.java</code>与<code>resources.arsc</code>，并合并所有已编译的文件并将它们打包到一个软件包中</p>
<p>关于其他<code>Task</code>内容也都比较多，感兴趣的同学可以自行查看相关源码，这里就不缀述了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要详细介绍了<code>Android APK</code>打包编译的总体流程，主要步骤，以及<code>AGP</code>中相关的<code>Task</code>。这些知识点在平常的开发中或许没有多大用处，但是如果你要做包体积优化，或者编译优化相关的一些工作的话，这些应该是需要了解的前置知识，希望对你有所帮助~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6924918885259378702" target="_blank" rel="noopener">Android&amp;Kotlin编译速度原理剖析（上）</a><br><a href="https://mp.weixin.qq.com/s/6Cb6MqV9GQG60hBltss61A" target="_blank" rel="noopener">从构建工具看 Android APK 编译打包流程</a><br><a href="https://juejin.cn/post/6973089862278725640" target="_blank" rel="noopener">Android D8 编译器 和 R8 工具</a><br><a href="https://juejin.cn/post/7111116047960244254" target="_blank" rel="noopener">Android开发应该知道的签名知识！</a>          </p>
]]></content>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>别了 KAPT , 使用 KSP 快速实现 ButterKnife</title>
    <url>/blog/2022/07/ksp-version-butterknife.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注解处理器是<code>Android</code>开发中一种常用的技术，很多常用的框架比如<code>ButterKnife</code>，<code>ARouter</code>，<code>Glide</code>中都使用到了注解处理器相关技术        </p>
<p>但是如果项目比较大的话，会很容易发现<code>KAPT</code>是拖慢编译速度的常见原因，这也是谷歌推出<code>KSP</code>取代<code>KAPT</code>的原因</p>
<p>目前<code>KSP</code>已经发布了正式版，越来越多的框架也已经支持了<code>KSP</code>，因此现在应该是时候把你的迁移到<code>KSP</code>了~</p>
<p>本文主要介绍了<code>KSP</code>的一些优势与原理，以及使用<code>KSP</code>快速实现一个简易的<code>ButterKnife</code>框架，以实现<code>KSP</code>的快速上手</p>
<h2 id="为什么使用KSP"><a href="#为什么使用KSP" class="headerlink" title="为什么使用KSP"></a>为什么使用<code>KSP</code></h2><h3 id="KAPT为什么慢"><a href="#KAPT为什么慢" class="headerlink" title="KAPT为什么慢?"></a><code>KAPT</code>为什么慢?</h3><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/july/p1.jpg" alt></p>
<p>从上面这张图其实就可以看出原因了，<code>KAPT</code>处理注解的原理是将代码首先生成<code>Java Stubs</code>，再将<code>Java Stubs</code>交给<code>APT</code>处理的，这样天然多了一步，自然就耗时了</p>
<p>同时在项目中可以发现，往往生成<code>Java Stubs</code>的时间比<code>APT</code>真正处理注解的时间要长，因此使用<code>KSP</code>有时可以得到100%以上的速度提升     </p>
<p>同时由于<code>KAPT</code>不能直接解析<code>Kotlin</code>的特有的一些符号，比如<code>data class</code>，当我们要处理这些符号的时候就比较麻烦，而<code>KSP</code>则可以直接识别<code>Kotlin</code>符号</p>
<h3 id="KSP是什么"><a href="#KSP是什么" class="headerlink" title="KSP是什么"></a><code>KSP</code>是什么</h3><blockquote>
<p>Kotlin Symbol Processing (KSP) is an API that you can use to develop lightweight compiler plugins. KSP provides a simplified compiler plugin API that leverages the power of Kotlin while keeping the learning curve at a minimum. Compared to kapt, annotation processors that use KSP can run up to 2 times faster.</p>
</blockquote>
<p>官网对<code>KSP</code>的描述如上，主要说了两点：   </p>
<ol>
<li><code>KSP</code>是对<code>KCP</code>(<code>Kotlin</code>编译器插件)的轻量化封装，可以在降低我们学习曲线的同时，可以使用到<code>Kotlin</code>编译器的一些能力   </li>
<li>相比于<code>KAPT</code>，<code>KSP</code>处理注解可以得到2倍的性能提升</li>
</ol>
<p>上面得到了<code>KCP</code>(<code>Kotlin</code>编译器插件)，<code>KCP</code>在<code>kotlinc</code>过程中提供 <code>hook</code> 时机，可以在此期间解析 <code>AST</code>、修改字节码产物等，<code>Kotlin</code> 的不少语法糖都是 <code>KCP</code> 实现的，例如 <code>data class</code>、 <code>@Parcelize</code>、<code>kotlin-android-extension</code> 等, 如今火爆的 <code>Compose</code> 其编译期工作也是借助 <code>KCP</code> 完成的。</p>
<p><code>KCP</code>虽然强大，但开发成本也很高，学习曲线比较陡峭，因此当我们只需要处理注解等问题时，使用<code>KCP</code>是多余的，于是<code>Google</code>推出了<code>KSP</code>，它基于<code>KCP</code>，但屏蔽了<code>KCP</code>的细节，让我们专注于注解处理的业务</p>
<h2 id="KSP实战"><a href="#KSP实战" class="headerlink" title="KSP实战"></a><code>KSP</code>实战</h2><p><code>ButterKnife</code>是上古时期比较常用的一个框架，现在有<code>KAE</code>和<code>ViewBinding</code>了，当然也就用不上了      </p>
<p><code>ButterKnife</code>的主要原理是为注解解析的字段自动生成<code>findViewById</code>的代码，其中主要也是用到了注解处理技术，接下来我们就一起实现一个简易的<code>ButterKnife</code>框架</p>
<h3 id="1-声明注解"><a href="#1-声明注解" class="headerlink" title="1. 声明注解"></a>1. 声明注解</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">BindView</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>
<p>首先要做的就是声明<code>BindView</code>注解</p>
<h3 id="2-添加ProcessorProvider"><a href="#2-添加ProcessorProvider" class="headerlink" title="2. 添加ProcessorProvider"></a>2. 添加<code>ProcessorProvider</code></h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessorProvider</span> : <span class="type">SymbolProcessorProvider &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(environment: <span class="type">SymbolProcessorEnvironment</span>)</span></span>: SymbolProcessor &#123;</span><br><span class="line">        <span class="keyword">return</span> ButterKnifeProcessor(environment.codeGenerator, environment.logger)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProcessorProvider</code>用于提供注解处理器，其中主要提供了<code>SymbolProcessorEnvironment</code>，主要提供了以下功能</p>
<ol>
<li><code>environment.options</code>可以获取<code>build.gradle</code>声明的<code>ksp option</code>              </li>
<li><code>environment.logger</code>提供了<code>logger</code>供我们打印日志      </li>
<li>最常用的是<code>environment.codeGenerator</code>，用于生成与管理文件，不使用此 <code>API</code> 创建的文件将不会参与增量处理或后续编译。</li>
</ol>
<h3 id="3-获取注解处理的符号"><a href="#3-获取注解处理的符号" class="headerlink" title="3. 获取注解处理的符号"></a>3. 获取注解处理的符号</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> codeGenerator: CodeGenerator,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> logger: KSPLogger</span><br><span class="line">) : SymbolProcessor &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(resolver: <span class="type">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> symbols = resolver.getSymbolsWithAnnotation(BindView::<span class="class"><span class="keyword">class</span>.<span class="title">qualifiedName</span>!!)</span></span><br><span class="line">        <span class="keyword">val</span> ret = symbols.filter &#123; !it.validate() &#125;.toList()</span><br><span class="line">        <span class="keyword">val</span> butterKnifeList = symbols</span><br><span class="line">            .filter &#123; it <span class="keyword">is</span> KSPropertyDeclaration &amp;&amp; it.validate() &#125;</span><br><span class="line">            .map &#123; it <span class="keyword">as</span> KSPropertyDeclaration &#125;.toList()</span><br><span class="line">        ButterKnifeGenerator().generate(codeGenerator, logger, butterKnifeList)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码其实很简单，找出被<code>BindView</code>注解的符号，并过滤出<code>KSPropertyDeclaration</code>，也就是声明的属性</p>
<h3 id="4-使用kotlin-poet生成代码"><a href="#4-使用kotlin-poet生成代码" class="headerlink" title="4. 使用kotlin-poet生成代码"></a>4. 使用<code>kotlin-poet</code>生成代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OptIn(KotlinPoetKspPreview::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        codeGenerator: <span class="type">CodeGenerator</span>, logger: <span class="type">KSPLogger</span>,list: <span class="type">List</span>&lt;<span class="type">KSPropertyDeclaration</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">    	<span class="comment">// 将获取的符号按包名与类名分组</span></span><br><span class="line">        <span class="keyword">val</span> map = list.groupBy &#123;</span><br><span class="line">            <span class="keyword">val</span> parent = it.parent <span class="keyword">as</span> KSClassDeclaration</span><br><span class="line">            <span class="keyword">val</span> key = <span class="string">"<span class="subst">$&#123;parent.toClassName().simpleName&#125;</span>,<span class="subst">$&#123;parent.packageName.asString()&#125;</span>"</span></span><br><span class="line">            key</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> classItem = it.value[<span class="number">0</span>].parent <span class="keyword">as</span> KSClassDeclaration</span><br><span class="line">            <span class="comment">// 添加文件</span></span><br><span class="line">            <span class="keyword">val</span> fileSpecBuilder = FileSpec.builder(</span><br><span class="line">                classItem.packageName.asString(),</span><br><span class="line">                <span class="string">"<span class="subst">$&#123;classItem.toClassName().simpleName&#125;</span>ViewBind"</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加方法</span></span><br><span class="line">            <span class="keyword">val</span> functionBuilder = FunSpec.builder(<span class="string">"bindView"</span>)</span><br><span class="line">                .receiver(classItem.toClassName())</span><br><span class="line"></span><br><span class="line">            it.value.forEach &#123; item -&gt;</span><br><span class="line">            	<span class="comment">// 获取属性名与注解的值</span></span><br><span class="line">                <span class="keyword">val</span> symbolName = item.simpleName.asString()</span><br><span class="line">                <span class="keyword">val</span> annotationValue =</span><br><span class="line">                    (item.annotations.firstOrNull()?.arguments?.firstOrNull()?.value <span class="keyword">as</span>? <span class="built_in">Int</span>) ?: <span class="number">0</span></span><br><span class="line">                functionBuilder.addStatement(<span class="string">"<span class="variable">$symbolName</span> = findViewById(<span class="subst">$&#123;annotationValue&#125;</span>)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写文件</span></span><br><span class="line">            fileSpecBuilder.addFunction(functionBuilder.build())</span><br><span class="line">                .build()</span><br><span class="line">                .writeTo(codeGenerator, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也不长，主要分为以下几步：  </p>
<ol>
<li>因为我们获取的是所有被<code>BindView</code>注解的忏悔，因此需要将获取的符号根据包名与类名分组 </li>
<li>遍历<code>map</code>，生成文件，并在其中生成相应<code>Activity</code>的<code>bindView</code>扩展方法</li>
<li>在<code>bindView</code>方法中，利用相关<code>API</code>获取属性名与注解的值     </li>
<li>利用<code>kotlin-poet</code>与<code>codeGenerator</code>生成代码</li>
</ol>
<h3 id="5-生成的代码"><a href="#5-生成的代码" class="headerlink" title="5. 生成的代码"></a>5. 生成的代码</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zj.ksp_butterknife</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.<span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> MainActivity.<span class="title">bindView</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">  fabView = findViewById(<span class="number">2131230915</span>)</span><br><span class="line">  toolbar = findViewById(<span class="number">2131231195</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>build/generated/ksp/debug/kotlin</code>目录下可以看到生成的代码，如上所示，其实就是给<code>MainActivity</code>添加了个扩展方法，在其中会自动为被注解的属性赋值</p>
<h3 id="6-在项目中使用"><a href="#6-在项目中使用" class="headerlink" title="6. 在项目中使用"></a>6. 在项目中使用</h3><figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">plugins</span> &#123;</span><br><span class="line">    <span class="built_in">id</span>(<span class="string">"com.google.devtools.ksp"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">    kotlin &#123;</span><br><span class="line">        sourceSets &#123;</span><br><span class="line">        	// 让IDE识别KSP生成的代码</span><br><span class="line">            <span class="keyword">main</span>.kotlin.srcDirs += <span class="string">'build/generated/ksp'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="literal">project</span>(<span class="string">':butterknife-annotation'</span>)</span><br><span class="line">    ksp <span class="literal">project</span>(<span class="string">':butterknife-ksp-compiler'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>kapt</code>使用的步骤其实差不多，主要区别在于默认情况下<code>IDE</code>并不认识<code>KSP</code>生成的代码，为了在<code>IDE</code>中支持引用相关的类，需要扩展<code>main.kotlin.srcDirs</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了<code>KSP</code>的一些特性以及如何利用<code>KSP</code>快速实现一个简易的<code>ButterKnife</code>，<code>KSP</code>相比<code>KAPT</code>主要有以下优势       </p>
<ol>
<li><code>KSP</code>性能更好，有时可以达到2倍的速度提升；</li>
<li><code>KSP</code>开发起来更加方便，不需要自己处理增量编译逻辑；</li>
<li><code>KSP</code>支持多平台，而<code>KAPT</code>只支持<code>JVM</code>平台</li>
<li><code>KSP</code>拥有更符合<code>Kotin</code>习惯的<code>API</code>，同时可以识别<code>Kotin</code>特有的符号</li>
</ol>
<p>总得来说，<code>KSP</code>目前已经发布正式版了，越来越多的框架也已经支持了<code>KSP</code>，因此现在应该是时候把你的应用迁移到<code>KSP</code>了~</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有代码可见：<a href="https://github.com/shenzhen2017/ksp-butterknife" target="_blank" rel="noopener">https://github.com/shenzhen2017/ksp-butterknife</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bilibili.com/video/BV1Tf4y157ku" target="_blank" rel="noopener"> Kotlin 编译器插件：我们究竟在期待什么？</a><br><a href="https://blog.jetbrains.com/kotlin/2021/10/kotlin-symbol-processors/" target="_blank" rel="noopener">Kotlin Symbol Processors</a></p>
]]></content>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 快速编译背后的黑科技，了解一下~</title>
    <url>/blog/2022/07/kotlin-fast-compilation.html</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://blog.jetbrains.com/kotlin/2020/09/the-dark-secrets-of-fast-compilation-for-kotlin/" target="_blank" rel="noopener">The Dark Secrets of Fast Compilation for Kotlin</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速编译大量代码一向是一个难题，尤其是当编译器必须执行很多复杂操作时，例如重载方法解析和泛型类型推断。 本文主要介绍在日常开发中做一些小改动时，<code>Kotlin</code>编译器是如何加快编译速度的</p>
<h2 id="为什么编译那么耗时"><a href="#为什么编译那么耗时" class="headerlink" title="为什么编译那么耗时?"></a>为什么编译那么耗时?</h2><p>编译时间长通常有三大原因：</p>
<ol>
<li>代码库大小：通常代码码越大，编译耗时越长</li>
<li>你的工具链优化了多少，这包括编译器本身和你正在使用的任何构建工具。</li>
<li>你的编译器有多智能：无论是在不打扰用户的情况下计算出许多事情，还是需要不断提示和样板代码</li>
</ol>
<p>前两个因素很明显，让我们谈谈第三个因素：编译器的智能。 这通常是一个复杂的权衡，在 <code>Kotlin</code> 中，我们决定支持干净可读的类型安全代码。这意味着编译器必须非常智能，因为我们在编译期需要做很多工作。</p>
<p><code>Kotlin</code> 旨在用于项目寿命长、规模大且涉及大量人员的工业开发环境。 </p>
<p>因此，我们希望静态类型安全，能够及早发现错误，并获得精确的提示（支持自动补全、重构和在 <code>IDE</code> 中查找使用、精确的代码导航等）。 </p>
<p>然后，我们还想要干净可读的代码，没有不必要的噪音。这意味着我们不希望代码中到处都是类型。 这就是为什么我们有支持 <code>lambda</code> 和扩展函数类型的智能类型推断和重载解析算法等等。 <code>Kotlin</code> 编译器会自己计算出很多东西，以同时保持代码干净和类型安全。</p>
<h2 id="编译器可以同时智能与高效吗"><a href="#编译器可以同时智能与高效吗" class="headerlink" title="编译器可以同时智能与高效吗?"></a>编译器可以同时智能与高效吗?</h2><p>为了让智能编译器快速运行，您当然需要优化工具链的每一部分，这是我们一直在努力的事情。 除此之外，我们正在开发新一代 <code>Kotlin</code> 编译器，它的运行速度将比当前编译器快得多，但这篇文章不是关于这个的。</p>
<p>不管编译器有多快，在大型项目上都不会太快。 而且，在调试时所做的每一个小改动都重新编译整个代码库是一种巨大的浪费。 因此，我们试图尽可能多地复用之前的编译，并且只编译我们绝对需要的文件。</p>
<p>有两种通用方法可以减少重新编译的代码量：</p>
<ul>
<li><strong>编译避免</strong>：即只重新编译受影响的模块，</li>
<li><strong>增量编译</strong>：即只重新编译受影响的文件。</li>
</ul>
<p>人们可能会想到一种更细粒度的方法，它可以跟踪单个函数或类的变化，因此重新编译的次数甚至少于一个文件，但我不知道这种方法在工业语言中的实际实现，总的来说它似乎没有必要。</p>
<p>现在让我们更详细地了解一下编译避免和增量编译。</p>
<h2 id="编译避免"><a href="#编译避免" class="headerlink" title="编译避免"></a>编译避免</h2><p>编译避免的核心思想是：</p>
<ul>
<li>查找<code>dirty</code>（即发生更改）的文件</li>
<li>重新编译这些文件所属的<code>module</code></li>
<li>确定哪些其他模块可能会受到更改的影响，重新编译这些模块，并检查它们的<code>ABI</code></li>
<li>然后重复这个过程直到重新编译所有受影响的模块</li>
</ul>
<p>从以上步骤可以看出，没有人依赖的模块中的更改将比每个人都依赖的模块(比如<code>util</code>模块)中的更改编译得更快（如果它影响其 <code>ABI</code>），因为如果你修改了<code>util</code>模块，依赖了它的模块全都需要编译</p>
<h3 id="ABI是什么"><a href="#ABI是什么" class="headerlink" title="ABI是什么"></a><code>ABI</code>是什么</h3><p>上面介绍了在编译过程中会检查<code>ABI</code>，那么<code>ABI</code>是什么呢?</p>
<p><code>ABI</code> 代表应用程序二进制接口，它与 <code>API</code> 相同，但用于二进制文件。本质上，<code>ABI</code> 是依赖模块关心的二进制文件中唯一的部分。</p>
<p>粗略地说，<code>Kotlin</code> 二进制文件（无论是 <code>JVM</code> 类文件还是 <code>KLib</code>）包含<code>declaration</code>和<code>body</code>两部分。其他模块可以引用<code>declaration</code>，但不是所有<code>declaration</code>。因此，例如，私有类和成员不是 <code>ABI</code> 的一部分。</p>
<p><code>body</code>可以成为 <code>ABI</code> 的一部分吗？也是可以的，比如当我们使用<code>inline</code>时。 同时<code>Kotlin</code> 具有内联函数和编译时常量（<code>const val</code>）。因此如果内联函数的<code>body</code>或 <code>const val</code> 的值发生更改，则可能需要重新编译相关模块。</p>
<p>因此，粗略地说，<code>Kotlin</code> 模块的 <code>ABI</code> 由<code>declaration</code>、内联<code>body</code>和其他模块可见的<code>const val</code>值组成。</p>
<p>因此检测 <code>ABI</code> 变化的直接方法是</p>
<ul>
<li>以某种形式存储先前编译的 <code>ABI</code>（您可能希望存储哈希以提高效率)</li>
<li>编译模块后，将结果与存储的 <code>ABI</code> 进行比较：</li>
<li>如果相同，我们就完成了；</li>
<li>如果改变了，重新编译依赖模块。</li>
</ul>
<h3 id="编译避免的优缺点"><a href="#编译避免的优缺点" class="headerlink" title="编译避免的优缺点"></a>编译避免的优缺点</h3><p>避免编译的最大优点是相对简单。</p>
<p>当模块很小时，这种方法确实很有帮助，因为重新编译的单元是整个模块。 但如果你的模块很大，重新编译的耗时会很长。        因此为了尽可能地利用编译避免提升速度，决定了我们的工程应该由很多小模块组成。作为开发人员，我们可能想要也可能不想要这个。          小模块不一定听起来像一个糟糕的设计，但我宁愿为人而不是机器构建我的代码。为了利用编译避免，实际上限制了我们项目的架构。</p>
<p>另一个观察结果是，许多项目都有类似于<code>util</code>的基础模块，其中包含许多有用的小功能。 几乎所有其他模块都依赖于<code>util</code>模块，至少是可传递的。 现在，假设我想添加另一个在我的代码库中使用了 3 次的小实用函数。 它添加到<code>util</code>模块中会导致<code>ABI</code>发生变化，因此所有依赖模块都受到影响，进而导致整个项目都需要重新编译。</p>
<p>最重要的是，拥有许多小模块（每个都依赖于多个其他模块）意味着我的项目的<code>configuration</code>时间可能会变得巨大，因为对于每个模块，它都包含其独特的依赖项集（源代码和二进制文件）。 在 <code>Gradle</code> 中配置每个模块通常需要 50-100 毫秒。 大型项目拥有超过 1000 个模块的情况并不少见，因此总配置时间可能会超过一分钟。 它必须在每次构建以及每次将项目导入 <code>IDE</code> 时都运行（例如，添加新依赖项时）。</p>
<p><code>Gradle</code> 中有许多特性可以减轻编译避免的一些缺点：例如，可以使用缓存<code>configuration cache</code>。 尽管如此，这里仍有很大的改进空间，这就是为什么在 <code>Kotlin</code> 中我们使用增量编译。</p>
<h2 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h2><p>增量编译比编译避免更加细粒度：它适用于单个文件而不是模块。 因此，当通用模块的 <code>ABI</code> 发生微小变化时，它不关心模块大小，也不重新编译整个项目。这种方式不会限制用户项目的架构，并且可以加快编译速度</p>
<p><code>JPS</code>(<code>IntelliJ</code>的内置构建系统)一直支持增量编译。 而<code>Gradle</code>仅支持开箱即用的编译避免。 从 1.4 开始，<code>Kotlin Gradle</code> 插件为 <code>Gradle</code> 带来了一些有限的增量编译实现，但仍有很大的改进空间。</p>
<p>理想情况下，我们只需查看更改的文件，准确确定哪些文件依赖于它们，然后重新编译所有这些文件。        </p>
<p>听起来很简单，但实际上准确地确定这组依赖文件非常复杂。 </p>
<p>一方面，源文件之间可能存在循环依赖关系，这是大多数现代构建系统中的模块所不允许的。并且单个文件的依赖关系没有明确声明。请注意，如果引用了相同的包和链调用，<code>imports</code>不足以确定依赖关系：对于 <code>A.b.c()</code>，我们最多需要导入<code>A</code>，但 <code>B</code> 类型的更改也会影响我们。</p>
<p>由于所有这些复杂性，增量编译试图通过多轮来获取受影响的文件集，以下是它的完成方式的概要：</p>
<ul>
<li>查找<code>dirty</code>（更改）的文件</li>
<li>重新编译它们（使用之前编译的结果作为二进制依赖，而不是编译其他源文件）</li>
<li>检查这些文件对应的<code>ABI</code>是否发生了变化</li>
<li>如果没有，我们就完成了！</li>
<li>如果发生了变化，则查找受更改影响的文件，将它们添加到脏文件集中，重新编译</li>
<li>重复直到 <code>ABI</code> 稳定（这称为“固定点”）</li>
</ul>
<p>由于我们已经知道如何比较 ABI，所以这里基本上只有两个棘手的地方：</p>
<ul>
<li>使用先前编译的结果来编译源的任意子集</li>
<li>查找受一组给定的 <code>ABI</code> 更改影响的文件。</li>
</ul>
<p>这两者都是 <code>Kotlin</code> 增量编译器的功能。 让我们一个一个看一下。</p>
<h3 id="编译脏文件"><a href="#编译脏文件" class="headerlink" title="编译脏文件"></a>编译脏文件</h3><p>编译器知道如何使用先前编译结果的子集来跳过编译非脏文件，而只需加载其中定义的符号来为脏文件生成二进制文件。 如果不是为了增量，编译器不一定能够做到这一点：从模块生成一个大二进制文件而不是每个源文件生成一个小二进制文件，这在 <code>JVM</code> 世界之外并不常见。 而且它不是 <code>Kotlin</code> 语言的一个特性，它是增量编译器的一个实现细节。</p>
<p>当我们将脏文件的 <code>ABI</code> 与之前的结果进行比较时，我们可能会发现我们很幸运，不需要再进行几轮重新编译。 以下是一些只需要重新编译脏文件的更改示例（因为它们不会更改 <code>ABI</code>）：</p>
<ul>
<li>注释、字符串文字（<code>const val</code> 除外）等，例如：更改调试输出中的某些内容</li>
<li>更改仅限于非内联且不影响返回类型推断的函数体，例如：添加/删除调试输出，或更改函数的内部逻辑</li>
<li>仅限于私有声明的更改（它们可以是类或文件私有的），例如：引入或重命名私有函数</li>
<li>重新排序函数声明</li>
</ul>
<p>如您所见，这些情况在调试和迭代改进代码时非常常见。</p>
<h3 id="扩大脏文件集"><a href="#扩大脏文件集" class="headerlink" title="扩大脏文件集"></a>扩大脏文件集</h3><p>如果我们不那么幸运并且某些声明已更改，则意味着某些依赖于脏文件的文件在重新编译时可能会产生不同的结果，即使它们的代码中没有任何一行被更改。</p>
<p>一个简单的策略是此时放弃并重新编译整个模块。<br>这将把所有编译避免的问题都摆在桌面上：一旦你修改了一个声明，大模块就会成为一个问题，而且大量的小模块也有性能成本，如上所述。<br>所以，我们需要更细化：找到受影响的文件并重新编译它们。     </p>
<p>因此，我们希望找到依赖于实际更改的 <code>ABI</code> 部分的文件。<br>例如，如果用户将 <code>foo</code> 重命名为 <code>bar</code>，我们只想重新编译关心名称 <code>foo</code> 和 <code>bar</code> 的文件，而不管其他文件，即使它们引用了此 <code>ABI</code>的其他部分。<br>增量编译器会记住哪些文件依赖于先前编译中的哪个声明，我们可以使用这种数据，有点像模块依赖图。同样，这不是非增量编译器通常会做的事情。</p>
<p>理想情况下，对于每个文件，我们应该存储哪些文件依赖于它，以及它们关心 <code>ABI</code> 的哪些部分。实际上，如此精确地存储所有依赖项的成本太高了。而且在许多情况下，存储完整签名毫无意义。</p>
<p>我们看一下下面这个例子：    </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dirty.kt</span></span><br><span class="line"><span class="comment">// rename this to be 'fun foo(i: Int)'</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">changeMe</span><span class="params">(i: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="number">0</span> <span class="keyword">else</span> bar().length</span><br><span class="line"></span><br><span class="line"><span class="comment">// clean.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">Any</span>)</span></span> = <span class="string">""</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> =  foo(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>我们定义两个<code>kt</code>文件 ，<code>dirty.kt</code>与<code>clean.kt</code>       </p>
<p>假设用户将函数 <code>changeMe</code> 重命名为 <code>foo</code>。 请注意，虽然 <code>clean.kt</code> 没有改变，但 <code>bar()</code> 的主体将在重新编译时改变：它现在将从<code>dirty.kt</code> 调用 <code>foo(Int)</code>，而不是从 <code>clean.kt</code> 调用 <code>foo(Any)</code> ，并且它的返回类型 也会改变。 </p>
<p>这意味着我们必须重新编译<code>dirty.kt</code> 和<code>clean.kt</code>。 增量编译器如何发现这一点？</p>
<p>我们首先重新编译更改的文件：<code>dirty.kt</code>。 然后我们看到 <code>ABI</code> 中的某些内容发生了变化：</p>
<ul>
<li>没有功能 <code>changeMe</code> 了</li>
<li>有一个函数 <code>foo</code> 接受一个 <code>Int</code> 并返回一个 <code>Int</code>。</li>
</ul>
<p>现在我们看到 <code>clean.kt</code> 依赖于名称 <code>foo</code>。 这意味着我们必须再次重新编译 <code>clean.kt</code> 和 <code>dirty.kt</code>。 为什么？ 因为类型不能被信任。    </p>
<p>增量编译必须产生与所有代码的完全重新编译相同的结果。<br>考虑<code>dirty.kt</code> 中新出现的<code>foo</code> 的返回类型。它是推断出来的，实际上它取决于 <code>clean.kt</code> 中 <code>bar</code> 的类型，它是文件之间的循环依赖。<br>因此，当我们将 <code>clean.kt</code> 添加到组合中时，返回类型可能会发生变化。在这个例子中，我们会得到一个编译错误，但是在我们重新编译 <code>clean.kt</code> 和 <code>dirty.kt</code> 之前，我们不知道它。</p>
<p><code>Kotlin</code> 增量编译的第一原则：您可以信任的只是名称。</p>
<p>这就是为什么对于每个文件，我们存储它产生的 <code>ABI</code>，以及在编译期间查找的名称（不是完整的声明）。</p>
<p>我们存储所有这些的方式可以进行一些优化。</p>
<p>例如，某些名称永远不会在文件之外查找，例如局部变量的名称，在某些情况下还有局部函数的名称。<br>我们可以从索引中省略它们。为了使算法更精确，我们记录了在查找每个名称时查阅了哪些文件。为了压缩我们使用散列的索引。这里有更多改进的空间。</p>
<p>您可能已经注意到，我们必须多次重新编译初始的脏文件集。 唉，没有办法解决这个问题：可能存在循环依赖，只有一次编译所有受影响的文件才能产生正确的结果。 </p>
<p>在最坏的情况下，增量编译可能会比编译避免做更多的工作，因此应该有适当的启发式方法来防止它。</p>
<h3 id="跨模块的增量编译"><a href="#跨模块的增量编译" class="headerlink" title="跨模块的增量编译"></a>跨模块的增量编译</h3><p>迄今为止最大的挑战是可以跨越模块边界的增量编译。</p>
<p>比如说，我们在一个模块中有脏文件，我们做了几轮并在那里到达一个固定点。现在我们有了这个模块的新 <code>ABI</code>，需要对依赖的模块做一些事情。</p>
<p>当然，我们知道初始模块的 <code>ABI</code> 中哪些名称受到影响，并且我们知道依赖模块中的哪些文件查找了这些名称。</p>
<p>现在，我们可以应用基本相同的增量算法，但从 <code>ABI</code> 更改开始，而不是从一组脏文件开始。      </p>
<p>如果模块之间没有循环依赖，单独重新编译依赖文件就足够了。但是，如果他们的 <code>ABI</code> 发生了变化，我们需要将更多来自同一模块的文件添加到集合中，并再次重新编译相同的文件。</p>
<p>在 <code>Gradle</code> 中完全实现这一点是一个公开的挑战。这可能需要对 <code>Gradle</code> 架构进行一些更改，但我们从过去的经验中知道，这样的事情是可能的，并且受到 <code>Gradle</code> 团队的欢迎。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，您对现代编程语言中的快速编译所带来的挑战有了基本的了解。请注意，一些语言故意选择让他们的编译器不那么智能，以避免不得不做这一切。不管好坏，<code>Kotlin</code> 走的是另一条路，让 <code>Kotlin</code> 编译器如此智能似乎是用户最喜欢的特性，因为它们同时提供了强大的抽象、可读性和简洁的代码。</p>
<p>虽然我们正在开发新一代编译器前端，它将通过重新考虑核心类型检查和名称解析算法的实现来加快编译速度，但我们知道这篇博文中描述的所有内容都不会过时。        </p>
<p>原因之一是使用 <code>Java</code> 编程语言的体验，它享受 <code>IntelliJ IDEA</code> 的增量编译功能，甚至拥有比今天的 <code>kotlinc</code> 快得多的编译器。         </p>
<p>另一个原因是我们的目标是尽可能接近解释语言的开发体验，这些语言无需任何编译即可立即获取更改。 </p>
<p>所以，<code>Kotlin</code> 的快速编译策略是：优化的编译器 + 优化的工具链 + 复杂的增量。</p>
<h2 id="译者总结"><a href="#译者总结" class="headerlink" title="译者总结"></a>译者总结</h2><p>本文主要介绍了<code>Kotlin</code>编译器在加快编译速度方面做的一些工作，介绍了编译避免与增量编译的区别以及什么是<code>ABI</code>。     </p>
<p>了解<code>Kotlin</code>增量编译的原理可以帮助我们提高增量编译成功的概率，比如<code>inline</code>函数体也是<code>ABI</code>的一部分，因此当我们声明内联函数时，内联函数体应该写得尽量简单，内部通常只需要调用另一个非内联函数即可。      </p>
<p>这样当<code>inline</code>函数内部逻辑发生更改时，不需要重新编译依赖于它的那些文件，从而实现增量编译。     </p>
<p>同时从实际开发过程中体验，<code>Kotlin</code>增量编译还是经常会失效，尤其是发生跨模块更改时。<code>Kotlin</code>新一代编译器已经发布了<code>Alpha</code>版本，期待会有更好的表现~</p>
]]></content>
      <tags>
        <tag>编译技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin 增量编译是怎么实现的？</title>
    <url>/blog/2022/08/kotlin-compile-analysis.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编译运行是一个<code>Android</code>开发者每天都要做的工作，增量编译对于开发者也极其重要，高命中率的增量编译可以极大的提高开发者的开发效率与体验</p>
<p>之前写了一些文章介绍<code>Kotlin</code>增量编译的原理，以及<code>Kotlin 1.7</code>支持了跨模块增量编译        </p>
<p>了解了这些基本原理之后，我们今天一起来看下<code>Kotlin</code>增量编译的源码，看看<code>Kotlin</code>增量编译到底是怎么实现的</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><a href="https://juejin.cn/post/7118908219841314823" target="_blank" rel="noopener">Kotlin 快速编译背后的黑科技，了解一下~</a><br><a href="https://juejin.cn/post/7126698891692474375" target="_blank" rel="noopener">Kotlin 1.7 新特性：支持跨模块增量编译</a><br><a href="https://juejin.cn/post/7131889789787176974" target="_blank" rel="noopener">Transform 被废弃，TransformAction 了解一下~</a>   </p>
<p>主要是<code>Kotlin</code>增量编译的原理介绍，以及因为在源码中使用了<code>TransformAction</code>，也需要了解一下<code>TransformAction</code>的基本使用</p>
<h2 id="增量编译流程"><a href="#增量编译流程" class="headerlink" title="增量编译流程"></a>增量编译流程</h2><h3 id="第一步：编译入口"><a href="#第一步：编译入口" class="headerlink" title="第一步：编译入口"></a>第一步：编译入口</h3><p>如果我们要在项目中使用<code>Kotlin</code>，都必须要添加<code>org.jetbrains.kotlin.android</code>插件，这个插件是我们编译<code>Kotlin</code>的入口，它的代码在<code>kotlin-gradle-plugin</code>插件中</p>
<p>这个插件的实现类就是<code>KotlinAndroidPluginWrapper</code>，可以看出<code>KotlinAndroidPluginWrapper</code>就是个包装，里面主要就是创建并配置<code>KotlinAndroidPlugin</code></p>
<h3 id="第二步：配置KotlinAndroidPlugin"><a href="#第二步：配置KotlinAndroidPlugin" class="headerlink" title="第二步：配置KotlinAndroidPlugin"></a>第二步：配置<code>KotlinAndroidPlugin</code></h3><p><code>KotlinAndroidPlugin</code>是插件真正的入口，在这里完成<code>compileKotlin Task</code>相关的配置工作</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinAndroidPlugin</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> registry: ToolingModelBuilderRegistry</span><br><span class="line">) : Plugin&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        checkGradleCompatibility()</span><br><span class="line"></span><br><span class="line">        project.dynamicallyApplyWhenAndroidPluginIsApplied() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preprocessVariant</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        variantData: <span class="type">BaseVariant</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        compilation: <span class="type">KotlinJvmAndroidCompilation</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        project: <span class="type">Project</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        rootKotlinOptions: <span class="type">KotlinJvmOptionsImpl</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        tasksProvider: <span class="type">KotlinTasksProvider</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> configAction = KotlinCompileConfig(compilation)</span><br><span class="line">        configAction.configureTask &#123; task -&gt;</span><br><span class="line">            task.useModuleDetection.value(<span class="literal">true</span>).disallowChanges()</span><br><span class="line">            <span class="comment">// 将kotlin 编译结果存储在tmp/kotlin-classes/$variantDataName目录下，会作为java compiler的class-path输入</span></span><br><span class="line">            task.destinationDirectory.<span class="keyword">set</span>(project.layout.buildDirectory.dir(<span class="string">"tmp/kotlin-classes/<span class="variable">$variantDataName</span>"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        tasksProvider.registerKotlinJVMTask(project, compilation.compileKotlinTaskName, compilation.kotlinOptions, configAction)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略了一些代码，主要做了几件事：  </p>
<ol>
<li>检查<code>KGP</code>与<code>Gradle</code>的版本兼容，如果不兼容则抛出异常，中止构建</li>
<li>如果在<code>project</code>中已经添加了<code>android</code>插件，则开始配置<code>kotlin-android</code>插件</li>
<li>通过<code>KotlinCompileConfig</code>来配置<code>KotlinCompile Task</code>，设置<code>destinationDirectory</code>作为<code>Kotlin</code>编译结果存储目录，后续会作为<code>java compiler</code>的<code>classpath</code>输入</li>
</ol>
<h3 id="第三步：配置KotlinCompile的输入输出"><a href="#第三步：配置KotlinCompile的输入输出" class="headerlink" title="第三步：配置KotlinCompile的输入输出"></a>第三步：配置<code>KotlinCompile</code>的输入输出</h3><p>要实现增量编译，最重要的一点就是配置输入输出，当输入输出没有发生变化时，<code>Task</code>就可以被跳过，而<code>KotlinCompile</code>输入输出的配置，主要是在<code>KotlinCompileConfig</code>中完成的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">configureTaskProvider &#123; taskProvider -&gt;</span><br><span class="line">	<span class="comment">// 是否开启classpathSnapthot</span></span><br><span class="line">    <span class="keyword">val</span> useClasspathSnapshot = propertiesProvider.useClasspathSnapshot</span><br><span class="line">    <span class="keyword">val</span> classpathConfiguration = <span class="keyword">if</span> (useClasspathSnapshot) &#123;</span><br><span class="line">    	<span class="comment">// 注册 Transform</span></span><br><span class="line">        registerTransformsOnce(project)</span><br><span class="line">        project.configurations.detachedConfiguration(</span><br><span class="line">            project.dependencies.create(objectFactory.fileCollection().from(project.provider &#123; taskProvider.<span class="keyword">get</span>().libraries &#125;))</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    taskProvider.configure &#123; task -&gt;</span><br><span class="line">    	<span class="comment">// 配置输入属性</span></span><br><span class="line">        task.classpathSnapshotProperties.useClasspathSnapshot.value(useClasspathSnapshot).disallowChanges()</span><br><span class="line">        <span class="keyword">if</span> (useClasspathSnapshot) &#123;</span><br><span class="line">        	<span class="comment">// 通过TransformAction读取输入</span></span><br><span class="line">            <span class="keyword">val</span> classpathEntrySnapshotFiles = classpathConfiguration!!.incoming.artifactView &#123;</span><br><span class="line">                it.attributes.attribute(ARTIFACT_TYPE_ATTRIBUTE, CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE)</span><br><span class="line">            &#125;.files</span><br><span class="line">            task.classpathSnapshotProperties.classpathSnapshot.from(classpathEntrySnapshotFiles).disallowChanges()</span><br><span class="line">            task.classpathSnapshotProperties.classpathSnapshotDir.value(getClasspathSnapshotDir(task)).disallowChanges()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            task.classpathSnapshotProperties.classpath.from(task.project.provider &#123; task.libraries &#125;).disallowChanges()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，主要做了这么几件事       </p>
<ol>
<li>判断是否开启了<code>classpathSnapthot</code>，这也是支持跨模块增量编译的开关，如果开启了就注册<code>Transform</code></li>
<li>通过<code>TransformAction</code>获取输入，并配置给<code>Task</code>相应的属性</li>
</ol>
<p>下面我们着重来看下<code>TransformAction</code>在这里做了什么工作?</p>
<h3 id="第四步：跨模块增量编译支持"><a href="#第四步：跨模块增量编译支持" class="headerlink" title="第四步：跨模块增量编译支持"></a>第四步：跨模块增量编译支持</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerTransformsOnce</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> buildMetricsReporterService = BuildMetricsReporterService.registerIfAbsent(project)</span><br><span class="line">    project.dependencies.registerTransform(ClasspathEntrySnapshotTransform::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123;</span><br><span class="line">        it.from.attribute(ARTIFACT_TYPE_ATTRIBUTE, JAR_ARTIFACT_TYPE)</span><br><span class="line">        it.to.attribute(ARTIFACT_TYPE_ATTRIBUTE, CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE)</span><br><span class="line">    &#125;</span><br><span class="line">    project.dependencies.registerTransform(ClasspathEntrySnapshotTransform::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123;</span><br><span class="line">        it.from.attribute(ARTIFACT_TYPE_ATTRIBUTE, DIRECTORY_ARTIFACT_TYPE)</span><br><span class="line">        it.to.attribute(ARTIFACT_TYPE_ATTRIBUTE, CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解了前置知识中的<code>TransformAction</code>，可以看出这就是注册了只变换<code>ArtifactType</code>的变换，主要涉及<code>JAR_ARTIFACT_TYPE</code>和<code>DIRECTORY_ARTIFACT_TYPE</code>转换为<code>CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE</code></p>
<p>也就是说依赖的<code>jar</code>和类目录都会转换为<code>CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE</code>类型，也就可以获取我们依赖的所有<code>classpath</code>的<code>abi</code>了</p>
<p>接下来我们看下<code>ClasspathEntrySnapshotTransform</code>的实现</p>
<h4 id="ClasspathEntrySnapshotTransform实现"><a href="#ClasspathEntrySnapshotTransform实现" class="headerlink" title="ClasspathEntrySnapshotTransform实现"></a><code>ClasspathEntrySnapshotTransform</code>实现</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClasspathEntrySnapshotTransform</span> : <span class="type">TransformAction</span>&lt;<span class="type">ClasspathEntrySnapshotTransform.Parameters</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@get:Classpath</span></span><br><span class="line">    <span class="meta">@get:InputArtifact</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> inputArtifact: Provider&lt;FileSystemLocation&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(outputs: <span class="type">TransformOutputs</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> classpathEntryInputDirOrJar = inputArtifact.<span class="keyword">get</span>().asFile</span><br><span class="line">        <span class="keyword">val</span> snapshotOutputFile = outputs.file(classpathEntryInputDirOrJar.name.replace(<span class="string">'.'</span>, <span class="string">'_'</span>) + <span class="string">"-snapshot.bin"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> granularity = getClassSnapshotGranularity(classpathEntryInputDirOrJar, parameters.gradleUserHomeDir.<span class="keyword">get</span>().asFile)</span><br><span class="line"></span><br><span class="line">		 <span class="keyword">val</span> snapshot = ClasspathEntrySnapshotter.snapshot(classpathEntryInputDirOrJar, granularity, metrics)</span><br><span class="line">         ClasspathEntrySnapshotExternalizer.saveToFile(snapshotOutputFile, snapshot)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果是anroid.jar或者aar依赖，粒度为class, 否则为class_member_level </span></span><br><span class="line"><span class="comment">    /</span></span><br><span class="line"><span class="comment">    private fun getClassSnapshotGranularity(classpathEntryDirOrJar: File, gradleUserHomeDir: File): ClassSnapshotGranularity &#123;</span></span><br><span class="line"><span class="comment">        return if (</span></span><br><span class="line"><span class="comment">            classpathEntryDirOrJar.startsWith(gradleUserHomeDir) ||</span></span><br><span class="line"><span class="comment">            classpathEntryDirOrJar.name == "android.jar"</span></span><br><span class="line"><span class="comment">        ) CLASS_LEVEL</span></span><br><span class="line"><span class="comment">        else CLASS_MEMBER_LEVEL</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p>关于自定义<code>TransformAction</code>，其实跟<code>Task</code>一样，也主要看3个部分，输入，输出，执行方法体</p>
<ol>
<li><code>ClasspathEntrySnapshotTransform</code>的输入就是模块依赖的<code>jar</code>或者文件目录</li>
<li>输出则是以<code>-snapshot.bin</code>结尾的文件       </li>
<li>方法体只做了一件事，通过<code>ClasspathEntrySnapshotter</code>计算出<code>claspath</code>的快照并保存，如果是<code>aar</code>依赖，计算的粒度为<code>class</code>，如果是项目内的类，计算的粒度是<code>class_member_level</code></li>
</ol>
<p><code>ClasspathEntrySnapshotter</code>内部是如何计算<code>classpath</code>快照的我们这就不看了，我们简单看下下面这样一个类计算的快照是怎样的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startTest</span><span class="params">(text: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(text)</span><br><span class="line">        test1(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"here test126<span class="variable">$index</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/argust/p2.jpg" alt></p>
<p><code>MyTest</code>类计算出来的快照如图所示，主要<code>classId</code>,<code>classAbiHash</code>,<code>classHeaderStrings</code>等内容</p>
<p>可以看出<code>private</code>函数的声明也是<code>abi</code>的一部分，当<code>public</code>或者<code>private</code>的函数声明发生变化时，<code>classAbiHash</code>都会发生变化，而只修改函数体时，<code>snapshot</code>不会发生任何变化。</p>
<h3 id="第五步：KotlinCompile-Task执行编译"><a href="#第五步：KotlinCompile-Task执行编译" class="headerlink" title="第五步：KotlinCompile Task执行编译"></a>第五步：<code>KotlinCompile Task</code>执行编译</h3><p>在配置完成之后，接下来我们就来看下<code>KotlinCompile</code>是怎么执行编译的</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinCompile</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> kotlinOptions: KotlinJvmOptions,</span><br><span class="line">    workerExecutor: WorkerExecutor,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> objectFactory: ObjectFactory</span><br><span class="line">) : AbstractKotlinCompile&lt;K2JVMCompilerArguments&gt;(objectFactory &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// classpathSnapshot入参</span></span><br><span class="line">    <span class="meta">@get:Nested</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> classpathSnapshotProperties: ClasspathSnapshotProperties</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClasspathSnapshotProperties</span> </span>&#123;</span><br><span class="line">        <span class="meta">@get:Classpath</span></span><br><span class="line">        <span class="meta">@get:Incremental</span></span><br><span class="line">        <span class="meta">@get:Optional</span> <span class="comment">// Set if useClasspathSnapshot == true</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">val</span> classpathSnapshot: ConfigurableFileCollection</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增量编译参数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> incrementalProps: List&lt;FileCollection&gt;</span><br><span class="line">        <span class="keyword">get</span>() = listOf(</span><br><span class="line">            sources,</span><br><span class="line">            javaSources,</span><br><span class="line">            classpathSnapshotProperties.classpathSnapshot</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">callCompilerAsync</span><span class="params">(inputChanges: <span class="type">InputChanges</span>)</span></span> &#123;</span><br><span class="line">    	<span class="comment">// 获取增量编译环境变量</span></span><br><span class="line">        <span class="keyword">val</span> icEnv = <span class="keyword">if</span> (isIncrementalCompilationEnabled()) &#123;</span><br><span class="line">            IncrementalCompilationEnvironment(</span><br><span class="line">                changedFiles = getChangedFiles(inputChanges, incrementalProps),</span><br><span class="line">                classpathChanges = getClasspathChanges(inputChanges),</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">val</span> environment = GradleCompilerEnvironment(incrementalCompilationEnvironment = icEnv)</span><br><span class="line">        compilerRunner.runJvmCompilerAsync(</span><br><span class="line">            (kotlinSources + scriptSources).toList(),</span><br><span class="line">            commonSourceSet.toList(),</span><br><span class="line">            javaSources.files,</span><br><span class="line">            environment,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找改动了的input</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">getChangedFiles</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inputChanges: <span class="type">InputChanges</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        incrementalProps: <span class="type">List</span>&lt;<span class="type">FileCollection</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> = <span class="keyword">if</span> (!inputChanges.isIncremental) &#123;</span><br><span class="line">        ChangedFiles.Unknown()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        incrementalProps</span><br><span class="line">            .fold(mutableListOf&lt;File&gt;() to mutableListOf&lt;File&gt;()) &#123; (modified, removed), prop -&gt;</span><br><span class="line">                inputChanges.getFileChanges(prop).forEach &#123;</span><br><span class="line">                    <span class="keyword">when</span> (it.changeType) &#123;</span><br><span class="line">                        ChangeType.ADDED, ChangeType.MODIFIED -&gt; modified.add(it.file)</span><br><span class="line">                        ChangeType.REMOVED -&gt; removed.add(it.file)</span><br><span class="line">                        <span class="keyword">else</span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                modified to removed</span><br><span class="line">            &#125;</span><br><span class="line">            .run &#123;</span><br><span class="line">                ChangedFiles.Known(first, second)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找改变了的classpath</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getClasspathChanges</span><span class="params">(inputChanges: <span class="type">InputChanges</span>)</span></span>: ClasspathChanges = <span class="keyword">when</span> &#123;</span><br><span class="line">        !classpathSnapshotProperties.useClasspathSnapshot.<span class="keyword">get</span>() -&gt; ClasspathSnapshotDisabled</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                !inputChanges.isIncremental -&gt; NotAvailableForNonIncrementalRun(classpathSnapshotFiles)</span><br><span class="line">                inputChanges.getFileChanges(classpathSnapshotProperties.classpathSnapshot).none() -&gt; NoChanges(classpathSnapshotFiles)</span><br><span class="line">                !classpathSnapshotFiles.shrunkPreviousClasspathSnapshotFile.exists() -&gt; &#123;</span><br><span class="line">                    NotAvailableDueToMissingClasspathSnapshot(classpathSnapshotFiles)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; ToBeComputedByIncrementalCompiler(classpathSnapshotFiles)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>KotlinCompile</code>，我们也可以从入参，出参，<code>TaskAction</code>的角度来分析</p>
<ol>
<li><code>classpathSnapshotProperties</code>是个包装类型的输入，内部包括<code>@Classpath</code>类型的输入，使用<code>@Classpath</code>输入时，如果输入文件名发生变化而内容没有发生变化时，不会触发<code>Task</code>重新运行，这对<code>classpath</code>来说非常重要</li>
<li><code>incrementalProps</code>是组件后的增量编译输入参数，包括<code>kotlin</code>输入，<code>java</code>输入，<code>classpath</code>输入等</li>
<li><code>CompileKotlin</code>的<code>TaskAction</code>，它最后会执行到<code>callCompilerAsync</code>方法，在其中通过<code>getChangedFiles</code>与<code>getClasspathChanges</code>获取改变了的输入与<code>classpath</code></li>
<li><code>getClasspathChanges</code>方法通过<code>inputChanges</code>获取一个已经改变与删除的文件的<code>Pair</code></li>
<li><code>getClasspathChanges</code>则根据增量编译是否开启，是否有文件发生更改，历史<code>snapshotFile</code>是否存在，返回不同的<code>ClassPathChanges</code>密封类</li>
</ol>
<p>在增量编译参数拼装完成后，接下来就是跟着逻辑走，最后会走到<code>GradleKotlinCompilerWork</code> 的 <code>compileWithDaemmonOrFailbackImpl</code></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a20c41dfc3f94bc5993d8a0e3d20d203~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">compileWithDaemonOrFallbackImpl</span><span class="params">(messageCollector: <span class="type">MessageCollector</span>)</span></span>: ExitCode &#123;</span><br><span class="line">  <span class="keyword">val</span> executionStrategy = kotlinCompilerExecutionStrategy()</span><br><span class="line">  <span class="keyword">if</span> (executionStrategy == DAEMON_EXECUTION_STRATEGY) &#123;</span><br><span class="line">    <span class="keyword">val</span> daemonExitCode = compileWithDaemon(messageCollector)</span><br><span class="line">    <span class="keyword">if</span> (daemonExitCode != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> daemonExitCode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> isGradleDaemonUsed = System.getProperty(<span class="string">"org.gradle.daemon"</span>)?.let(String::toBoolean)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (executionStrategy == IN_PROCESS_EXECUTION_STRATEGY || isGradleDaemonUsed == <span class="literal">false</span>) &#123;</span><br><span class="line">    compileInProcess(messageCollector)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compileOutOfProcess()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>kotlin</code>编译有三种策略，分别是     </p>
<ol>
<li>守护进程编译：<code>Kotlin</code>编译的默认模式，只有这种模式才支持增量编译，可以在多个<code>Gradle daemon</code>进程间共享</li>
<li>进程内编译：<code>Gradle daemon</code>进程内编译</li>
<li>进程外编译：每次编译都是在不同的进程</li>
</ol>
<p><code>compileWithDaemon</code> 会调用到 <code>Kotlin Compile</code> 里执行真正的编译逻辑：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> exitCode = <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> res = <span class="keyword">if</span> (isIncremental) &#123;</span><br><span class="line">    incrementalCompilationWithDaemon(daemon, sessionId, targetPlatform, bufferingMessageCollector)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nonIncrementalCompilationWithDaemon(daemon, sessionId, targetPlatform, bufferingMessageCollector)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里会执行 <code>org.jetbrains.kotlin.daemon.CompileServiceImpl</code> 的 <code>compile</code> 方法，这样就终于调到了<code>Kotlin</code>编译器内部</p>
<h3 id="第六步：Kotlin-编译器计算出需重编译的文件"><a href="#第六步：Kotlin-编译器计算出需重编译的文件" class="headerlink" title="第六步：Kotlin 编译器计算出需重编译的文件"></a>第六步：<code>Kotlin</code> 编译器计算出需重编译的文件</h3><p>经过这么多步骤，终于走到<code>Kotlin</code>编译器内部了，下面我们来看下<code>Kotlin</code>编译器的增量编译逻辑</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;ServicesFacadeT, JpsServicesFacadeT, CompilationResultsT&gt;</span> <span class="title">compileImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	CompilerMode.INCREMENTAL_COMPILER -&gt; &#123;</span><br><span class="line">	    <span class="keyword">when</span> (targetPlatform) &#123;</span><br><span class="line">	        CompileService.TargetPlatform.JVM -&gt; withIC(k2PlatformArgs) &#123;</span><br><span class="line">	            doCompile(sessionId, daemonReporter, tracer = <span class="literal">null</span>) &#123; _, _ -&gt;</span><br><span class="line">	                execIncrementalCompiler(</span><br><span class="line">	                    k2PlatformArgs <span class="keyword">as</span> K2JVMCompilerArguments,</span><br><span class="line">	                    gradleIncrementalArgs,</span><br><span class="line">	                    <span class="comment">//...</span></span><br><span class="line">	                )</span><br><span class="line">	            &#125;</span><br><span class="line">        &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，会判断输入的编译参数，如果是增量编译并且是<code>JVM</code>平台的话，就会执行<code>execIncrementalCompiler</code>方法，最后会调用到<code>sourcesToCompile</code>方法</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sourcesToCompile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    caches: <span class="type">CacheManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    changedFiles: <span class="type">ChangedFiles</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    args: <span class="type">Args</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    messageCollector: <span class="type">MessageCollector</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    dependenciesAbiSnapshots: <span class="type">Map</span>&lt;<span class="type">String</span>, AbiSnapshot&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: CompilationMode =</span><br><span class="line">    <span class="keyword">when</span> (changedFiles) &#123;</span><br><span class="line">        <span class="keyword">is</span> ChangedFiles.Known -&gt; calculateSourcesToCompile(caches, changedFiles, args, messageCollector, dependenciesAbiSnapshots)</span><br><span class="line">        <span class="keyword">is</span> ChangedFiles.Unknown -&gt; CompilationMode.Rebuild(BuildAttribute.UNKNOWN_CHANGES_IN_GRADLE_INPUTS)</span><br><span class="line">        <span class="keyword">is</span> ChangedFiles.Dependencies -&gt; error(<span class="string">"Unexpected ChangedFiles type (ChangedFiles.Dependencies)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateSourcesToCompileImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        caches: <span class="type">IncrementalJvmCachesManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        changedFiles: <span class="type">ChangedFiles</span>.<span class="type">Known</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        args: <span class="type">K2JVMCompilerArguments</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        abiSnapshots: <span class="type">Map</span>&lt;<span class="type">String</span>, AbiSnapshot&gt; = HashMap()</span></span>,</span><br><span class="line">        withAbiSnapshot: <span class="built_in">Boolean</span></span><br><span class="line">    ): CompilationMode &#123;</span><br><span class="line">      	<span class="keyword">val</span> dirtyFiles = DirtyFilesContainer(caches, reporter, kotlinSourceFilesExtensions)</span><br><span class="line">      	<span class="comment">// 初始化dirtyFiles</span></span><br><span class="line">        initDirtyFiles(dirtyFiles, changedFiles)</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 计算变化的classpath</span></span><br><span class="line">        <span class="keyword">val</span> classpathChanges = <span class="keyword">when</span> (classpathChanges) &#123;</span><br><span class="line">            <span class="keyword">is</span> NoChanges -&gt; ChangesEither.Known(emptySet(), emptySet())</span><br><span class="line">            <span class="comment">//  classpathSnapshot可用时</span></span><br><span class="line">            <span class="keyword">is</span> ToBeComputedByIncrementalCompiler -&gt; reporter.measure(BuildTime.COMPUTE_CLASSPATH_CHANGES) &#123;</span><br><span class="line">                computeClasspathChanges(</span><br><span class="line">                    classpathChanges.classpathSnapshotFiles,</span><br><span class="line">                    caches.lookupCache,</span><br><span class="line">                    storeCurrentClasspathSnapshotForReuse,</span><br><span class="line">                    ClasspathSnapshotBuildReporter(reporter)</span><br><span class="line">                ).toChangesEither()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> NotAvailableDueToMissingClasspathSnapshot -&gt; ChangesEither.Unknown(BuildAttribute.CLASSPATH_SNAPSHOT_NOT_FOUND)</span><br><span class="line">            <span class="keyword">is</span> NotAvailableForNonIncrementalRun -&gt; ChangesEither.Unknown(BuildAttribute.UNKNOWN_CHANGES_IN_GRADLE_INPUTS)</span><br><span class="line">            <span class="comment">// classpathSnapshot不可用时</span></span><br><span class="line">            <span class="keyword">is</span> ClasspathSnapshotDisabled -&gt; reporter.measure(BuildTime.IC_ANALYZE_CHANGES_IN_DEPENDENCIES) &#123;</span><br><span class="line">                <span class="keyword">val</span> lastBuildInfo = BuildInfo.read(lastBuildInfoFile)   </span><br><span class="line">                getClasspathChanges(</span><br><span class="line">                    args.classpathAsList, changedFiles, lastBuildInfo, modulesApiHistory, reporter, abiSnapshots, withAbiSnapshot,</span><br><span class="line">                    caches.platformCache, scopes</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> NotAvailableForJSCompiler -&gt; error(<span class="string">"Unexpected type for this code path: <span class="subst">$&#123;classpathChanges.javaClass.name&#125;</span>."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将结果添加到dirtyFiles</span></span><br><span class="line">        <span class="keyword">val</span> unused = <span class="keyword">when</span> (classpathChanges) &#123;</span><br><span class="line">            <span class="keyword">is</span> ChangesEither.Unknown -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> CompilationMode.Rebuild(classpathChanges.reason)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> ChangesEither.Known -&gt; &#123;</span><br><span class="line">                dirtyFiles.addByDirtySymbols(classpathChanges.lookupSymbols)</span><br><span class="line">                dirtyClasspathChanges = classpathChanges.fqNames</span><br><span class="line">                dirtyFiles.addByDirtyClasses(classpathChanges.fqNames)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> CompilationMode.Incremental(dirtyFiles)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>calculateSourcesToCompileImpl</code>的目的就是计算<code>Kotlin</code>编译器应该重新编译哪些代码，主要分为以下几个步骤</p>
<ol>
<li>初始化<code>dirtyFiles</code>，并将<code>changedFiles</code>加入<code>dirtyFiles</code>，因为<code>changedFiles</code>需要重新编译</li>
<li><code>classpathSnapshot</code>可用时，通过传入的<code>snapshot.bin</code>文件，与<code>Project</code>目录下的<code>shrunk-classpath-snapshot.bin</code>进行比较得出变化的<code>classpath</code>，以及受影响的类。在比较结束时，也会更新当前目录的<code>shrunk-classpath-snapshot.bin</code>，供下次比较使用</li>
<li>当<code>classpathSnapshot</code>不可用时，通过<code>getClasspathChanges</code>方法来判断<code>classpath</code>变化，这里面实际上是通过<code>last-build.bin</code>与<code>build-history.bin</code>来判断的，同时每次编译完成也会更新<code>build-history.bin</code></li>
<li>将受<code>classpath</code>变化影响的类也加入<code>dirtyFiles</code></li>
<li>返回<code>dirtyFiles</code>供<code>Kotlin</code>编译器真正开始编译</li>
</ol>
<p>在这一步，<code>Kotlin</code>编译器利用输入的各种参数进行分析，将需要重新编译的文件加入<code>dirtyFiles</code>，供下一步使用</p>
<h3 id="第七步：Kotlin编译器真正开始编译"><a href="#第七步：Kotlin编译器真正开始编译" class="headerlink" title="第七步：Kotlin编译器真正开始编译"></a>第七步：<code>Kotlin</code>编译器真正开始编译</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">compileImpl</span><span class="params">()</span></span>: ExitCode &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">var</span> compilationMode = sourcesToCompile(caches, changedFiles, args, messageCollector, classpathAbiSnapshot)</span><br><span class="line">    <span class="keyword">when</span> (compilationMode) &#123;</span><br><span class="line">        <span class="keyword">is</span> CompilationMode.Incremental -&gt; &#123;</span><br><span class="line">        	<span class="comment">// ...</span></span><br><span class="line">            compileIncrementally(args, caches, allSourceFiles, compilationMode, messageCollector, withAbiSnapshot)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> CompilationMode.Rebuild -&gt; rebuildReason = compilationMode.reason</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">compileIncrementally</span><span class="params">()</span></span>: ExitCode &#123;</span><br><span class="line">   	<span class="keyword">while</span> (dirtySources.any() || runWithNoDirtyKotlinSources(caches)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">val</span> (sourcesToCompile, removedKotlinSources) = dirtySources.partition(File::exists)</span><br><span class="line">        <span class="comment">// 真正进行编译</span></span><br><span class="line">        <span class="keyword">val</span> compiledSources = runCompiler(</span><br><span class="line">            sourcesToCompile, args, caches, services, messageCollectorAdapter,</span><br><span class="line">            allKotlinSources, compilationMode <span class="keyword">is</span> CompilationMode.Incremental</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exitCode == ExitCode.OK) &#123;</span><br><span class="line">        <span class="comment">// 写入`last-build.bin`</span></span><br><span class="line">        BuildInfo.write(currentBuildInfo, lastBuildInfoFile)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dirtyData = DirtyData(buildDirtyLookupSymbols, buildDirtyFqNames)</span><br><span class="line">    <span class="comment">// 写入`build-history.bin`</span></span><br><span class="line">    processChangesAfterBuild(compilationMode, currentBuildInfo, dirtyData)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exitCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要做了这么几件事：    </p>
<ol>
<li>通过<code>sourcesToCompile</code>计算出发生改变的文件后，如果可以增量编译，则进入到<code>compileIncrementally</code>     </li>
<li>从<code>dirtySouces</code>中找出需要重新编译的文件，交给<code>runCompiler</code>方法进行真正的编译</li>
<li>在编译结束之后，写入<code>last-build.bin</code>与<code>build-history.bin</code>文件，供下次编译时对比使用</li>
</ol>
<p>到这里，增量编译的流程也就基本完成了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文较为详细地介绍了<code>Kotin</code>是怎么一步步从编译入口到真正开始增量编译的，了解<code>Kotlin</code>增量编译原理可以帮助你定位为什么<code>Kotlin</code>增量编译有时会失效，也可以了解如何写出更容易命中增量编译的代码，希望对你有所帮助。</p>
<p>关于<code>Kotlin</code>增量编译还有更多的细节，本文也只是介绍了主要的流程，感兴趣的同学可直接查看<code>KGP</code>和<code>Kotlin</code>编译器的源码</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/7087832824501239821" target="_blank" rel="noopener">深入研究Android编译流程-Kotlin是如何编译的</a></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>KAE 将被正式移除，如何无缝迁移？</title>
    <url>/blog/2022/10/android-compile-speed.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>KAE 插件早在 2020 年就已经被宣布废弃了，并且将在 Kotlin 1.8 中被正式移除：<a href="https://android-developers.googleblog.com/2022/02/discontinuing-kotlin-synthetics-for-views.html" target="_blank" rel="noopener">Discontinuing Kotlin synthetics for views</a></p>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p1.png" alt></p>
<p>如上图示，移除 KAE 的代码已经被 Merge 了，因此如果我们需要升级到 Kotlin 1.8，则必须要移除 KAE</p>
<p>那么移除 KAE 后，我们该如何迁移呢？</p>
<h2 id="迁移方案"><a href="#迁移方案" class="headerlink" title="迁移方案"></a>迁移方案</h2><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p2.png" alt></p>
<p>官方的迁移方案如上所示，官方建议我们老项目迁移到 ViewBinding，老项目直接迁移到 Jetpack Compose</p>
<p>对于新代码我们当然可以这么做，但是对于大量存量代码，我们该如何迁移？由于 KAE 简单易用的特性，它在项目中经常被大量使用，要迁移如此多的存量代码，并不是一个简单的工作</p>
<h3 id="存量代码迁移方案"><a href="#存量代码迁移方案" class="headerlink" title="存量代码迁移方案"></a>存量代码迁移方案</h3><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p3.png" alt></p>
<p>KAE 存量代码主要有如图3种迁移方式</p>
<p>最简单也最直接的当然就是直接手动修改，这种方式的问题在于要迁移的代码数量庞大，迁移成本高。同时手动迁移容易出错，也不容易回测，测试不能覆盖到所有的页面，导致引入线上 bug</p>
<p>第二个方案，是把 KAE 直接从 Kotlin 源码中抽取出来单独维护，但是 KAE 中也大量依赖了 Kotlin 的源码，抽取成本较高。同时 KAE 中大量使用了 Kotlin 编译器插件的 API，而这部分 API 并没有稳定，当 K2 编译器正式发布的时候很可能还会有较大的改动，而这也带来较高的维护成本。</p>
<p>第三个方案就是本篇要重点介绍的 Kace</p>
<h2 id="Kace-是什么？"><a href="#Kace-是什么？" class="headerlink" title="Kace 是什么？"></a>Kace 是什么？</h2><p>Kace 即 kotlin-android-compatible-extensions，一个用于帮助从 kotlin-android-extensions 无缝迁移的框架</p>
<p>目前已经开源，开源地址可见：<a href="https://github.com/kanyun-inc/Kace" target="_blank" rel="noopener">https://github.com/kanyun-inc/Kace</a></p>
<p>相比其它方案，Kace 主要有以下优点</p>
<ol>
<li>接入方便，不需要手动修改旧代码，可以真正做到无缝迁移</li>
<li>与 KAE 表现一致(都支持 viewId 缓存，并在页面销毁时清除)，不会引入预期外的 bug</li>
<li>统一迁移，回测方便，如果存在问题时，应该是批量存在的，避免手动修改可能引入线上 bug 的问题</li>
<li>通过生成源码的方式兼容 KAE，维护成本低</li>
</ol>
<h2 id="快速迁移"><a href="#快速迁移" class="headerlink" title="快速迁移"></a>快速迁移</h2><p>使用 Kace 完成迁移主要分为以下几步</p>
<h3 id="1-添加插件到-classpath"><a href="#1-添加插件到-classpath" class="headerlink" title="1. 添加插件到 classpath"></a>1. 添加插件到 classpath</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式 1</span></span><br><span class="line"><span class="comment">// 传统方式，在根目录的 build.gradle.kts 中添加以下代码</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"com.kanyun.kace:kace-gradle-plugin:1.0.0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2</span></span><br><span class="line"><span class="comment">// 引用插件新方式，在 settings.gradle.kts 中添加以下代码</span></span><br><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        id(<span class="string">"com.kanyun.kace"</span>) version <span class="string">"1.0.0"</span> apply <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-应用插件"><a href="#2-应用插件" class="headerlink" title="2. 应用插件"></a>2. 应用插件</h3><p>移除<code>kotlin-android-extensions</code>插件，并添加以下代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">"com.kanyun.kace"</span>)</span><br><span class="line">    id(<span class="string">"kotlin-parcelize"</span>) <span class="comment">// 可选，当使用了`@Parcelize`注解时需要添加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-配置插件（可选）"><a href="#3-配置插件（可选）" class="headerlink" title="3. 配置插件（可选）"></a>3. 配置插件（可选）</h3><p>默认情况下 Kace 会解析模块内的每个 layout 并生成代码，用户也可以自定义需要解析的 layout</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">kace &#123;</span><br><span class="line">    whiteList = listOf() <span class="comment">// 当 whiteList 不为空时，只有 whiteList 中的 layout 才会被解析</span></span><br><span class="line">    blackList = listOf(<span class="string">"activity_main.xml"</span>) <span class="comment">// 当 blackList 不为空时，blackList 中的 layout 不会被解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过以上几步，迁移就完全啦~</p>
<h2 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h2><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p4.png" alt></p>
<p>如上所示，Kace 目前支持了以上四种最常用的类型，其他 kotlin-android-extensions 支持的类型如 android.app.Fragment, android.app.Dialog, kotlinx.android.extensions.LayoutContainer 等，由于被废弃或者使用较少，Kace 目前没有做支持</p>
<h2 id="版本兼容"><a href="#版本兼容" class="headerlink" title="版本兼容"></a>版本兼容</h2><table>
<thead>
<tr>
<th></th>
<th>Kotlin</th>
<th>AGP</th>
<th>Gradle</th>
</tr>
</thead>
<tbody>
<tr>
<td>最低支持版本</td>
<td>1.7.0</td>
<td>4.2.0</td>
<td>6.7.1</td>
</tr>
</tbody>
</table>
<p>由于 Kace 的目标是帮助开发者更方便地迁移到 Kotlin 1.8，因此 Kotlin 最低支持版本比较高</p>
<h2 id="原理解析：前置知识"><a href="#原理解析：前置知识" class="headerlink" title="原理解析：前置知识"></a>原理解析：前置知识</h2><h3 id="编译器插件是什么？"><a href="#编译器插件是什么？" class="headerlink" title="编译器插件是什么？"></a>编译器插件是什么？</h3><p>Kotlin 的编译过程，简单来说就是将 Kotlin 源代码编译成目标产物的过程，具体步骤如下图所示：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/909ba8e80597430996e4e2f2817b83a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt></p>
<p>Kotlin 编译器插件，通过利用编译过程中提供的各种Hook时机，让我们可以在编译过程中插入自己的逻辑，以达到修改编译产物的目的。比如我们可以通过 IrGenerationExtension 来修改 IR 的生成，可以通过 ClassBuilderInterceptorExtension 修改字节码生成逻辑</p>
<p>Kotlin 编译器插件可以分为 Gradle 插件，编译器插件，IDE 插件三部分，如下图所示</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f3334def17d484aab8c009cb4608935~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt></p>
<h3 id="kotlin-android-extensions-是怎么实现的"><a href="#kotlin-android-extensions-是怎么实现的" class="headerlink" title="kotlin-android-extensions 是怎么实现的"></a>kotlin-android-extensions 是怎么实现的</h3><p>我们知道，KAE 是一个 Kotlin 编译器插件，当然也可以分为 Gradle 插件，编译器插件，IDE 插件三部分。我们这里只分析 Gradle 插件与编译器插件的源码，它们的具体结构如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/987583643eb443e79b80c9d2e5680e2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
<ol>
<li><code>AndroidExtensionsSubpluginIndicator</code>是<code>KAE</code>插件的入口</li>
<li><code>AndroidSubplugin</code>用于配置传递给编译器插件的参数</li>
<li><code>AndroidCommandLineProcessor</code>用于接收编译器插件的参数</li>
<li><code>AndroidComponentRegistrar</code>用于注册如图的各种<code>Extension</code></li>
</ol>
<p>关于更细节的分析可以参阅：<a href="https://juejin.cn/post/7155491115645435917" target="_blank" rel="noopener">kotlin-android-extensions 插件到底是怎么实现的？</a></p>
<p>总的来说，其实 KAE 主要做了两件事</p>
<ol>
<li>KAE 会将 viewId 转化为 findViewByIdCached 方法调用</li>
<li>KAE 会在页面关闭时清除 viewId cache</li>
</ol>
<p>那么我们要无缝迁移，就也要实现相同的效果</p>
<h2 id="Kace-原理解析"><a href="#Kace-原理解析" class="headerlink" title="Kace 原理解析"></a>Kace 原理解析</h2><h3 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h3><p>我们首先想到的是解析 layout 自动生成扩展属性，如下图所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的代码</span></span><br><span class="line"><span class="keyword">val</span> AndroidExtensions.button1</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached&lt;Button&gt;(R.id.button1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> AndroidExtensions.buttion2</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached(R.id.button1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 Activity 添加 AndroidExtensions 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), AndroidExtensions &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> androidExtensionImpl <span class="keyword">by</span> lazy &#123; AndroidExtensionsImpl() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        lifecycle.addObserver(androidExtensionImpl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View?&gt;</span> <span class="title">findViewByIdCached</span><span class="params">(owner: <span class="type">AndroidExtensionsBase</span>, id: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> androidExtensionImpl.findViewByIdCached(id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，主要做了这么几件事：</p>
<ol>
<li>通过 gradle 插件，自动解析 layout 生成<code>AndroidExtensions</code>接口的扩展属性</li>
<li>给 Activity 添加 <code>AndroidExtensions</code> 接口</li>
<li>由于需要支持缓存，因此也需要添加一个全局的变量：<code>androidExtensionImpl</code></li>
<li>由于需要在页面关闭时清除缓存，因此也需要添加<code>lifecycle Observer</code></li>
<li>重写<code>findViewByIdCached</code>方法，将具体工作委托给<code>AndroidExtensionsImpl</code></li>
</ol>
<p>通过以上步骤，其实 KAE 的功能已经实现了，我们可以在 Activity 中通过<code>button1</code>，<code>button2</code>等 viewId 获取对应的 View</p>
<p>但是这样还是太麻烦了，修改一个页面需要添加这么多代码，还能再优化吗？</p>
<h3 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="keyword">val</span> AndroidExtensions.button1</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached&lt;Button&gt;(<span class="keyword">this</span>, R.id.button1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> AndroidExtensions.buttion2</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached(<span class="keyword">this</span>, R.id.button1)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), AndroidExtensions <span class="keyword">by</span> AndroidExtensionsImpl() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>我们通过委托简化了代码调用，只需要添加一行<code>AndroidExtensions by AndroidExtensionsImpl()</code>就可以实现迁移</li>
<li>我们不需要在初始化的时候手动添加<code>lifecycle observer</code>，这是因为我们在调用<code>findViewByIdCached</code>方法时会将<code>this</code>传递过去，因此可以在第一次调用时初始化，自动添加<code>lifecycle observer</code></li>
</ol>
<p>可以看出，现在已经比较简洁了，只需要添加一行代码就可以实现迁移，但如果项目中有几百个页面使用了 KAE 的话，改起来还是有点痛苦的，目前还不能算是真正的无缝迁移</p>
<p>那么还能再优化吗?</p>
<h3 id="第三次尝试"><a href="#第三次尝试" class="headerlink" title="第三次尝试"></a>第三次尝试</h3><p>第3次尝试就是 Kace 的最终方案，结构如图所示  </p>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p5.png" alt></p>
<p>下面我们就来介绍一下</p>
<h3 id="kace-compiler-实现"><a href="#kace-compiler-实现" class="headerlink" title="kace-compiler 实现"></a>kace-compiler 实现</h3><p>kace-compiler 是一个 Kotlin 编译器插件，它的作用是给目标类型（Activity 或者 Fragment）自动添加接口与实现</p>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p6.png" alt></p>
<p>如上所示，kace-compiler 的作用就是通过<code>KaceSyntheticResolveExtension</code>扩展添加接口，以及<code>KaceIrGenerationExtension</code>扩展添加实现</p>
<p>处理后的代码如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), AndroidExtensions &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> $$androidExtensionImpl <span class="keyword">by</span> lazy &#123; AndroidExtensionsImpl() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View?&gt;</span> <span class="title">findViewByIdCached</span><span class="params">(owner: <span class="type">AndroidExtensionsBase</span>, id: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> $$androidExtensionImpl.findViewByIdCached(id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能还记得，前面说过由于编译器插件 API 还没有稳定，因此将 KAE 抽取出来独立维护成本较高，那么我们这里为什么还使用了编译器插件呢？</p>
<p>这是因为我们这里使用的编译器插件是比较少的，生成的代码也很简单，将来维护起来并不复杂，但是可以大幅的降低迁移成本，实现真正的无缝迁移</p>
<h3 id="kace-gradle-plugin-生成代码"><a href="#kace-gradle-plugin-生成代码" class="headerlink" title="kace-gradle-plugin 生成代码"></a>kace-gradle-plugin 生成代码</h3><p>kace-gradle-plugin 的主要作用就是解析 layout 然后生成代码，生成的代码如下所示</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlinx.android.synthetic.debug.activity_main</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="keyword">val</span> AndroidExtensionsBase.button1</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached&lt;android.widget.Button&gt;(<span class="keyword">this</span>, R.id.button1)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="keyword">val</span> Activity.button1</span><br><span class="line">    <span class="keyword">get</span>() = (<span class="keyword">this</span> <span class="keyword">as</span> AndroidExtensionsBase).button1</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="keyword">val</span> Fragment.button1</span><br><span class="line">    <span class="keyword">get</span>() = (<span class="keyword">this</span> <span class="keyword">as</span> AndroidExtensionsBase).button1</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlinx.android.synthetic.main.activity_main.view</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="keyword">val</span> View.button1</span><br><span class="line">    <span class="keyword">get</span>() = findViewById&lt;android.widget.Button&gt;(R.id.button1)</span><br></pre></td></tr></table></figure>
<ol>
<li>给 Activity, Fragment, View 等类型添加扩展属性</li>
<li>给 View 添加的扩展属性目前不支持缓存，而是直接通过<code>finidViewById</code>实现</li>
<li>支持根据不同的<code>variant</code>，生成不同的<code>package</code>的代码，比如<code>debug</code></li>
</ol>
<h2 id="Kace-性能优化"><a href="#Kace-性能优化" class="headerlink" title="Kace 性能优化"></a>Kace 性能优化</h2><h3 id="明确输入输出"><a href="#明确输入输出" class="headerlink" title="明确输入输出"></a>明确输入输出</h3><p>前面介绍了 kace-gradle-plugin 的主要作用就是解析 layout 然后生成代码，但是对于一个比较大的模块，layout 可能有几百个，如果每次编译时都要运行这个 Task，会带来一定的性能损耗</p>
<p>理想情况下，在输入输出没有发生变化的情况下，应该跳过这个 Task</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/873a47d931704ee1bdfce191d260b9a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p>
<p>比如 Gradle 中内置的 JavaCompilerTask，在源码与 jdk 版本没有发生变化的时候，会自动跳过（标记为 up-to-date）</p>
<p>Gradle 需要我们明确 Task 的输入与输出是什么，这样它才能决定是否可以自动跳过这个Task，如下所示： </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KaceGenerateTask</span> : <span class="type">DefaultTask</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Internal</span></span><br><span class="line">    <span class="keyword">val</span> layoutDirs: ConfigurableFileCollection = project.files()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Incremental</span></span><br><span class="line">    <span class="meta">@get:InputFiles</span></span><br><span class="line">    <span class="meta">@get:PathSensitive</span>(PathSensitivity.RELATIVE)</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">val</span> androidLayoutResources: FileCollection = layoutDirs</span><br><span class="line">        .asFileTree</span><br><span class="line">        .matching &#123; patternFilterable -&gt;</span><br><span class="line">            patternFilterable.include(<span class="string">"**/*.xml"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Input</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> layoutVariantMap: MapProperty&lt;String, String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Input</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> namespace: Property&lt;String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:OutputDirectory</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> sourceOutputDir: DirectoryProperty    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，通过注解的方式明确了 Task 的输入输出，在输入与输出都没有发生改变的时候，该 Task 会被标记为 up-to-date ，通过编译避免的方式提高编译性能</p>
<h3 id="并行-Task"><a href="#并行-Task" class="headerlink" title="并行 Task"></a>并行 Task</h3><p><code>KaceGenerateTask</code>的主要作用其实就是解析 layout 然后生成代码，每个 layout 都是相互独立的，在这种情况下就特别适合使用并行 Task</p>
<p>要实现并行 Task，首先要将 Task 转化为 <code>Worker API</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KaceGenerateAction</span> : <span class="type">WorkAction</span>&lt;<span class="type">KaceGenerateAction.Parameters</span>&gt; </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Parameters</span> : <span class="type">WorkParameters &#123;</span></span></span><br><span class="line">        <span class="keyword">val</span> destDir: DirectoryProperty</span><br><span class="line">        <span class="keyword">val</span> layoutFile: RegularFileProperty</span><br><span class="line">        <span class="keyword">val</span> variantName: Property&lt;String&gt;</span><br><span class="line">        <span class="keyword">val</span> namespace: Property&lt;String&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> item = LayoutItem(</span><br><span class="line">            parameters.destDir.<span class="keyword">get</span>().asFile,</span><br><span class="line">            parameters.layoutFile.<span class="keyword">get</span>().asFile,</span><br><span class="line">            parameters.variantName.<span class="keyword">get</span>()</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> namespace = parameters.namespace.<span class="keyword">get</span>()</span><br><span class="line">        <span class="keyword">val</span> file = item.layoutFile</span><br><span class="line">        <span class="keyword">val</span> layoutNodeItems = parseXml(saxParser, file, logger)</span><br><span class="line">        writeActivityFragmentExtension(layoutNodeItems, item, namespace)</span><br><span class="line">        writeViewExtension(layoutNodeItems, item, namespace)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>第一步：首先我们需要定义一个接口来表示每个<code>Action</code>需要的参数，即<code>KaceGenerateAction.Parameters</code></li>
<li>第二步：您需要将自定义<code>Task</code>中为每个单独文件执行工作的部分重构为单独的类，即<code>KaceGenerateAction</code></li>
<li>第三步：您应该重构自定义<code>Task</code>类以将工作提交给 <code>WorkerExecutor</code>，而不是自己完成工作</li>
</ol>
<p>接下来就是将<code>KaceGenerateAction</code>提交给<code>WorkerExector</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KaceGenerateTask</span> : <span class="type">DefaultTask</span></span>() &#123;</span><br><span class="line">    <span class="meta">@get:Inject</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> workerExecutor: WorkerExecutor</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">action</span><span class="params">(inputChanges: <span class="type">InputChanges</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> workQueue = workerExecutor.noIsolation()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        changedLayoutItemList.forEach &#123; item -&gt;</span><br><span class="line">            workQueue.submit(KaceGenerateAction::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123; parameters -&gt;</span><br><span class="line">                parameters.destDir.<span class="keyword">set</span>(destDir)</span><br><span class="line">                parameters.layoutFile.<span class="keyword">set</span>(item.layoutFile)</span><br><span class="line">                parameters.variantName.<span class="keyword">set</span>(item.variantName)</span><br><span class="line">                parameters.namespace.<span class="keyword">set</span>(namespace)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        workQueue.await() <span class="comment">// 等待所有 Action 完成，计算耗时</span></span><br><span class="line">        <span class="keyword">val</span> duration = System.currentTimeMillis() - startTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 您需要拥有`WorkerExecutor`服务才能提交`Action`。这里我们添加了一个抽象的`workerExecutor`并添加注解，`Gradle` 将在运行时注入服务</span><br><span class="line"><span class="number">2</span>. 在提交`Action`之前，我们需要通过不同的隔离模式获取`WorkQueue`，这里使用的是线程隔离模式</span><br><span class="line"><span class="number">3</span>. 提交`Action`时，指定`Action`实现，在这种情况下调用`KaceGenerateAction`并配置其参数</span><br><span class="line"></span><br><span class="line">经过测试，在一个包括 <span class="number">500</span> 个 layout 的模块中，在开启并行 Task 前全量编译耗时约 <span class="number">4</span> 秒，而开启后全量编译耗时减少到 <span class="number">2</span> 秒左右，可以有 <span class="number">100</span>% 左右的提升</span><br><span class="line"></span><br><span class="line">### 支持增量编译</span><br><span class="line">还有一种常见的场景，当我们只修改了一个 layout 时，如果模块内的所有 layout 都需要重新解析并生成代码，也是非常浪费性能的</span><br><span class="line"></span><br><span class="line">理想情况下，应该只需要重新解析与处理我们修改的 layout 就行了，Gradle 同样提供了 API 供我们实现增量编译</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KaceGenerateTask</span> : <span class="type">DefaultTask</span></span>() &#123;</span><br><span class="line">    <span class="meta">@get:Incremental</span></span><br><span class="line">    <span class="meta">@get:InputFiles</span></span><br><span class="line">    <span class="meta">@get:PathSensitive</span>(PathSensitivity.RELATIVE)</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">val</span> androidLayoutResources: FileCollection = layoutDirs</span><br><span class="line">        .asFileTree</span><br><span class="line">        .matching &#123; patternFilterable -&gt;</span><br><span class="line">            patternFilterable.include(<span class="string">"**/*.xml"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">action</span><span class="params">(inputChanges: <span class="type">InputChanges</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> changeFiles = getChangedFiles(inputChanges, androidLayoutResources)</span><br><span class="line">        <span class="comment">// ...        </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getChangedFiles</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inputChanges: <span class="type">InputChanges</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        layoutResources: <span class="type">FileCollection</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> = <span class="keyword">if</span> (!inputChanges.isIncremental) &#123;</span><br><span class="line">        ChangedFiles.Unknown()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        inputChanges.getFileChanges(layoutResources)</span><br><span class="line">            .fold(mutableListOf&lt;File&gt;() to mutableListOf&lt;File&gt;()) &#123; (modified, removed), item -&gt;</span><br><span class="line">                <span class="keyword">when</span> (item.changeType) &#123;</span><br><span class="line">                    ChangeType.ADDED, ChangeType.MODIFIED -&gt; modified.add(item.file)</span><br><span class="line">                    ChangeType.REMOVED -&gt; removed.add(item.file)</span><br><span class="line">                    <span class="keyword">else</span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">                &#125;</span><br><span class="line">                modified to removed</span><br><span class="line">            &#125;.run &#123;</span><br><span class="line">                ChangedFiles.Known(first, second)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以下步骤，就可以实现增量编译</p>
<ol>
<li><code>androidLayoutResources</code>使用<code>@Incremental</code>注解标识，表示支持增量处理的输入</li>
<li>给<code>TaskAction</code>方法添加<code>inputChange</code>参数</li>
<li>通过<code>inputChanges</code>方法获取输入中发生了更改的文件，如果发生了更改则重新处理，如果被删除了则同样删除目标目录中的文件，没有发生更改的文件则不处理</li>
</ol>
<p>通过支持增量编译，当只修改或者添加一个 layout 时，增量编译耗时可以减少到 8ms 左右，大幅减少了编译耗时</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何使用 Kace ，以及 Kace 到底是如何实现的，如果有任何问题，欢迎提出 Issue，如果对你有所帮助，欢迎点赞收藏 Star ~</p>
<h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><p><a href="https://github.com/kanyun-inc/Kace" target="_blank" rel="noopener">https://github.com/kanyun-inc/Kace</a></p>
]]></content>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>学习一下 nowinandroid 的构建脚本</title>
    <url>/blog/2022/11/now-in-android-learn.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/android/nowinandroid" target="_blank" rel="noopener">nowinandroid</a> 项目是谷歌开源的示例项目，它遵循 Android 设计和开发的最佳实践，并旨在成为开发人员的有用参考</p>
<p>这个项目在架构演进，模块化方案，单元测试，Jetpack Compose，启动优化等多个方面都做了很好的示例，的确是一个值得学习的好项目</p>
<p>今天我们来学习一下 nowinandroid 项目的构建脚本，看一下都有哪些值得学习的地方</p>
<h2 id="gradle-properties-中的配置"><a href="#gradle-properties-中的配置" class="headerlink" title="gradle.properties 中的配置"></a>gradle.properties 中的配置</h2><p>要看一个项目的构建脚本，我们首先看一下 gradle.properties</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable configuration caching between builds.</span></span><br><span class="line"><span class="attr">org.gradle.unsafe.configuration-cache</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">android.useAndroidX</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Non-transitive R classes is recommended and is faster/smaller</span></span><br><span class="line"><span class="attr">android.nonTransitiveRClass</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable build features that are enabled by default,</span></span><br><span class="line"><span class="comment"># https://developer.android.com/studio/releases/gradle-plugin#buildFeatures</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.buildconfig</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.aidl</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.renderscript</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.resvalues</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.shaders</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>可以看出，nowinandroid 项目主要做了以下几个配置</p>
<ol>
<li>开启配置阶段缓存</li>
<li>开启 <code>androidX</code>，并且移除了 <code>Jetifier</code></li>
<li>关闭 <code>R</code> 文件传递</li>
<li>关闭 <code>build features</code></li>
</ol>
<p>前面3个配置之前都介绍过，我们来看一下关闭 <code>build features</code></p>
<p> AGP 4.0.0 引入了一种新方法来控制您要启用和停用哪些构建功能，如<code>ViewBinding</code>，<code>BuildConfig</code>。</p>
<p>我们可以在 gradle.properties 中全局开启或关闭某些功能，也可以在模块级 build.gradle 文件中为每个模块设置相应的选项，如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// The default value for each feature is shown below. You can change the value to</span></span><br><span class="line">    <span class="comment">// override the default behavior.</span></span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        <span class="comment">// Determines whether to generate a BuildConfig class.</span></span><br><span class="line">        buildConfig = <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// Determines whether to support View Binding.</span></span><br><span class="line">        <span class="comment">// Note that the viewBinding.enabled property is now deprecated.</span></span><br><span class="line">        viewBinding = <span class="keyword">false</span></span><br><span class="line">        <span class="comment">// Determines whether to support Data Binding.</span></span><br><span class="line">        <span class="comment">// Note that the dataBinding.enabled property is now deprecated.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过停用不需要的构建可能，可以提升我们的构建性能，比如我们最熟悉的<code>BuildConfig</code>，每个模块都会生成这样一个类，但其实我们在绝大多数情况下是用不到的，因此其实可以将其默认关闭（在 AGP 8.0 中 BuildConfig 生成已经变成默认关闭了）</p>
<h2 id="自动安装-git-hook"><a href="#自动安装-git-hook" class="headerlink" title="自动安装 git hook"></a>自动安装 git hook</h2><p>有时我们会添加一些 git hook，用于在代码提交或者 push 时做一些检查</p>
<p>但使用 git hook 的一个问题在于，每次拉取新项目之后，都需要手动安装一下 git hook，这一点常常容易被忘记</p>
<p>那么有没有什么办法可以自动安装 git hook 呢？nowinandroid 项目提供了一个示例</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">// settings.gradle.kts</span></span><br><span class="line"></span><br><span class="line">val prePushHook = <span class="keyword">file</span>(<span class="string">".git/hooks/pre-push"</span>)</span><br><span class="line">val commitMsgHook = <span class="keyword">file</span>(<span class="string">".git/hooks/commit-msg"</span>)</span><br><span class="line">val hooksInstalled = commitMsgHook.<span class="keyword">exists</span>()</span><br><span class="line">    &amp;&amp; prePushHook.<span class="keyword">exists</span>()</span><br><span class="line">    &amp;&amp; prePushHook.readBytes().contentEquals(<span class="keyword">file</span>(<span class="string">"tools/pre-push"</span>).readBytes())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!hooksInstalled) &#123;</span><br><span class="line">    <span class="keyword">exec</span> &#123;</span><br><span class="line">        <span class="keyword">commandLine</span>(<span class="string">"tools/setup.sh"</span>)</span><br><span class="line">        workingDir = rootProject.projectDir</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实原理很简单，在<code>settings.gradle.kts</code>中添加以上代码，这样在 Gradle 同步时，就会自动判断 git hook 有没有被安装，如果没有被安装则自动安装</p>
<h2 id="使用-includeBuild-而不是-buildSrc"><a href="#使用-includeBuild-而不是-buildSrc" class="headerlink" title="使用 includeBuild 而不是 buildSrc"></a>使用 includeBuild 而不是 buildSrc</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pluginManagement</span> &#123;</span><br><span class="line">    <span class="selector-tag">includeBuild</span>(<span class="string">"build-logic"</span>)</span><br><span class="line">    <span class="selector-tag">repositories</span> &#123;</span><br><span class="line">        <span class="selector-tag">google</span>()</span><br><span class="line">        <span class="selector-tag">mavenCentral</span>()</span><br><span class="line">        <span class="selector-tag">gradlePluginPortal</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了支持在不同的模块间共享构建逻辑，此前我们常常会添加一个 buildSrc 模块</p>
<p>但是 buildSrc 模块的问题在于每次发生修改都会导致项目的绝大多数缓存失效，从而导致构建速度变得极慢</p>
<p>因此官方现在更推荐我们使用 includeBuild，比如 nowinandroid 的构建逻辑就通过 includeBuild 放在了 <code>build-logic</code> 目录</p>
<h2 id="如何复用-build-gradle-代码"><a href="#如何复用-build-gradle-代码" class="headerlink" title="如何复用 build.gradle 代码"></a>如何复用 build.gradle 代码</h2><p>其实我们项目中的各个模块的 build.gradle 中的代码，大部分是重复的，做的都是一些重复的配置，当要修改时就需要一个一个去修改了</p>
<p>nowinandroid 通过抽取重复配置的方式大幅度的减少了 build.gradle 中的代码，如下所示</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">   <span class="built_in"> id</span>(<span class="string">"nowinandroid.android.feature"</span>)</span><br><span class="line">   <span class="built_in"> id</span>(<span class="string">"nowinandroid.android.library.compose"</span>)</span><br><span class="line">   <span class="built_in"> id</span>(<span class="string">"nowinandroid.android.library.jacoco"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="type">namespace</span> = <span class="string">"com.google.samples.apps.nowinandroid.feature.author"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(libs.kotlinx.datetime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 nowinandroid 的一个 feature 模块，可以看出除了每个模块不同的<code>namespace</code>与各个模块的依赖之外，其他的内容都抽取到<code>nowinandroid.android.feature</code>等插件中去了，而这些插件的代码都存放在<code>build-logic</code> 目录中，通过 includeBuild 引入，大家可自行查看</p>
<p>总得来说，通过这种方式可以大幅减少重复配置代码，当配置需要迁移时也更加方便</p>
<h2 id="使用-Version-Catalog"><a href="#使用-Version-Catalog" class="headerlink" title="使用 Version Catalog"></a>使用 Version Catalog</h2><p>在 build.gradle 中添加依赖有以下几个痛点</p>
<ol>
<li>项目依赖统一管理，在单独文件中配置</li>
<li>不同Module中的依赖版本号统一</li>
<li>添加依赖时支持代码提示</li>
</ol>
<p>针对这几种需求，Gradle7.0 推出了一个新的特性，使用 Version Catalog 统一依赖版本，它支持以下特性：</p>
<ul>
<li>对所有 module 可见，可统一管理所有module的依赖</li>
<li>支持声明依赖bundles,即总是一起使用的依赖可以组合在一起</li>
<li>支持版本号与依赖名分离，可以在多个依赖间共享版本号</li>
<li>支持在单独的libs.versions.toml文件中配置依赖</li>
<li>支持代码提示(仅 kts)</li>
</ul>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p9.jpg" alt></p>
<p>noinandroid 中目前已经全面启用了 Version Catalog，如上所示，统一依赖版本，支持代码提示，体验还是不错的</p>
<p>关于 Version Catalog 的具体使用可以查看：<a href="https://juejin.cn/post/6997396071055900680" target="_blank" rel="noopener">【Gradle7.0】依赖统一管理的全新方式，了解一下~</a></p>
<h2 id="代码格式检查"><a href="#代码格式检查" class="headerlink" title="代码格式检查"></a>代码格式检查</h2><p>nowinandroid 作为一个开源项目，不可避免地会有第三方贡献一些代码，因此也需要在代码合并前做一些格式检查，保证代码风格的统一</p>
<p>nowinandroid 通过 spotless 来检查代码格式，主要是通过两种方式触发    </p>
<ol>
<li>通过上面提到的 git hook，在代码 push 时触发检查</li>
<li>通过 github workflow，在代码 push 到 main 分支时触发检查</li>
</ol>
<p>上面两种方式都会调用以下命令</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./gradlew</span> spotlessCheck <span class="params">--init-script</span> gradle/init.gradle.kts <span class="params">--no-configuration-cache</span> <span class="params">--stacktrace</span></span><br></pre></td></tr></table></figure>
<p>可以看出，这里主要是执行 spotlessCheck 任务，并且指定了 init-script，我们来看一下 init.gradle.kts 里面做了什么</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init.gradle.kts</span></span><br><span class="line">rootProject &#123;</span><br><span class="line">    subprojects &#123;</span><br><span class="line">        apply&lt;com<span class="selector-class">.diffplug</span><span class="selector-class">.gradle</span><span class="selector-class">.spotless</span>.SpotlessPlugin&gt;()</span><br><span class="line">        extensions.configure&lt;com<span class="selector-class">.diffplug</span><span class="selector-class">.gradle</span><span class="selector-class">.spotless</span>.SpotlessExtension&gt; &#123;</span><br><span class="line">            kotlin &#123;</span><br><span class="line">                target(<span class="string">"**/*.kt"</span>)</span><br><span class="line">                targetExclude(<span class="string">"**/build/**/*.kt"</span>)</span><br><span class="line">                ktlint(ktlintVersion).userData(mapOf(<span class="string">"android"</span> to <span class="string">"true"</span>))</span><br><span class="line">                licenseHeaderFile(rootProject.file(<span class="string">"spotless/copyright.kt"</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            format(<span class="string">"kts"</span>) &#123;</span><br><span class="line">                target(<span class="string">"**/*.kts"</span>)</span><br><span class="line">                targetExclude(<span class="string">"**/build/**/*.kts"</span>)</span><br><span class="line">                <span class="comment">// Look for the first line that doesn't have a block comment (assumed to be the license)</span></span><br><span class="line">                licenseHeaderFile(rootProject.file(<span class="string">"spotless/copyright.kts"</span>), <span class="string">"(^(?![\\/ ]\\*).*$)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            format(<span class="string">"xml"</span>) &#123;</span><br><span class="line">                target(<span class="string">"**/*.xml"</span>)</span><br><span class="line">                targetExclude(<span class="string">"**/build/**/*.xml"</span>)</span><br><span class="line">                <span class="comment">// Look for the first XML tag that isn't a comment (&lt;!--) or the xml declaration (&lt;?xml)</span></span><br><span class="line">                licenseHeaderFile(rootProject.file(<span class="string">"spotless/copyright.xml"</span>), <span class="string">"(&lt;[^!?])"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里指定了对于 kotlin , kts , xml 等文件的格式要求，比如 kotlin 代码需要遵守 ktlint 规范，并且文件开头必须是 license 声明</p>
<h2 id="自定义-lint-检查"><a href="#自定义-lint-检查" class="headerlink" title="自定义 lint 检查"></a>自定义 lint 检查</h2><p>除了代码风格的统一，nowinandroid 项目还自定义了一些 lint 检查，跟 spoltess 一样，也是通过 git hook 与 github workflow 两种方式触发，两种方式都会触发以下代码</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./gradlew</span> lintDemoDebug <span class="params">--stacktrace</span></span><br></pre></td></tr></table></figure>
<p>nowinandroid 中有一个自定义的 lint 模块，自定义 lint 规则就定义在这里，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesignSystemDetector</span> : <span class="type">Detector</span></span>(), Detector.UastScanner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createUastHandler</span><span class="params">(context: <span class="type">JavaContext</span>)</span></span>: UElementHandler &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">object</span> : UElementHandler() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitCallExpression</span><span class="params">(node: <span class="type">UCallExpression</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> name = node.methodName ?: <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">val</span> preferredName = METHOD_NAMES[name] ?: <span class="keyword">return</span></span><br><span class="line">                reportIssue(context, node, name, preferredName)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitQualifiedReferenceExpression</span><span class="params">(node: <span class="type">UQualifiedReferenceExpression</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> name = node.receiver.asRenderString()</span><br><span class="line">                <span class="keyword">val</span> preferredName = RECEIVER_NAMES[name] ?: <span class="keyword">return</span></span><br><span class="line">                reportIssue(context, node, name, preferredName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmField</span></span><br><span class="line">        <span class="keyword">val</span> ISSUE: Issue = Issue.create(</span><br><span class="line">            id = <span class="string">"DesignSystem"</span>,</span><br><span class="line">            briefDescription = <span class="string">"Design system"</span>,</span><br><span class="line">            explanation = <span class="string">"This check highlights calls in code that use Compose Material "</span> +</span><br><span class="line">                <span class="string">"composables instead of equivalents from the Now in Android design system "</span> +</span><br><span class="line">                <span class="string">"module."</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unfortunately :lint is a Java module and thus can't depend on the :core-designsystem</span></span><br><span class="line">        <span class="comment">// Android module, so we can't use composable function references (eg. ::Button.name)</span></span><br><span class="line">        <span class="comment">// instead of hardcoded names.</span></span><br><span class="line">        <span class="keyword">val</span> METHOD_NAMES = mapOf(</span><br><span class="line">            <span class="string">"MaterialTheme"</span> to <span class="string">"NiaTheme"</span>,</span><br><span class="line">            <span class="string">"Button"</span> to <span class="string">"NiaFilledButton"</span>,</span><br><span class="line">            <span class="string">"OutlinedButton"</span> to <span class="string">"NiaOutlinedButton"</span>,</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> RECEIVER_NAMES = mapOf(</span><br><span class="line">            <span class="string">"Icons"</span> to <span class="string">"NiaIcons"</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">reportIssue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            context: <span class="type">JavaContext</span>, node: <span class="type">UElement</span>, name: <span class="type">String</span>, preferredName: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span> &#123;</span><br><span class="line">            context.report(</span><br><span class="line">                ISSUE, node, context.getLocation(node),</span><br><span class="line">                <span class="string">"Using <span class="variable">$name</span> instead of <span class="variable">$preferredName</span>"</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总得来说，这个自定义规则是检查是否使用了 Compose 的默认 Material 组件而没有使用 nowinandroid 封装好的组件，如果检查不通过则会抛出异常，提醒开发者修改</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 nowinandroid 项目构建脚本中的一系列小技巧，具体包括以下内容</p>
<ol>
<li>gradle.properties 中的配置</li>
<li>自动安装 git hook</li>
<li>使用 includeBuild 而不是 buildSrc</li>
<li>如何复用 build.gradle 代码</li>
<li>使用 Version Catalog</li>
<li>代码格式检查</li>
<li>自定义 lint 检查</li>
</ol>
<p>希望对你有所帮助~</p>
<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/android/nowinandroid" target="_blank" rel="noopener">https://github.com/android/nowinandroid</a></p>
]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>江同学的 2022 年终总结，请查收~</title>
    <url>/blog/2022/12/2022-sum-up.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼间 2022 年也要过去了，今年也是坚持写年终总结的第 3 年，这个好习惯还是要保持下去。</p>
<p>古人说，述往事，思来者，岁末年终，正是总结盘点过去一年的收获并立下新的一年的<code>Flag</code>的时候~</p>
<h2 id="2021-年立下的-Flag"><a href="#2021-年立下的-Flag" class="headerlink" title="2021 年立下的 Flag"></a>2021 年立下的 Flag</h2><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/december/p1.jpg" alt></p>
<p>去年的 Flag 就立在这里，下面我们来看下今年的完成情况</p>
<ul>
<li>[x] <del>持续输出，掘金升级到<code>LV5</code></del></li>
<li>[x] <del>坚持开源，<code>Github</code>的<code>Star</code>数突破1000</del></li>
<li>[x] <del>维护一个技术公众号，并突破500粉丝</del></li>
<li>[ ] 计算机基础巩固，继续学习操作系统，计算机网络，数据结构等知识</li>
<li>[ ] 继续深入学习<code>Compose</code>原理并输出，继续开源<code>Compose</code>项目</li>
<li>[x] <del>掌握一种跨平台技术，<code>Flutter</code>或者前端技术</del></li>
<li>[x] <del>继续坚持<code>ARTS</code>打卡，坚持每周总结与下周规划</del></li>
</ul>
<p>可以看出，大概完成了<code>70%</code>吧，我感觉对于一年的长期计划来说，完成度算还行吧<br>其中<code>Compose</code>因为项目中没有引入，所以今年没有做进一步的研究，至于计算机基础巩固也一直没有抽出时间来做，总是被其他事情打断</p>
<h2 id="2022-年的收获"><a href="#2022-年的收获" class="headerlink" title="2022 年的收获"></a>2022 年的收获</h2><h3 id="社区活动"><a href="#社区活动" class="headerlink" title="社区活动"></a>社区活动</h3><h4 id="北京-DevFest"><a href="#北京-DevFest" class="headerlink" title="北京 DevFest"></a>北京 DevFest</h4><p>由于疫情原因，北京 DevFest 是这几年第一次参加线下社区活动，面基了不少网友，也终于见识了很多关注已久的大佬的庐山真面目。</p>
<p>同时客串了一下 Compose Camp 代码工作坊的助教，顺便白嫖了谷歌周边大礼包</p>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/december/p2.jpg" alt></p>
<h4 id="北京-Kotlin-用户组"><a href="#北京-Kotlin-用户组" class="headerlink" title="北京 Kotlin 用户组"></a>北京 Kotlin 用户组</h4><p>今年也开始接手北京 Kotlin 用户组的组织工作，首先简单介绍一下<a href="https://beijing-kug.github.io/" target="_blank" rel="noopener">北京 Kotlin 用户组</a></p>
<ul>
<li>北京 Kotlin 用户组是一个交流 Kotlin 相关技术的平台，欢迎所有对 Kotlin 感兴趣的开发者加入用户组</li>
<li>在这里可以和其它成员一起讨论 Kotlin 语言的各项技术与最新特性</li>
<li>我们还会不定期举行分享会，进行与 Kotlin 相关的主题分享与讨论</li>
</ul>
<p>如果你想要加入的话，可以关注微信公众号“程序员江同学”，点击技术讨论，加入技术交流群</p>
<h3 id="开源与分享"><a href="#开源与分享" class="headerlink" title="开源与分享"></a>开源与分享</h3><p>今年主要进行了两场线上分享，分别在年初与年末</p>
<h4 id="社区说分享"><a href="#社区说分享" class="headerlink" title="社区说分享"></a>社区说分享</h4><p>上半年参与了谷歌社区说的分享活动，分享的主题是： Android 架构演进之 MVI 详解</p>
<p>主要包括以下内容</p>
<ul>
<li>MVI架构到底是什么?</li>
<li>MVI 架构的使用介绍与示例</li>
<li>MVI架构在Compose中的应用</li>
<li>MVI架构在KMP中的应用</li>
</ul>
<p>感兴趣的同学可以查看视频回放：<a href="https://www.bilibili.com/video/BV1x5411D7sA/" target="_blank" rel="noopener">「社区说」《Android 架构演进之 MVI 详解》</a></p>
<p>也可以查看示例项目：<a href="https://github.com/RicardoJiang/android-architecture" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-architecture</a></p>
<h4 id="Kace-插件分享"><a href="#Kace-插件分享" class="headerlink" title="Kace 插件分享"></a>Kace 插件分享</h4><p>Kace 即 kotlin-android-compatible-extensions，一个用于帮助从 kotlin-android-extensions 无缝迁移的框架</p>
<p>kotlin-android-extensions 框架已经过时了很久，并且将在 Kotlin 1.8 中被正式移除</p>
<p>对于新代码，我们可以使用 ViewBinding 等方式替换，但是大量存量代码的迁移，对于开发者来说不是一个轻松的工作</p>
<p>为此，我们团队开发了 Kace 框架, 帮助开发者实现 kotlin-android-extensions 插件的无缝迁移</p>
<p>目前 Kace 已经开源，开源地址：<a href="https://github.com/kanyun-inc/Kace" target="_blank" rel="noopener">https://github.com/kanyun-inc/Kace</a></p>
<p>关于 Kace 的使用与原理解析，也可以查看视频回放：<a href="https://www.bilibili.com/video/BV1r841187RV/" target="_blank" rel="noopener">KAE将被正式移除，如何无缝迁移？</a></p>
<h3 id="写作与输出"><a href="#写作与输出" class="headerlink" title="写作与输出"></a>写作与输出</h3><p>我一直认为输出是一种最好的学习方式，通过写作的方式，将你学习的东西总结输出，可以帮助你更好的理解与掌握知识点，这种方式其实就是“费曼学习法”</p>
<p>今年同样是坚持写博客的一年，主要的输出平台是在掘金与微信公众号</p>
<p>今年在掘金共输出 35 篇博客，创作者等级也升到了 LV5，完成了去年立的 Flag</p>
<p>同时今年也有幸成为了掘金签约作者，本次签约要求以专栏的形式输出，因此这也促使我去思考如何输出一些成体系的内容，这也是我本次签约最大的收获</p>
<p>我输出的内容主要是 Android 编译期相关的一些技术，详情可见专栏：<a href="https://juejin.cn/column/7140249609728688135" target="_blank" rel="noopener">Android编译期那些事~</a></p>
<p>这个专栏的目标是专注于 Android 编译期相关技术，具体包括以下内容：  </p>
<ul>
<li>AGP ，KGP 等常用插件的原理解析</li>
<li>Gradle 进阶内容及常用插件分享</li>
<li>字节码插桩技术如 ASM 等分享 </li>
<li>Kotlin 编译期相关技术如 KCP ，KSP等分享</li>
<li>编译速度优化相关分享</li>
</ul>
<p>目前专栏内容也只是包括了其中一部分内容，希望明年能继续完善补充相关内容</p>
<p>今年也开始运营微信公众号：“程序员江同学”，今年在微信公众号共输出 32 篇文章，涨粉数量也达到了年初的目标，不过还是少的可怜，哈哈~</p>
<h2 id="2023-年的展望"><a href="#2023-年的展望" class="headerlink" title="2023 年的展望"></a>2023 年的展望</h2><p>接下来再立下 2023 年的 Flag 吧，看看明年能实现多少~</p>
<ul>
<li>持续输出，掘金升级到 LV6</li>
<li>继续维护公众号，并突破2000粉丝</li>
<li>坚持开源，Github 的 Star 数突破 2000</li>
<li>北京 Kotlin 用户组多组织几场活动</li>
<li>继续完善”Android编译期那些事”专栏</li>
<li>继续完善 android-workflow 项目</li>
<li>继续学习 JNI 和性能优化相关知识</li>
<li>最后，希望以上都能实现</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一路总结下来，看起来今年过得还挺充实的，2022 年即将过去了，我将会怀念它</p>
<p>最后，提前祝大家新年快乐吧，祝大家在新的一年里，身体健康，工作顺利~</p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Native Hook 快速上手</title>
    <url>/blog/2023/03/native-hook-start.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hook 原意是指钩子，它表示的就是在某个函数的上下文做自定义的处理来实现我们想要的黑科技</p>
<p>大家可能比较熟悉 Java 层的一些 Hook 技术，比如反射，动态代理，或者 ASM 字节码插桩</p>
<p>在 Java 层之外，Android 系统还有很大一部分属于 Native 层，有时不可避免的需要用到 Native Hook 技术</p>
<p>本文主要介绍 Native Hook 是什么，以及如何通过一个例子快速上手</p>
<h2 id="Native-Hook-是什么？"><a href="#Native-Hook-是什么？" class="headerlink" title="Native Hook 是什么？"></a>Native Hook 是什么？</h2><p>Native Hook 技术通常有以下两种实现方式</p>
<ul>
<li>PLT Hook：通过修改 GOT 表，将目标函数的地址指向自定义的 Hook 函数的地址，从而拦截和修改目标函数的行为。</li>
<li>Inline Hook：直接将函数开始处的指令更替为跳转指令，使得原函数直接跳转到 Hook 的目标函数函数</li>
</ul>
<p>我们下面来分别介绍一下</p>
<h3 id="PLT-Hook"><a href="#PLT-Hook" class="headerlink" title="PLT Hook"></a>PLT Hook</h3><p>PLT Hook 用一句描述就是：通过修改 GOT 表，将目标函数的地址指向自定义的 Hook 函数的地址，从而拦截和修改目标函数的行为。那么 GOT 表是什么呢？这需要我们对 SO 库文件的 ELF 文件格式和动态链接过程有所了解。</p>
<p>ELF(Executable and Linkable Format) 文件格式是一种可执行文件和可链接文件格式，它是现代Unix和Linux系统上最常见的二进制文件格式之一，so 库其实就是一个 ELF 文件</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p1.png" alt></p>
<p>ELF 文件格式也比较复杂，我们这里主要关心<code>.plt</code>与<code>.got</code>两个表</p>
<ul>
<li>The Global Offset Table/全局偏移量表 (GOT)。简单来说就是在数据段的地址表，假定我们有一些代码段的指令引用一些地址变量，编译器会引用 GOT 表来替代直接引用绝对地址，因为绝对地址在编译期是无法知道的，只有重定位后才会得到 ，GOT 自己本身将会包含函数引用的绝对地址。</li>
<li>The Procedure Linkage Table/过程链接表 (PLT)。PLT 不同于 GOT，它位于代码段，动态库的每一个外部函数都会在 PLT 中有一条记录，每一条 PLT 记录都是一小段可执行代码。一般来说，外部代码都是在调用 PLT 表里的记录，然后 PLT 的相应记录会负责调用实际的函数。我们一般把这种设定叫作“蹦床”（Trampoline）。</li>
</ul>
<p>简单来说，对于其它 so 中的函数，在编译期无法确定其地址，只有在运行时才能获取，因此需要查询 GOT 表来查询外部函数的绝对地址。外部库函数的绝对地址在 got 表中的初始值都是 0 ，只有当实际调用这个函数时，Linker 程序才会写入实际的地址。</p>
<p>因此如果我们想要实现 native hook，只需要把 got 表中的目标函数的地址修改为我们自定义的地址即可。</p>
<p>那么在这个过程中，PLT 表的作用又是什么呢？</p>
<p>实际上，在函数调用的过程中，会先跳转到 PLT 表，它位于代码段，每一条 PLT 记录都是一小段可执行代码，这段代码会查询 GOT 表，获取真实地址然后跳转对应的函数</p>
<p>听起来有些多此一举，实际上 PLT 表可以起到延迟绑定的作用，只有当真正调用目标函数时，got 表中才会去绑定真实地址，如果没有调用则不绑定。因为很多函数可能在程序执行完时都不会被用到，那么一开始把所有函数都链接好实际是一种浪费。这就是 PLT 表起到的作用</p>
<p>因此在 So 中调用外部函数的实际过程如下所示:</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p2.jpg" alt></p>
<p>在了解了 PLT HOOK 的基本原理之后，其实我们可以自己解析 got 表然后替换为自定义的函数地址实现 hook，也可以使用一些已经比较成熟的库</p>
<ul>
<li><a href="https://github.com/bytedance/bhook" target="_blank" rel="noopener">https://github.com/bytedance/bhook</a>    </li>
<li><a href="https://github.com/iqiyi/xHook" target="_blank" rel="noopener">https://github.com/iqiyi/xHook</a></li>
</ul>
<p>本文后面的实战都是使用 bhook 实现 hook的</p>
<h3 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h3><p>从上面的介绍我们可以看出，PLT Hook 存在一定的局限性，它只能 hook 外部 so 的调用，但如果要 hook 当前的 so 呢？</p>
<p>Hook so 内部调用可以通过 Inline Hook 实现</p>
<p>Inline Hook 是通过在程序运行时动态修改内存中的汇编指令，来改变程序执行流程的一种 Hook 方式，它的基本原理是直接将函数开始处的指令更替为跳转指令，使得原函数直接跳转到 Hook 的目标函数函数，并保留被覆盖的原指令以完成后续再调用回来的目的。</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p3.png" alt></p>
<p>Inline Hook 的基本流程如上所示，主要分为以下几步</p>
<ol>
<li>拷贝原函数的头部两条汇编指令，并覆盖成跳转到自定义函数的指令</li>
<li>执行自定义函数，再执行前面被覆盖的两条指令</li>
<li>执行后续指令</li>
</ol>
<p>与 PLT Hook 方式相比，Inline Hook 更加强大，几乎可以 Hook 任何函数，但由于其实现十分复杂，需要直接修改汇编指令，因此会有很多兼容性问题，不太稳定，因此如果想要使用的话推荐直接使用相应的开源库，比如字节开源的：<a href="https://github.com/bytedance/android-inline-hook" target="_blank" rel="noopener">https://github.com/bytedance/android-inline-hook</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总得来说，两种 Native Hook 方式各有优劣，可根据实际情况使用</p>
<ul>
<li>PLT HooK的优点在于稳定，缺点则在于只能 Hook 外部函数的调用</li>
<li>Inline Hook的优点在于可以 hook so 内部调用，缺点则在于不够稳定，存在一定的兼容问题</li>
</ul>
<h2 id="Native-Hook-实战"><a href="#Native-Hook-实战" class="headerlink" title="Native Hook 实战"></a>Native Hook 实战</h2><p>接下来我们通过 Native Hook 技术来实现对 Native 内存申请的监控，主要支持以下功能</p>
<ol>
<li>添加对 malloc, free 函数的 hook，支持统计 so 的内存申请与释放情况</li>
<li>当申请超大内存时，支持获取 native 堆栈以定位问题</li>
<li>直接获取的 native 堆栈是个 16 进制数组，无法看出有效信息，因此还需要将解析堆栈还原出 so 名与函数信息</li>
</ol>
<h3 id="Hook-函数"><a href="#Hook-函数" class="headerlink" title="Hook 函数"></a>Hook 函数</h3><p>我们这里通过 bhook 库来实现对 malloc, free 函数的 hook，如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc_proxy</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    BYTEHOOK_STACK_SCOPE();</span><br><span class="line">    Dl_info callerInfo = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (dladdr(__builtin_return_address(<span class="number">0</span>), &amp;callerInfo)) &#123;</span><br><span class="line">    	<span class="comment">// 统计分配的内存</span></span><br><span class="line">        onMalloc(callerInfo.dli_fname, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">void</span> *object = BYTEHOOK_CALL_PREV(malloc_proxy, len);</span><br><span class="line">    objMap[object] = len;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_proxy</span><span class="params">(<span class="keyword">void</span> *__ptr)</span> </span>&#123;</span><br><span class="line">    BYTEHOOK_STACK_SCOPE();</span><br><span class="line">    Dl_info callerInfo = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (dladdr(__builtin_return_address(<span class="number">0</span>), &amp;callerInfo)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> len = objMap.<span class="built_in">find</span>(__ptr);</span><br><span class="line">        <span class="comment">// 统计 free的内存</span></span><br><span class="line">        onFree(callerInfo.dli_fname, len-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BYTEHOOK_CALL_PREV(free_proxy, __ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bytehook_hook_all(<span class="literal">nullptr</span>, <span class="string">"malloc"</span>, (<span class="keyword">void</span> *) malloc_proxy,</span><br><span class="line">                      <span class="literal">nullptr</span>,</span><br><span class="line">                      <span class="literal">nullptr</span>);</span><br><span class="line">    bytehook_hook_all(<span class="literal">nullptr</span>, <span class="string">"free"</span>, (<span class="keyword">void</span> *) free_proxy,</span><br><span class="line">                      <span class="literal">nullptr</span>,</span><br><span class="line">                      <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hook 的逻辑非常简单，通过调用<code>bytehook_hook_all</code>，指定要<code>hook</code>的方法与代理方法，所有的<code>malloc</code>方法调用都会被代理到<code>malloc_proxy</code>方法，所有的<code>free</code>方法调用也会被代理到<code>free_proxy</code>方法中</p>
<p>然后我们在代理方法中加入 so 分配与回收内存的监控，就可以统计出一个 so 库一共申请了多少内存，释放了多少内存，打印出来的日志如下所示</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">So</span> /apex/com.<span class="keyword">android.art/lib64/libart-compiler.so </span>allocated <span class="number">581632</span> <span class="keyword">bytes, </span>freed <span class="number">2883686</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.art/lib64/libc++.so </span>allocated <span class="number">2779694</span> <span class="keyword">bytes, </span>freed <span class="number">2640</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.art/lib64/liblzma.so </span>allocated <span class="number">9071256</span> <span class="keyword">bytes, </span>freed <span class="number">9071256</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.i18n/lib64/libicuuc.so </span>allocated <span class="number">36428</span> <span class="keyword">bytes, </span>freed <span class="number">1164</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.runtime/lib64/bionic/libc.so </span>allocated <span class="number">33360</span> <span class="keyword">bytes, </span>freed <span class="number">0</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.vndk.v30/lib64/libc++.so </span>allocated <span class="number">10944</span> <span class="keyword">bytes, </span>freed <span class="number">0</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/<span class="meta">data</span>/app/~~<span class="number">6</span>Mf4VQY4K16aFji1rZ4dkg==/com.zj.<span class="keyword">android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libandroid-performance.so </span>allocated <span class="number">184549424</span> <span class="keyword">bytes, </span>freed <span class="number">184549424</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/<span class="meta">data</span>/app/~~<span class="number">6</span>Mf4VQY4K16aFji1rZ4dkg==/com.zj.<span class="keyword">android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libmemory-hook.so </span>allocated <span class="number">3310960</span> <span class="keyword">bytes, </span>freed <span class="number">2776978</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libbinder.so allocated <span class="number">129408</span> <span class="keyword">bytes, </span>freed <span class="number">462200</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libc++.so allocated <span class="number">14428072</span> <span class="keyword">bytes, </span>freed <span class="number">864</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libhwui.so allocated <span class="number">725687</span> <span class="keyword">bytes, </span>freed <span class="number">11980415</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libutils.so allocated <span class="number">1896281</span> <span class="keyword">bytes, </span>freed <span class="number">2132345</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libz.so allocated <span class="number">565024</span> <span class="keyword">bytes, </span>freed <span class="number">565024</span> <span class="keyword">bytes</span></span><br></pre></td></tr></table></figure>
<h3 id="获取-native-堆栈"><a href="#获取-native-堆栈" class="headerlink" title="获取 native 堆栈"></a>获取 native 堆栈</h3><p>除了统计 So 内存使用情况之外，在申请超大内存时，我们也可以获取 native 堆栈以方便定位问题</p>
<p>目前，在 Android 中获取 Native 堆栈的方法基本上都是通过 CFI 来实现的。CFI 代表 Call Frame Information，即帧调用信息。在程序运行时，当 Native 函数执行进入栈指令时，它会将对应指令的信息（即 CFI ）写入 so 文件中的 .eh_frame 和 .eh_frame_hdr 段中，这两个段是 so 文件中的段之一。因此，要获取 Native 堆栈，只需要读取这两个段中的数据即可。</p>
<p>在 Android 系统中，我们可以使用 libunwind 库来直接获取 Native 堆栈信息，其底层原理实际上也是通过读取 CFI 来实现的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unwind.h&gt; //引入 unwind 库</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backtrace_stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> **current;</span><br><span class="line">    <span class="keyword">void</span> **<span class="built_in">end</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> _Unwind_Reason_Code <span class="title">unwind_callback</span><span class="params">(struct _Unwind_Context *context, <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *state = (struct backtrace_stack *) (data);</span><br><span class="line">    <span class="keyword">uintptr_t</span> pc = _Unwind_GetIP(context);  <span class="comment">// 获取 pc 值，即绝对地址</span></span><br><span class="line">    <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;current == state-&gt;<span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *state-&gt;current++ = (<span class="keyword">void</span> *) (pc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">fill_backtraces_buffer</span><span class="params">(<span class="keyword">void</span> **<span class="built_in">buffer</span>, <span class="keyword">int</span> <span class="built_in">max</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backtrace_stack</span> <span class="title">stack</span> = &#123;</span><span class="built_in">buffer</span>, <span class="built_in">buffer</span> + <span class="built_in">max</span>&#125;;</span><br><span class="line">    _Unwind_Backtrace(unwind_callback, &amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>.current - <span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc_proxy</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">80</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="comment">// 当申请内存大小大于 80M 时获取堆栈</span></span><br><span class="line">        <span class="keyword">int</span> maxStackSize = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">void</span> *<span class="built_in">buffer</span>[maxStackSize];</span><br><span class="line">        <span class="keyword">int</span> count = fill_backtraces_buffer(<span class="built_in">buffer</span>, maxStackSize);</span><br><span class="line">        dumpBacktrace(<span class="built_in">buffer</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，当申请内存大小大于 80M 时，我们通过 unwind 来获取堆栈，将将获取的堆栈放入 buffer 数组中</p>
<p>但是我们获得的 buffer 数组只是 16 进制的地址，根本看不出有效信息，如下所示：</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p4.jpg" alt></p>
<p>因此我们还要进行下一步，还原堆栈信息</p>
<h3 id="还原堆栈信息"><a href="#还原堆栈信息" class="headerlink" title="还原堆栈信息"></a>还原堆栈信息</h3><p>要将16进制的地址堆栈还原成带有效信息的堆栈，通常需要完成以下三个步骤：</p>
<ol>
<li>首先要确认相关的 so 文件名称；</li>
<li>接下来需要计算相应的偏移地址；</li>
<li>最后，基于带符号表（ELF文件中的一张表，存放了函数、方法、变量等名称符号信息）的so文件，还原指针对应的函数名和行数。</li>
</ol>
<h4 id="确认-so-文件名称"><a href="#确认-so-文件名称" class="headerlink" title="确认 so 文件名称"></a>确认 so 文件名称</h4><p>我们可以通过<code>dladdr</code>函数来查询 so 文件名，函数定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">dladdr</span> <span class="params">( <span class="keyword">void</span> * addr , Dl_info * info )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dli_fname;   <span class="comment">//地址对应的 so 名</span></span><br><span class="line">    <span class="keyword">void</span>       *dli_fbase;   <span class="comment">//对应so库的基地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dli_sname;   <span class="comment">//如果so库有符号表，这会显示离地址最近的函数名</span></span><br><span class="line">    <span class="keyword">void</span>       *dli_saddr;   <span class="comment">//符号表中，离地址最近的函数的地址</span></span><br><span class="line">&#125; Dl_info;</span><br></pre></td></tr></table></figure>
<p>我们将函数地址传入<code>dladdr</code>函数，就可以获取相应的 so 库名称与基地址，如下所示： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpBacktrace</span><span class="params">(<span class="keyword">void</span> **<span class="built_in">buffer</span>, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">void</span> *addr = <span class="built_in">buffer</span>[i];</span><br><span class="line">        Dl_info info = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (dladdr(addr, &amp;info)) &#123;</span><br><span class="line">            LOG(<span class="string">"# %d : %p : %s(%s)(%p)"</span>, i, addr, info.dli_fname,</span><br><span class="line">                info.dli_sname, info.dli_saddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>dladdr</code>函数获取的堆栈打印如下所示：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0 : 0x767174309c : /data/app/~~6Mf4VQY4K16aFji1rZ4dkg==/com.zj.android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libmemory-hook.so(0x2609c)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 1 : 0x7671742ec8 : /data/app/~~6Mf4VQY4K16aFji1rZ4dkg==/com.zj.android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libmemory-hook.so(0x25ec8)(_Z12malloc_proxym)(0x7671742dbc)</span></span><br><span class="line"><span class="comment"># 2 : 0x76712f23d8 : /data/app/~~6Mf4VQY4K16aFji1rZ4dkg==/com.zj.android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libandroid-performance.so(0x203d8)(Java_com_zj_android_performance_jni_NativeLibTest_testMalloc)(0x76712f23a8)</span></span><br><span class="line"><span class="comment"># 3 : 0x7691222248 : /apex/com.android.art/lib64/libart.so(0x222248)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 4 : 0x7691218968 : /apex/com.android.art/lib64/libart.so(0x218968)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 5 : 0x7691285ff4 : /apex/com.android.art/lib64/libart.so(0x285ff4)(_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc)(0x7691285f30)</span></span><br><span class="line"><span class="comment"># 6 : 0x76913ea3ec : /apex/com.android.art/lib64/libart.so(0x3ea3ec)(_ZN3art11interpreter34ArtInterpreterToCompiledCodeBridgeEPNS_6ThreadEPNS_9ArtMethodEPNS_11ShadowFrameEtPNS_6JValueE)(0x76913ea254)</span></span><br><span class="line"><span class="comment"># 7 : 0x76913e4f88 : /apex/com.android.art/lib64/libart.so(0x3e4f88)(_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE)(0x76913e4c48)</span></span><br><span class="line"><span class="comment"># 8 : 0x769175fd10 : /apex/com.android.art/lib64/libart.so(0x75fd10)(MterpInvokeVirtual)(0x769175f878)</span></span><br><span class="line"><span class="comment"># 9 : 0x7691203818 : /apex/com.android.art/lib64/libart.so(0x203818)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 10 : 0x769176b3f4 : /apex/com.android.art/lib64/libart.so(</span></span><br><span class="line"><span class="comment"># 11 : 0x7691203998 : /apex/com.android.art/lib64/libart.so(0x203998)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 12 : 0x769176b3f4 : /apex/com.android.art/lib64/libart.so(</span></span><br><span class="line"><span class="comment"># 13 : 0x7691203998 : /apex/com.android.art/lib64/libart.so(0x203998)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 14 : 0x76913dcd30 : /apex/com.android.art/lib64/libart.so(0x3dcd30)((null))(0x0)</span></span><br><span class="line"></span><br><span class="line">malloc <span class="number">92274688</span> <span class="keyword">byte</span> success</span><br></pre></td></tr></table></figure>
<p>可以看出，在有符号表的情况下，so 名与函数名都正确的打印出来了，而对于 libart，由于已经移除了符号表，则显示为 null ，地址也为 0 </p>
<h3 id="计算函数偏移地址"><a href="#计算函数偏移地址" class="headerlink" title="计算函数偏移地址"></a>计算函数偏移地址</h3><p>通过<code>dladdr</code>函数，我们已经获取了堆栈的 so 名与函数名，那可不可以具体定位到到底是函数的哪一行出现了问题吗？</p>
<p>我们可以通过 NDK 的 addr2line 工具，根据函数偏移地址，获取地址对应的函数名、行号等信息</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">addr2line -C -f -e xxx.so 函数偏移地址</span><br><span class="line"></span><br><span class="line"><span class="deletion">-C:将低级别的符号名解码为用户级别的名字。</span></span><br><span class="line"><span class="deletion">-e:指定需要转换地址的可执行文件名</span></span><br><span class="line"><span class="deletion">-f:在显示文件名、行号信息的同时显示函数名。</span></span><br></pre></td></tr></table></figure>
<p>我们在堆栈中获取的地址是函数的绝对地址，要获取偏移地址减去 so 的基地址就可以了</p>
<p>偏移地址 = 函数的绝对地址 - 库文件的基地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpBacktrace</span><span class="params">(<span class="keyword">void</span> **<span class="built_in">buffer</span>, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dladdr(addr, &amp;info)) &#123;</span><br><span class="line">        	<span class="comment">// 计算偏移地址</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uintptr_t</span> address_relative = (<span class="keyword">uintptr_t</span>) addr - (<span class="keyword">uintptr_t</span>) info.dli_fbase;</span><br><span class="line">            LOG(<span class="string">"# %d : %p : %s(%p)(%s)(%p)"</span>, i, addr, info.dli_fname, address_relative,</span><br><span class="line">                info.dli_sname, info.dli_saddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的日志也可以看出，有问题的<code>Java_com_zj_android_performance_jni_NativeLibTest_testMalloc</code>函数的偏移地址是<code>0x203d8</code></p>
<h3 id="还原函数名及行号"><a href="#还原函数名及行号" class="headerlink" title="还原函数名及行号"></a>还原函数名及行号</h3><p>现在，我们已经得知了函数的偏移地址，接下来就可以使用 addr2line 工具来获取行号了。在 Android 的 NDK 中已经提供了这个工具，位于 /ndk/xxx/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin 目录中。如果您使用的是 M1 电脑，可以选择 aarch64 目录。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">arm</span>-linux-<span class="keyword">androideabi-addr2line </span>  -C -f -e libandroid_performance.so  <span class="number">0x203d8</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，这里的 so 必须是带符号表的，因此需要在编译产物中的 native_libs 目录去找(注意不是 stripped_native_libs 目录)</p>
<p>运行以上命令后，得到的结果如下</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p5.jpg" alt></p>
<p>可以看出，已经定位到了具体的函数名与行号</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Native Hook 是什么以及常见实现方案，同时通过一个监控 native 内存的例子进行了实践</p>
<p>在 Android 应用性能优化中，Native Hook 技术广泛应用于内存优化、启动优化等方面，如 bitmap hook、pthread hook、GC 抑制等。因此，如果您希望在相关领域进行技术优化，掌握 Native Hook 技术将是非常有必要的。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文主要是对<a href="https://juejin.cn/book/7153836660768292878" target="_blank" rel="noopener">Android 性能优化小册</a>相关内容的学习实践，感兴趣的同学可以点击查看</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本文所有源码可见：<a href="https://github.com/RicardoJiang/android-performance" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-performance</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【稳定性优化】安全气囊如何实现？</title>
    <url>/blog/2023/03/android-stability-optimize.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，当 Andoird 程序发生未捕获的异常的时候，程序会直接 Crash 退出</p>
<p>而所谓安全气囊，是指在 Crash 发生时，可以捕获异常，触发兜底逻辑，在程序退出前做最后的抢救</p>
<p>接下来我们来看一下怎么实现一个安全气囊，以在 Crash 发生时做最后的抢救</p>
<h2 id="Java-层安全气囊"><a href="#Java-层安全气囊" class="headerlink" title="Java 层安全气囊"></a>Java 层安全气囊</h2><h3 id="Java-异常如何捕获"><a href="#Java-异常如何捕获" class="headerlink" title="Java 异常如何捕获"></a>Java 异常如何捕获</h3><p>在实现安全气囊之前，我们先思考一个问题，像 bugly, sentry 这种库，是如何捕获异常并上传堆栈的呢？</p>
<p>要了解这个问题，我们首先要了解一下当异常发生时是怎么传播的</p>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2023/march/p7.png" alt></p>
<p>其实也很简单，主要分为以下几步</p>
<ol>
<li>当抛出异常时，通过<code>Thread.dispatchUncaughtException</code>进行分发</li>
<li>依次由<code>Thread</code>，<code>ThreadGroup</code>，<code>Thread.getDefaultUncaughtExceptionHandler</code>处理</li>
<li>在默认情况下，<code>KillApplicationHandler</code>会被设置<code>defaultUncaughtExceptionHandler</code></li>
<li><code>KillApplicationHandler</code>中会调用<code>Process.killProcess</code>退出应用</li>
</ol>
<p>这就是异常发生时的传播路径，可以看出，如果我们通过<code>Thread.setDefaultUncaughtExceptionHandler</code>设置自定义处理器，就可以捕获异常做一些兜底操作了，其实 bugly 这些库也是这么做的</p>
<h3 id="自定义异常处理器的问题"><a href="#自定义异常处理器的问题" class="headerlink" title="自定义异常处理器的问题"></a>自定义异常处理器的问题</h3><p>那么问题来了，如果我们设置了自定义处理器，在里面只做一些打印日志的操作，而不是退出应用，是不是就可以让 app 永不崩溃了呢？</p>
<p>答案当然是否定的，主要有以下两个问题</p>
<h4 id="Looper-循环问题"><a href="#Looper-循环问题" class="headerlink" title="Looper 循环问题"></a>Looper 循环问题</h4><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2023/march/p8.png" alt></p>
<p>我们知道，App 的运行在很大程序上依赖于 Handler 消息机制，<code>Handler</code> 不断的往 <code>MessageQueue</code> 中发送 <code>Message</code>，而<code>Looper</code>则死循环的不断从<code>MessageQueue</code>中取出<code>Message</code>并消费，整个 app 才能运行起来</p>
<p>而当异常发生时，<code>Looper.loop</code> 循环被退出了，事件也就不会被消费了，因此虽然 app 不会直接退出，但也会因为无响应发生 ANR</p>
<p>因此，当崩溃发生在主线程时，我们需要恢复一下<code>Looper.loop</code></p>
<h4 id="主流程抛出异常问题"><a href="#主流程抛出异常问题" class="headerlink" title="主流程抛出异常问题"></a>主流程抛出异常问题</h4><p>当我们在主淤积抛出异常时，比如在<code>onCreate</code>方法中，虽然我们捕获住了异常，但程序的执行也被中断了，界面的绘制可能无法完成，点击事件的设置也没有生效</p>
<p>这就导致了 app 虽然没有退出，但用户却无法操作的问题，这种情况似乎还不如直接 Crash 了呢</p>
<p>因此我们的安全气囊应该支持配置，只处理那些非主流程的操作，比如点击按钮触发的崩溃，或者一些打点等对用户无感知操作造成的崩溃</p>
<h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p>为了解决上面提到的两个问题，我们的方案如下</p>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2023/march/p9.jpg" alt></p>
<p>主要分为以下几步：  </p>
<ol>
<li>注册自定义<code>DefaultUncaughtExceptionHandler</code></li>
<li>当异常发生是捕获异常</li>
<li>匹配异常堆栈是否符合配置，如果符合则捕获，否则交给默认处理器处理</li>
<li>判断异常发生时是否是主线程，如果是则重启<code>Looper</code></li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现如下： </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setUpJavaAirBag</span><span class="params">(configList: <span class="type">List</span>&lt;<span class="type">JavaAirBagConfig</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> preDefaultExceptionHandler = Thread.getDefaultUncaughtExceptionHandler()</span><br><span class="line">    <span class="comment">// 设置自定义处理器</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler &#123; thread, exception -&gt;</span><br><span class="line">        handleException(preDefaultExceptionHandler, configList, thread, exception)</span><br><span class="line">        <span class="keyword">if</span> (thread == Looper.getMainLooper().thread) &#123;</span><br><span class="line">        	<span class="comment">// 重启 Looper</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Looper.loop()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                    handleException(</span><br><span class="line">                        preDefaultExceptionHandler, configList, Thread.currentThread(), e</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    preDefaultExceptionHandler: <span class="type">Thread</span>.<span class="type">UncaughtExceptionHandler</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    configList: <span class="type">List</span>&lt;<span class="type">JavaAirBagConfig</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    thread: <span class="type">Thread</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    exception: <span class="type">Throwable</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 匹配配置</span></span><br><span class="line">    <span class="keyword">if</span> (configList.any &#123; isStackTraceMatching(exception, it) &#125;) &#123;</span><br><span class="line">        Log.w(<span class="string">"StabilityOptimize"</span>, <span class="string">"Java Crash 已捕获"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.w(<span class="string">"StabilityOptimize"</span>, <span class="string">"Java Crash 未捕获，交给原有 ExceptionHandler 处理"</span>)</span><br><span class="line">        preDefaultExceptionHandler.uncaughtException(thread, exception)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Native-层安全气囊"><a href="#Native-层安全气囊" class="headerlink" title="Native 层安全气囊"></a>Native 层安全气囊</h2><p>通过上面的步骤，我们实现了一个 Java 层安全气囊，但是如果发生 Native 层崩溃时，程序还是会崩溃</p>
<p>那么我们能不能按照 Java 层安全气囊的思路，实现一个 Native 层的安全气囊？</p>
<h3 id="Native-异常如何捕获"><a href="#Native-异常如何捕获" class="headerlink" title="Native 异常如何捕获"></a>Native 异常如何捕获</h3><p>Native 层异常是通过信号机制实现的</p>
<p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2023/march/p10.png" alt></p>
<ol>
<li>crash产生后，会在用户态阶段调用中断进入内核态</li>
<li>在处理完内核操作，返回用户态时，会检查信号队列上是否有信号需要处理</li>
<li>如果有信号需要处理，则会调用<code>sigaction</code>函数进行相应处理</li>
</ol>
<p>那么如果我们通过注册信号处理函数<code>sigaction</code>设置自定义信号处理器，是不是可以实现跟 Java 安全气囊一样的效果？</p>
<p>需要注意的是，我们可以通过<code>sigaction</code>设置自定义信号处理器，但是<code>SIGKILL</code>与<code>SIGSTOP</code>信号我们是无法更改其默认行为的，如果我们设置了自定义信号处理器，没有退出 app，但错误实际还是产生了，当错误实在不可控时，系统还是会发送<code>SIGKILL/SIGSTOP</code>信号，这个时候还会导致我们 crash 时无法获取真正的堆栈，因此我们在自定义信号处理器时需要慎重</p>
<p>可以看出，要了解 Native 异常捕获，需要对 Linux 信号机制有一定了解，想了解更多的同学可以查看：<a href="https://juejin.cn/post/7196131493448613945" target="_blank" rel="noopener">写给android开发的Linux 信号 - 上篇</a></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>在了解了 Native 层异常处理的原理之后，我们通过自定义信号处理器来实现一个 Native 层的安全气囊，主要分为以下几步</p>
<ol>
<li>注册自定义信号处理器</li>
<li>获取 Native 堆栈并与配置堆栈进行比较</li>
<li>如果匹配上了则忽略相关崩溃，如果未匹配上则交给原信号处理器处理</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_zj_android_stability_optimize_StabilityNativeLib_openNativeAirBag(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>,</span><br><span class="line">        jint signal,</span><br><span class="line">        jstring soName,</span><br><span class="line">        jstring backtrace) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigc</span>;</span></span><br><span class="line">        <span class="comment">// 自定义处理器</span></span><br><span class="line">        sigc.sa_sigaction = sig_handler;</span><br><span class="line">        sigemptyset(&amp;sigc.sa_mask);</span><br><span class="line">        sigc.sa_flags = SA_SIGINFO | SA_ONSTACK | SA_RESTART;</span><br><span class="line">        <span class="comment">// 注册信号</span></span><br><span class="line">        <span class="keyword">int</span> flag = sigaction(signal, &amp;sigc, &amp;old);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取堆栈</span></span><br><span class="line">    <span class="keyword">auto</span> stackTrace = getStackTraceWhenCrash();</span><br><span class="line">    <span class="comment">// 与配置的堆栈进行匹配</span></span><br><span class="line">    <span class="keyword">if</span> (sig == airBagConfig.signal &amp;&amp;</span><br><span class="line">        stackTrace.<span class="built_in">find</span>(airBagConfig.soName) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos &amp;&amp;</span><br><span class="line">        stackTrace.<span class="built_in">find</span>(airBagConfig.backtrace) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        LOG(<span class="string">"异常信号已捕获"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 没匹配上的交给原有处理器处理</span></span><br><span class="line">        LOG(<span class="string">"异常信号交给原有信号处理器处理"</span>);</span><br><span class="line">        sigaction(sig, &amp;old, <span class="literal">nullptr</span>);</span><br><span class="line">        raise(sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>通过上面的步骤，其实 Native 层的安全气囊已经实现了，在 demo 中触发 Native Crash 可以被捕获到</p>
<p>但是信号处理函数必须是<code>async-signal-safe</code>和可重入的，理论上不应该在信号处理函数中做太多工作，比如<code>malloc</code>等函数都不是可重入的</p>
<p>而我们在信号处理函数中获取了堆栈，打印了日志，很可能会造成一些意料之外的问题</p>
<p>理论上我们可以在子线程获取堆栈，在信号处理函数中只需要发出信号就可以了，但我尝试在子线程中使用 unwind 获取堆栈，发现获取不到真正的堆栈，因此还存在一定的问题，有了解的大佬可以在评论区指点下</p>
<p>Native 层安全气囊的方案也可以看看@Pika 写的<a href="https://github.com/TestPlanB/mooner" target="_blank" rel="noopener">https://github.com/TestPlanB/mooner</a>，支持捕获 Android 基于“pthread_create” 产生的子线程中异常业务逻辑产生信号，导致的native crash</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了Java 层与 Native 层安全气囊的实现方案与异常捕获原理，在一些非主流程的 Crash 发生时，通过安全气囊可以做一些最后的挽救，在降低崩溃率方面应该还是有一些应用场景的，希望本文对你有所帮助~</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有源码可见：<a href="https://github.com/RicardoJiang/android-performance" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-performance</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>启动优化中的一些黑科技，了解一下~</title>
    <url>/blog/2023/04/android-startup-optimize.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>启动速度优化是 android 开发中的常见需求，除了一些常规的手段之外，也有一些黑科技手段，我们来看一下这些黑科技手段是否有效，以及如何实现</p>
<p>本文主要是对<a href="https://juejin.cn/book/7153836660768292878" target="_blank" rel="noopener">Android 性能优化小册</a>相关内容的学习实践，感兴趣的同学可以点击查看</p>
<h2 id="线程优先级设置"><a href="#线程优先级设置" class="headerlink" title="线程优先级设置"></a>线程优先级设置</h2><p>线程优先级设置的概念很容易理解，优先级越高的线程越容易获取 CPU 时间片，那么为了保证 app 的流畅运行，那么我们就应该将核心线程的优先级提高，而将其他线程的优先级调低</p>
<p>对于 app 来说，核心线程就是主线程 + RenderThread，那么我们是否有必要手动设置线程优先级呢？</p>
<p>我们可以通过以下命令获取当前的线程优先级</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> </span><br><span class="line">ps -A | grep 包名 <span class="comment">// 根据包名找到Pid</span></span><br><span class="line">top -H -p PID    <span class="comment">// 查看线程优先级命令</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p1.jpg" alt></p>
<p>运行结果如上图所示，要看懂上面的图我们要先了解一点背景知识</p>
<ul>
<li><code>PR</code>: 优先级 (priority)，值越小优先级越高，会受<code>NI</code>的值的影响</li>
<li><code>NI</code>: 即 Nice 值，我们可以通过<code>Process.setThreadPriority</code>设置，同样是值越小优先级越高</li>
</ul>
<p>其实我们只需要知道它们都是值越小优先级越高就好了，可以看出主线程与 RenderThread 的优先级都挺高的，仅次于 Binder 线程</p>
<p>我看到一些启动优化的文章谈到线程优先级设置，但测试结果似乎是没有必要？难道是版本问题？有了解的同学可以在评论区说下</p>
<h2 id="核心线程绑定大核"><a href="#核心线程绑定大核" class="headerlink" title="核心线程绑定大核"></a>核心线程绑定大核</h2><h3 id="绑定大核是否有必要"><a href="#绑定大核是否有必要" class="headerlink" title="绑定大核是否有必要?"></a>绑定大核是否有必要?</h3><p>核心线程绑定大核的思路也很容易理解，现在的 CPU 都是多核的，大核的频率比小核要高不少，如果我们的核心线程固定运行在大核上，那么应用性能自然会有所提升</p>
<p>就拿我手上的小米10来说，使用的是骁龙865的 CPU，由一颗A77超大核+三颗A77大核+四颗A55小核心组成，我们可以通过<code>/sys/devices/system/cpu/</code>目录下的文件获取各个核的频率，如下所示</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu0<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">1804800</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu1<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">1804800</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu2<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">1804800</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu3<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">1804800</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu4<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">2419200</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu5<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">2419200</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu6<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">2419200</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu7<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">2841600</span></span><br></pre></td></tr></table></figure>
<p>可以看出，cpu0 到 cpu3 是4个小核， cpu4 到 cpu6 是3个大核，cpu7 是超大核，它们之间的频率还是相差挺大的</p>
<p>同时通过 systrace 工具可以发现，主线程基本都运行在 cpu7 这个超大核上，而 RenderThread 会在 cpu4 到 cpu6 间切换，有时甚至会调度到小核上</p>
<p>因此可以看出还是有必要把 RenderThread 绑定到一个大核上的，绑定可以更好的利用缓存以及减少线程的上下文切换</p>
<h3 id="绑定大核实现"><a href="#绑定大核实现" class="headerlink" title="绑定大核实现"></a>绑定大核实现</h3><p>绑定大核是通过函数<code>sched_setaffinity</code>实现的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_zj_android_startup_optimize_StartupNativeLib_bindCore(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>, jint thread_id, jint core) &#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> mask;     <span class="comment">//CPU核的集合</span></span><br><span class="line">    CPU_ZERO(&amp;mask);     <span class="comment">//将mask置空</span></span><br><span class="line">    CPU_SET(core, &amp;mask);    <span class="comment">//将需要绑定的cpu核设置给mask，核为序列0,1,2,3……</span></span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(thread_id, <span class="keyword">sizeof</span>(mask), &amp;mask) == <span class="number">-1</span>) &#123;     <span class="comment">//将线程绑核</span></span><br><span class="line">        LOG(<span class="string">"bind thread %d to core %d fail"</span>, thread_id, core);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(<span class="string">"bind thread %d to core %d success"</span>, thread_id, core);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，<code>sched_setaffinity</code>共有 3 个参数</p>
<ul>
<li>参数 1 是线程的 id，如果为 0 则表示主线程</li>
<li>参数 2 表示 cpu 序列掩码的长度</li>
<li>参数 3 则表示需要绑定的 cpu 序列的掩码</li>
</ul>
<p>以上是线程绑定大核的核心代码，可以看到我们还需要获取 RenderThread 的 id ，以及 cpu 大核的序列</p>
<p>应用中线程的信息记录在 /proc/pid/task 的文件中，通过解析 task 文件就可以获取当前进程的所有线程，而 cpu 大核序列也可以通过解析 <code>/sys/devices/system/cpu</code> 目录实现</p>
<p>具体代码就不在这里粘贴了，完整代码可见文末链接</p>
<h2 id="GC-抑制"><a href="#GC-抑制" class="headerlink" title="GC 抑制"></a>GC 抑制</h2><h3 id="GC-抑制是否有必要"><a href="#GC-抑制是否有必要" class="headerlink" title="GC 抑制是否有必要?"></a>GC 抑制是否有必要?</h3><p>我们知道 Java 的拉圾回收机制，在 Android 5.0 之后，ART 取代了 Dalvik，ART 虚拟机在垃圾回收的时候虽然没有像 Dalvik 一样 stop the world，但在启动阶段如果发生垃圾回收，GC 线程同样抢占了不少系统资源</p>
<p>Google 也注意到启动阶段 GC 对启动速度的影响，并在 Android 10 之后做了一定的优化，详情可见如下提交：<a href="https://cs.android.com/android/_/android/platform/art/+/a98a28262f645d100e2dee9587e7822d35ade6f9" target="_blank" rel="noopener">https://cs.android.com/android/_/android/platform/art/+/a98a28262f645d100e2dee9587e7822d35ade6f9</a></p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p2.jpg" alt></p>
<p>可以看出，基本思路是在 2s 内提高后台 GC 的阈值，减少启动阶段的 GC 次数，根据 Google 的测试，抑制 GC 后效果如下</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p3.png" alt></p>
<p>可以看出，GC 次数明显减少，启动速度也有一定的提升。那么我们是不是可以使用一些手段让 Android 10 以下也能实现这个效果呢?</p>
<p>同时我们也可以通过以下代码获取 gc 的次数与耗时，方便统计 gc 对启动耗时的影响，以评估是否有必要做 GC 抑制</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.gc-count"</span>) <span class="comment">// gc 次数</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.gc-time"</span>)  <span class="comment">// gc 耗时</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.blocking-gc-count"</span>) <span class="comment">// 阻塞 gc 次数</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.blocking-gc-time"</span>) <span class="comment">// 阻塞 gc 耗时</span></span><br></pre></td></tr></table></figure>
<h3 id="GC-抑制实现"><a href="#GC-抑制实现" class="headerlink" title="GC 抑制实现"></a>GC 抑制实现</h3><h4 id="HeapTaskDaemon-执行流程"><a href="#HeapTaskDaemon-执行流程" class="headerlink" title="HeapTaskDaemon 执行流程"></a>HeapTaskDaemon 执行流程</h4><p>GC 主要是通过 HeapTaskDaemon 线程实现的，这是一个守护线程，在 Zygote 线程启动后这个线程也就启动了，启动后主要做了以下工作</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p4.png" alt></p>
<ol>
<li>从<code>HeapTaskDaemon.runInternal()</code>方法开始一步步调用到 native 层的 <code>task_processor.RunAllTasks()</code> 方法</li>
<li>当<code>TaskProcessor</code>中的<code>tasks</code>为空时，会休眠等待，否则会取出第一个<code>HeapTask</code>并执行其<code>Run</code>方法</li>
</ol>
<p>而<code>HeapTask</code>的<code>Run</code>方法是一个虚函数，需要子类来实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapTask</span> :</span> <span class="keyword">public</span> SelfDeletingTask &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfDeletingTask</span> :</span> <span class="keyword">public</span> <span class="built_in">Task</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> :</span> <span class="keyword">public</span> Closure &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Closure</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Closure() &#123; &#125;</span><br><span class="line">  <span class="comment">// 定义 Run 虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">(Thread* self)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>HeapTask</code>就是垃圾回收的任务，有多个子类，比如最常见的 ConcurrentGCTask 就是其子类，在 Java 内存达到阈值时就会执行这个 Task，用于执行并发 GC</p>
<h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><p>在了解了 HeapTaskDaemon 的执行流程之后，我们想到，如果启动时在<code>ConcurrentGCTask</code>的<code>Run</code>方法执行前休眠一段时间，不就可以实现 GC 抑制了吗？</p>
<p>而<code>Run</code>方法正好是虚函数，虚函数与 Java 中的抽象函数类似，留给子类去扩展实现多态</p>
<p>虚函数和外部库函数一样都没法直接执行，需要在表中去查找函数的真实地址，那么我们是不是可以使用类似 PLT Hook的思路，使用自定义函数的地址替换原有函数地址，实现 Hook 呢？</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p5.png" alt></p>
<p>答案是肯定的，如上图所示，一个类中如果存在虚函数，那么编译器就会为这个类生成一张虚函数表，并且将虚函数表的地址放在对象实例的首地址的内存中。同一个类的不同实例，共用一张虚函数表的。</p>
<p>因此我们的主要思路如下：</p>
<ol>
<li>启动时将虚函数表中的 Run 函数地址替换为自定义函数地址</li>
<li>在自定义函数内部休眠一段时间，抑制 GC</li>
<li>休眠完成后将虚函数表中的函数地址替换回来，避免影响后续执行</li>
</ol>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>很显然要想实现 Hook，我们首先需要获取<code>ConcurrentGCTask</code>对象地址与其<code>Run</code>方法地址</p>
<p>那么我们可以如何获取方法地址呢？</p>
<p>dlopen 函数和 dlsym 可以用于打开动态链接库中的函数，通过函数的符号返回函数地址</p>
<p>因此我们需要做下面两件事   </p>
<ol>
<li>获取函数符号</li>
<li>根据函数符号获取函数地址</li>
</ol>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb pull /<span class="keyword">system</span>/lib64/libart.so<span class="comment"> // Android 10 以前系统，Android 10 之后换了位置</span></span><br><span class="line">aarch64-linux-android-readelf -s <span class="comment">--wide libart.so</span></span><br></pre></td></tr></table></figure>
<p>通过以上方式可以导出 so 中的符号，查找到结果如下</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="variable">_ZTVN3art2gc4Heap16ConcurrentGCTaskE</span>   <span class="comment">// ConcurrentGCTask</span></span><br><span class="line"><span class="variable">_ZN3art2gc4Heap16ConcurrentGCTask3RunEPNS_6ThreadE</span> <span class="comment">// Run 方法</span></span><br></pre></td></tr></table></figure>
<p>可以看出，符号是原来的名字做了一定的变换，这是 c++ 的 name mangling 机制，mangling 的目的就是为了给重载的函数不同的签名，具体的规则可以自行查阅，这里就不赘述了</p>
<p>还有需要注意的一点是，Android 7.0 以上对 dlsym 的调用有限制，同时从 aarch64-linux-android-readelf 的结果可以看出， <code>ConcurrentGCTask</code> 在 .dynsym 段，而 <code>Run</code> 方法在 .symtab 段，而 dlsym 只能搜索 .dynsym 段，而无法搜索 .symtab 段，因此我们这里使用<code>enhanced_dlsym</code>开源库，既支持 Android 7.0 以上调用，也可以查找 .stymtab 段</p>
<p>好了，前置知识讲完了，下面来看下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以RTLD_NOW模式打开动态库libart.so，拿到句柄，RTLD_NOW即解析出每个未定义变量的地址</span></span><br><span class="line">    <span class="keyword">void</span> *handle = enhanced_dlopen(<span class="string">"/system/lib64/libart.so"</span>, RTLD_NOW);</span><br><span class="line">    <span class="comment">//通过符号拿到ConcurrentGCTask对象地址</span></span><br><span class="line">    <span class="keyword">void</span> *taskAddress = enhanced_dlsym(handle, <span class="string">"_ZTVN3art2gc4Heap16ConcurrentGCTaskE"</span>);</span><br><span class="line">    <span class="comment">//通过符号拿到run方法</span></span><br><span class="line">    <span class="keyword">void</span> *runAddress = enhanced_dlsym(handle, <span class="string">"_ZN3art2gc4Heap16ConcurrentGCTask3RunEPNS_6ThreadE"</span>);</span><br><span class="line">    <span class="comment">//由于 ConcurrentGCTask 只有五个虚函数，所以我们只需要查询前五个地址即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//对象头地址中的内容存放的就是是虚函数表的地址，所以这里是指针的指针，即是虚函数表地址，拿到虚函数表地址后，转换成数组，并遍历获取值</span></span><br><span class="line">        <span class="keyword">void</span> *vfunc = ((<span class="keyword">void</span> **) taskAddress)[i];</span><br><span class="line">        <span class="comment">// 如果虚函数表中的值是前面拿到的 Run 函数的地址，那么就找到了Run函数在虚函数表中的地址</span></span><br><span class="line">        <span class="keyword">if</span> (vfunc == runAddress) &#123;</span><br><span class="line">            <span class="comment">//这里需要注意的是，这里 +i 操作拿到的是地址，而不是值，因为这里的值是 Run 函数的真实地址</span></span><br><span class="line">            mSlot = (<span class="keyword">void</span> **) taskAddress + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存原有函数</span></span><br><span class="line">    originFun = *mSlot;</span><br><span class="line">    <span class="comment">// 将虚函数表中的值替换成我们hook函数的地址</span></span><br><span class="line">    replaceFunc(mSlot, (<span class="keyword">void</span> *) &amp;hookRun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们的 hook 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookRun</span><span class="params">(<span class="keyword">void</span> *thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//休眠3秒</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//将虚函数表中的值还原成原函数，避免每次执行run函数时都会执行hook的方法</span></span><br><span class="line">    replaceFunc(mSlot, originFun);</span><br><span class="line">    <span class="comment">//执行原来的Run方法</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) originFun)(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码就是上面这些，主要做了这么几件事： </p>
<ol>
<li>通过符号获取<code>Run</code>方法地址</li>
<li>遍历虚函数表，找到虚函数表中存放<code>Run</code>方法真实地址的位置</li>
<li>保存原函数地址，并将虚函数表中的值替换成我们 hook 的函数地址</li>
<li>在 hook 函数中休眠一段时间，休眠结束后还原虚函数表，避免影响后续任务</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在性能优化中除了一些常规手段外，也经常有一些黑科技手段，本文主要介绍了启动优化中的线程优先级设置，核心线程绑定大核，GC 抑制等手段，<br>讲解了一下这些黑科技手段是否有效，以及具体是怎么实现的，希望对你有所帮助</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文主要是对<a href="https://juejin.cn/book/7153836660768292878" target="_blank" rel="noopener">Android 性能优化小册</a>相关内容的学习实践，感兴趣的同学可以点击查看</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本文所有源码可见：<a href="https://github.com/RicardoJiang/android-performance" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-performance</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【卡顿优化】卡顿问题如何监控？</title>
    <url>/blog/2023/04/android-jank-optimize.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>卡顿问题是 Android 开发中的一个常见但容易忽视的问题，毕竟又不是不能用。 同时 App 卡顿问题有着不易衡量卡顿程度，不易复现，难以定位等特点。</p>
<p>但是 App 卡顿会给用户体验带来较大的影响，从而影响用户的留存。本文主要包括以下内容：</p>
<ol>
<li>我们应该如何衡量卡顿程度？如何对 app 的卡顿程度建立数据指标？</li>
<li>如何定位卡顿代码，找到带来卡顿的堆栈？</li>
</ol>
<h2 id="如何衡量卡顿程度"><a href="#如何衡量卡顿程度" class="headerlink" title="如何衡量卡顿程度"></a>如何衡量卡顿程度</h2><p>说到卡顿程度，大家一开始想起来的或许就是 FPS，FPS 即每秒显示的帧数，可以看出这是一个平均值，FPS 高并不代表页面流畅，比如下面这个例子</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p1.gif" alt></p>
<p>图片来源：<a href="https://mp.weixin.qq.com/s/aJeAUAjcKOMvznDMGj2UUA" target="_blank" rel="noopener">卡顿率降低50%！京东商城APP卡顿监控及优化实践</a></p>
<p>可以看出，在滚动过程中，页面 FPS 最低也有 57 帧每秒，但却能感受到明显的滑动卡顿，这是因为 1s 内前半段某几帧的超时绘制被后半段的平稳绘制给平均了</p>
<p>可以看出，FPS 并不能完全表现出页面的卡顿程度，FPS 高并不代表页面流畅</p>
<p>那么我们应该用什么指标来表示页面卡顿程序呢？我们可以使用卡顿率来衡量</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><span class="line"><span class="attr">卡顿率 </span>=<span class="string"> 卡顿的帧数 / 总帧数</span></span><br></pre></td></tr></table></figure>
<p>有了公式，那么我们如何确定卡顿的帧数，怎么样才算卡顿呢？</p>
<p>假如屏幕刷新率是 60/s，那么每帧耗时约 16ms，那么当一帧耗时超过 16ms 时，就发生了掉帧，也就是卡顿。掉帧数越多，说明卡顿也就越严重，比如如果某一帧实际绘制时间是 160ms，则说明其掉了 9 帧，对用户体验的影响也就更大</p>
<p>我们可以根据掉帧程度对卡顿进一步细化，比如按照下表定义卡顿的程度</p>
<table>
<thead>
<tr>
<th>卡顿程度定义</th>
<th>正常范围</th>
<th>轻微卡顿</th>
<th>中等卡顿</th>
<th>严重卡顿</th>
<th>冻结帧</th>
</tr>
</thead>
<tbody>
<tr>
<td>掉帧数</td>
<td>[0:3)</td>
<td>[3:9)</td>
<td>[9:24)</td>
<td>[24:42)</td>
<td>[42:∞)</td>
</tr>
</tbody>
</table>
<p>如上所示，我们可以定义掉帧数 3 到 9 帧为轻微卡顿，其他依次类推，通过这种方式，我们只需要获取每一帧的耗时，就可以获取页面的总体卡顿率，轻微卡顿率，严重卡顿率等，对页面的卡顿程度有了一个量化的指标</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>为了获取页面的总体卡顿率，轻微卡顿率等指标，我们需要获取以下数据</p>
<ol>
<li>页面总帧数</li>
<li>卡顿的帧数</li>
<li>卡顿各帧的耗时</li>
</ol>
<p>获取各帧耗时业界一般有以下两种方案</p>
<ol>
<li>通过设置自定义<code>android.util.Printer</code>，监听<code>Looper</code>的<code>dispatchMessage</code>耗时</li>
<li>通过向<code>Choreographer</code>循环注册<code>FrameCallback</code>，统计两次<code>Vsync</code>事件时间间隔</li>
</ol>
<p>以上两种方式都可以实现，但其实 JetPack 已经提供了一个用于监控线上卡顿的库：<a href="https://developer.android.com/topic/performance/jankstats?hl=zh-cn" target="_blank" rel="noopener">JankStats 库</a></p>
<p>JankStats 基于现有的 Android 平台功能构建，在 Android 7及更高版本中使用 FrameMetrics API 实现，在低版本中使用 OnPreDrawListener 实现，因此我们可以直接使用这个库监控即可</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JankLoggingActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> jankStats: JankStats</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jankFrameListener = JankStats.OnFrameListener &#123; frameData -&gt;</span><br><span class="line">    	<span class="comment">// 在实际使用中可以将日志上传到远端统计</span></span><br><span class="line">		Log.v(<span class="string">"JankStatsSample"</span>, frameData.toString())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        	<span class="comment">// 初始化 JankStats，传入 window 和卡顿回调</span></span><br><span class="line">       		jankStats = JankStats.createAndTrack(window, jankFrameListener).apply &#123;</span><br><span class="line">        	<span class="comment">// 支持设置卡顿阈值，默认为2</span></span><br><span class="line">        	<span class="keyword">this</span>.jankHeuristicMultiplier = <span class="number">3f</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置页面状态</span></span><br><span class="line">        <span class="keyword">val</span> metricsStateHolder = PerformanceMetricsState.getHolderForHierarchy(binding.root)</span><br><span class="line">        metricsStateHolder.state?.putState(<span class="string">"Activity"</span>, javaClass.simpleName)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	<span class="keyword">super</span>.onResume()</span><br><span class="line">    	<span class="comment">// onResume后重新开始统计</span></span><br><span class="line">    	jankStats.isTrackingEnabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	<span class="keyword">super</span>.onPause()</span><br><span class="line">    	<span class="comment">// onPause后停止统计</span></span><br><span class="line">    	jankStats.isTrackingEnabled = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，JankStats 使用起来非常简单，主要要做下面几件事</p>
<ol>
<li>初始化 JankStats，需要传入关联的 window 和卡顿监听 </li>
<li>支持设置页面状态，比如当日志上报时需要了解卡顿是在哪个页面发生的，我们这里就传入了当前     Activity 的名字，在卡顿回调中可以读取。这个特点非常重要，我们可以通过这个 API 区分卡顿的场景，比如当页面发生滚动时和不滚动时设置不同的 state，就可以统计出滚动和非滚动时的卡顿率</li>
<li>支持设置卡顿阈值，默认为 2，即本帧耗时大于一帧预期耗时的2倍就判定为卡顿，我们这里修改为 3</li>
<li>支持开始与暂停统计，当 Activity 退到后台时可以暂时关闭统计</li>
<li>JankStats 库会将每一帧的所有跟踪数据报告给已启用的 JankStats 对象的 <code>OnFrameListener</code>, 应用可以存储和聚合这些数据，以便日后上传。</li>
</ol>
<p>这里的聚合是指我们可以先将卡顿数据存储在内存或者本地存储中，当卡顿数量达到一定程度或者页面切换时，再统一上传卡顿数据，减少上传次数，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">JankActivityLifecycleCallback</span> : <span class="type">ActivityLifecycleCallbacks &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jankAggregatorMap = hashMapOf&lt;String, JankStatsAggregator&gt;()</span><br><span class="line">    <span class="comment">// 聚合回调</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jankReportListener = JankStatsAggregator.OnJankReportListener &#123; reason, totalFrames, jankFrameData -&gt;</span><br><span class="line">            jankFrameData.forEach &#123; frameData -&gt;</span><br><span class="line">            	<span class="comment">// 获取当前 Activity name</span></span><br><span class="line">            	Log.v(<span class="string">"Activity"</span>,frameData.states.firstOrNull &#123; it.key == <span class="string">"Activity"</span> &#125;?.value ?: <span class="string">""</span>)</span><br><span class="line">            	<span class="comment">// 获取掉帧数</span></span><br><span class="line">                <span class="keyword">val</span> dropFrameCount = frameData.frameDurationUiNanos / singleFrameNanosDuration</span><br><span class="line">                <span class="keyword">if</span> (dropFrameCount &lt;= JankMonitor.SLIGHT_JANK_MULTIPIER) &#123;</span><br><span class="line">                    slightJankCount++</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropFrameCount &lt;= JankMonitor.MIDDLE_JANK_MULTIPIER) &#123;</span><br><span class="line">                    middleJankCount++</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropFrameCount &lt;= JankMonitor.CRITICAL_JANK_MULTIPIER) &#123;</span><br><span class="line">                    criticalJankCount++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    frozenJankCount++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 实际使用中可以上传到远端统计</span></span><br><span class="line">            Log.v(<span class="string">"JankMonitor"</span>,<span class="string">"*** Jank Report (<span class="variable">$reason</span>), "</span> +</span><br><span class="line">                        <span class="string">"totalFrames = <span class="variable">$totalFrames</span>, "</span> +  <span class="comment">// 总帧数</span></span><br><span class="line">                        <span class="string">"jankFrames = <span class="subst">$&#123;jankFrameData.size&#125;</span>, "</span> + <span class="comment">// 总卡顿数</span></span><br><span class="line">                        <span class="string">"slightJankCount = <span class="variable">$slightJankCount</span>, "</span> + <span class="comment">// 轻微卡顿数</span></span><br><span class="line">                        <span class="string">"middleJankCount = <span class="variable">$middleJankCount</span>, "</span> + <span class="comment">// 中等卡顿数</span></span><br><span class="line">                        <span class="string">"criticalJankCount = <span class="variable">$criticalJankCount</span>, "</span> + <span class="comment">// 严重卡顿数</span></span><br><span class="line">                        <span class="string">"frozenJankCount = <span class="variable">$frozenJankCount</span>"</span> <span class="comment">// 冻结帧数</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 为所有 Activity 添加卡顿监听</span></span><br><span class="line">        activity.window.callback = <span class="keyword">object</span> : WindowCallbackWrapper(activity.window.callback) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onContentChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> activityName = activity.javaClass.simpleName</span><br><span class="line">                <span class="keyword">if</span> (!jankAggregatorMap.containsKey(activityName)) &#123;</span><br><span class="line">                    <span class="keyword">val</span> jankAggregator = JankStatsAggregator(activity.window, jankReportListener)</span><br><span class="line">                    PerformanceMetricsState.getHolderForHierarchy(activity.window.decorView).state?.putState(<span class="string">"Activity"</span>, activityName)</span><br><span class="line">                    jankAggregatorMap[activityName] = jankAggregator</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，主要做了以下事</p>
<ol>
<li>为所有 Activity 添加了聚合的卡顿监听，当卡顿数达到阈值或者 Activity 退到后台时会触发聚合回调</li>
<li>在聚合回调中可以获取这段时间的总帖数，与卡顿的帧的列表，通过计算卡顿帧的掉帧数，我们可以获取总卡顿数，轻微卡顿数，严重卡顿数等。将这些数据上传就可以计算出页面的卡顿率</li>
<li>在聚合回调中我们同样可以获取页面的状态，比如我们这里设置的<code>activityName</code>，通过设置状态我们可以统计不同场景下的卡顿率，比如滚动与非滚动</li>
</ol>
<p>这里精简了部分代码，完整代码可见：<a href="https://github.com/RicardoJiang/android-performance/tree/main/jank-optimize" target="_blank" rel="noopener">android-performance/jank-optimize</a></p>
<h2 id="如何定位卡顿代码"><a href="#如何定位卡顿代码" class="headerlink" title="如何定位卡顿代码"></a>如何定位卡顿代码</h2><p>通过以上方式建立了页面的卡顿指标，有了衡量页面卡顿程度的数据，下一步我们要进行优化的话，很明显我们需要定位到卡顿的代码，优化这些卡顿的代码，才可以降低我们的卡顿率</p>
<p>那么卡顿的慢函数该如何定位呢？业界一般也是有两种方式</p>
<h3 id="堆栈抓取方案"><a href="#堆栈抓取方案" class="headerlink" title="堆栈抓取方案"></a>堆栈抓取方案</h3><p>思路其实很简单，在卡顿发生时 Dump 主线程堆栈，通过分析堆栈找到卡顿的原因。</p>
<p>需要注意的是，如果我们在帧结束的时候，再去判断该帧是否卡顿，如果卡顿则 Dump 堆栈，这个时候获取的堆栈很可能是不太准确的，如下图所示：</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p7.png" alt></p>
<p>可以看出，抓取堆栈的时机是明显偏晚了，如果这个 Message 里执行的函数特别多，你将很难定位出具体的问题</p>
<p>所以通常我们会启动一个子线程，开启定时任务，如果一定时间内消息没有执行完成，则判定为卡顿，从而发起 Dump 堆栈，如下图所示：</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p8.jpg" alt></p>
<p>如上所示，通过在子线程中开启一个定时任务，判断主线程中是否发生卡顿，如果发生卡顿则抓取主线程堆栈，通过这种方式可以比较准确的获取卡顿堆栈</p>
<p>滴滴开源的<a href="https://github.com/didi/DoKit/tree/master/Android/dokit/src/main/java/com/didichuxing/doraemonkit/kit/blockmonitor" target="_blank" rel="noopener">DoKit</a>就是通过这种方式来获取卡顿堆栈的，感兴趣的可以去看下源码</p>
<p>这种方案在获取堆栈时比较准确，但如果你的定时任务周期较短，频繁 Dump，会对性能有较大影响，而如果周期较长，则会遗漏一些耗时任务，总得来说需要设置一个合适的阈值</p>
<p>同时通过获取堆栈的方式也无法获取各个方法的执行耗时，你无法一眼看出各个方法的耗时影响，需要进一步的线下定位</p>
<h3 id="字节码插桩方案"><a href="#字节码插桩方案" class="headerlink" title="字节码插桩方案"></a>字节码插桩方案</h3><p>堆栈抓取方案的最大缺陷是无法获取方法的执行耗时，而字节码插桩方式可以完美解决这一问题</p>
<p>通过在函数执行的开头与结尾分别插入一段代码，自然就可以计算出这个函数的执行耗时，在运行时，将前面一段时间的方法执行耗时收集起来，当发生卡顿时，则将此前一段时间的方法执行耗时全都上报，自然就可以清晰的定位出具体是哪个函数耗时了</p>
<p><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary" target="_blank" rel="noopener">Matrix</a>的慢函数定位就是通过字节码插桩实现的，字节码插桩方案的难点在于插桩方案对于运行时性能和包体积的影响，如果插桩明显地拖慢了 App 的运行性能，自然是得不偿失了。以下是 Matrix 插桩前后的对比数据</p>
<table>
<thead>
<tr>
<th style="text-align:left">item</th>
<th style="text-align:center">trace</th>
<th style="text-align:center">untrace</th>
<th style="text-align:center">info</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">FPS</td>
<td style="text-align:center">56.16</td>
<td style="text-align:center">56.19</td>
<td style="text-align:center">Android7.0 好机器朋友圈帧率</td>
</tr>
<tr>
<td style="text-align:left">FPS</td>
<td style="text-align:center">41.18</td>
<td style="text-align:center">42.70</td>
<td style="text-align:center">Android4.2 差机器朋友圈帧率</td>
</tr>
<tr>
<td style="text-align:left">apk size</td>
<td style="text-align:center">81.91 MB</td>
<td style="text-align:center">81.12 MB</td>
<td style="text-align:center">实际插桩方法总数 163141</td>
</tr>
<tr>
<td style="text-align:left">memory</td>
<td style="text-align:center">+7.6M</td>
<td style="text-align:center">～</td>
<td style="text-align:center">运行时内存</td>
</tr>
</tbody>
</table>
<p>根据 Matrix 的文档，Matrix 插桩对于好机器的性能影响可忽略，对差机器性能稍有损耗，但影响很小。 对安装包大小影响，对于微信这种大体量的应用，实际插桩函数 16w+，对安装包增加了 800K 左右。</p>
<p>看起来非常优秀，可以直接用于线上，不过我也没有实践过，有使用过的同学可以在评论区交流下~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>卡顿问题也是 Android 性能优化中的一个常见问题，本文介绍了应该如何衡量页面卡顿程度，重点介绍了如何使用 JankStats 统计卡顿率，同时介绍了子线程定时 Dump 主线程堆栈，字节码插桩两种定位慢函数的方式。</p>
<p>基于以上内容，我们可以建立页面的卡顿指标，在发现卡顿时也可以较为准确地定位慢函数以进行治理，希望对你有所帮助~</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本文所有源码可见：<a href="https://github.com/RicardoJiang/android-performance" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-performance</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Compose 在 iOS 上实现灵动岛效果</title>
    <url>/blog/2023/05/compose-dynamic-island.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在去年 DevFest 的 Compose Camp 活动上，fundroid 与朱江两位讲师带着大家使用 Compose 实现了灵动岛效果</p>
<p>但是灵动岛毕竟是 iOS 上的特性，正好今年 KotlinConf 上宣布了 Compose-iOS 已经 alpha 了，那么如果我们将已经用 Compose 实现的灵动岛效果，移植到 iOS 上又会怎么样呢？</p>
<p>想想多是一件美事啊，说干就干，看看把代码从 Jetpack Compose 迁移到 Compose Multiplatform 中到底要做什么工作，要付出什么成本</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p3.gif" alt></p>
<p>首先看下效果，可以看到，基本实现了灵动岛切换的动画效果，与在 Android 上的效果也基本一致</p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>要使用 Compose MultiPlatform 开发，需要以下环境</p>
<ul>
<li>XCode</li>
<li>Android Studio</li>
<li>Kotlin Multiplatform Mobile 插件</li>
<li>Cocoapods 依赖管理器</li>
</ul>
<p>其实跟 Kotlin Multiplatform 所需要的环境一致，其中最麻烦的可能是 Cocoapods 的安装，可以查看 KMM 安装 Cocoapods 的文档：<a href="https://kotlinlang.org/docs/native-cocoapods.html#set-up-an-environment-to-work-with-cocoapods" target="_blank" rel="noopener">Set up an environment to work with CocoaPods
</a></p>
<p>此外，你也可以通过<code>kdoctor</code>命令来检查环境配置否正确</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">brew install kdoctor <span class="comment">// 安装 kdoctor</span></span><br><span class="line">kdoctor <span class="comment">// 检查</span></span><br></pre></td></tr></table></figure>
<p>如果所有环境都配置正确，你会看到以下输出</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Environment diagnose (<span class="keyword">to</span> see all details, use -v option):</span><br><span class="line">[✓] Operation System</span><br><span class="line">[✓] Java</span><br><span class="line">[✓] Android Studio</span><br><span class="line">[✓] Xcode</span><br><span class="line">[✓] Cocoapods</span><br><span class="line"></span><br><span class="line">Conclusion:</span><br><span class="line">  ✓ Your<span class="built_in"> system </span>is ready <span class="keyword">for</span> Kotlin Multiplatform Mobile development!</span><br></pre></td></tr></table></figure>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>Compose Multiplatform 项目其实就是在 KMM 项目中加入一些 Compose 的内容，还是有不少模板代码的，我们可以直接使用 JetBrains 提供的项目模板生成项目：<a href="https://github.com/JetBrains/compose-multiplatform-ios-android-template" target="_blank" rel="noopener">compose-multiplatform-ios-android-template</a></p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p5.png" alt></p>
<p>如图所示，其实就是一个 KMM 工程的结构，android 项目的入口是 androidApp，iOS 项目的入口是 iosApp，共享代码放在 shared 模块</p>
<p>在 shared 模块中，各个平台共享代码放在 commonMain 目录中，而各个平台的定制代码则放在 androidMain 与 iosMain 中</p>
<p>在这里主要的不同在于，android 平台直接返回了一个 Composable 函数，供 android 层调用，而 iOS 平台则返回了一个 UIViewController</p>
<h3 id="代码移植"><a href="#代码移植" class="headerlink" title="代码移植"></a>代码移植</h3><p>在项目创建完成后，接下来就是代码移植的工作了。移植过程可以说是非常简单，基本上不用做任何改动，Jetpack Compose 项目就可以迁移成 Compose Multiplatform 项目</p>
<p>在我迁移过程中碰到的唯一不同在于资源文件的处理，如下所示，R 文件引用方式需要修改成字符串方式引用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Jetpack Compose</span></span><br><span class="line">Image(</span><br><span class="line">    painterResource(R.drawable.icon_cover),</span><br><span class="line">    <span class="string">"music cover"</span>,</span><br><span class="line">    Modifier</span><br><span class="line">        .size(animationData.musicImageSize)</span><br><span class="line">        .clip(RoundedCornerShape(animationData.musicImageCorner))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compose Multiplatform</span></span><br><span class="line">Image(</span><br><span class="line">    painterResource(<span class="string">"icon_cover.xml"</span>),</span><br><span class="line">    <span class="string">"music cover"</span>,</span><br><span class="line">    Modifier</span><br><span class="line">        .size(animationData.musicImageSize)</span><br><span class="line">        .clip(RoundedCornerShape(animationData.musicImageCorner))</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>除此之外，两者的状态管理，布局，动画等 api 是完全一致的，可以直接复用代码</p>
<p>经过以上步骤，迁移就完成了，直接运行 androidApp 与 iosApp 就可以得到文章开始展示的效果了</p>
<h2 id="正在处理中的问题"><a href="#正在处理中的问题" class="headerlink" title="正在处理中的问题"></a>正在处理中的问题</h2><p>当然，现在 Compose Multiplatform 还处在 alpha 阶段，并不是说已经可以用于生产了，还有不少问题正在处理中</p>
<h3 id="待支持的功能"><a href="#待支持的功能" class="headerlink" title="待支持的功能"></a>待支持的功能</h3><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p6.png" alt>      </p>
<p>图片来源：<a href="https://www.youtube.com/watch?v=FWVi4aV36d8" target="_blank" rel="noopener">Compose Multiplatform on iOS by: Sebastian Aigner and Nikita Lipsky</a></p>
<p>可以看出，Compose Multiplatform 还是有不少细节问题要处理的</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>我们打开 XCode 的 instruments 然后运行 app，就可以得到运行的 trace 文件，统计出运行次数较多或者比较耗时的方法</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p7.jpg" alt></p>
<p>可以看出，耗时方法有相当一部分是 GC 相关的，当 GC 暂停发生时，会冻结所有对象，自然也会影响 UI 的渲染，导致卡顿</p>
<p>好消息是 Kotlin 正在优化 GC，期望将 GC 暂停控制在 1 到 2 ms 之内</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出将 Jetpack Compose 版的灵动岛迁移到 Compose Multiplatform 的成本是非常低的，最耗时的部分可能是配环境的部分，两者的 API 基本上是一致的，因此代码可以无缝复用</p>
<p>Compose 跨平台补全了 Kotlin 跨平台只支持共享逻辑不支持共享 UI 的短板，降低了 Kotlin 跨平台的开发成本，总得来说，未来可期，希望 Jetbrains 能早日推出正式版</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有代码可见：<a href="https://github.com/RicardoJiang/DynamicIsland" target="_blank" rel="noopener">https://github.com/RicardoJiang/DynamicIsland</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.youtube.com/watch?v=FWVi4aV36d8" target="_blank" rel="noopener">Compose Multiplatform on iOS by: Sebastian Aigner and Nikita Lipsky</a></p>
]]></content>
      <tags>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title>【 Android 性能优化】ANR 问题如何监控？</title>
    <url>/blog/2023/05/android-anr-monitor.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ANR 即 Applicatipon No Response，程序无响应。Android 系统设计了 ANR 机制，其目的是监控与其交互的组件（Activity 等）和用户交互（InputEvent）的超时情况。这样能够判断应用进程（主线程）是否存在卡死或响应过慢的问题</p>
<p>相比 Crash，ANR 问题存在原因复杂，不易定位的特点，本文主要包括以下内容</p>
<ol>
<li>ANR 工作流程</li>
<li>如何监控 ANR？</li>
<li>如何定位 ANR 原因？</li>
</ol>
<h2 id="ANR-工作流程"><a href="#ANR-工作流程" class="headerlink" title="ANR 工作流程"></a>ANR 工作流程</h2><p>ANR 可能触发的时机有多种，通常可以分为以下几方面：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17f8d15a473244799be01927e5c0c785~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>图片来源：<a href="https://juejin.cn/post/6940061649348853796#heading-6" target="_blank" rel="noopener">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></p>
<p>其基本原理其实 WatchDog 的思想，如果发出的事件，在一定时间内没有消费，则触发 ANR。具体源码就不在这里跟了，想详细了解的同学可查看：<a href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg" target="_blank" rel="noopener">微信Android客户端的ANR监控方案</a></p>
<p>这里说一下总体流程，如下图所示：</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p1.png" alt></p>
<ol>
<li>发生 ANR 后，系统会采集许多进程数据，进行堆栈转储，以生成 ANR Trace文件。其中，第一个被采集的进程必定是发生 ANR 的进程。</li>
<li>系统会向这些应用进程发送 SIGQUIT 信号，这些应用进程收到信号后开始进行堆栈转储</li>
<li>应用进程 Dump 堆栈成功后通过 Socket 与系统进程通信写 Trace 文件</li>
<li>在 Trace 文件写入完成后，如果发生 ANR 的进程是前台进程则弹出 Dialog，否则则直接杀死进程</li>
</ol>
<h2 id="如何监控-ANR？"><a href="#如何监控-ANR？" class="headerlink" title="如何监控 ANR？"></a>如何监控 ANR？</h2><p>在了解了 ANR 的工作流程之后，我们该如何监控 ANR 的发生呢？</p>
<h3 id="ANR-WatchDog-检测思路"><a href="#ANR-WatchDog-检测思路" class="headerlink" title="ANR WatchDog 检测思路"></a>ANR WatchDog 检测思路</h3><p>既然 ANR 的原因是输入在定时间内没有响应，那么我们很自然地想到，向主线程发送一个任务，如果一段时间内没有被执行的话，就认为发生了 ANR</p>
<p>这个思路主要有以下几个问题</p>
<ol>
<li>不准确，超时条件不一定会导致 ANR，例如，5 秒超时只是在 TouchEvent 未被消耗时发生 ANR 的条件之一，而其他条件则不一定是 5 秒。</li>
<li>漏检测：如果超时时间定为 5 秒，去检测 TouchEvent 的 ANR 存在一定的漏检测的概率（周期不同步）。</li>
</ol>
<h3 id="ANR-信号监听思路"><a href="#ANR-信号监听思路" class="headerlink" title="ANR 信号监听思路"></a>ANR 信号监听思路</h3><p>在上面介绍 ANR 总体流程时，我们注意到当 ANR 发生时会发送 SIGQUIT 信号，那么我们通过监听这一信号不就可以实现 ANR 监控了吗？事实上 <a href="https://github.com/iqiyi/xCrash" target="_blank" rel="noopener">XCrash</a> 与 <a href="https://github.com/Tencent/matrix" target="_blank" rel="noopener">Matrix</a> 都是通过这种方式实现 ANR 监控的</p>
<p>在这里需要注意，默认情况下进程通过<code>SignalCatcher</code>监听<code>SIGQUIT</code>信号，进行堆栈转储生成 ANR Trace 文件。因此当我们监听<code>SIGQUIT</code>信号后，需要重新向<code>SignalCatcher</code>发送<code>SIGQUIT</code></p>
<p>如果缺少重新向 SignalCatcher 发送 SIGQUIT 信号的步骤，Android System 管理服务（AMS）将一直等待 ANR 进程写入堆栈信息。直到超过20秒的超时时间，AMS 才会被迫中断，并继续后续流程。这将导致 ANR 弹窗的显示非常缓慢（因为超时时间为20秒），同时在 /data/anr 目录下也无法生成完整的 ANR Trace 文件。</p>
<h4 id="误报情况处理"><a href="#误报情况处理" class="headerlink" title="误报情况处理"></a>误报情况处理</h4><p>当监听到 SIGQUIT 信号时，不一定是发生了 ANR。</p>
<p>Matrix 的文档中提到了两种误报的情况：</p>
<ol>
<li>比如可能是其它进程 ANR 了，发生 ANR 的进程不是唯一需要进行堆栈转储的进程。系统会收集许多其他进程进行堆栈转储，用于生成 ANR Trace 文件</li>
<li>厂商或者是开发者自己发送的<code>SIGQUIT</code>信号，发送SIGQUIT信号其实是很容易的一件事情</li>
</ol>
<p>因此我们需要在监听到信号时再进行一次检查：在 ANR 弹窗前，会给发生 ANR 的进程标记一个 NOT_RESPONDING 的 flag，而这个 flag 我们可以通过 ActivityManager 来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkErrorState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application application = sApplication == <span class="keyword">null</span> ? Matrix.with().getApplication() : sApplication;</span><br><span class="line">        ActivityManager am = (ActivityManager) application.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.ProcessErrorStateInfo&gt; procs = am.getProcessesInErrorState();</span><br><span class="line">        <span class="keyword">if</span> (procs == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (ActivityManager.ProcessErrorStateInfo proc : procs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (proc.pid != android.os.Process.myPid()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc.condition != ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">        MatrixLog.e(TAG,<span class="string">"[checkErrorState] error : %s"</span>, t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们可以在监听到信号时判断当前进程是否被标记为 NOT_RESPONDING 来判断当前进程是否发生了 ANR</p>
<h4 id="漏报情况处理"><a href="#漏报情况处理" class="headerlink" title="漏报情况处理"></a>漏报情况处理</h4><p>当进程被标记为 NOT_RESPONDING 时一定发生了 ANR，但是当进程发生了 ANR 时，不一定会被标记为 NOT_RESPONDING</p>
<p>Matrix 的文档中提到了两种漏报情况</p>
<ol>
<li>后台ANR（SilentAnr）: 后台 ANR 会直接杀死进程，不会走到标记状态的代码</li>
<li>厂商定制逻辑: 相当一部分机型(比如 OPPO、VIVO 两家的高版本 Android )修改了 ANR 的逻辑，即使是前台 ANR 也会直接杀死进程</li>
</ol>
<p>Matrix 通过判断主线程在收到 SIGQUIT 信号时是否处于卡顿状态来判断当前是否发生 ANR，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThreadStuck</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageQueue mainQueue = Looper.getMainLooper().getQueue();</span><br><span class="line">        Field field = mainQueue.getClass().getDeclaredField(<span class="string">"mMessages"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">final</span> Message mMessage = (Message) field.get(mainQueue);</span><br><span class="line">        <span class="keyword">if</span> (mMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> when = mMessage.getWhen();</span><br><span class="line">            <span class="keyword">if</span>(when == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> time = when - SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> timeThreshold = BACKGROUND_MSG_THRESHOLD;</span><br><span class="line">            <span class="keyword">if</span> (foreground) &#123;</span><br><span class="line">                timeThreshold = FOREGROUND_MSG_THRESHOLD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> time &lt; timeThreshold;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>通过反射获取主线程<code>Looper</code>的<code>mMessage</code>对象，该消息的<code>when</code>变量，就表示该消息的入队时间</li>
<li>将入队时间与当前时间进行比较，就可以获取该消息的等待时间</li>
<li>当等待时间超过一定阈值的话，我们就认为主线程处于阻塞状态，结合 SIGQUIT 信号，判断为发生了 ANR</li>
</ol>
<h2 id="如何定位-ANR-原因？"><a href="#如何定位-ANR-原因？" class="headerlink" title="如何定位 ANR 原因？"></a>如何定位 ANR 原因？</h2><p>ANR 的影响因素有很多，我们可以把他们分为以下几类：</p>
<ol>
<li>系统资源不足，其它进程或线程存在严重资源抢占，如 IO，Mem，CPU</li>
<li>线程间存在资源抢占，比如死锁等</li>
<li>主线程繁忙，用户输入得不到及时响应</li>
</ol>
<p>在将 ANR 原因分为了以上几类之后，我们需要获取详细的日志信息，才能在发生 ANR 时及时定位原因</p>
<h3 id="获取系统负载信息"><a href="#获取系统负载信息" class="headerlink" title="获取系统负载信息"></a>获取系统负载信息</h3><p>想要获取系统负载信息，我们在线下可以通过获取 /data/anr 目录下的 trace 文件来查看，但是在高版本手机上，我们通常没有权限获取这个目录下的文件，那么在线上我们该如何获取系统负载信息呢？</p>
<p>应用层可通过 AcivityManager 获取 ProcessErrorStateInfo，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">val</span> am = application.getSystemService(Context.ACTIVITY_SERVICE) <span class="keyword">as</span> ActivityManager</span><br><span class="line">    <span class="keyword">val</span> processesInErrorStates = am.processesInErrorState</span><br></pre></td></tr></table></figure>
<p>通过<code>ProcessErrorStateInfo</code>我们可以获取<code>shortMessage</code>与<code>longMessage</code>，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shortMessage</span></span><br><span class="line">ANR Input dispatching timed out (<span class="number">8445</span>a92 com<span class="selector-class">.android</span>.test/com<span class="selector-class">.android</span><span class="selector-class">.test</span><span class="selector-class">.anr</span><span class="selector-class">.ANRActivity</span> (server) is not responding. Waited <span class="number">5000ms</span> <span class="keyword">for</span> MotionEvent(action=DOWN))</span><br></pre></td></tr></table></figure>
<p><code>shortMessage</code>就是产生 ANR 的原因，比较简单</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">longMessage</span></span><br><span class="line"><span class="string">ANR</span> <span class="string">in</span> <span class="string">com.android.test</span> <span class="string">(com.android.test/.anr.ANRActivity)</span></span><br><span class="line"><span class="attr">PID:</span> <span class="number">23283</span></span><br><span class="line"><span class="attr">Reason:</span> <span class="string">Input</span> <span class="string">dispatching</span> <span class="string">timed</span> <span class="string">out</span> <span class="string">(8445a92</span> <span class="string">com.android.test/com.android.test.anr.ANRActivity</span> <span class="string">(server)</span> <span class="string">is</span> <span class="string">not</span> <span class="string">responding.</span> <span class="string">Waited</span> <span class="string">5000ms</span> <span class="string">for</span> <span class="string">MotionEvent(action=DOWN))</span></span><br><span class="line"><span class="attr">Parent:</span> <span class="string">com.android.test/.anr.ANRActivity</span></span><br><span class="line"><span class="attr">ErrorId:</span> <span class="string">91ceb0ce-0af6-496e-8c4f-781075c056db</span></span><br><span class="line"><span class="attr">Frozen:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Load:</span> <span class="number">0.0</span> <span class="string">/</span> <span class="number">0.29</span> <span class="string">/</span> <span class="number">0.33</span></span><br><span class="line"><span class="string">-----</span> <span class="string">Output</span> <span class="string">from</span> <span class="string">/proc/pressure/memory</span> <span class="string">-----</span></span><br><span class="line"><span class="string">some</span> <span class="string">avg10=0.00</span> <span class="string">avg60=0.00</span> <span class="string">avg300=0.00</span> <span class="string">total=150136881</span></span><br><span class="line"><span class="string">full</span> <span class="string">avg10=0.00</span> <span class="string">avg60=0.00</span> <span class="string">avg300=0.00</span> <span class="string">total=51283028</span></span><br><span class="line"><span class="string">-----</span> <span class="string">End</span> <span class="string">output</span> <span class="string">from</span> <span class="string">/proc/pressure/memory</span> <span class="string">-----</span></span><br><span class="line"><span class="string">CPU</span> <span class="string">usage</span> <span class="string">from</span> <span class="string">153ms</span> <span class="string">to</span> <span class="string">605ms</span> <span class="string">later</span> <span class="string">(2023-05-04</span> <span class="number">22</span><span class="string">:38:19.034</span> <span class="string">to</span> <span class="number">2023</span><span class="number">-05</span><span class="number">-04</span> <span class="number">22</span><span class="string">:38:19.486):</span></span><br><span class="line">  <span class="number">79</span><span class="string">%</span> <span class="attr">1990/system_server:</span> <span class="number">35</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">43</span><span class="string">%</span> <span class="attr">kernel / faults:</span> <span class="number">1598</span> <span class="string">minor</span></span><br><span class="line">    <span class="number">43</span><span class="string">%</span> <span class="attr">23375/AnrConsumer:</span> <span class="number">8.1</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">35</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">21</span><span class="string">%</span> <span class="attr">2008/HeapTaskDaemon:</span> <span class="number">19</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">2.7</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">2.7</span><span class="string">%</span> <span class="attr">2919/InputDispatcher:</span> <span class="number">2.7</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">  <span class="number">32</span><span class="string">%</span> <span class="attr">23283/com.android.test:</span> <span class="number">16</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">16</span><span class="string">%</span> <span class="attr">kernel / faults:</span> <span class="number">7</span> <span class="string">minor</span></span><br><span class="line">    <span class="number">28</span><span class="string">%</span> <span class="attr">23315/RenderThread:</span> <span class="number">16</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">12</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">4</span><span class="string">%</span> <span class="attr">23306/binder:23283_3:</span> <span class="number">0</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">4</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">4</span><span class="string">%</span> <span class="attr">23354/binder:23283_5:</span> <span class="number">4</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">  <span class="number">17</span><span class="string">%</span> <span class="attr">1195/surfaceflinger:</span> <span class="number">17</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">10</span><span class="string">%</span> <span class="attr">1195/surfaceflinger:</span> <span class="number">10</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">2.5</span><span class="string">%</span> <span class="attr">1347/binder:1195_1:</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">2.5</span><span class="string">%</span> <span class="attr">1414/TimerDispatch:</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">  <span class="number">5</span><span class="string">%</span> <span class="attr">1071/vendor.qti.hardware.display.composer-service:</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">2.5</span><span class="string">%</span> <span class="attr">1071/composer-servic:</span> <span class="number">0</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">  <span class="string">//...</span></span><br><span class="line"><span class="number">21</span><span class="string">%</span> <span class="attr">TOTAL:</span> <span class="number">10</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">10</span><span class="string">%</span> <span class="string">kernel</span> <span class="string">+</span> <span class="number">0.8</span><span class="string">%</span> <span class="string">irq</span> <span class="string">+</span> <span class="number">0.2</span><span class="string">%</span> <span class="string">softirq</span></span><br></pre></td></tr></table></figure>
<p><code>longMessage</code>则是系统在发生 ANR 之后的一段时间内的负载信息，包括 CPU，IO，内存等</p>
<h3 id="获取进程内所有线程状态"><a href="#获取进程内所有线程状态" class="headerlink" title="获取进程内所有线程状态"></a>获取进程内所有线程状态</h3><p>发生 ANR 也可能是因为进程内的线程发生了资源抢占或者死锁，那么该如何获取进程内所有线程的状态，我们可以再看一下上面的这张图</p>
<p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p1.png" alt></p>
<p>Signal Catcher 的 Dump 发生在应用进程，并且通过 Socket Writer 来写 Trace的。如果我们能够在这个 write 方法上进行 Hook，就可以获取到系统记录下来的 ANR Trace 内容。这个内容非常全面，包括了所有线程的各种状态、锁和堆栈信息（包括 native 堆栈），对于排查问题非常有帮助，特别是一些与 native 问题、死锁等有关的问题。</p>
<p>Matrix 就是通过这种方式来获取 ANR Trace 的，具体实现可见：<a href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg" target="_blank" rel="noopener">微信Android客户端的ANR监控方案</a></p>
<h3 id="定位主线程问题"><a href="#定位主线程问题" class="headerlink" title="定位主线程问题"></a>定位主线程问题</h3><p>由主线程繁忙引起的 ANR 定位困难的原因在于：<strong>耗时可能由历史消息引起，发生 ANR 时正在执行的消息并不耗时</strong>。如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1becc120e1014ee6a340dfbd2bfa6c2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p>
<p>图片来源：<a href="https://juejin.cn/post/6940061649348853796#heading-15" target="_blank" rel="noopener">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></p>
<p>如果在系统服务执行某个历史消息时，已经耗费了大量时间，但在这个消息执行完毕后，系统服务并没有达到触发 ANR 超时的临界点，之后的主线程继续调度其他消息时，如果此时系统判定响应超时，那么正在执行的业务场景将不幸被命中。此时，当前正在执行的业务逻辑并不复杂，但由于之前的某个消息过度耗时，导致系统未能及时响应后续事件。</p>
<p>针对这类问题，一个解决方案是：记录主线程过去一段时间(比如 10s)内所有消息的调度历史，保存业务方需要的关键数据(比如消息耗时或者方法耗时)，在发生 ANR 时，上报监控阈值内的历史数据</p>
<p>通过这种方式，在 ANR 发生时，可以回放过去一段时间的耗时方法，定位耗时原因</p>
<p>头条和虾皮都基于这种思路开发了一些 ANR 监控工具，详情可见：<a href="https://juejin.cn/post/6942665216781975582" target="_blank" rel="noopener">今日头条 ANR 优化实践系列 - 监控工具与分析思路</a>与<a href="https://juejin.cn/post/7136008620658917407" target="_blank" rel="noopener">Android 卡顿与 ANR 的分析实践</a></p>
<p>这些工具目前都没有开源，也有开发者基于头条的思路开源了一套实现，感兴趣的同学可以看看：<a href="https://juejin.cn/post/7031834640034103304" target="_blank" rel="noopener">app卡顿系列四 ：今日头条卡顿监控方案落地</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是对 Matrix，今日头条等 ANR 监控方案的学习，介绍了系统 ANR 机制的工作流程，以及如何监控 ANR 问题，ANR 问题发生时如何定位具体原因等内容</p>
<p>ANR 问题定位困难的原因常常在于信息不足，通过上面介绍的获取系统负载信息，获取进程内所有线程状态，定位主线程问题等方案，应该可以比较有效地还原现场，帮助定位 ANR 问题，希望对你有所帮助~</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg" target="_blank" rel="noopener">微信Android客户端的ANR监控方案</a><br><a href="https://juejin.cn/post/6942665216781975582" target="_blank" rel="noopener">今日头条 ANR 优化实践系列 - 监控工具与分析思路</a></p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>ELF 文件格式详解</title>
    <url>/blog/2023/06/elf-file-summary.html</url>
    <content><![CDATA[<p>最近在读《程序员的自我修养：链接，装载与库》，其实这本书跟 Android 开发的联系还挺紧密的，无论是 NDK 开发，或者是性能优化中一些常用的 Native Hoook 手段，都需要了解一些链接，装载相关的知识点。本文为读书笔记。</p>
<h2 id="ELF-文件是什么？"><a href="#ELF-文件是什么？" class="headerlink" title="ELF 文件是什么？"></a>ELF 文件是什么？</h2><p>ELF 即 Executable and Linkable Format，是 linux 下的可执行文件。</p>
<p>除了 ELF 文件本身，源代码编译后但未链接的中间文件(.o 文件)，动态链接库(.so 文件)，静态链接库(.a 文件)，都按照 ELF 文件格式存储.</p>
<p>ELF 文件标准中把系统中采用 ELF 格式的文件分为以下 4 类</p>
<ul>
<li>可重定位文件(relocatable file)：包括 .o 文件和 .a 文件</li>
<li>可执行文件(executable file)：即 EFL 可执行文件，通常没有后缀</li>
<li>共享库文件(shared object file)：即 .so 文件</li>
<li>核心转储文件(core dump file): 即 core dump 文件</li>
</ul>
<h2 id="ELF-文件总体结构"><a href="#ELF-文件总体结构" class="headerlink" title="ELF 文件总体结构"></a>ELF 文件总体结构</h2><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/june/p2.png" alt></p>
<p>一个 ELF 文件的总体结构如上图所示（上图为链接视图，执行视图略有不同），主要包括以下内容</p>
<ul>
<li>ELF Header，ELF文件头，它包含了描述整个文件的基本属性</li>
<li>ELF 文件中的各个段(section)</li>
<li>段表(section header table), 该表描述了 ELF 文件包含的所有段的信息，比如每个段的段名，段的长度等</li>
<li>其他一些辅助结构，如字符串表，符号表等</li>
</ul>
<h2 id="ELF-文件结构详解"><a href="#ELF-文件结构详解" class="headerlink" title="ELF 文件结构详解"></a>ELF 文件结构详解</h2><p>在上面我们了解了 ELF 文件的总体结构，但耳听为虚，眼见为实，我们接下来实操一下，看下 Elf 文件具体是怎么样的</p>
<p>首先我们添加一个<code>SimpleSection.c</code>文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    fun1(static_var + static_var2 + a + b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们通过<code>gcc -c SimpleSection.c</code>命令只编译不链接生成目标文件：SimpleSection.o，这也是一个 ELF 文件，我们接下来就来分析这个文件的内容</p>
<h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ readelf -h SimpleSection.o</span><br><span class="line"></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2's complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  <span class="keyword">Start</span> <span class="keyword">of</span> program headers:          <span class="number">0</span> (<span class="keyword">bytes</span> <span class="keyword">into</span> <span class="keyword">file</span>)</span><br><span class="line">  <span class="keyword">Start</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:          <span class="number">1184</span> (<span class="keyword">bytes</span> <span class="keyword">into</span> <span class="keyword">file</span>)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> this header:               <span class="number">64</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> program headers:           <span class="number">0</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="built_in">Number</span> <span class="keyword">of</span> program headers:         <span class="number">0</span></span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:           <span class="number">64</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="built_in">Number</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:         <span class="number">14</span></span><br><span class="line">  <span class="keyword">Section</span> header <span class="keyword">string</span> <span class="keyword">table</span> <span class="keyword">index</span>: <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>如上所示，通过<code>readelf</code>命令获取了文件头，可以看到，ELF 的文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、文件类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等信息，包含了描述整个文件的基本属性</p>
<p>ELF 文件头结构及相关常数被定义在<code>/usr/include/elf.h</code>文件中，readelf 输出的信息与这些结构很多都可以一一对应，感兴趣的可以自行查看</p>
<h4 id="ELF-魔数"><a href="#ELF-魔数" class="headerlink" title="ELF 魔数"></a>ELF 魔数</h4><p>头文件中比较有意思的是魔数，魔数的作用是用来确认文件的类型，操作系统在加载可执行文件时会检验魔数是否正确，如果不正确则会拒绝加载</p>
<p>比如我们上面的输出，最开始的 4 个字节是所有 ELF 文件都必须相同的标识码：<code>0x7f</code>, <code>0x45</code>, <code>0x4c</code>, <code>0x46</code>, 第一字节对应 DEL 控制符的 ASCII 码，后面 3 个字节则正好是 ELF 三个字母的 ASCII 码</p>
<p>第 5 个字节用于标识 ELF 文件类，0x01 表示 32 位，0x02 表示 64 位，第 6 个字节用于标记字节序，规定该 ELF 文件是大端还是小端的，第 7 个字节用于标记 ELF 文件主版本号，一般是 1</p>
<p>而后面的 9 个字节，ELF 标准还没有定义，一般填0，有些平台会使用这 9 个字节作为扩展标志</p>
<h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>在头文件之后就是 ELF 文件中各种各样的段了，我们通过 readelf 命令来查看段表，段表中记录了每个段的段名，段的长度，在文件中的偏移，读写权限，以及其它属性</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">readelf</span> <span class="string">-S</span> <span class="string">SimpleSection.o</span></span><br><span class="line"></span><br><span class="line"><span class="string">There</span> <span class="string">are</span> <span class="number">14</span> <span class="string">section</span> <span class="string">headers,</span> <span class="attr">starting at offset 0x4a0:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Section Headers:</span></span><br><span class="line">  <span class="string">[Nr]</span> <span class="string">Name</span>              <span class="string">Type</span>             <span class="string">Address</span>           <span class="string">Offset</span>    <span class="string">Size</span>              <span class="string">EntSize</span>          <span class="string">Flags</span>  <span class="string">Link</span>  <span class="string">Info</span>  <span class="string">Align</span></span><br><span class="line">  <span class="string">[</span> <span class="number">0</span><span class="string">]</span>                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  <span class="string">[</span> <span class="number">1</span><span class="string">]</span> <span class="string">.text</span>             <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="string">000000000000005f</span>  <span class="number">0000000000000000</span>  <span class="string">AX</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">2</span><span class="string">]</span> <span class="string">.rela.text</span>        <span class="string">RELA</span>             <span class="number">0000000000000000</span>  <span class="number">00000380</span>  <span class="number">0000000000000078</span>  <span class="number">0000000000000018</span>   <span class="string">I</span>      <span class="number">11</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[</span> <span class="number">3</span><span class="string">]</span> <span class="string">.data</span>             <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000a0</span>  <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  <span class="string">WA</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  <span class="string">[</span> <span class="number">4</span><span class="string">]</span> <span class="string">.bss</span>              <span class="string">NOBITS</span>           <span class="number">0000000000000000</span>  <span class="string">000000a8</span>  <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  <span class="string">WA</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  <span class="string">[</span> <span class="number">5</span><span class="string">]</span> <span class="string">.rodata</span>           <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000a8</span>  <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>   <span class="string">A</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">6</span><span class="string">]</span> <span class="string">.comment</span>          <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000ac</span>  <span class="string">000000000000002c</span>  <span class="number">0000000000000001</span>  <span class="string">MS</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">7</span><span class="string">]</span> <span class="string">.note.GNU-stack</span>   <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000d8</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">8</span><span class="string">]</span> <span class="string">.note.gnu.propert</span> <span class="string">NOTE</span>             <span class="number">0000000000000000</span>  <span class="string">000000d8</span>  <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   <span class="string">A</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[</span> <span class="number">9</span><span class="string">]</span> <span class="string">.eh_frame</span>         <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000f8</span>  <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   <span class="string">A</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[10]</span> <span class="string">.rela.eh_frame</span>    <span class="string">RELA</span>             <span class="number">0000000000000000</span>  <span class="string">000003f8</span>  <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   <span class="string">I</span>      <span class="number">11</span>     <span class="number">9</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[11]</span> <span class="string">.symtab</span>           <span class="string">SYMTAB</span>           <span class="number">0000000000000000</span>  <span class="number">00000150</span>  <span class="string">00000000000001b0</span>  <span class="number">0000000000000018</span>          <span class="number">12</span>    <span class="number">12</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[12]</span> <span class="string">.strtab</span>           <span class="string">STRTAB</span>           <span class="number">0000000000000000</span>  <span class="number">00000300</span>  <span class="string">000000000000007b</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[13]</span> <span class="string">.shstrtab</span>         <span class="string">STRTAB</span>           <span class="number">0000000000000000</span>  <span class="number">00000428</span>  <span class="number">0000000000000074</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="attr">Key to Flags:</span></span><br><span class="line">  <span class="string">W</span> <span class="string">(write),</span> <span class="string">A</span> <span class="string">(alloc),</span> <span class="string">X</span> <span class="string">(execute),</span> <span class="string">M</span> <span class="string">(merge),</span> <span class="string">S</span> <span class="string">(strings),</span> <span class="string">I</span> <span class="string">(info),</span></span><br><span class="line">  <span class="string">L</span> <span class="string">(link</span> <span class="string">order),</span> <span class="string">O</span> <span class="string">(extra</span> <span class="string">OS</span> <span class="string">processing</span> <span class="string">required),</span> <span class="string">G</span> <span class="string">(group),</span> <span class="string">T</span> <span class="string">(TLS),</span></span><br><span class="line">  <span class="string">C</span> <span class="string">(compressed),</span> <span class="string">x</span> <span class="string">(unknown),</span> <span class="string">o</span> <span class="string">(OS</span> <span class="string">specific),</span> <span class="string">E</span> <span class="string">(exclude),</span></span><br><span class="line">  <span class="string">l</span> <span class="string">(large),</span> <span class="string">p</span> <span class="string">(processor</span> <span class="string">specific)</span></span><br></pre></td></tr></table></figure>
<p>可以看出，段表是一个数组，数组的每一项对应每一个段，其中第一个项是无效的，类型为<code>NULL</code>，因此<code>SimpleSection.o</code>共有 13 个有效的段，段表对应的结构体也定义在<code>/usr/include/elf.h</code>文件中，感兴趣的可以自行查看</p>
<p>下面我们介绍一下段表各个字段的含义</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>段名，段名是个字符串，位于一个叫作 .shstrtab 的字符串表中</td>
</tr>
<tr>
<td>Type</td>
<td>段的类型，段名只在编译和链接阶段有作用，不能真正地表示段的类型，我们也可以将一个数据段命名为”.txt”，对于编译器和链接器来说，主要决定段的属性的是段的类型与段的标志位</td>
</tr>
<tr>
<td>Flags</td>
<td>段的标志位，段的标志位表示该段在进程虚拟地址空间中的属性，比如是否可写，是否可执行等</td>
</tr>
<tr>
<td>Address</td>
<td>段虚拟地址，如果该段可以被加载，则为该段被加载后在进程地址空间中的虚拟地址，否则为 0</td>
</tr>
<tr>
<td>Offset</td>
<td>段偏移，如果该段存在于文件中，则表示该段在文件中的偏移，否则无意义，比如对于 .bss 段就没有意义</td>
</tr>
<tr>
<td>Size</td>
<td>段的长度</td>
</tr>
<tr>
<td>Link 和 Info</td>
<td>段的链接信息，如果段的类型是与链接相关的，比如重定位表，符号表等，则该字段有意义，否则无意义</td>
</tr>
<tr>
<td>Align</td>
<td>段对齐地址，有些段对段地址对齐有要求，由于地址对齐的数量都是 2 的指数倍，Align 表示对齐数量中的指数，比如当 Align = 3 时表示 8 倍，当 Algin 为 0 或者 1 时表示没有对齐要求</td>
</tr>
<tr>
<td>EntSize</td>
<td>项的长度，有些段包含了一些固定大小的项，比如符号表，它包含的每个符号所占的大小是一样的，对于这种段，EntSize 表示每一项的大小。如果为 0 表示该段没有固定大小的项</td>
</tr>
</tbody>
</table>
<p>在了解了段表的结构之后，接下来我们看一下各个段的具体内容</p>
<h3 id="text-代码段"><a href="#text-代码段" class="headerlink" title=".text 代码段"></a>.text 代码段</h3><p>首先我们通过 objdump 命令来看下代码段的具体内容，objdump 的 “-s” 参数可以将所有段的内容以 16 进制的方式打印出来，”-d” 参数可以将所有包含指令的段反汇编，结果如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">objdump</span> <span class="string">-s</span> <span class="string">-d</span> <span class="string">SimpleSection.o</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Contents of section .text:</span></span><br><span class="line"> <span class="number">0000</span> <span class="string">f30f1efa</span> <span class="number">554889e5</span> <span class="string">4883ec10</span> <span class="string">897dfc8b</span>  <span class="string">....UH..H....&#125;..</span></span><br><span class="line"> <span class="number">0010</span> <span class="string">45fc89c6</span> <span class="string">488d3d00</span> <span class="string">000000b8</span> <span class="number">00000000</span>  <span class="string">E...H.=.........</span></span><br><span class="line"> <span class="number">0020</span> <span class="string">e8000000</span> <span class="string">0090c9c3</span> <span class="string">f30f1efa</span> <span class="number">554889e5</span>  <span class="string">............UH..</span></span><br><span class="line"> <span class="number">0030</span> <span class="string">4883ec10</span> <span class="string">c745f801</span> <span class="string">0000008b</span> <span class="number">15000000</span>  <span class="string">H....E..........</span></span><br><span class="line"> <span class="number">0040</span> <span class="string">008b0500</span> <span class="number">00000001</span> <span class="string">c28b45f8</span> <span class="string">01c28b45</span>  <span class="string">..........E....E</span></span><br><span class="line"> <span class="number">0050</span> <span class="string">fc01d089</span> <span class="string">c7e80000</span> <span class="string">00008b45</span> <span class="string">f8c9c3</span>    <span class="string">...........E...</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">Disassembly of section .text:</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> <span class="string">&lt;fun1&gt;:</span></span><br><span class="line">   <span class="attr">0:</span>   <span class="string">f3</span> <span class="string">0f</span> <span class="string">1e</span> <span class="string">fa</span>             <span class="string">endbr64</span> </span><br><span class="line">   <span class="attr">4:</span>   <span class="number">55</span>                      <span class="string">push</span>   <span class="string">%rbp</span></span><br><span class="line">   <span class="attr">5:</span>   <span class="number">48</span> <span class="number">89</span> <span class="string">e5</span>                <span class="string">mov</span>    <span class="string">%rsp,%rbp</span></span><br><span class="line">   <span class="attr">8:</span>   <span class="number">48</span> <span class="number">83</span> <span class="string">ec</span> <span class="number">10</span>             <span class="string">sub</span>    <span class="string">$0x10,%rsp</span></span><br><span class="line">   <span class="attr">c:</span>   <span class="number">89</span> <span class="string">7d</span> <span class="string">fc</span>                <span class="string">mov</span>    <span class="string">%edi,-0x4(%rbp)</span></span><br><span class="line">   <span class="attr">f:</span>   <span class="string">8b</span> <span class="number">45</span> <span class="string">fc</span>                <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp),%eax</span></span><br><span class="line">  <span class="attr">12:</span>   <span class="number">89</span> <span class="string">c6</span>                   <span class="string">mov</span>    <span class="string">%eax,%esi</span></span><br><span class="line">  <span class="attr">14:</span>   <span class="number">48</span> <span class="string">8d</span> <span class="string">3d</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="string">lea</span>    <span class="number">0x0</span><span class="string">(%rip),%rdi</span>        <span class="comment"># 1b &lt;fun1+0x1b&gt;</span></span><br><span class="line">  <span class="attr">1b:</span>   <span class="string">b8</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="string">mov</span>    <span class="string">$0x0,%eax</span></span><br><span class="line">  <span class="attr">20:</span>   <span class="string">e8</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="string">callq</span>  <span class="number">25</span> <span class="string">&lt;fun1+0x25&gt;</span></span><br><span class="line">  <span class="attr">25:</span>   <span class="number">90</span>                      <span class="string">nop</span></span><br><span class="line">  <span class="attr">26:</span>   <span class="string">c9</span>                      <span class="string">leaveq</span> </span><br><span class="line">  <span class="attr">27:</span>   <span class="string">c3</span>                      <span class="string">retq</span>   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000028</span> <span class="string">&lt;main&gt;:</span></span><br><span class="line">  <span class="attr">28:</span>   <span class="string">f3</span> <span class="string">0f</span> <span class="string">1e</span> <span class="string">fa</span>             <span class="string">endbr64</span> </span><br><span class="line">  <span class="attr">2c:</span>   <span class="number">55</span>                      <span class="string">push</span>   <span class="string">%rbp</span></span><br><span class="line">  <span class="attr">2d:</span>   <span class="number">48</span> <span class="number">89</span> <span class="string">e5</span>                <span class="string">mov</span>    <span class="string">%rsp,%rbp</span></span><br><span class="line">  <span class="attr">30:</span>   <span class="number">48</span> <span class="number">83</span> <span class="string">ec</span> <span class="number">10</span>             <span class="string">sub</span>    <span class="string">$0x10,%rsp</span></span><br><span class="line">  <span class="attr">34:</span>   <span class="string">c7</span> <span class="number">45</span> <span class="string">f8</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="string">movl</span>   <span class="string">$0x1,-0x8(%rbp)</span></span><br><span class="line">  <span class="attr">3b:</span>   <span class="string">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="string">mov</span>    <span class="number">0x0</span><span class="string">(%rip),%edx</span>        <span class="comment"># 41 &lt;main+0x19&gt;</span></span><br><span class="line">  <span class="attr">41:</span>   <span class="string">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="string">mov</span>    <span class="number">0x0</span><span class="string">(%rip),%eax</span>        <span class="comment"># 47 &lt;main+0x1f&gt;</span></span><br><span class="line">  <span class="attr">47:</span>   <span class="number">01</span> <span class="string">c2</span>                   <span class="string">add</span>    <span class="string">%eax,%edx</span></span><br><span class="line">  <span class="attr">49:</span>   <span class="string">8b</span> <span class="number">45</span> <span class="string">f8</span>                <span class="string">mov</span>    <span class="number">-0x8</span><span class="string">(%rbp),%eax</span></span><br><span class="line">  <span class="attr">4c:</span>   <span class="number">01</span> <span class="string">c2</span>                   <span class="string">add</span>    <span class="string">%eax,%edx</span></span><br><span class="line">  <span class="attr">4e:</span>   <span class="string">8b</span> <span class="number">45</span> <span class="string">fc</span>                <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp),%eax</span></span><br><span class="line">  <span class="attr">51:</span>   <span class="number">01</span> <span class="string">d0</span>                   <span class="string">add</span>    <span class="string">%edx,%eax</span></span><br><span class="line">  <span class="attr">53:</span>   <span class="number">89</span> <span class="string">c7</span>                   <span class="string">mov</span>    <span class="string">%eax,%edi</span></span><br><span class="line">  <span class="attr">55:</span>   <span class="string">e8</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="string">callq</span>  <span class="string">5a</span> <span class="string">&lt;main+0x32&gt;</span></span><br><span class="line">  <span class="attr">5a:</span>   <span class="string">8b</span> <span class="number">45</span> <span class="string">f8</span>                <span class="string">mov</span>    <span class="number">-0x8</span><span class="string">(%rbp),%eax</span></span><br><span class="line">  <span class="attr">5d:</span>   <span class="string">c9</span>                      <span class="string">leaveq</span> </span><br><span class="line">  <span class="attr">5e:</span>   <span class="string">c3</span>                      <span class="string">retq</span></span><br></pre></td></tr></table></figure>
<p><code>Contents of section .text</code>就是.text的数据以十六进制方式打印出来的内容，总共 0x5f 字节，最左面一列是偏移量，中间4列是十六进制内容，最右面一列是 .text 段的 ASCII 码形式。</p>
<p><code>Disassembly of section .text</code>则是代码段反汇编的结果，可以很明显地看到，.text 段中的内容就是<code>SimpleSection.c</code>里两个函数<code>func1()</code>和<code>main()</code>的指令。</p>
<h3 id="数据段与只读数据段"><a href="#数据段与只读数据段" class="headerlink" title="数据段与只读数据段"></a>数据段与只读数据段</h3><p>接下来我们通过 objdump 命令看看数据段与只读数据段的内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">objdump</span> <span class="string">-x</span> <span class="string">-s</span> <span class="string">-d</span> <span class="string">SimpleSection.o</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Sections:</span></span><br><span class="line"><span class="string">Idx</span> <span class="string">Name</span>          <span class="string">Size</span>      <span class="string">VMA</span>               <span class="string">LMA</span>               <span class="string">File</span> <span class="string">off</span>  <span class="string">Algn</span></span><br><span class="line">  <span class="number">1</span> <span class="string">.data</span>         <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="string">000000a0</span>  <span class="number">2</span><span class="string">**2</span></span><br><span class="line">                  <span class="string">CONTENTS,</span> <span class="string">ALLOC,</span> <span class="string">LOAD,</span> <span class="string">DATA</span></span><br><span class="line">  <span class="number">3</span> <span class="string">.rodata</span>       <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="string">000000a8</span>  <span class="number">2</span><span class="string">**0</span></span><br><span class="line">                  <span class="string">CONTENTS,</span> <span class="string">ALLOC,</span> <span class="string">LOAD,</span> <span class="string">READONLY,</span> <span class="string">DATA</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Contents of section .data:</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">54000000</span> <span class="number">55000000</span>                    <span class="string">T...U...</span>        </span><br><span class="line"><span class="attr">Contents of section .rodata:</span></span><br><span class="line"> <span class="number">0000</span> <span class="string">25640a00</span>                             <span class="string">%d..</span></span><br></pre></td></tr></table></figure>
<p>.data 段保存的是那些已经初始化了的全局静态变量和局部静态变量，<code>SimpleSection.c</code>中的<code>global_init_var</code>与<code>static_var</code>两个变量属于这种情况，这两个变量每个4个字节，一共刚好 8 个字节，所以 .data 段的大小为8个字节</p>
<p>.rodata 段存放的是只读数据，一般是程序中的只读变量(如 const 修饰的变量)和字符串常量，比如在<code>SimpleSection.c</code>中调用<code>printf</code>时用到的字符串常量，就储存在 .rodata 段中。需要注意的是，有的编译器会把字符串常量放在 .data 段中，而不会单独放在 .rodata 段中</p>
<p>接下来我们看下两个段中存储的内容</p>
<p>.data 中存储的内容即<code>0x00000054</code>与<code>0x00000055</code>，以小端序存放，它们的值正好对应十进制的<code>84</code>与<code>85</code>，也就是我们赋给<code>global_init_var</code>与<code>static_var</code>的值</p>
<p>.rodata 中存储的内容为<code>0x25640a00</code>，正好对应<code>%d\n</code>的 ASCII 码，可以对照<a href="http://c.biancheng.net/c/ascii/" target="_blank" rel="noopener">ASCII码一览表，ASCII码对照表</a>查看</p>
<h3 id="bss-段"><a href="#bss-段" class="headerlink" title=".bss 段"></a>.bss 段</h3><p>.bss 段存放未初始化的全局变量和局部静态变量，那么问题来了，为什么要把已初始化的变量和未初始化的变量分开存储的，为什么不直接放在 .data 段中？</p>
<p>答案是 .bss 段不占空间，我们接下来看一个直观的例子，来看看 .bss 的作用</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> echo <span class="string">"char array[1024*1024*64] = &#123;'A'&#125;; int main() &#123;return 0;&#125;"</span> | gcc <span class="literal">-x</span> c - <span class="literal">-o</span> <span class="keyword">data</span></span><br><span class="line"><span class="variable">$</span> ls <span class="literal">-lh</span> <span class="keyword">data</span></span><br><span class="line"><span class="literal">-rwxrwxrwx</span> <span class="number">1</span> codespace codespace <span class="number">65</span>M Jun <span class="number">25</span> <span class="number">01</span>:<span class="number">26</span> <span class="keyword">data</span></span><br><span class="line"><span class="variable">$</span> echo <span class="string">"char array[1024*1024*64]; int main() &#123;return 0;&#125;"</span> | gcc <span class="literal">-x</span> c - <span class="literal">-o</span> bss</span><br><span class="line"><span class="variable">$</span> ls <span class="literal">-lh</span> bss</span><br><span class="line"><span class="literal">-rwxrwxrwx</span> <span class="number">1</span> codespace codespace <span class="number">17</span>K Jun <span class="number">25</span> <span class="number">01</span>:<span class="number">27</span> bss</span><br></pre></td></tr></table></figure>
<ul>
<li>示例 1 中，array 变量已经被初始化，存放在 .data 段中，占用文件空间，因此整个文件大小共有 65 M</li>
<li>示例 2 中，array 变量未被初始化，存放在 .bss 段中，不占用文件空间，因此整个文件大小只有 17 K</li>
</ul>
<p>可以看到，差别非常大。当然 .bss 段不占据实际的磁盘空间，但它的大小与符号还是要有地方存储，.bss 段的大小记录在段表中，符号记录在符号表中。当文件加载运行时，才分配空间以及初始化</p>
<p>接下来我们用 objdump 命令来看看<code>SimpleSection.o</code> 的 .bss 段的内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">objdump</span> <span class="string">-x</span> <span class="string">-s</span> <span class="string">-d</span> <span class="string">SimpleSection.o</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">Sections:</span></span><br><span class="line"><span class="string">Idx</span> <span class="string">Name</span>          <span class="string">Size</span>      <span class="string">VMA</span>               <span class="string">LMA</span>               <span class="string">File</span> <span class="string">off</span>  <span class="string">Algn</span></span><br><span class="line">  <span class="number">2</span> <span class="string">.bss</span>          <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="string">000000a8</span>  <span class="number">2</span><span class="string">**2</span></span><br><span class="line">                  <span class="string">ALLOC</span></span><br><span class="line"><span class="attr">SYMBOL TABLE:</span></span><br><span class="line"><span class="number">0000000000000000</span> <span class="string">l</span>     <span class="string">O</span> <span class="string">.bss</span>   <span class="number">0000000000000004</span> <span class="string">static_var2.1921</span></span><br><span class="line"><span class="number">0000000000000004</span>       <span class="string">O</span> <span class="string">*COM*</span>  <span class="number">0000000000000004</span> <span class="string">global_uninit_var</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们本来预期 .bass 段中会有<code>global_uninit_var</code>与<code>static_var2</code>两个变量，共 8 个字节，实际上只有<code>static_var2</code>一个变量，4 个字节</p>
<p>这是因为有些编译器会将全局的未初始化变量存放在目标文件.bss 段，有些则不存放，只是预留一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在 .bss 段分配空间</p>
<h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><p>除了 .text, .data, .bss 这 3 个最常用的段之外，ELF 文件也包含一些其他的段，下面列出了一些常见的段</p>
<table>
<thead>
<tr>
<th>段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.rodata1</td>
<td>只读数据段，存放只读数据，与 .rodata 一样</td>
</tr>
<tr>
<td>.comment</td>
<td>存放编译器版本信息</td>
</tr>
<tr>
<td>.debug</td>
<td>调试信息</td>
</tr>
<tr>
<td>.dynamic</td>
<td>动态链接信息</td>
</tr>
<tr>
<td>.hash</td>
<td>符号哈希表</td>
</tr>
<tr>
<td>.line</td>
<td>调试时的行号表，即源代码行号与编译后指令的对应表</td>
</tr>
<tr>
<td>.note</td>
<td>额外的编译信息，如程序的公司名，发布版本号等</td>
</tr>
<tr>
<td>.strtab</td>
<td>字符串表，用于存储 ELF 中的各种字符串</td>
</tr>
<tr>
<td>.symtab</td>
<td>符号表</td>
</tr>
<tr>
<td>.shstrtab</td>
<td>段表字符串表，用于存储段表中用到的字符串</td>
</tr>
<tr>
<td>.plt .got</td>
<td>动态链接的跳转表和全局入口表</td>
</tr>
<tr>
<td>.init .finit</td>
<td>程序初始化与终结代码段</td>
</tr>
<tr>
<td>.rel.text</td>
<td>重定位表</td>
</tr>
</tbody>
</table>
<p>这里面的很多段我们之后都会用到，比如 PLT Hook 中会用到的 .plt .got 段，在静态链接中会用到重定位表，这里可以先留个印象</p>
<h2 id="Elf-中的符号"><a href="#Elf-中的符号" class="headerlink" title="Elf 中的符号"></a>Elf 中的符号</h2><p>链接过程的本质是把多个目标文件按照一定的规则拼接起来，在链接过程中，目标文件的拼接其实就是目标文件之间对地址的引用，即对函数和变量的地址的引用。</p>
<p>每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p>
<p>整个链接过程正是基于符号才能够正确完成。链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址</p>
<p>我们将符号表中的符号分为以下几类:</p>
<ul>
<li>定义在本目标文件的全局符号，可以被其他目标文件引用。比如<code>SimpleSection.o</code>里面的<code>func1</code>、<code>main</code>和<code>global_init_var</code>。</li>
<li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号（External Symbol），也就是我们前面所讲的符号引用。比如<code>SimpleSection.o</code>里面的<code>printf</code>。</li>
<li>段名，这种符号往往由编译器产生，它的值就是该段的起始地址。比如<code>SimpleSection.o</code>里面的<code>.text</code>、<code>.data</code>等。</li>
<li>局部符号，这类符号只在编译单元内部可见。比如<code>SimpleSection.o</code>里面的<code>static_var</code>和<code>static_var2</code>。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件。这些局部符号对于链接过程没有作用，链接器往往也忽略它们。</li>
<li>行号信息，即目标文件指令与源代码中代码行的对应关系，它也是可选的。”</li>
</ul>
<p>其中最值得关注的就是全局符号，因为链接过程只关心全局符号的相互拼接，局部符号、段名、行号等都是次要的，它们对于其他目标文件来说是“不可见”的，在链接过程中也是无关紧要的</p>
<h3 id="ELF-符号表的结构"><a href="#ELF-符号表的结构" class="headerlink" title="ELF 符号表的结构"></a>ELF 符号表的结构</h3><p>首先我们通过 readelf 命令来查看<code>SimpleSection.o</code> 的符号表</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ readelf -s SimpleSection.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">'.symtab'</span> contains 18 entries:</span><br><span class="line">   Num:    Value          Size<span class="built_in"> Type </span>   Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL <span class="built_in"> DEFAULT </span> UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL <span class="built_in"> DEFAULT </span> ABS SimpleSection.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   5 </span><br><span class="line">     6: 0000000000000004     4 OBJECT  LOCAL <span class="built_in"> DEFAULT </span>   3 static_var.1920</span><br><span class="line">     7: 0000000000000000     4 OBJECT  LOCAL <span class="built_in"> DEFAULT </span>   4 static_var2.1921</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   7 </span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   8 </span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   9 </span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   6 </span><br><span class="line">    12: 0000000000000000     4 OBJECT  GLOBAL<span class="built_in"> DEFAULT </span>   3 global_init_var</span><br><span class="line">    13: 0000000000000004     4 OBJECT  GLOBAL<span class="built_in"> DEFAULT </span> COM global_uninit_var</span><br><span class="line">    14: 0000000000000000    40 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>   1 fun1</span><br><span class="line">    15: 0000000000000000     0 NOTYPE  GLOBAL<span class="built_in"> DEFAULT </span> UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    16: 0000000000000000     0 NOTYPE  GLOBAL<span class="built_in"> DEFAULT </span> UND printf</span><br><span class="line">    17: 0000000000000028    55 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>   1 main</span><br></pre></td></tr></table></figure>
<p>接下来我们介绍一个各个列的含义，如下表所示</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>符号名</td>
</tr>
<tr>
<td>Value</td>
<td>符号对应的值，不同的符号，其值的含义不同，见下文详细解析</td>
</tr>
<tr>
<td>Size</td>
<td>符号大小，对于包含数据的符号，这个值是数据类型的大小，比如一个 int 类型的符号占 4 个字节，如果该值为 0 表示该符号大小为 0 或未知</td>
</tr>
<tr>
<td>Type</td>
<td>符号类型，分为未知符号类型，数据对象类型，函数类型，文件类型等</td>
</tr>
<tr>
<td>Bind</td>
<td>绑定信息，用于区分局部符号，全局符号与弱引用符号</td>
</tr>
<tr>
<td>Vis</td>
<td>在 C/C++ 中未使用，可忽略</td>
</tr>
<tr>
<td>Ndx</td>
<td>符号所在的段,如果符号定义在本目标文件中，该值表示符号所在段在段表中的下标。<br>如果该值为 ABS,表示该符号包含了一个绝对的值，比如上面的文件类型的符号。<br>如果该值为 COM，表示该值是一个 Common 块类型的符号。<br>如果该值为 UND，表示为定义，说明该符号在本目标文件中被引用，在其他文件中声明</td>
</tr>
</tbody>
</table>
<p>上面说到不同的符号，其值含义不同，具体可以分为以下几种</p>
<ul>
<li>在目标文件中，如果是符号的定义并且该符号不是<code>COMMON块</code>类型的，则<code>Value</code>表示该符号在段中的偏移。比如<code>SimpleSection.o</code>中的<code>func1</code>、<code>main</code>和<code>global_init_var</code>。</li>
<li>在目标文件中，如果符号是<code>COMMON块</code>类型的，则<code>Value</code>表示该符号的对齐属性。比如<code>SimpleSection.o</code>中的<code>global_uninit_var</code>。</li>
<li>在可执行文件中，<code>Value</code>表示符号的虚拟地址。这个虚拟地址对于动态链接器来说十分有用。</li>
</ul>
<h3 id="C-的-Name-Mangling-机制"><a href="#C-的-Name-Mangling-机制" class="headerlink" title="C++ 的 Name Mangling 机制"></a>C++ 的 Name Mangling 机制</h3><p>我们前面提到每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆，因此在 C 语言目标文件链接过程中，如果有两个文件中都有<code>fun1</code>函数，链接过程就会报错</p>
<p>但当程序很大时，不同的模块由多人开发，如果命名规范不严格，很容易出现符号冲突的问题，于是像C++这样的后来设计的语言开始考虑到了这个问题，增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题。</p>
<p>同时 C++拥有类、继承、虚机制、重载、名称空间等这些特性，它们使得符号管理更为复杂。最简单的例子，两个相同名字的函数<code>func(int)</code>和<code>func(double)</code>，尽管函数名相同，但是参数列表不同，那么编译器和链接器在链接过程中如何区分这两个函数呢？为了支持 C++ 这些复杂的特性，人们发明了符号修饰（Name Decoration）机制</p>
<p>比如下面这段代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span>           </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;     &#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span>  <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">float</span> f)</span>  </span>&#123; <span class="keyword">return</span> i + f; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span> </span>&#123; <span class="keyword">return</span> i+d;   &#125;</span><br></pre></td></tr></table></figure>
<p>经过name mangling操作后，得到的符号表中和<code>func</code>有关的内容如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ g++ main<span class="selector-class">.cc</span> -o main<span class="selector-class">.o</span> &amp;&amp; objdump -t main.o</span><br><span class="line">main<span class="selector-class">.o</span>:     file format elf64-x86-<span class="number">64</span></span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line"><span class="number">0000000000001157</span> g     F <span class="selector-class">.text</span>  <span class="number">000000000000001</span>c              _Z4funcid</span><br><span class="line"><span class="number">000000000000113</span>b g     F <span class="selector-class">.text</span>  <span class="number">000000000000001</span>c              _Z4funcif</span><br><span class="line"><span class="number">0000000000001129</span> g     F <span class="selector-class">.text</span>  <span class="number">0000000000000012</span>              _Z4funci</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，所有的符号都以<code>_Z</code>开头，前缀<code>_Z</code>是 GCC 的规定，具体是怎样转化的这里就不详细介绍了，有兴趣的读者可以参考GCC的名称修饰标准。同时我们也可以利用 nm 或 c++filt 等工具来解析被修饰的符号，不用自己手动解析</p>
<p>Name Mangling 机制使用地非常广泛，当我们查看 android so 的符号表时，可以看到很多以<code>_Z</code>开头的符号，就可以知道他们都是被修饰过的符号</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 ELF 文件的详细结构，包括文件头，段表，各个段的结构，符号表的结构等内容。</p>
<p>这些基础知识可能有些枯燥，但是这些知识点在 Android 性能优化中的应用还是很广泛的，因此还是有必要了解一下的</p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
</search>

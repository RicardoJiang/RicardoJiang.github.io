<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ricardo-谁谓河广</title>
  
  <subtitle>谁谓河广</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://RicardoJiang.github.io/"/>
  <updated>2023-12-27T15:40:05.241Z</updated>
  <id>http://RicardoJiang.github.io/</id>
  
  <author>
    <name>Ricardo.M.Jiang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>江同学的 2023 年终总结，请查收~</title>
    <link href="http://RicardoJiang.github.io/blog/2023/12/2023-sum-up.html"/>
    <id>http://RicardoJiang.github.io/blog/2023/12/2023-sum-up.html</id>
    <published>2023-12-26T14:48:18.000Z</published>
    <updated>2023-12-27T15:40:05.241Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间 2023 年也要过去了，今年也是坚持写年终总结的第 4 年，这个好习惯还是要保持下去。</p><p>感觉今年的输出比往年要少些，有很多目标也没有实现，但还是把今年的输出记录在这里，作为总结，如果对你有用，欢迎留言点赞转发。</p><h2 id="举办-KotlinConf-Global-活动"><a href="#举办-KotlinConf-Global-活动" class="headerlink" title="举办 KotlinConf Global 活动"></a>举办 KotlinConf Global 活动</h2><p>KotlinConf 是由JetBrains 主办的年度大会，汇集了来自世界各地的开发者、爱好者与专家，分享他们的Kotlin 知识与经验。而 KotlinConf Global 则是 KotlinConf 在全球各个城市的拓展活动。在活动中，我们可以与社区成员一起观看 KotlinConf 直播，也可以举办线下分享活动。</p><p>今年是经历疫情之后 KotlinConf 的再次回归，我们也趁此机会举办了北京 Kotlin 用户组久违的线下活动。</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/december/p18.png" alt></p><p>这也是我首次举办开发者线下聚会活动，从最初的活动申请，到后续的时间、地点的确定，再到诸如寻找讲师、活动宣传、推动报名、安排礼品准备，以及布置会场、实际举办活动，以及最后的总结、复盘等多环节，都有不少有意思的事，学到了很多。</p><p>活动的直播回放也已经上传到 B 站了，感兴趣的同学可以查看</p><ul><li><a href="https://www.bilibili.com/video/BV1Zz4y1874b/" target="_blank" rel="noopener">你想知道的 Jetpack Compose 的编译器黑魔法</a></li><li><a href="https://www.bilibili.com/video/BV1gs4y1Q7UH/" target="_blank" rel="noopener">Compose 到底能玩出什么花？</a></li><li><a href="https://www.bilibili.com/video/BV1Xs4y1u7jG/" target="_blank" rel="noopener">KMM 跨平台原理及实践</a></li></ul><p>同时在这里再次感谢霍丙乾，朱江，刘银龙三位讲师的大力支持，以及高金龙，关振智两位热心志愿者的鼎力帮助，期待与各位 Kotlin 开发者明年再相聚~</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/december/p19.png" alt></p><h2 id="《Kotlin-技术月报》总结与输出"><a href="#《Kotlin-技术月报》总结与输出" class="headerlink" title="《Kotlin 技术月报》总结与输出"></a>《Kotlin 技术月报》总结与输出</h2><p>我已经担任了一段时间的北京 Kotlin 用户组的组织者，但一直感觉对社区没有足够的输出，在参加 KotlinConf 和 Google I/O 的过程中，我发现他们都有大量的 Kotlin 技术分享，同时各地的 Kotlin 组织也举办了不少活动。因此为了帮助社区的小伙伴们更好地了解 Kotlin 相关的最新动态，我决定尝试使用月报的形式，整理展示最近一个月的 Kotlin 技术动态。</p><p>月报的主要内容包括：整理展示最近一个月的最新技术动态，精选博客，精选视频，社区活动等，目前已经编写了 8 期，感兴趣的同学可查看：<a href="https://beijing-kug.github.io/news/" target="_blank" rel="noopener">https://beijing-kug.github.io/news/</a></p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/december/p20.png" alt></p><p>同时在这里欢迎所有对 Kotlin 感兴趣的开发者加入用户组，在这里可以和其它成员一起讨论 Kotlin 语言的各项技术与最新特性，我们还会不定期举行分享会，进行与 Kotlin 相关的主题分享与讨论。如果你想要加入，可以关注微信公众号“程序员江同学”，点击技术讨论，加入技术交流群</p><h2 id="《Android-性能优化手册》开发"><a href="#《Android-性能优化手册》开发" class="headerlink" title="《Android 性能优化手册》开发"></a>《Android 性能优化手册》开发</h2><p>从事 Android 开发已经好几年了，开发过程中也经常涉及性能优化需求。但总的来说，仍存在诸多不足之处，一是缺乏深入理解，二是不够体系化。</p><p>在我看来，Android 性能优化的难点在于以下几点</p><ul><li>Android 系统架构涵盖应用层、Framework 层、Android 运行时和原生库以及 Linux 内核层等多个层次，要真正体系化的进行性能优化，不仅要了解应用层，更要全面理解这些层面以及它们之间的关系</li><li>性能优化涉及的知识面非常广泛，包括计算机硬件，操作系统，内存管理、线程与进程调度，JVM 虚拟机，C/C++ 基础等多个方面，需要对这些知识点进行深入学习才能更好地进行优化</li></ul><p>由于性能优化的复杂性，并不是零零散散地看一些博客文章就可以掌握的，因此我发起了本站，期望能够系统地整理 Android 性能优化的各个方向及关键知识点，并介绍业界常用的性能优化实战方案与技术动态。</p><p>本站预期将包含以下内容，正在建设中，敬请期待</p><ul><li>Android 性能优化相关学习资源与学习路线总结</li><li>以技术月报的形式总结过去一个月(但不限于此)性能优化相关的优质博客，视频，开源项目等</li><li>Android 性能优化中需要用到的计算机基础知识介绍</li><li>针对启动速度、内存、卡顿、瘦身等常见优化方向，进行原理剖析并结合实战案例来解决</li></ul><p>对 Android 性能优化感兴趣的同学可查看：<a href="https://android-performance-optimization.github.io/" target="_blank" rel="noopener">Android 性能优化手册</a></p><h2 id="Kotlin-中文开发者大会分享"><a href="#Kotlin-中文开发者大会分享" class="headerlink" title="Kotlin 中文开发者大会分享"></a>Kotlin 中文开发者大会分享</h2><p>众所周知，使用 Gson、Jackson 等框架反序列化 JSON 到 Kotlin 类时存在空安全问题和构造器默认值失效的问题，同时常用的 Gson, Moshi 等框架往往在功能上比较强大，全面，而在性能上却没有很明显的优势。为了实现更安全的 Gson 与更快的 Moshi，我们团队开发并开源了 Kudos 框架。</p><p>Kudos 是 Kotlin utilities for deserializing objects 的缩写。它可以解决使用 Gson、Jackson 等框架反序列化 JSON 到 Kotlin 类时所存在的空安全问题和构造器默认值失效的问题，同时可以简化高性能的反序列化框架 JsonReader 的使用方式。</p><p>Kudos 已经在 Github 上开源，开源地址可见：<a href="https://github.com/kanyun-inc/Kudos" target="_blank" rel="noopener">https://github.com/kanyun-inc/Kudos</a></p><p>同时我也在 2023 Kotlin 中文开发者大会上对 Kudos 框架的需求背景，使用方式，实现原理等内容做了分享，分享文字版可见：<a href="https://juejin.cn/post/7313242107681882138" target="_blank" rel="noopener">使用 KCP 打造更安全的 Gson 与更快的 Moshi</a></p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/december/p21.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相信大家都听过一句话，能教会别人才是真正的懂了，这句话背后的原理其实就是费曼学习法。当我们学习一个知识点时，并不是学过了就算学完了，一定要有相应的输出。</p><p>在输出过程中，我们肯定也会遇到新的问题，然后继续学习、分享，循环这样一个过程，最终更全面的掌握知识，最终触类旁通，举一反三，通过输出的方式可以帮助我们更加深入的掌握知识点。</p><p>这也是我这些年一直在坚持输出的原因，希望在新的一年里可以跟大家多交流，相互学习，共同进步~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转眼间 2023 年也要过去了，今年也是坚持写年终总结的第 4 年，这个好习惯还是要保持下去。&lt;/p&gt;
&lt;p&gt;感觉今年的输出比往年要少些，有很多目标也没有实现，但还是把今年的输出记录在这里，作为总结，如果对你有用，欢迎留言点赞转发。&lt;/p&gt;
&lt;h2 id=&quot;举办-Kotli
      
    
    </summary>
    
    
      <category term="总结" scheme="http://RicardoJiang.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ELF 文件格式详解</title>
    <link href="http://RicardoJiang.github.io/blog/2023/06/elf-file-summary.html"/>
    <id>http://RicardoJiang.github.io/blog/2023/06/elf-file-summary.html</id>
    <published>2023-06-19T15:16:14.000Z</published>
    <updated>2023-10-02T05:58:25.790Z</updated>
    
    <content type="html"><![CDATA[<p>最近在读《程序员的自我修养：链接，装载与库》，其实这本书跟 Android 开发的联系还挺紧密的，无论是 NDK 开发，或者是性能优化中一些常用的 Native Hoook 手段，都需要了解一些链接，装载相关的知识点。本文为读书笔记。</p><h2 id="ELF-文件是什么？"><a href="#ELF-文件是什么？" class="headerlink" title="ELF 文件是什么？"></a>ELF 文件是什么？</h2><p>ELF 即 Executable and Linkable Format，是 linux 下的可执行文件。</p><p>除了 ELF 文件本身，源代码编译后但未链接的中间文件(.o 文件)，动态链接库(.so 文件)，静态链接库(.a 文件)，都按照 ELF 文件格式存储.</p><p>ELF 文件标准中把系统中采用 ELF 格式的文件分为以下 4 类</p><ul><li>可重定位文件(relocatable file)：包括 .o 文件和 .a 文件</li><li>可执行文件(executable file)：即 EFL 可执行文件，通常没有后缀</li><li>共享库文件(shared object file)：即 .so 文件</li><li>核心转储文件(core dump file): 即 core dump 文件</li></ul><h2 id="ELF-文件总体结构"><a href="#ELF-文件总体结构" class="headerlink" title="ELF 文件总体结构"></a>ELF 文件总体结构</h2><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/june/p2.png" alt></p><p>一个 ELF 文件的总体结构如上图所示（上图为链接视图，执行视图略有不同），主要包括以下内容</p><ul><li>ELF Header，ELF文件头，它包含了描述整个文件的基本属性</li><li>ELF 文件中的各个段(section)</li><li>段表(section header table), 该表描述了 ELF 文件包含的所有段的信息，比如每个段的段名，段的长度等</li><li>其他一些辅助结构，如字符串表，符号表等</li></ul><h2 id="ELF-文件结构详解"><a href="#ELF-文件结构详解" class="headerlink" title="ELF 文件结构详解"></a>ELF 文件结构详解</h2><p>在上面我们了解了 ELF 文件的总体结构，但耳听为虚，眼见为实，我们接下来实操一下，看下 Elf 文件具体是怎么样的</p><p>首先我们添加一个<code>SimpleSection.c</code>文件，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_init_var = <span class="number">84</span>;</span><br><span class="line"><span class="keyword">int</span> global_uninit_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    fun1(static_var + static_var2 + a + b);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们通过<code>gcc -c SimpleSection.c</code>命令只编译不链接生成目标文件：SimpleSection.o，这也是一个 ELF 文件，我们接下来就来分析这个文件的内容</p><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -h SimpleSection.o</span><br><span class="line"></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2's complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              REL (Relocatable file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x0</span><br><span class="line">  <span class="keyword">Start</span> <span class="keyword">of</span> program headers:          <span class="number">0</span> (<span class="keyword">bytes</span> <span class="keyword">into</span> <span class="keyword">file</span>)</span><br><span class="line">  <span class="keyword">Start</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:          <span class="number">1184</span> (<span class="keyword">bytes</span> <span class="keyword">into</span> <span class="keyword">file</span>)</span><br><span class="line">  Flags:                             <span class="number">0x0</span></span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> this header:               <span class="number">64</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> program headers:           <span class="number">0</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="built_in">Number</span> <span class="keyword">of</span> program headers:         <span class="number">0</span></span><br><span class="line">  <span class="keyword">Size</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:           <span class="number">64</span> (<span class="keyword">bytes</span>)</span><br><span class="line">  <span class="built_in">Number</span> <span class="keyword">of</span> <span class="keyword">section</span> headers:         <span class="number">14</span></span><br><span class="line">  <span class="keyword">Section</span> header <span class="keyword">string</span> <span class="keyword">table</span> <span class="keyword">index</span>: <span class="number">13</span></span><br></pre></td></tr></table></figure><p>如上所示，通过<code>readelf</code>命令获取了文件头，可以看到，ELF 的文件头中定义了ELF魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI版本、文件类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表的位置和长度及段的数量等信息，包含了描述整个文件的基本属性</p><p>ELF 文件头结构及相关常数被定义在<code>/usr/include/elf.h</code>文件中，readelf 输出的信息与这些结构很多都可以一一对应，感兴趣的可以自行查看</p><h4 id="ELF-魔数"><a href="#ELF-魔数" class="headerlink" title="ELF 魔数"></a>ELF 魔数</h4><p>头文件中比较有意思的是魔数，魔数的作用是用来确认文件的类型，操作系统在加载可执行文件时会检验魔数是否正确，如果不正确则会拒绝加载</p><p>比如我们上面的输出，最开始的 4 个字节是所有 ELF 文件都必须相同的标识码：<code>0x7f</code>, <code>0x45</code>, <code>0x4c</code>, <code>0x46</code>, 第一字节对应 DEL 控制符的 ASCII 码，后面 3 个字节则正好是 ELF 三个字母的 ASCII 码</p><p>第 5 个字节用于标识 ELF 文件类，0x01 表示 32 位，0x02 表示 64 位，第 6 个字节用于标记字节序，规定该 ELF 文件是大端还是小端的，第 7 个字节用于标记 ELF 文件主版本号，一般是 1</p><p>而后面的 9 个字节，ELF 标准还没有定义，一般填0，有些平台会使用这 9 个字节作为扩展标志</p><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>在头文件之后就是 ELF 文件中各种各样的段了，我们通过 readelf 命令来查看段表，段表中记录了每个段的段名，段的长度，在文件中的偏移，读写权限，以及其它属性</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">readelf</span> <span class="string">-S</span> <span class="string">SimpleSection.o</span></span><br><span class="line"></span><br><span class="line"><span class="string">There</span> <span class="string">are</span> <span class="number">14</span> <span class="string">section</span> <span class="string">headers,</span> <span class="attr">starting at offset 0x4a0:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Section Headers:</span></span><br><span class="line">  <span class="string">[Nr]</span> <span class="string">Name</span>              <span class="string">Type</span>             <span class="string">Address</span>           <span class="string">Offset</span>    <span class="string">Size</span>              <span class="string">EntSize</span>          <span class="string">Flags</span>  <span class="string">Link</span>  <span class="string">Info</span>  <span class="string">Align</span></span><br><span class="line">  <span class="string">[</span> <span class="number">0</span><span class="string">]</span>                   <span class="literal">NULL</span>             <span class="number">0000000000000000</span>  <span class="number">00000000</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span></span><br><span class="line">  <span class="string">[</span> <span class="number">1</span><span class="string">]</span> <span class="string">.text</span>             <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="number">00000040</span>  <span class="string">000000000000005f</span>  <span class="number">0000000000000000</span>  <span class="string">AX</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">2</span><span class="string">]</span> <span class="string">.rela.text</span>        <span class="string">RELA</span>             <span class="number">0000000000000000</span>  <span class="number">00000380</span>  <span class="number">0000000000000078</span>  <span class="number">0000000000000018</span>   <span class="string">I</span>      <span class="number">11</span>     <span class="number">1</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[</span> <span class="number">3</span><span class="string">]</span> <span class="string">.data</span>             <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000a0</span>  <span class="number">0000000000000008</span>  <span class="number">0000000000000000</span>  <span class="string">WA</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  <span class="string">[</span> <span class="number">4</span><span class="string">]</span> <span class="string">.bss</span>              <span class="string">NOBITS</span>           <span class="number">0000000000000000</span>  <span class="string">000000a8</span>  <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>  <span class="string">WA</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">4</span></span><br><span class="line">  <span class="string">[</span> <span class="number">5</span><span class="string">]</span> <span class="string">.rodata</span>           <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000a8</span>  <span class="number">0000000000000004</span>  <span class="number">0000000000000000</span>   <span class="string">A</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">6</span><span class="string">]</span> <span class="string">.comment</span>          <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000ac</span>  <span class="string">000000000000002c</span>  <span class="number">0000000000000001</span>  <span class="string">MS</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">7</span><span class="string">]</span> <span class="string">.note.GNU-stack</span>   <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000d8</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[</span> <span class="number">8</span><span class="string">]</span> <span class="string">.note.gnu.propert</span> <span class="string">NOTE</span>             <span class="number">0000000000000000</span>  <span class="string">000000d8</span>  <span class="number">0000000000000020</span>  <span class="number">0000000000000000</span>   <span class="string">A</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[</span> <span class="number">9</span><span class="string">]</span> <span class="string">.eh_frame</span>         <span class="string">PROGBITS</span>         <span class="number">0000000000000000</span>  <span class="string">000000f8</span>  <span class="number">0000000000000058</span>  <span class="number">0000000000000000</span>   <span class="string">A</span>       <span class="number">0</span>     <span class="number">0</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[10]</span> <span class="string">.rela.eh_frame</span>    <span class="string">RELA</span>             <span class="number">0000000000000000</span>  <span class="string">000003f8</span>  <span class="number">0000000000000030</span>  <span class="number">0000000000000018</span>   <span class="string">I</span>      <span class="number">11</span>     <span class="number">9</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[11]</span> <span class="string">.symtab</span>           <span class="string">SYMTAB</span>           <span class="number">0000000000000000</span>  <span class="number">00000150</span>  <span class="string">00000000000001b0</span>  <span class="number">0000000000000018</span>          <span class="number">12</span>    <span class="number">12</span>     <span class="number">8</span></span><br><span class="line">  <span class="string">[12]</span> <span class="string">.strtab</span>           <span class="string">STRTAB</span>           <span class="number">0000000000000000</span>  <span class="number">00000300</span>  <span class="string">000000000000007b</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line">  <span class="string">[13]</span> <span class="string">.shstrtab</span>         <span class="string">STRTAB</span>           <span class="number">0000000000000000</span>  <span class="number">00000428</span>  <span class="number">0000000000000074</span>  <span class="number">0000000000000000</span>           <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="attr">Key to Flags:</span></span><br><span class="line">  <span class="string">W</span> <span class="string">(write),</span> <span class="string">A</span> <span class="string">(alloc),</span> <span class="string">X</span> <span class="string">(execute),</span> <span class="string">M</span> <span class="string">(merge),</span> <span class="string">S</span> <span class="string">(strings),</span> <span class="string">I</span> <span class="string">(info),</span></span><br><span class="line">  <span class="string">L</span> <span class="string">(link</span> <span class="string">order),</span> <span class="string">O</span> <span class="string">(extra</span> <span class="string">OS</span> <span class="string">processing</span> <span class="string">required),</span> <span class="string">G</span> <span class="string">(group),</span> <span class="string">T</span> <span class="string">(TLS),</span></span><br><span class="line">  <span class="string">C</span> <span class="string">(compressed),</span> <span class="string">x</span> <span class="string">(unknown),</span> <span class="string">o</span> <span class="string">(OS</span> <span class="string">specific),</span> <span class="string">E</span> <span class="string">(exclude),</span></span><br><span class="line">  <span class="string">l</span> <span class="string">(large),</span> <span class="string">p</span> <span class="string">(processor</span> <span class="string">specific)</span></span><br></pre></td></tr></table></figure><p>可以看出，段表是一个数组，数组的每一项对应每一个段，其中第一个项是无效的，类型为<code>NULL</code>，因此<code>SimpleSection.o</code>共有 13 个有效的段，段表对应的结构体也定义在<code>/usr/include/elf.h</code>文件中，感兴趣的可以自行查看</p><p>下面我们介绍一下段表各个字段的含义</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Name</td><td>段名，段名是个字符串，位于一个叫作 .shstrtab 的字符串表中</td></tr><tr><td>Type</td><td>段的类型，段名只在编译和链接阶段有作用，不能真正地表示段的类型，我们也可以将一个数据段命名为”.txt”，对于编译器和链接器来说，主要决定段的属性的是段的类型与段的标志位</td></tr><tr><td>Flags</td><td>段的标志位，段的标志位表示该段在进程虚拟地址空间中的属性，比如是否可写，是否可执行等</td></tr><tr><td>Address</td><td>段虚拟地址，如果该段可以被加载，则为该段被加载后在进程地址空间中的虚拟地址，否则为 0</td></tr><tr><td>Offset</td><td>段偏移，如果该段存在于文件中，则表示该段在文件中的偏移，否则无意义，比如对于 .bss 段就没有意义</td></tr><tr><td>Size</td><td>段的长度</td></tr><tr><td>Link 和 Info</td><td>段的链接信息，如果段的类型是与链接相关的，比如重定位表，符号表等，则该字段有意义，否则无意义</td></tr><tr><td>Align</td><td>段对齐地址，有些段对段地址对齐有要求，由于地址对齐的数量都是 2 的指数倍，Align 表示对齐数量中的指数，比如当 Align = 3 时表示 8 倍，当 Algin 为 0 或者 1 时表示没有对齐要求</td></tr><tr><td>EntSize</td><td>项的长度，有些段包含了一些固定大小的项，比如符号表，它包含的每个符号所占的大小是一样的，对于这种段，EntSize 表示每一项的大小。如果为 0 表示该段没有固定大小的项</td></tr></tbody></table><p>在了解了段表的结构之后，接下来我们看一下各个段的具体内容</p><h3 id="text-代码段"><a href="#text-代码段" class="headerlink" title=".text 代码段"></a>.text 代码段</h3><p>首先我们通过 objdump 命令来看下代码段的具体内容，objdump 的 “-s” 参数可以将所有段的内容以 16 进制的方式打印出来，”-d” 参数可以将所有包含指令的段反汇编，结果如下所示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">objdump</span> <span class="string">-s</span> <span class="string">-d</span> <span class="string">SimpleSection.o</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Contents of section .text:</span></span><br><span class="line"> <span class="number">0000</span> <span class="string">f30f1efa</span> <span class="number">554889e5</span> <span class="string">4883ec10</span> <span class="string">897dfc8b</span>  <span class="string">....UH..H....&#125;..</span></span><br><span class="line"> <span class="number">0010</span> <span class="string">45fc89c6</span> <span class="string">488d3d00</span> <span class="string">000000b8</span> <span class="number">00000000</span>  <span class="string">E...H.=.........</span></span><br><span class="line"> <span class="number">0020</span> <span class="string">e8000000</span> <span class="string">0090c9c3</span> <span class="string">f30f1efa</span> <span class="number">554889e5</span>  <span class="string">............UH..</span></span><br><span class="line"> <span class="number">0030</span> <span class="string">4883ec10</span> <span class="string">c745f801</span> <span class="string">0000008b</span> <span class="number">15000000</span>  <span class="string">H....E..........</span></span><br><span class="line"> <span class="number">0040</span> <span class="string">008b0500</span> <span class="number">00000001</span> <span class="string">c28b45f8</span> <span class="string">01c28b45</span>  <span class="string">..........E....E</span></span><br><span class="line"> <span class="number">0050</span> <span class="string">fc01d089</span> <span class="string">c7e80000</span> <span class="string">00008b45</span> <span class="string">f8c9c3</span>    <span class="string">...........E...</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">Disassembly of section .text:</span></span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000000</span> <span class="string">&lt;fun1&gt;:</span></span><br><span class="line">   <span class="attr">0:</span>   <span class="string">f3</span> <span class="string">0f</span> <span class="string">1e</span> <span class="string">fa</span>             <span class="string">endbr64</span> </span><br><span class="line">   <span class="attr">4:</span>   <span class="number">55</span>                      <span class="string">push</span>   <span class="string">%rbp</span></span><br><span class="line">   <span class="attr">5:</span>   <span class="number">48</span> <span class="number">89</span> <span class="string">e5</span>                <span class="string">mov</span>    <span class="string">%rsp,%rbp</span></span><br><span class="line">   <span class="attr">8:</span>   <span class="number">48</span> <span class="number">83</span> <span class="string">ec</span> <span class="number">10</span>             <span class="string">sub</span>    <span class="string">$0x10,%rsp</span></span><br><span class="line">   <span class="attr">c:</span>   <span class="number">89</span> <span class="string">7d</span> <span class="string">fc</span>                <span class="string">mov</span>    <span class="string">%edi,-0x4(%rbp)</span></span><br><span class="line">   <span class="attr">f:</span>   <span class="string">8b</span> <span class="number">45</span> <span class="string">fc</span>                <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp),%eax</span></span><br><span class="line">  <span class="attr">12:</span>   <span class="number">89</span> <span class="string">c6</span>                   <span class="string">mov</span>    <span class="string">%eax,%esi</span></span><br><span class="line">  <span class="attr">14:</span>   <span class="number">48</span> <span class="string">8d</span> <span class="string">3d</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="string">lea</span>    <span class="number">0x0</span><span class="string">(%rip),%rdi</span>        <span class="comment"># 1b &lt;fun1+0x1b&gt;</span></span><br><span class="line">  <span class="attr">1b:</span>   <span class="string">b8</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="string">mov</span>    <span class="string">$0x0,%eax</span></span><br><span class="line">  <span class="attr">20:</span>   <span class="string">e8</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="string">callq</span>  <span class="number">25</span> <span class="string">&lt;fun1+0x25&gt;</span></span><br><span class="line">  <span class="attr">25:</span>   <span class="number">90</span>                      <span class="string">nop</span></span><br><span class="line">  <span class="attr">26:</span>   <span class="string">c9</span>                      <span class="string">leaveq</span> </span><br><span class="line">  <span class="attr">27:</span>   <span class="string">c3</span>                      <span class="string">retq</span>   </span><br><span class="line"></span><br><span class="line"><span class="number">0000000000000028</span> <span class="string">&lt;main&gt;:</span></span><br><span class="line">  <span class="attr">28:</span>   <span class="string">f3</span> <span class="string">0f</span> <span class="string">1e</span> <span class="string">fa</span>             <span class="string">endbr64</span> </span><br><span class="line">  <span class="attr">2c:</span>   <span class="number">55</span>                      <span class="string">push</span>   <span class="string">%rbp</span></span><br><span class="line">  <span class="attr">2d:</span>   <span class="number">48</span> <span class="number">89</span> <span class="string">e5</span>                <span class="string">mov</span>    <span class="string">%rsp,%rbp</span></span><br><span class="line">  <span class="attr">30:</span>   <span class="number">48</span> <span class="number">83</span> <span class="string">ec</span> <span class="number">10</span>             <span class="string">sub</span>    <span class="string">$0x10,%rsp</span></span><br><span class="line">  <span class="attr">34:</span>   <span class="string">c7</span> <span class="number">45</span> <span class="string">f8</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    <span class="string">movl</span>   <span class="string">$0x1,-0x8(%rbp)</span></span><br><span class="line">  <span class="attr">3b:</span>   <span class="string">8b</span> <span class="number">15</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="string">mov</span>    <span class="number">0x0</span><span class="string">(%rip),%edx</span>        <span class="comment"># 41 &lt;main+0x19&gt;</span></span><br><span class="line">  <span class="attr">41:</span>   <span class="string">8b</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="string">mov</span>    <span class="number">0x0</span><span class="string">(%rip),%eax</span>        <span class="comment"># 47 &lt;main+0x1f&gt;</span></span><br><span class="line">  <span class="attr">47:</span>   <span class="number">01</span> <span class="string">c2</span>                   <span class="string">add</span>    <span class="string">%eax,%edx</span></span><br><span class="line">  <span class="attr">49:</span>   <span class="string">8b</span> <span class="number">45</span> <span class="string">f8</span>                <span class="string">mov</span>    <span class="number">-0x8</span><span class="string">(%rbp),%eax</span></span><br><span class="line">  <span class="attr">4c:</span>   <span class="number">01</span> <span class="string">c2</span>                   <span class="string">add</span>    <span class="string">%eax,%edx</span></span><br><span class="line">  <span class="attr">4e:</span>   <span class="string">8b</span> <span class="number">45</span> <span class="string">fc</span>                <span class="string">mov</span>    <span class="number">-0x4</span><span class="string">(%rbp),%eax</span></span><br><span class="line">  <span class="attr">51:</span>   <span class="number">01</span> <span class="string">d0</span>                   <span class="string">add</span>    <span class="string">%edx,%eax</span></span><br><span class="line">  <span class="attr">53:</span>   <span class="number">89</span> <span class="string">c7</span>                   <span class="string">mov</span>    <span class="string">%eax,%edi</span></span><br><span class="line">  <span class="attr">55:</span>   <span class="string">e8</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          <span class="string">callq</span>  <span class="string">5a</span> <span class="string">&lt;main+0x32&gt;</span></span><br><span class="line">  <span class="attr">5a:</span>   <span class="string">8b</span> <span class="number">45</span> <span class="string">f8</span>                <span class="string">mov</span>    <span class="number">-0x8</span><span class="string">(%rbp),%eax</span></span><br><span class="line">  <span class="attr">5d:</span>   <span class="string">c9</span>                      <span class="string">leaveq</span> </span><br><span class="line">  <span class="attr">5e:</span>   <span class="string">c3</span>                      <span class="string">retq</span></span><br></pre></td></tr></table></figure><p><code>Contents of section .text</code>就是.text的数据以十六进制方式打印出来的内容，总共 0x5f 字节，最左面一列是偏移量，中间4列是十六进制内容，最右面一列是 .text 段的 ASCII 码形式。</p><p><code>Disassembly of section .text</code>则是代码段反汇编的结果，可以很明显地看到，.text 段中的内容就是<code>SimpleSection.c</code>里两个函数<code>func1()</code>和<code>main()</code>的指令。</p><h3 id="数据段与只读数据段"><a href="#数据段与只读数据段" class="headerlink" title="数据段与只读数据段"></a>数据段与只读数据段</h3><p>接下来我们通过 objdump 命令看看数据段与只读数据段的内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">objdump</span> <span class="string">-x</span> <span class="string">-s</span> <span class="string">-d</span> <span class="string">SimpleSection.o</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Sections:</span></span><br><span class="line"><span class="string">Idx</span> <span class="string">Name</span>          <span class="string">Size</span>      <span class="string">VMA</span>               <span class="string">LMA</span>               <span class="string">File</span> <span class="string">off</span>  <span class="string">Algn</span></span><br><span class="line">  <span class="number">1</span> <span class="string">.data</span>         <span class="number">00000008</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="string">000000a0</span>  <span class="number">2</span><span class="string">**2</span></span><br><span class="line">                  <span class="string">CONTENTS,</span> <span class="string">ALLOC,</span> <span class="string">LOAD,</span> <span class="string">DATA</span></span><br><span class="line">  <span class="number">3</span> <span class="string">.rodata</span>       <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="string">000000a8</span>  <span class="number">2</span><span class="string">**0</span></span><br><span class="line">                  <span class="string">CONTENTS,</span> <span class="string">ALLOC,</span> <span class="string">LOAD,</span> <span class="string">READONLY,</span> <span class="string">DATA</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Contents of section .data:</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">54000000</span> <span class="number">55000000</span>                    <span class="string">T...U...</span>        </span><br><span class="line"><span class="attr">Contents of section .rodata:</span></span><br><span class="line"> <span class="number">0000</span> <span class="string">25640a00</span>                             <span class="string">%d..</span></span><br></pre></td></tr></table></figure><p>.data 段保存的是那些已经初始化了的全局静态变量和局部静态变量，<code>SimpleSection.c</code>中的<code>global_init_var</code>与<code>static_var</code>两个变量属于这种情况，这两个变量每个4个字节，一共刚好 8 个字节，所以 .data 段的大小为8个字节</p><p>.rodata 段存放的是只读数据，一般是程序中的只读变量(如 const 修饰的变量)和字符串常量，比如在<code>SimpleSection.c</code>中调用<code>printf</code>时用到的字符串常量，就储存在 .rodata 段中。需要注意的是，有的编译器会把字符串常量放在 .data 段中，而不会单独放在 .rodata 段中</p><p>接下来我们看下两个段中存储的内容</p><p>.data 中存储的内容即<code>0x00000054</code>与<code>0x00000055</code>，以小端序存放，它们的值正好对应十进制的<code>84</code>与<code>85</code>，也就是我们赋给<code>global_init_var</code>与<code>static_var</code>的值</p><p>.rodata 中存储的内容为<code>0x25640a00</code>，正好对应<code>%d\n</code>的 ASCII 码，可以对照<a href="http://c.biancheng.net/c/ascii/" target="_blank" rel="noopener">ASCII码一览表，ASCII码对照表</a>查看</p><h3 id="bss-段"><a href="#bss-段" class="headerlink" title=".bss 段"></a>.bss 段</h3><p>.bss 段存放未初始化的全局变量和局部静态变量，那么问题来了，为什么要把已初始化的变量和未初始化的变量分开存储的，为什么不直接放在 .data 段中？</p><p>答案是 .bss 段不占空间，我们接下来看一个直观的例子，来看看 .bss 的作用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> echo <span class="string">"char array[1024*1024*64] = &#123;'A'&#125;; int main() &#123;return 0;&#125;"</span> | gcc <span class="literal">-x</span> c - <span class="literal">-o</span> <span class="keyword">data</span></span><br><span class="line"><span class="variable">$</span> ls <span class="literal">-lh</span> <span class="keyword">data</span></span><br><span class="line"><span class="literal">-rwxrwxrwx</span> <span class="number">1</span> codespace codespace <span class="number">65</span>M Jun <span class="number">25</span> <span class="number">01</span>:<span class="number">26</span> <span class="keyword">data</span></span><br><span class="line"><span class="variable">$</span> echo <span class="string">"char array[1024*1024*64]; int main() &#123;return 0;&#125;"</span> | gcc <span class="literal">-x</span> c - <span class="literal">-o</span> bss</span><br><span class="line"><span class="variable">$</span> ls <span class="literal">-lh</span> bss</span><br><span class="line"><span class="literal">-rwxrwxrwx</span> <span class="number">1</span> codespace codespace <span class="number">17</span>K Jun <span class="number">25</span> <span class="number">01</span>:<span class="number">27</span> bss</span><br></pre></td></tr></table></figure><ul><li>示例 1 中，array 变量已经被初始化，存放在 .data 段中，占用文件空间，因此整个文件大小共有 65 M</li><li>示例 2 中，array 变量未被初始化，存放在 .bss 段中，不占用文件空间，因此整个文件大小只有 17 K</li></ul><p>可以看到，差别非常大。当然 .bss 段不占据实际的磁盘空间，但它的大小与符号还是要有地方存储，.bss 段的大小记录在段表中，符号记录在符号表中。当文件加载运行时，才分配空间以及初始化</p><p>接下来我们用 objdump 命令来看看<code>SimpleSection.o</code> 的 .bss 段的内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">objdump</span> <span class="string">-x</span> <span class="string">-s</span> <span class="string">-d</span> <span class="string">SimpleSection.o</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">Sections:</span></span><br><span class="line"><span class="string">Idx</span> <span class="string">Name</span>          <span class="string">Size</span>      <span class="string">VMA</span>               <span class="string">LMA</span>               <span class="string">File</span> <span class="string">off</span>  <span class="string">Algn</span></span><br><span class="line">  <span class="number">2</span> <span class="string">.bss</span>          <span class="number">00000004</span>  <span class="number">0000000000000000</span>  <span class="number">0000000000000000</span>  <span class="string">000000a8</span>  <span class="number">2</span><span class="string">**2</span></span><br><span class="line">                  <span class="string">ALLOC</span></span><br><span class="line"><span class="attr">SYMBOL TABLE:</span></span><br><span class="line"><span class="number">0000000000000000</span> <span class="string">l</span>     <span class="string">O</span> <span class="string">.bss</span>   <span class="number">0000000000000004</span> <span class="string">static_var2.1921</span></span><br><span class="line"><span class="number">0000000000000004</span>       <span class="string">O</span> <span class="string">*COM*</span>  <span class="number">0000000000000004</span> <span class="string">global_uninit_var</span></span><br></pre></td></tr></table></figure><p>可以看到，我们本来预期 .bass 段中会有<code>global_uninit_var</code>与<code>static_var2</code>两个变量，共 8 个字节，实际上只有<code>static_var2</code>一个变量，4 个字节</p><p>这是因为有些编译器会将全局的未初始化变量存放在目标文件.bss 段，有些则不存放，只是预留一个未定义的全局变量符号，等到最终链接成可执行文件的时候再在 .bss 段分配空间</p><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><p>除了 .text, .data, .bss 这 3 个最常用的段之外，ELF 文件也包含一些其他的段，下面列出了一些常见的段</p><table><thead><tr><th>段名</th><th>说明</th></tr></thead><tbody><tr><td>.rodata1</td><td>只读数据段，存放只读数据，与 .rodata 一样</td></tr><tr><td>.comment</td><td>存放编译器版本信息</td></tr><tr><td>.debug</td><td>调试信息</td></tr><tr><td>.dynamic</td><td>动态链接信息</td></tr><tr><td>.hash</td><td>符号哈希表</td></tr><tr><td>.line</td><td>调试时的行号表，即源代码行号与编译后指令的对应表</td></tr><tr><td>.note</td><td>额外的编译信息，如程序的公司名，发布版本号等</td></tr><tr><td>.strtab</td><td>字符串表，用于存储 ELF 中的各种字符串</td></tr><tr><td>.symtab</td><td>符号表</td></tr><tr><td>.shstrtab</td><td>段表字符串表，用于存储段表中用到的字符串</td></tr><tr><td>.plt .got</td><td>动态链接的跳转表和全局入口表</td></tr><tr><td>.init .finit</td><td>程序初始化与终结代码段</td></tr><tr><td>.rel.text</td><td>重定位表</td></tr></tbody></table><p>这里面的很多段我们之后都会用到，比如 PLT Hook 中会用到的 .plt .got 段，在静态链接中会用到重定位表，这里可以先留个印象</p><h2 id="Elf-中的符号"><a href="#Elf-中的符号" class="headerlink" title="Elf 中的符号"></a>Elf 中的符号</h2><p>链接过程的本质是把多个目标文件按照一定的规则拼接起来，在链接过程中，目标文件的拼接其实就是目标文件之间对地址的引用，即对函数和变量的地址的引用。</p><p>每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p><p>整个链接过程正是基于符号才能够正确完成。链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的符号表（Symbol Table），这个表里面记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址</p><p>我们将符号表中的符号分为以下几类:</p><ul><li>定义在本目标文件的全局符号，可以被其他目标文件引用。比如<code>SimpleSection.o</code>里面的<code>func1</code>、<code>main</code>和<code>global_init_var</code>。</li><li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做外部符号（External Symbol），也就是我们前面所讲的符号引用。比如<code>SimpleSection.o</code>里面的<code>printf</code>。</li><li>段名，这种符号往往由编译器产生，它的值就是该段的起始地址。比如<code>SimpleSection.o</code>里面的<code>.text</code>、<code>.data</code>等。</li><li>局部符号，这类符号只在编译单元内部可见。比如<code>SimpleSection.o</code>里面的<code>static_var</code>和<code>static_var2</code>。调试器可以使用这些符号来分析程序或崩溃时的核心转储文件。这些局部符号对于链接过程没有作用，链接器往往也忽略它们。</li><li>行号信息，即目标文件指令与源代码中代码行的对应关系，它也是可选的。”</li></ul><p>其中最值得关注的就是全局符号，因为链接过程只关心全局符号的相互拼接，局部符号、段名、行号等都是次要的，它们对于其他目标文件来说是“不可见”的，在链接过程中也是无关紧要的</p><h3 id="ELF-符号表的结构"><a href="#ELF-符号表的结构" class="headerlink" title="ELF 符号表的结构"></a>ELF 符号表的结构</h3><p>首先我们通过 readelf 命令来查看<code>SimpleSection.o</code> 的符号表</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s SimpleSection.o</span><br><span class="line"></span><br><span class="line">Symbol table <span class="string">'.symtab'</span> contains 18 entries:</span><br><span class="line">   Num:    Value          Size<span class="built_in"> Type </span>   Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL <span class="built_in"> DEFAULT </span> UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL <span class="built_in"> DEFAULT </span> ABS SimpleSection.c</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   3 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   4 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   5 </span><br><span class="line">     6: 0000000000000004     4 OBJECT  LOCAL <span class="built_in"> DEFAULT </span>   3 static_var.1920</span><br><span class="line">     7: 0000000000000000     4 OBJECT  LOCAL <span class="built_in"> DEFAULT </span>   4 static_var2.1921</span><br><span class="line">     8: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   7 </span><br><span class="line">     9: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   8 </span><br><span class="line">    10: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   9 </span><br><span class="line">    11: 0000000000000000     0 SECTION LOCAL <span class="built_in"> DEFAULT </span>   6 </span><br><span class="line">    12: 0000000000000000     4 OBJECT  GLOBAL<span class="built_in"> DEFAULT </span>   3 global_init_var</span><br><span class="line">    13: 0000000000000004     4 OBJECT  GLOBAL<span class="built_in"> DEFAULT </span> COM global_uninit_var</span><br><span class="line">    14: 0000000000000000    40 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>   1 fun1</span><br><span class="line">    15: 0000000000000000     0 NOTYPE  GLOBAL<span class="built_in"> DEFAULT </span> UND _GLOBAL_OFFSET_TABLE_</span><br><span class="line">    16: 0000000000000000     0 NOTYPE  GLOBAL<span class="built_in"> DEFAULT </span> UND printf</span><br><span class="line">    17: 0000000000000028    55 FUNC    GLOBAL<span class="built_in"> DEFAULT </span>   1 main</span><br></pre></td></tr></table></figure><p>接下来我们介绍一个各个列的含义，如下表所示</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>Name</td><td>符号名</td></tr><tr><td>Value</td><td>符号对应的值，不同的符号，其值的含义不同，见下文详细解析</td></tr><tr><td>Size</td><td>符号大小，对于包含数据的符号，这个值是数据类型的大小，比如一个 int 类型的符号占 4 个字节，如果该值为 0 表示该符号大小为 0 或未知</td></tr><tr><td>Type</td><td>符号类型，分为未知符号类型，数据对象类型，函数类型，文件类型等</td></tr><tr><td>Bind</td><td>绑定信息，用于区分局部符号，全局符号与弱引用符号</td></tr><tr><td>Vis</td><td>在 C/C++ 中未使用，可忽略</td></tr><tr><td>Ndx</td><td>符号所在的段,如果符号定义在本目标文件中，该值表示符号所在段在段表中的下标。<br>如果该值为 ABS,表示该符号包含了一个绝对的值，比如上面的文件类型的符号。<br>如果该值为 COM，表示该值是一个 Common 块类型的符号。<br>如果该值为 UND，表示为定义，说明该符号在本目标文件中被引用，在其他文件中声明</td></tr></tbody></table><p>上面说到不同的符号，其值含义不同，具体可以分为以下几种</p><ul><li>在目标文件中，如果是符号的定义并且该符号不是<code>COMMON块</code>类型的，则<code>Value</code>表示该符号在段中的偏移。比如<code>SimpleSection.o</code>中的<code>func1</code>、<code>main</code>和<code>global_init_var</code>。</li><li>在目标文件中，如果符号是<code>COMMON块</code>类型的，则<code>Value</code>表示该符号的对齐属性。比如<code>SimpleSection.o</code>中的<code>global_uninit_var</code>。</li><li>在可执行文件中，<code>Value</code>表示符号的虚拟地址。这个虚拟地址对于动态链接器来说十分有用。</li></ul><h3 id="C-的-Name-Mangling-机制"><a href="#C-的-Name-Mangling-机制" class="headerlink" title="C++ 的 Name Mangling 机制"></a>C++ 的 Name Mangling 机制</h3><p>我们前面提到每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆，因此在 C 语言目标文件链接过程中，如果有两个文件中都有<code>fun1</code>函数，链接过程就会报错</p><p>但当程序很大时，不同的模块由多人开发，如果命名规范不严格，很容易出现符号冲突的问题，于是像C++这样的后来设计的语言开始考虑到了这个问题，增加了名称空间（Namespace）的方法来解决多模块的符号冲突问题。</p><p>同时 C++拥有类、继承、虚机制、重载、名称空间等这些特性，它们使得符号管理更为复杂。最简单的例子，两个相同名字的函数<code>func(int)</code>和<code>func(double)</code>，尽管函数名相同，但是参数列表不同，那么编译器和链接器在链接过程中如何区分这两个函数呢？为了支持 C++ 这些复杂的特性，人们发明了符号修饰（Name Decoration）机制</p><p>比如下面这段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>    <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span>           </span>&#123; <span class="keyword">return</span> <span class="number">0</span>;     &#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span>  <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">float</span> f)</span>  </span>&#123; <span class="keyword">return</span> i + f; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d)</span> </span>&#123; <span class="keyword">return</span> i+d;   &#125;</span><br></pre></td></tr></table></figure><p>经过name mangling操作后，得到的符号表中和<code>func</code>有关的内容如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main<span class="selector-class">.cc</span> -o main<span class="selector-class">.o</span> &amp;&amp; objdump -t main.o</span><br><span class="line">main<span class="selector-class">.o</span>:     file format elf64-x86-<span class="number">64</span></span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line"><span class="number">0000000000001157</span> g     F <span class="selector-class">.text</span>  <span class="number">000000000000001</span>c              _Z4funcid</span><br><span class="line"><span class="number">000000000000113</span>b g     F <span class="selector-class">.text</span>  <span class="number">000000000000001</span>c              _Z4funcif</span><br><span class="line"><span class="number">0000000000001129</span> g     F <span class="selector-class">.text</span>  <span class="number">0000000000000012</span>              _Z4funci</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，所有的符号都以<code>_Z</code>开头，前缀<code>_Z</code>是 GCC 的规定，具体是怎样转化的这里就不详细介绍了，有兴趣的读者可以参考GCC的名称修饰标准。同时我们也可以利用 nm 或 c++filt 等工具来解析被修饰的符号，不用自己手动解析</p><p>Name Mangling 机制使用地非常广泛，当我们查看 android so 的符号表时，可以看到很多以<code>_Z</code>开头的符号，就可以知道他们都是被修饰过的符号</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细介绍了 ELF 文件的详细结构，包括文件头，段表，各个段的结构，符号表的结构等内容。</p><p>这些基础知识可能有些枯燥，但是这些知识点在 Android 性能优化中的应用还是很广泛的，因此还是有必要了解一下的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在读《程序员的自我修养：链接，装载与库》，其实这本书跟 Android 开发的联系还挺紧密的，无论是 NDK 开发，或者是性能优化中一些常用的 Native Hoook 手段，都需要了解一些链接，装载相关的知识点。本文为读书笔记。&lt;/p&gt;
&lt;h2 id=&quot;ELF-文件是
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://RicardoJiang.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>使用 Compose 在 iOS 上实现灵动岛效果</title>
    <link href="http://RicardoJiang.github.io/blog/2023/05/compose-dynamic-island.html"/>
    <id>http://RicardoJiang.github.io/blog/2023/05/compose-dynamic-island.html</id>
    <published>2023-05-21T09:04:12.000Z</published>
    <updated>2023-10-02T05:09:49.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在去年 DevFest 的 Compose Camp 活动上，fundroid 与朱江两位讲师带着大家使用 Compose 实现了灵动岛效果</p><p>但是灵动岛毕竟是 iOS 上的特性，正好今年 KotlinConf 上宣布了 Compose-iOS 已经 alpha 了，那么如果我们将已经用 Compose 实现的灵动岛效果，移植到 iOS 上又会怎么样呢？</p><p>想想多是一件美事啊，说干就干，看看把代码从 Jetpack Compose 迁移到 Compose Multiplatform 中到底要做什么工作，要付出什么成本</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p3.gif" alt></p><p>首先看下效果，可以看到，基本实现了灵动岛切换的动画效果，与在 Android 上的效果也基本一致</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>要使用 Compose MultiPlatform 开发，需要以下环境</p><ul><li>XCode</li><li>Android Studio</li><li>Kotlin Multiplatform Mobile 插件</li><li>Cocoapods 依赖管理器</li></ul><p>其实跟 Kotlin Multiplatform 所需要的环境一致，其中最麻烦的可能是 Cocoapods 的安装，可以查看 KMM 安装 Cocoapods 的文档：<a href="https://kotlinlang.org/docs/native-cocoapods.html#set-up-an-environment-to-work-with-cocoapods" target="_blank" rel="noopener">Set up an environment to work with CocoaPods</a></p><p>此外，你也可以通过<code>kdoctor</code>命令来检查环境配置否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install kdoctor <span class="comment">// 安装 kdoctor</span></span><br><span class="line">kdoctor <span class="comment">// 检查</span></span><br></pre></td></tr></table></figure><p>如果所有环境都配置正确，你会看到以下输出</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Environment diagnose (<span class="keyword">to</span> see all details, use -v option):</span><br><span class="line">[✓] Operation System</span><br><span class="line">[✓] Java</span><br><span class="line">[✓] Android Studio</span><br><span class="line">[✓] Xcode</span><br><span class="line">[✓] Cocoapods</span><br><span class="line"></span><br><span class="line">Conclusion:</span><br><span class="line">  ✓ Your<span class="built_in"> system </span>is ready <span class="keyword">for</span> Kotlin Multiplatform Mobile development!</span><br></pre></td></tr></table></figure><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>Compose Multiplatform 项目其实就是在 KMM 项目中加入一些 Compose 的内容，还是有不少模板代码的，我们可以直接使用 JetBrains 提供的项目模板生成项目：<a href="https://github.com/JetBrains/compose-multiplatform-ios-android-template" target="_blank" rel="noopener">compose-multiplatform-ios-android-template</a></p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p5.png" alt></p><p>如图所示，其实就是一个 KMM 工程的结构，android 项目的入口是 androidApp，iOS 项目的入口是 iosApp，共享代码放在 shared 模块</p><p>在 shared 模块中，各个平台共享代码放在 commonMain 目录中，而各个平台的定制代码则放在 androidMain 与 iosMain 中</p><p>在这里主要的不同在于，android 平台直接返回了一个 Composable 函数，供 android 层调用，而 iOS 平台则返回了一个 UIViewController</p><h3 id="代码移植"><a href="#代码移植" class="headerlink" title="代码移植"></a>代码移植</h3><p>在项目创建完成后，接下来就是代码移植的工作了。移植过程可以说是非常简单，基本上不用做任何改动，Jetpack Compose 项目就可以迁移成 Compose Multiplatform 项目</p><p>在我迁移过程中碰到的唯一不同在于资源文件的处理，如下所示，R 文件引用方式需要修改成字符串方式引用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Jetpack Compose</span></span><br><span class="line">Image(</span><br><span class="line">    painterResource(R.drawable.icon_cover),</span><br><span class="line">    <span class="string">"music cover"</span>,</span><br><span class="line">    Modifier</span><br><span class="line">        .size(animationData.musicImageSize)</span><br><span class="line">        .clip(RoundedCornerShape(animationData.musicImageCorner))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compose Multiplatform</span></span><br><span class="line">Image(</span><br><span class="line">    painterResource(<span class="string">"icon_cover.xml"</span>),</span><br><span class="line">    <span class="string">"music cover"</span>,</span><br><span class="line">    Modifier</span><br><span class="line">        .size(animationData.musicImageSize)</span><br><span class="line">        .clip(RoundedCornerShape(animationData.musicImageCorner))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>除此之外，两者的状态管理，布局，动画等 api 是完全一致的，可以直接复用代码</p><p>经过以上步骤，迁移就完成了，直接运行 androidApp 与 iosApp 就可以得到文章开始展示的效果了</p><h2 id="正在处理中的问题"><a href="#正在处理中的问题" class="headerlink" title="正在处理中的问题"></a>正在处理中的问题</h2><p>当然，现在 Compose Multiplatform 还处在 alpha 阶段，并不是说已经可以用于生产了，还有不少问题正在处理中</p><h3 id="待支持的功能"><a href="#待支持的功能" class="headerlink" title="待支持的功能"></a>待支持的功能</h3><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p6.png" alt>      </p><p>图片来源：<a href="https://www.youtube.com/watch?v=FWVi4aV36d8" target="_blank" rel="noopener">Compose Multiplatform on iOS by: Sebastian Aigner and Nikita Lipsky</a></p><p>可以看出，Compose Multiplatform 还是有不少细节问题要处理的</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>我们打开 XCode 的 instruments 然后运行 app，就可以得到运行的 trace 文件，统计出运行次数较多或者比较耗时的方法</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p7.jpg" alt></p><p>可以看出，耗时方法有相当一部分是 GC 相关的，当 GC 暂停发生时，会冻结所有对象，自然也会影响 UI 的渲染，导致卡顿</p><p>好消息是 Kotlin 正在优化 GC，期望将 GC 暂停控制在 1 到 2 ms 之内</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出将 Jetpack Compose 版的灵动岛迁移到 Compose Multiplatform 的成本是非常低的，最耗时的部分可能是配环境的部分，两者的 API 基本上是一致的，因此代码可以无缝复用</p><p>Compose 跨平台补全了 Kotlin 跨平台只支持共享逻辑不支持共享 UI 的短板，降低了 Kotlin 跨平台的开发成本，总得来说，未来可期，希望 Jetbrains 能早日推出正式版</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有代码可见：<a href="https://github.com/RicardoJiang/DynamicIsland" target="_blank" rel="noopener">https://github.com/RicardoJiang/DynamicIsland</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.youtube.com/watch?v=FWVi4aV36d8" target="_blank" rel="noopener">Compose Multiplatform on iOS by: Sebastian Aigner and Nikita Lipsky</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在去年 DevFest 的 Compose Camp 活动上，fundroid 与朱江两位讲师带着大家使用 Compose 实现了灵动岛效果
      
    
    </summary>
    
    
      <category term="compose" scheme="http://RicardoJiang.github.io/tags/compose/"/>
    
  </entry>
  
  <entry>
    <title>【 Android 性能优化】ANR 问题如何监控？</title>
    <link href="http://RicardoJiang.github.io/blog/2023/05/android-anr-monitor.html"/>
    <id>http://RicardoJiang.github.io/blog/2023/05/android-anr-monitor.html</id>
    <published>2023-05-03T08:07:32.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ANR 即 Applicatipon No Response，程序无响应。Android 系统设计了 ANR 机制，其目的是监控与其交互的组件（Activity 等）和用户交互（InputEvent）的超时情况。这样能够判断应用进程（主线程）是否存在卡死或响应过慢的问题</p><p>相比 Crash，ANR 问题存在原因复杂，不易定位的特点，本文主要包括以下内容</p><ol><li>ANR 工作流程</li><li>如何监控 ANR？</li><li>如何定位 ANR 原因？</li></ol><h2 id="ANR-工作流程"><a href="#ANR-工作流程" class="headerlink" title="ANR 工作流程"></a>ANR 工作流程</h2><p>ANR 可能触发的时机有多种，通常可以分为以下几方面：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17f8d15a473244799be01927e5c0c785~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p><p>图片来源：<a href="https://juejin.cn/post/6940061649348853796#heading-6" target="_blank" rel="noopener">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></p><p>其基本原理其实 WatchDog 的思想，如果发出的事件，在一定时间内没有消费，则触发 ANR。具体源码就不在这里跟了，想详细了解的同学可查看：<a href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg" target="_blank" rel="noopener">微信Android客户端的ANR监控方案</a></p><p>这里说一下总体流程，如下图所示：</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p1.png" alt></p><ol><li>发生 ANR 后，系统会采集许多进程数据，进行堆栈转储，以生成 ANR Trace文件。其中，第一个被采集的进程必定是发生 ANR 的进程。</li><li>系统会向这些应用进程发送 SIGQUIT 信号，这些应用进程收到信号后开始进行堆栈转储</li><li>应用进程 Dump 堆栈成功后通过 Socket 与系统进程通信写 Trace 文件</li><li>在 Trace 文件写入完成后，如果发生 ANR 的进程是前台进程则弹出 Dialog，否则则直接杀死进程</li></ol><h2 id="如何监控-ANR？"><a href="#如何监控-ANR？" class="headerlink" title="如何监控 ANR？"></a>如何监控 ANR？</h2><p>在了解了 ANR 的工作流程之后，我们该如何监控 ANR 的发生呢？</p><h3 id="ANR-WatchDog-检测思路"><a href="#ANR-WatchDog-检测思路" class="headerlink" title="ANR WatchDog 检测思路"></a>ANR WatchDog 检测思路</h3><p>既然 ANR 的原因是输入在定时间内没有响应，那么我们很自然地想到，向主线程发送一个任务，如果一段时间内没有被执行的话，就认为发生了 ANR</p><p>这个思路主要有以下几个问题</p><ol><li>不准确，超时条件不一定会导致 ANR，例如，5 秒超时只是在 TouchEvent 未被消耗时发生 ANR 的条件之一，而其他条件则不一定是 5 秒。</li><li>漏检测：如果超时时间定为 5 秒，去检测 TouchEvent 的 ANR 存在一定的漏检测的概率（周期不同步）。</li></ol><h3 id="ANR-信号监听思路"><a href="#ANR-信号监听思路" class="headerlink" title="ANR 信号监听思路"></a>ANR 信号监听思路</h3><p>在上面介绍 ANR 总体流程时，我们注意到当 ANR 发生时会发送 SIGQUIT 信号，那么我们通过监听这一信号不就可以实现 ANR 监控了吗？事实上 <a href="https://github.com/iqiyi/xCrash" target="_blank" rel="noopener">XCrash</a> 与 <a href="https://github.com/Tencent/matrix" target="_blank" rel="noopener">Matrix</a> 都是通过这种方式实现 ANR 监控的</p><p>在这里需要注意，默认情况下进程通过<code>SignalCatcher</code>监听<code>SIGQUIT</code>信号，进行堆栈转储生成 ANR Trace 文件。因此当我们监听<code>SIGQUIT</code>信号后，需要重新向<code>SignalCatcher</code>发送<code>SIGQUIT</code></p><p>如果缺少重新向 SignalCatcher 发送 SIGQUIT 信号的步骤，Android System 管理服务（AMS）将一直等待 ANR 进程写入堆栈信息。直到超过20秒的超时时间，AMS 才会被迫中断，并继续后续流程。这将导致 ANR 弹窗的显示非常缓慢（因为超时时间为20秒），同时在 /data/anr 目录下也无法生成完整的 ANR Trace 文件。</p><h4 id="误报情况处理"><a href="#误报情况处理" class="headerlink" title="误报情况处理"></a>误报情况处理</h4><p>当监听到 SIGQUIT 信号时，不一定是发生了 ANR。</p><p>Matrix 的文档中提到了两种误报的情况：</p><ol><li>比如可能是其它进程 ANR 了，发生 ANR 的进程不是唯一需要进行堆栈转储的进程。系统会收集许多其他进程进行堆栈转储，用于生成 ANR Trace 文件</li><li>厂商或者是开发者自己发送的<code>SIGQUIT</code>信号，发送SIGQUIT信号其实是很容易的一件事情</li></ol><p>因此我们需要在监听到信号时再进行一次检查：在 ANR 弹窗前，会给发生 ANR 的进程标记一个 NOT_RESPONDING 的 flag，而这个 flag 我们可以通过 ActivityManager 来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkErrorState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application application = sApplication == <span class="keyword">null</span> ? Matrix.with().getApplication() : sApplication;</span><br><span class="line">        ActivityManager am = (ActivityManager) application.getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">        List&lt;ActivityManager.ProcessErrorStateInfo&gt; procs = am.getProcessesInErrorState();</span><br><span class="line">        <span class="keyword">if</span> (procs == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (ActivityManager.ProcessErrorStateInfo proc : procs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (proc.pid != android.os.Process.myPid()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc.condition != ActivityManager.ProcessErrorStateInfo.NOT_RESPONDING) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">        MatrixLog.e(TAG,<span class="string">"[checkErrorState] error : %s"</span>, t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们可以在监听到信号时判断当前进程是否被标记为 NOT_RESPONDING 来判断当前进程是否发生了 ANR</p><h4 id="漏报情况处理"><a href="#漏报情况处理" class="headerlink" title="漏报情况处理"></a>漏报情况处理</h4><p>当进程被标记为 NOT_RESPONDING 时一定发生了 ANR，但是当进程发生了 ANR 时，不一定会被标记为 NOT_RESPONDING</p><p>Matrix 的文档中提到了两种漏报情况</p><ol><li>后台ANR（SilentAnr）: 后台 ANR 会直接杀死进程，不会走到标记状态的代码</li><li>厂商定制逻辑: 相当一部分机型(比如 OPPO、VIVO 两家的高版本 Android )修改了 ANR 的逻辑，即使是前台 ANR 也会直接杀死进程</li></ol><p>Matrix 通过判断主线程在收到 SIGQUIT 信号时是否处于卡顿状态来判断当前是否发生 ANR，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMainThreadStuck</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MessageQueue mainQueue = Looper.getMainLooper().getQueue();</span><br><span class="line">        Field field = mainQueue.getClass().getDeclaredField(<span class="string">"mMessages"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">final</span> Message mMessage = (Message) field.get(mainQueue);</span><br><span class="line">        <span class="keyword">if</span> (mMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> when = mMessage.getWhen();</span><br><span class="line">            <span class="keyword">if</span>(when == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> time = when - SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">long</span> timeThreshold = BACKGROUND_MSG_THRESHOLD;</span><br><span class="line">            <span class="keyword">if</span> (foreground) &#123;</span><br><span class="line">                timeThreshold = FOREGROUND_MSG_THRESHOLD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> time &lt; timeThreshold;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过反射获取主线程<code>Looper</code>的<code>mMessage</code>对象，该消息的<code>when</code>变量，就表示该消息的入队时间</li><li>将入队时间与当前时间进行比较，就可以获取该消息的等待时间</li><li>当等待时间超过一定阈值的话，我们就认为主线程处于阻塞状态，结合 SIGQUIT 信号，判断为发生了 ANR</li></ol><h2 id="如何定位-ANR-原因？"><a href="#如何定位-ANR-原因？" class="headerlink" title="如何定位 ANR 原因？"></a>如何定位 ANR 原因？</h2><p>ANR 的影响因素有很多，我们可以把他们分为以下几类：</p><ol><li>系统资源不足，其它进程或线程存在严重资源抢占，如 IO，Mem，CPU</li><li>线程间存在资源抢占，比如死锁等</li><li>主线程繁忙，用户输入得不到及时响应</li></ol><p>在将 ANR 原因分为了以上几类之后，我们需要获取详细的日志信息，才能在发生 ANR 时及时定位原因</p><h3 id="获取系统负载信息"><a href="#获取系统负载信息" class="headerlink" title="获取系统负载信息"></a>获取系统负载信息</h3><p>想要获取系统负载信息，我们在线下可以通过获取 /data/anr 目录下的 trace 文件来查看，但是在高版本手机上，我们通常没有权限获取这个目录下的文件，那么在线上我们该如何获取系统负载信息呢？</p><p>应用层可通过 AcivityManager 获取 ProcessErrorStateInfo，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">val</span> am = application.getSystemService(Context.ACTIVITY_SERVICE) <span class="keyword">as</span> ActivityManager</span><br><span class="line">    <span class="keyword">val</span> processesInErrorStates = am.processesInErrorState</span><br></pre></td></tr></table></figure><p>通过<code>ProcessErrorStateInfo</code>我们可以获取<code>shortMessage</code>与<code>longMessage</code>，如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shortMessage</span></span><br><span class="line">ANR Input dispatching timed out (<span class="number">8445</span>a92 com<span class="selector-class">.android</span>.test/com<span class="selector-class">.android</span><span class="selector-class">.test</span><span class="selector-class">.anr</span><span class="selector-class">.ANRActivity</span> (server) is not responding. Waited <span class="number">5000ms</span> <span class="keyword">for</span> MotionEvent(action=DOWN))</span><br></pre></td></tr></table></figure><p><code>shortMessage</code>就是产生 ANR 的原因，比较简单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">longMessage</span></span><br><span class="line"><span class="string">ANR</span> <span class="string">in</span> <span class="string">com.android.test</span> <span class="string">(com.android.test/.anr.ANRActivity)</span></span><br><span class="line"><span class="attr">PID:</span> <span class="number">23283</span></span><br><span class="line"><span class="attr">Reason:</span> <span class="string">Input</span> <span class="string">dispatching</span> <span class="string">timed</span> <span class="string">out</span> <span class="string">(8445a92</span> <span class="string">com.android.test/com.android.test.anr.ANRActivity</span> <span class="string">(server)</span> <span class="string">is</span> <span class="string">not</span> <span class="string">responding.</span> <span class="string">Waited</span> <span class="string">5000ms</span> <span class="string">for</span> <span class="string">MotionEvent(action=DOWN))</span></span><br><span class="line"><span class="attr">Parent:</span> <span class="string">com.android.test/.anr.ANRActivity</span></span><br><span class="line"><span class="attr">ErrorId:</span> <span class="string">91ceb0ce-0af6-496e-8c4f-781075c056db</span></span><br><span class="line"><span class="attr">Frozen:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">Load:</span> <span class="number">0.0</span> <span class="string">/</span> <span class="number">0.29</span> <span class="string">/</span> <span class="number">0.33</span></span><br><span class="line"><span class="string">-----</span> <span class="string">Output</span> <span class="string">from</span> <span class="string">/proc/pressure/memory</span> <span class="string">-----</span></span><br><span class="line"><span class="string">some</span> <span class="string">avg10=0.00</span> <span class="string">avg60=0.00</span> <span class="string">avg300=0.00</span> <span class="string">total=150136881</span></span><br><span class="line"><span class="string">full</span> <span class="string">avg10=0.00</span> <span class="string">avg60=0.00</span> <span class="string">avg300=0.00</span> <span class="string">total=51283028</span></span><br><span class="line"><span class="string">-----</span> <span class="string">End</span> <span class="string">output</span> <span class="string">from</span> <span class="string">/proc/pressure/memory</span> <span class="string">-----</span></span><br><span class="line"><span class="string">CPU</span> <span class="string">usage</span> <span class="string">from</span> <span class="string">153ms</span> <span class="string">to</span> <span class="string">605ms</span> <span class="string">later</span> <span class="string">(2023-05-04</span> <span class="number">22</span><span class="string">:38:19.034</span> <span class="string">to</span> <span class="number">2023</span><span class="number">-05</span><span class="number">-04</span> <span class="number">22</span><span class="string">:38:19.486):</span></span><br><span class="line">  <span class="number">79</span><span class="string">%</span> <span class="attr">1990/system_server:</span> <span class="number">35</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">43</span><span class="string">%</span> <span class="attr">kernel / faults:</span> <span class="number">1598</span> <span class="string">minor</span></span><br><span class="line">    <span class="number">43</span><span class="string">%</span> <span class="attr">23375/AnrConsumer:</span> <span class="number">8.1</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">35</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">21</span><span class="string">%</span> <span class="attr">2008/HeapTaskDaemon:</span> <span class="number">19</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">2.7</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">2.7</span><span class="string">%</span> <span class="attr">2919/InputDispatcher:</span> <span class="number">2.7</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">  <span class="number">32</span><span class="string">%</span> <span class="attr">23283/com.android.test:</span> <span class="number">16</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">16</span><span class="string">%</span> <span class="attr">kernel / faults:</span> <span class="number">7</span> <span class="string">minor</span></span><br><span class="line">    <span class="number">28</span><span class="string">%</span> <span class="attr">23315/RenderThread:</span> <span class="number">16</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">12</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">4</span><span class="string">%</span> <span class="attr">23306/binder:23283_3:</span> <span class="number">0</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">4</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">4</span><span class="string">%</span> <span class="attr">23354/binder:23283_5:</span> <span class="number">4</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">  <span class="number">17</span><span class="string">%</span> <span class="attr">1195/surfaceflinger:</span> <span class="number">17</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">10</span><span class="string">%</span> <span class="attr">1195/surfaceflinger:</span> <span class="number">10</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">2.5</span><span class="string">%</span> <span class="attr">1347/binder:1195_1:</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">2.5</span><span class="string">%</span> <span class="attr">1414/TimerDispatch:</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">0</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">  <span class="number">5</span><span class="string">%</span> <span class="attr">1071/vendor.qti.hardware.display.composer-service:</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">    <span class="number">2.5</span><span class="string">%</span> <span class="attr">1071/composer-servic:</span> <span class="number">0</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">2.5</span><span class="string">%</span> <span class="string">kernel</span></span><br><span class="line">  <span class="string">//...</span></span><br><span class="line"><span class="number">21</span><span class="string">%</span> <span class="attr">TOTAL:</span> <span class="number">10</span><span class="string">%</span> <span class="string">user</span> <span class="string">+</span> <span class="number">10</span><span class="string">%</span> <span class="string">kernel</span> <span class="string">+</span> <span class="number">0.8</span><span class="string">%</span> <span class="string">irq</span> <span class="string">+</span> <span class="number">0.2</span><span class="string">%</span> <span class="string">softirq</span></span><br></pre></td></tr></table></figure><p><code>longMessage</code>则是系统在发生 ANR 之后的一段时间内的负载信息，包括 CPU，IO，内存等</p><h3 id="获取进程内所有线程状态"><a href="#获取进程内所有线程状态" class="headerlink" title="获取进程内所有线程状态"></a>获取进程内所有线程状态</h3><p>发生 ANR 也可能是因为进程内的线程发生了资源抢占或者死锁，那么该如何获取进程内所有线程的状态，我们可以再看一下上面的这张图</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/may/p1.png" alt></p><p>Signal Catcher 的 Dump 发生在应用进程，并且通过 Socket Writer 来写 Trace的。如果我们能够在这个 write 方法上进行 Hook，就可以获取到系统记录下来的 ANR Trace 内容。这个内容非常全面，包括了所有线程的各种状态、锁和堆栈信息（包括 native 堆栈），对于排查问题非常有帮助，特别是一些与 native 问题、死锁等有关的问题。</p><p>Matrix 就是通过这种方式来获取 ANR Trace 的，具体实现可见：<a href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg" target="_blank" rel="noopener">微信Android客户端的ANR监控方案</a></p><h3 id="定位主线程问题"><a href="#定位主线程问题" class="headerlink" title="定位主线程问题"></a>定位主线程问题</h3><p>由主线程繁忙引起的 ANR 定位困难的原因在于：<strong>耗时可能由历史消息引起，发生 ANR 时正在执行的消息并不耗时</strong>。如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1becc120e1014ee6a340dfbd2bfa6c2c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt></p><p>图片来源：<a href="https://juejin.cn/post/6940061649348853796#heading-15" target="_blank" rel="noopener">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></p><p>如果在系统服务执行某个历史消息时，已经耗费了大量时间，但在这个消息执行完毕后，系统服务并没有达到触发 ANR 超时的临界点，之后的主线程继续调度其他消息时，如果此时系统判定响应超时，那么正在执行的业务场景将不幸被命中。此时，当前正在执行的业务逻辑并不复杂，但由于之前的某个消息过度耗时，导致系统未能及时响应后续事件。</p><p>针对这类问题，一个解决方案是：记录主线程过去一段时间(比如 10s)内所有消息的调度历史，保存业务方需要的关键数据(比如消息耗时或者方法耗时)，在发生 ANR 时，上报监控阈值内的历史数据</p><p>通过这种方式，在 ANR 发生时，可以回放过去一段时间的耗时方法，定位耗时原因</p><p>头条和虾皮都基于这种思路开发了一些 ANR 监控工具，详情可见：<a href="https://juejin.cn/post/6942665216781975582" target="_blank" rel="noopener">今日头条 ANR 优化实践系列 - 监控工具与分析思路</a>与<a href="https://juejin.cn/post/7136008620658917407" target="_blank" rel="noopener">Android 卡顿与 ANR 的分析实践</a></p><p>这些工具目前都没有开源，也有开发者基于头条的思路开源了一套实现，感兴趣的同学可以看看：<a href="https://juejin.cn/post/7031834640034103304" target="_blank" rel="noopener">app卡顿系列四 ：今日头条卡顿监控方案落地</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是对 Matrix，今日头条等 ANR 监控方案的学习，介绍了系统 ANR 机制的工作流程，以及如何监控 ANR 问题，ANR 问题发生时如何定位具体原因等内容</p><p>ANR 问题定位困难的原因常常在于信息不足，通过上面介绍的获取系统负载信息，获取进程内所有线程状态，定位主线程问题等方案，应该可以比较有效地还原现场，帮助定位 ANR 问题，希望对你有所帮助~</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://mp.weixin.qq.com/s/fWoXprt2TFL1tTapt7esYg" target="_blank" rel="noopener">微信Android客户端的ANR监控方案</a><br><a href="https://juejin.cn/post/6942665216781975582" target="_blank" rel="noopener">今日头条 ANR 优化实践系列 - 监控工具与分析思路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;ANR 即 Applicatipon No Response，程序无响应。Android 系统设计了 ANR 机制，其目的是监控与其交互的组
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://RicardoJiang.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【卡顿优化】卡顿问题如何监控？</title>
    <link href="http://RicardoJiang.github.io/blog/2023/04/android-jank-optimize.html"/>
    <id>http://RicardoJiang.github.io/blog/2023/04/android-jank-optimize.html</id>
    <published>2023-04-16T12:28:41.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>卡顿问题是 Android 开发中的一个常见但容易忽视的问题，毕竟又不是不能用。 同时 App 卡顿问题有着不易衡量卡顿程度，不易复现，难以定位等特点。</p><p>但是 App 卡顿会给用户体验带来较大的影响，从而影响用户的留存。本文主要包括以下内容：</p><ol><li>我们应该如何衡量卡顿程度？如何对 app 的卡顿程度建立数据指标？</li><li>如何定位卡顿代码，找到带来卡顿的堆栈？</li></ol><h2 id="如何衡量卡顿程度"><a href="#如何衡量卡顿程度" class="headerlink" title="如何衡量卡顿程度"></a>如何衡量卡顿程度</h2><p>说到卡顿程度，大家一开始想起来的或许就是 FPS，FPS 即每秒显示的帧数，可以看出这是一个平均值，FPS 高并不代表页面流畅，比如下面这个例子</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p1.gif" alt></p><p>图片来源：<a href="https://mp.weixin.qq.com/s/aJeAUAjcKOMvznDMGj2UUA" target="_blank" rel="noopener">卡顿率降低50%！京东商城APP卡顿监控及优化实践</a></p><p>可以看出，在滚动过程中，页面 FPS 最低也有 57 帧每秒，但却能感受到明显的滑动卡顿，这是因为 1s 内前半段某几帧的超时绘制被后半段的平稳绘制给平均了</p><p>可以看出，FPS 并不能完全表现出页面的卡顿程度，FPS 高并不代表页面流畅</p><p>那么我们应该用什么指标来表示页面卡顿程序呢？我们可以使用卡顿率来衡量</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">卡顿率 </span>=<span class="string"> 卡顿的帧数 / 总帧数</span></span><br></pre></td></tr></table></figure><p>有了公式，那么我们如何确定卡顿的帧数，怎么样才算卡顿呢？</p><p>假如屏幕刷新率是 60/s，那么每帧耗时约 16ms，那么当一帧耗时超过 16ms 时，就发生了掉帧，也就是卡顿。掉帧数越多，说明卡顿也就越严重，比如如果某一帧实际绘制时间是 160ms，则说明其掉了 9 帧，对用户体验的影响也就更大</p><p>我们可以根据掉帧程度对卡顿进一步细化，比如按照下表定义卡顿的程度</p><table><thead><tr><th>卡顿程度定义</th><th>正常范围</th><th>轻微卡顿</th><th>中等卡顿</th><th>严重卡顿</th><th>冻结帧</th></tr></thead><tbody><tr><td>掉帧数</td><td>[0:3)</td><td>[3:9)</td><td>[9:24)</td><td>[24:42)</td><td>[42:∞)</td></tr></tbody></table><p>如上所示，我们可以定义掉帧数 3 到 9 帧为轻微卡顿，其他依次类推，通过这种方式，我们只需要获取每一帧的耗时，就可以获取页面的总体卡顿率，轻微卡顿率，严重卡顿率等，对页面的卡顿程度有了一个量化的指标</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>为了获取页面的总体卡顿率，轻微卡顿率等指标，我们需要获取以下数据</p><ol><li>页面总帧数</li><li>卡顿的帧数</li><li>卡顿各帧的耗时</li></ol><p>获取各帧耗时业界一般有以下两种方案</p><ol><li>通过设置自定义<code>android.util.Printer</code>，监听<code>Looper</code>的<code>dispatchMessage</code>耗时</li><li>通过向<code>Choreographer</code>循环注册<code>FrameCallback</code>，统计两次<code>Vsync</code>事件时间间隔</li></ol><p>以上两种方式都可以实现，但其实 JetPack 已经提供了一个用于监控线上卡顿的库：<a href="https://developer.android.com/topic/performance/jankstats?hl=zh-cn" target="_blank" rel="noopener">JankStats 库</a></p><p>JankStats 基于现有的 Android 平台功能构建，在 Android 7及更高版本中使用 FrameMetrics API 实现，在低版本中使用 OnPreDrawListener 实现，因此我们可以直接使用这个库监控即可</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JankLoggingActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> jankStats: JankStats</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jankFrameListener = JankStats.OnFrameListener &#123; frameData -&gt;</span><br><span class="line">    <span class="comment">// 在实际使用中可以将日志上传到远端统计</span></span><br><span class="line">Log.v(<span class="string">"JankStatsSample"</span>, frameData.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        <span class="comment">// 初始化 JankStats，传入 window 和卡顿回调</span></span><br><span class="line">       jankStats = JankStats.createAndTrack(window, jankFrameListener).apply &#123;</span><br><span class="line">        <span class="comment">// 支持设置卡顿阈值，默认为2</span></span><br><span class="line">        <span class="keyword">this</span>.jankHeuristicMultiplier = <span class="number">3f</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置页面状态</span></span><br><span class="line">        <span class="keyword">val</span> metricsStateHolder = PerformanceMetricsState.getHolderForHierarchy(binding.root)</span><br><span class="line">        metricsStateHolder.state?.putState(<span class="string">"Activity"</span>, javaClass.simpleName)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onResume()</span><br><span class="line">    <span class="comment">// onResume后重新开始统计</span></span><br><span class="line">    jankStats.isTrackingEnabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onPause()</span><br><span class="line">    <span class="comment">// onPause后停止统计</span></span><br><span class="line">    jankStats.isTrackingEnabled = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看出，JankStats 使用起来非常简单，主要要做下面几件事</p><ol><li>初始化 JankStats，需要传入关联的 window 和卡顿监听 </li><li>支持设置页面状态，比如当日志上报时需要了解卡顿是在哪个页面发生的，我们这里就传入了当前     Activity 的名字，在卡顿回调中可以读取。这个特点非常重要，我们可以通过这个 API 区分卡顿的场景，比如当页面发生滚动时和不滚动时设置不同的 state，就可以统计出滚动和非滚动时的卡顿率</li><li>支持设置卡顿阈值，默认为 2，即本帧耗时大于一帧预期耗时的2倍就判定为卡顿，我们这里修改为 3</li><li>支持开始与暂停统计，当 Activity 退到后台时可以暂时关闭统计</li><li>JankStats 库会将每一帧的所有跟踪数据报告给已启用的 JankStats 对象的 <code>OnFrameListener</code>, 应用可以存储和聚合这些数据，以便日后上传。</li></ol><p>这里的聚合是指我们可以先将卡顿数据存储在内存或者本地存储中，当卡顿数量达到一定程度或者页面切换时，再统一上传卡顿数据，减少上传次数，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">JankActivityLifecycleCallback</span> : <span class="type">ActivityLifecycleCallbacks &#123;</span></span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jankAggregatorMap = hashMapOf&lt;String, JankStatsAggregator&gt;()</span><br><span class="line">    <span class="comment">// 聚合回调</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> jankReportListener = JankStatsAggregator.OnJankReportListener &#123; reason, totalFrames, jankFrameData -&gt;</span><br><span class="line">            jankFrameData.forEach &#123; frameData -&gt;</span><br><span class="line">            <span class="comment">// 获取当前 Activity name</span></span><br><span class="line">            Log.v(<span class="string">"Activity"</span>,frameData.states.firstOrNull &#123; it.key == <span class="string">"Activity"</span> &#125;?.value ?: <span class="string">""</span>)</span><br><span class="line">            <span class="comment">// 获取掉帧数</span></span><br><span class="line">                <span class="keyword">val</span> dropFrameCount = frameData.frameDurationUiNanos / singleFrameNanosDuration</span><br><span class="line">                <span class="keyword">if</span> (dropFrameCount &lt;= JankMonitor.SLIGHT_JANK_MULTIPIER) &#123;</span><br><span class="line">                    slightJankCount++</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropFrameCount &lt;= JankMonitor.MIDDLE_JANK_MULTIPIER) &#123;</span><br><span class="line">                    middleJankCount++</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropFrameCount &lt;= JankMonitor.CRITICAL_JANK_MULTIPIER) &#123;</span><br><span class="line">                    criticalJankCount++</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    frozenJankCount++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 实际使用中可以上传到远端统计</span></span><br><span class="line">            Log.v(<span class="string">"JankMonitor"</span>,<span class="string">"*** Jank Report (<span class="variable">$reason</span>), "</span> +</span><br><span class="line">                        <span class="string">"totalFrames = <span class="variable">$totalFrames</span>, "</span> +  <span class="comment">// 总帧数</span></span><br><span class="line">                        <span class="string">"jankFrames = <span class="subst">$&#123;jankFrameData.size&#125;</span>, "</span> + <span class="comment">// 总卡顿数</span></span><br><span class="line">                        <span class="string">"slightJankCount = <span class="variable">$slightJankCount</span>, "</span> + <span class="comment">// 轻微卡顿数</span></span><br><span class="line">                        <span class="string">"middleJankCount = <span class="variable">$middleJankCount</span>, "</span> + <span class="comment">// 中等卡顿数</span></span><br><span class="line">                        <span class="string">"criticalJankCount = <span class="variable">$criticalJankCount</span>, "</span> + <span class="comment">// 严重卡顿数</span></span><br><span class="line">                        <span class="string">"frozenJankCount = <span class="variable">$frozenJankCount</span>"</span> <span class="comment">// 冻结帧数</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(activity: <span class="type">Activity</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 为所有 Activity 添加卡顿监听</span></span><br><span class="line">        activity.window.callback = <span class="keyword">object</span> : WindowCallbackWrapper(activity.window.callback) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onContentChanged</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> activityName = activity.javaClass.simpleName</span><br><span class="line">                <span class="keyword">if</span> (!jankAggregatorMap.containsKey(activityName)) &#123;</span><br><span class="line">                    <span class="keyword">val</span> jankAggregator = JankStatsAggregator(activity.window, jankReportListener)</span><br><span class="line">                    PerformanceMetricsState.getHolderForHierarchy(activity.window.decorView).state?.putState(<span class="string">"Activity"</span>, activityName)</span><br><span class="line">                    jankAggregatorMap[activityName] = jankAggregator</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，主要做了以下事</p><ol><li>为所有 Activity 添加了聚合的卡顿监听，当卡顿数达到阈值或者 Activity 退到后台时会触发聚合回调</li><li>在聚合回调中可以获取这段时间的总帖数，与卡顿的帧的列表，通过计算卡顿帧的掉帧数，我们可以获取总卡顿数，轻微卡顿数，严重卡顿数等。将这些数据上传就可以计算出页面的卡顿率</li><li>在聚合回调中我们同样可以获取页面的状态，比如我们这里设置的<code>activityName</code>，通过设置状态我们可以统计不同场景下的卡顿率，比如滚动与非滚动</li></ol><p>这里精简了部分代码，完整代码可见：<a href="https://github.com/RicardoJiang/android-performance/tree/main/jank-optimize" target="_blank" rel="noopener">android-performance/jank-optimize</a></p><h2 id="如何定位卡顿代码"><a href="#如何定位卡顿代码" class="headerlink" title="如何定位卡顿代码"></a>如何定位卡顿代码</h2><p>通过以上方式建立了页面的卡顿指标，有了衡量页面卡顿程度的数据，下一步我们要进行优化的话，很明显我们需要定位到卡顿的代码，优化这些卡顿的代码，才可以降低我们的卡顿率</p><p>那么卡顿的慢函数该如何定位呢？业界一般也是有两种方式</p><h3 id="堆栈抓取方案"><a href="#堆栈抓取方案" class="headerlink" title="堆栈抓取方案"></a>堆栈抓取方案</h3><p>思路其实很简单，在卡顿发生时 Dump 主线程堆栈，通过分析堆栈找到卡顿的原因。</p><p>需要注意的是，如果我们在帧结束的时候，再去判断该帧是否卡顿，如果卡顿则 Dump 堆栈，这个时候获取的堆栈很可能是不太准确的，如下图所示：</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p7.png" alt></p><p>可以看出，抓取堆栈的时机是明显偏晚了，如果这个 Message 里执行的函数特别多，你将很难定位出具体的问题</p><p>所以通常我们会启动一个子线程，开启定时任务，如果一定时间内消息没有执行完成，则判定为卡顿，从而发起 Dump 堆栈，如下图所示：</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p8.jpg" alt></p><p>如上所示，通过在子线程中开启一个定时任务，判断主线程中是否发生卡顿，如果发生卡顿则抓取主线程堆栈，通过这种方式可以比较准确的获取卡顿堆栈</p><p>滴滴开源的<a href="https://github.com/didi/DoKit/tree/master/Android/dokit/src/main/java/com/didichuxing/doraemonkit/kit/blockmonitor" target="_blank" rel="noopener">DoKit</a>就是通过这种方式来获取卡顿堆栈的，感兴趣的可以去看下源码</p><p>这种方案在获取堆栈时比较准确，但如果你的定时任务周期较短，频繁 Dump，会对性能有较大影响，而如果周期较长，则会遗漏一些耗时任务，总得来说需要设置一个合适的阈值</p><p>同时通过获取堆栈的方式也无法获取各个方法的执行耗时，你无法一眼看出各个方法的耗时影响，需要进一步的线下定位</p><h3 id="字节码插桩方案"><a href="#字节码插桩方案" class="headerlink" title="字节码插桩方案"></a>字节码插桩方案</h3><p>堆栈抓取方案的最大缺陷是无法获取方法的执行耗时，而字节码插桩方式可以完美解决这一问题</p><p>通过在函数执行的开头与结尾分别插入一段代码，自然就可以计算出这个函数的执行耗时，在运行时，将前面一段时间的方法执行耗时收集起来，当发生卡顿时，则将此前一段时间的方法执行耗时全都上报，自然就可以清晰的定位出具体是哪个函数耗时了</p><p><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary" target="_blank" rel="noopener">Matrix</a>的慢函数定位就是通过字节码插桩实现的，字节码插桩方案的难点在于插桩方案对于运行时性能和包体积的影响，如果插桩明显地拖慢了 App 的运行性能，自然是得不偿失了。以下是 Matrix 插桩前后的对比数据</p><table><thead><tr><th style="text-align:left">item</th><th style="text-align:center">trace</th><th style="text-align:center">untrace</th><th style="text-align:center">info</th></tr></thead><tbody><tr><td style="text-align:left">FPS</td><td style="text-align:center">56.16</td><td style="text-align:center">56.19</td><td style="text-align:center">Android7.0 好机器朋友圈帧率</td></tr><tr><td style="text-align:left">FPS</td><td style="text-align:center">41.18</td><td style="text-align:center">42.70</td><td style="text-align:center">Android4.2 差机器朋友圈帧率</td></tr><tr><td style="text-align:left">apk size</td><td style="text-align:center">81.91 MB</td><td style="text-align:center">81.12 MB</td><td style="text-align:center">实际插桩方法总数 163141</td></tr><tr><td style="text-align:left">memory</td><td style="text-align:center">+7.6M</td><td style="text-align:center">～</td><td style="text-align:center">运行时内存</td></tr></tbody></table><p>根据 Matrix 的文档，Matrix 插桩对于好机器的性能影响可忽略，对差机器性能稍有损耗，但影响很小。 对安装包大小影响，对于微信这种大体量的应用，实际插桩函数 16w+，对安装包增加了 800K 左右。</p><p>看起来非常优秀，可以直接用于线上，不过我也没有实践过，有使用过的同学可以在评论区交流下~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>卡顿问题也是 Android 性能优化中的一个常见问题，本文介绍了应该如何衡量页面卡顿程度，重点介绍了如何使用 JankStats 统计卡顿率，同时介绍了子线程定时 Dump 主线程堆栈，字节码插桩两种定位慢函数的方式。</p><p>基于以上内容，我们可以建立页面的卡顿指标，在发现卡顿时也可以较为准确地定位慢函数以进行治理，希望对你有所帮助~</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本文所有源码可见：<a href="https://github.com/RicardoJiang/android-performance" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-performance</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;卡顿问题是 Android 开发中的一个常见但容易忽视的问题，毕竟又不是不能用。 同时 App 卡顿问题有着不易衡量卡顿程度，不易复现，难以
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://RicardoJiang.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>启动优化中的一些黑科技，了解一下~</title>
    <link href="http://RicardoJiang.github.io/blog/2023/04/android-startup-optimize.html"/>
    <id>http://RicardoJiang.github.io/blog/2023/04/android-startup-optimize.html</id>
    <published>2023-04-03T13:38:52.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>启动速度优化是 android 开发中的常见需求，除了一些常规的手段之外，也有一些黑科技手段，我们来看一下这些黑科技手段是否有效，以及如何实现</p><p>本文主要是对<a href="https://juejin.cn/book/7153836660768292878" target="_blank" rel="noopener">Android 性能优化小册</a>相关内容的学习实践，感兴趣的同学可以点击查看</p><h2 id="线程优先级设置"><a href="#线程优先级设置" class="headerlink" title="线程优先级设置"></a>线程优先级设置</h2><p>线程优先级设置的概念很容易理解，优先级越高的线程越容易获取 CPU 时间片，那么为了保证 app 的流畅运行，那么我们就应该将核心线程的优先级提高，而将其他线程的优先级调低</p><p>对于 app 来说，核心线程就是主线程 + RenderThread，那么我们是否有必要手动设置线程优先级呢？</p><p>我们可以通过以下命令获取当前的线程优先级</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> </span><br><span class="line">ps -A | grep 包名 <span class="comment">// 根据包名找到Pid</span></span><br><span class="line">top -H -p PID    <span class="comment">// 查看线程优先级命令</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p1.jpg" alt></p><p>运行结果如上图所示，要看懂上面的图我们要先了解一点背景知识</p><ul><li><code>PR</code>: 优先级 (priority)，值越小优先级越高，会受<code>NI</code>的值的影响</li><li><code>NI</code>: 即 Nice 值，我们可以通过<code>Process.setThreadPriority</code>设置，同样是值越小优先级越高</li></ul><p>其实我们只需要知道它们都是值越小优先级越高就好了，可以看出主线程与 RenderThread 的优先级都挺高的，仅次于 Binder 线程</p><p>我看到一些启动优化的文章谈到线程优先级设置，但测试结果似乎是没有必要？难道是版本问题？有了解的同学可以在评论区说下</p><h2 id="核心线程绑定大核"><a href="#核心线程绑定大核" class="headerlink" title="核心线程绑定大核"></a>核心线程绑定大核</h2><h3 id="绑定大核是否有必要"><a href="#绑定大核是否有必要" class="headerlink" title="绑定大核是否有必要?"></a>绑定大核是否有必要?</h3><p>核心线程绑定大核的思路也很容易理解，现在的 CPU 都是多核的，大核的频率比小核要高不少，如果我们的核心线程固定运行在大核上，那么应用性能自然会有所提升</p><p>就拿我手上的小米10来说，使用的是骁龙865的 CPU，由一颗A77超大核+三颗A77大核+四颗A55小核心组成，我们可以通过<code>/sys/devices/system/cpu/</code>目录下的文件获取各个核的频率，如下所示</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu0<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">1804800</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu1<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">1804800</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu2<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">1804800</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu3<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">1804800</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu4<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">2419200</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu5<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">2419200</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu6<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">2419200</span></span><br><span class="line"><span class="symbol">cas:</span><span class="meta-keyword">/sys/</span>devices<span class="meta-keyword">/system/</span>cpu $ cat cpu7<span class="meta-keyword">/cpufreq/</span>cpuinfo_max_freq</span><br><span class="line"><span class="number">2841600</span></span><br></pre></td></tr></table></figure><p>可以看出，cpu0 到 cpu3 是4个小核， cpu4 到 cpu6 是3个大核，cpu7 是超大核，它们之间的频率还是相差挺大的</p><p>同时通过 systrace 工具可以发现，主线程基本都运行在 cpu7 这个超大核上，而 RenderThread 会在 cpu4 到 cpu6 间切换，有时甚至会调度到小核上</p><p>因此可以看出还是有必要把 RenderThread 绑定到一个大核上的，绑定可以更好的利用缓存以及减少线程的上下文切换</p><h3 id="绑定大核实现"><a href="#绑定大核实现" class="headerlink" title="绑定大核实现"></a>绑定大核实现</h3><p>绑定大核是通过函数<code>sched_setaffinity</code>实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_zj_android_startup_optimize_StartupNativeLib_bindCore(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>, jint thread_id, jint core) &#123;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> mask;     <span class="comment">//CPU核的集合</span></span><br><span class="line">    CPU_ZERO(&amp;mask);     <span class="comment">//将mask置空</span></span><br><span class="line">    CPU_SET(core, &amp;mask);    <span class="comment">//将需要绑定的cpu核设置给mask，核为序列0,1,2,3……</span></span><br><span class="line">    <span class="keyword">if</span> (sched_setaffinity(thread_id, <span class="keyword">sizeof</span>(mask), &amp;mask) == <span class="number">-1</span>) &#123;     <span class="comment">//将线程绑核</span></span><br><span class="line">        LOG(<span class="string">"bind thread %d to core %d fail"</span>, thread_id, core);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG(<span class="string">"bind thread %d to core %d success"</span>, thread_id, core);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，<code>sched_setaffinity</code>共有 3 个参数</p><ul><li>参数 1 是线程的 id，如果为 0 则表示主线程</li><li>参数 2 表示 cpu 序列掩码的长度</li><li>参数 3 则表示需要绑定的 cpu 序列的掩码</li></ul><p>以上是线程绑定大核的核心代码，可以看到我们还需要获取 RenderThread 的 id ，以及 cpu 大核的序列</p><p>应用中线程的信息记录在 /proc/pid/task 的文件中，通过解析 task 文件就可以获取当前进程的所有线程，而 cpu 大核序列也可以通过解析 <code>/sys/devices/system/cpu</code> 目录实现</p><p>具体代码就不在这里粘贴了，完整代码可见文末链接</p><h2 id="GC-抑制"><a href="#GC-抑制" class="headerlink" title="GC 抑制"></a>GC 抑制</h2><h3 id="GC-抑制是否有必要"><a href="#GC-抑制是否有必要" class="headerlink" title="GC 抑制是否有必要?"></a>GC 抑制是否有必要?</h3><p>我们知道 Java 的拉圾回收机制，在 Android 5.0 之后，ART 取代了 Dalvik，ART 虚拟机在垃圾回收的时候虽然没有像 Dalvik 一样 stop the world，但在启动阶段如果发生垃圾回收，GC 线程同样抢占了不少系统资源</p><p>Google 也注意到启动阶段 GC 对启动速度的影响，并在 Android 10 之后做了一定的优化，详情可见如下提交：<a href="https://cs.android.com/android/_/android/platform/art/+/a98a28262f645d100e2dee9587e7822d35ade6f9" target="_blank" rel="noopener">https://cs.android.com/android/_/android/platform/art/+/a98a28262f645d100e2dee9587e7822d35ade6f9</a></p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p2.jpg" alt></p><p>可以看出，基本思路是在 2s 内提高后台 GC 的阈值，减少启动阶段的 GC 次数，根据 Google 的测试，抑制 GC 后效果如下</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p3.png" alt></p><p>可以看出，GC 次数明显减少，启动速度也有一定的提升。那么我们是不是可以使用一些手段让 Android 10 以下也能实现这个效果呢?</p><p>同时我们也可以通过以下代码获取 gc 的次数与耗时，方便统计 gc 对启动耗时的影响，以评估是否有必要做 GC 抑制</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.gc-count"</span>) <span class="comment">// gc 次数</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.gc-time"</span>)  <span class="comment">// gc 耗时</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.blocking-gc-count"</span>) <span class="comment">// 阻塞 gc 次数</span></span><br><span class="line">Debug.getRuntimeStat(<span class="string">"art.gc.blocking-gc-time"</span>) <span class="comment">// 阻塞 gc 耗时</span></span><br></pre></td></tr></table></figure><h3 id="GC-抑制实现"><a href="#GC-抑制实现" class="headerlink" title="GC 抑制实现"></a>GC 抑制实现</h3><h4 id="HeapTaskDaemon-执行流程"><a href="#HeapTaskDaemon-执行流程" class="headerlink" title="HeapTaskDaemon 执行流程"></a>HeapTaskDaemon 执行流程</h4><p>GC 主要是通过 HeapTaskDaemon 线程实现的，这是一个守护线程，在 Zygote 线程启动后这个线程也就启动了，启动后主要做了以下工作</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p4.png" alt></p><ol><li>从<code>HeapTaskDaemon.runInternal()</code>方法开始一步步调用到 native 层的 <code>task_processor.RunAllTasks()</code> 方法</li><li>当<code>TaskProcessor</code>中的<code>tasks</code>为空时，会休眠等待，否则会取出第一个<code>HeapTask</code>并执行其<code>Run</code>方法</li></ol><p>而<code>HeapTask</code>的<code>Run</code>方法是一个虚函数，需要子类来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapTask</span> :</span> <span class="keyword">public</span> SelfDeletingTask &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfDeletingTask</span> :</span> <span class="keyword">public</span> <span class="built_in">Task</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> :</span> <span class="keyword">public</span> Closure &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Closure</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Closure() &#123; &#125;</span><br><span class="line">  <span class="comment">// 定义 Run 虚函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Run</span><span class="params">(Thread* self)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>HeapTask</code>就是垃圾回收的任务，有多个子类，比如最常见的 ConcurrentGCTask 就是其子类，在 Java 内存达到阈值时就会执行这个 Task，用于执行并发 GC</p><h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><p>在了解了 HeapTaskDaemon 的执行流程之后，我们想到，如果启动时在<code>ConcurrentGCTask</code>的<code>Run</code>方法执行前休眠一段时间，不就可以实现 GC 抑制了吗？</p><p>而<code>Run</code>方法正好是虚函数，虚函数与 Java 中的抽象函数类似，留给子类去扩展实现多态</p><p>虚函数和外部库函数一样都没法直接执行，需要在表中去查找函数的真实地址，那么我们是不是可以使用类似 PLT Hook的思路，使用自定义函数的地址替换原有函数地址，实现 Hook 呢？</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/april/p5.png" alt></p><p>答案是肯定的，如上图所示，一个类中如果存在虚函数，那么编译器就会为这个类生成一张虚函数表，并且将虚函数表的地址放在对象实例的首地址的内存中。同一个类的不同实例，共用一张虚函数表的。</p><p>因此我们的主要思路如下：</p><ol><li>启动时将虚函数表中的 Run 函数地址替换为自定义函数地址</li><li>在自定义函数内部休眠一段时间，抑制 GC</li><li>休眠完成后将虚函数表中的函数地址替换回来，避免影响后续执行</li></ol><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>很显然要想实现 Hook，我们首先需要获取<code>ConcurrentGCTask</code>对象地址与其<code>Run</code>方法地址</p><p>那么我们可以如何获取方法地址呢？</p><p>dlopen 函数和 dlsym 可以用于打开动态链接库中的函数，通过函数的符号返回函数地址</p><p>因此我们需要做下面两件事   </p><ol><li>获取函数符号</li><li>根据函数符号获取函数地址</li></ol><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb pull /<span class="keyword">system</span>/lib64/libart.so<span class="comment"> // Android 10 以前系统，Android 10 之后换了位置</span></span><br><span class="line">aarch64-linux-android-readelf -s <span class="comment">--wide libart.so</span></span><br></pre></td></tr></table></figure><p>通过以上方式可以导出 so 中的符号，查找到结果如下</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_ZTVN3art2gc4Heap16ConcurrentGCTaskE</span>   <span class="comment">// ConcurrentGCTask</span></span><br><span class="line"><span class="variable">_ZN3art2gc4Heap16ConcurrentGCTask3RunEPNS_6ThreadE</span> <span class="comment">// Run 方法</span></span><br></pre></td></tr></table></figure><p>可以看出，符号是原来的名字做了一定的变换，这是 c++ 的 name mangling 机制，mangling 的目的就是为了给重载的函数不同的签名，具体的规则可以自行查阅，这里就不赘述了</p><p>还有需要注意的一点是，Android 7.0 以上对 dlsym 的调用有限制，同时从 aarch64-linux-android-readelf 的结果可以看出， <code>ConcurrentGCTask</code> 在 .dynsym 段，而 <code>Run</code> 方法在 .symtab 段，而 dlsym 只能搜索 .dynsym 段，而无法搜索 .symtab 段，因此我们这里使用<code>enhanced_dlsym</code>开源库，既支持 Android 7.0 以上调用，也可以查找 .stymtab 段</p><p>好了，前置知识讲完了，下面来看下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delayGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以RTLD_NOW模式打开动态库libart.so，拿到句柄，RTLD_NOW即解析出每个未定义变量的地址</span></span><br><span class="line">    <span class="keyword">void</span> *handle = enhanced_dlopen(<span class="string">"/system/lib64/libart.so"</span>, RTLD_NOW);</span><br><span class="line">    <span class="comment">//通过符号拿到ConcurrentGCTask对象地址</span></span><br><span class="line">    <span class="keyword">void</span> *taskAddress = enhanced_dlsym(handle, <span class="string">"_ZTVN3art2gc4Heap16ConcurrentGCTaskE"</span>);</span><br><span class="line">    <span class="comment">//通过符号拿到run方法</span></span><br><span class="line">    <span class="keyword">void</span> *runAddress = enhanced_dlsym(handle, <span class="string">"_ZN3art2gc4Heap16ConcurrentGCTask3RunEPNS_6ThreadE"</span>);</span><br><span class="line">    <span class="comment">//由于 ConcurrentGCTask 只有五个虚函数，所以我们只需要查询前五个地址即可。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//对象头地址中的内容存放的就是是虚函数表的地址，所以这里是指针的指针，即是虚函数表地址，拿到虚函数表地址后，转换成数组，并遍历获取值</span></span><br><span class="line">        <span class="keyword">void</span> *vfunc = ((<span class="keyword">void</span> **) taskAddress)[i];</span><br><span class="line">        <span class="comment">// 如果虚函数表中的值是前面拿到的 Run 函数的地址，那么就找到了Run函数在虚函数表中的地址</span></span><br><span class="line">        <span class="keyword">if</span> (vfunc == runAddress) &#123;</span><br><span class="line">            <span class="comment">//这里需要注意的是，这里 +i 操作拿到的是地址，而不是值，因为这里的值是 Run 函数的真实地址</span></span><br><span class="line">            mSlot = (<span class="keyword">void</span> **) taskAddress + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存原有函数</span></span><br><span class="line">    originFun = *mSlot;</span><br><span class="line">    <span class="comment">// 将虚函数表中的值替换成我们hook函数的地址</span></span><br><span class="line">    replaceFunc(mSlot, (<span class="keyword">void</span> *) &amp;hookRun);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们的 hook 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookRun</span><span class="params">(<span class="keyword">void</span> *thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//休眠3秒</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//将虚函数表中的值还原成原函数，避免每次执行run函数时都会执行hook的方法</span></span><br><span class="line">    replaceFunc(mSlot, originFun);</span><br><span class="line">    <span class="comment">//执行原来的Run方法</span></span><br><span class="line">    ((<span class="keyword">void</span> (*)(<span class="keyword">void</span> *)) originFun)(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码就是上面这些，主要做了这么几件事： </p><ol><li>通过符号获取<code>Run</code>方法地址</li><li>遍历虚函数表，找到虚函数表中存放<code>Run</code>方法真实地址的位置</li><li>保存原函数地址，并将虚函数表中的值替换成我们 hook 的函数地址</li><li>在 hook 函数中休眠一段时间，休眠结束后还原虚函数表，避免影响后续任务</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在性能优化中除了一些常规手段外，也经常有一些黑科技手段，本文主要介绍了启动优化中的线程优先级设置，核心线程绑定大核，GC 抑制等手段，<br>讲解了一下这些黑科技手段是否有效，以及具体是怎么实现的，希望对你有所帮助</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文主要是对<a href="https://juejin.cn/book/7153836660768292878" target="_blank" rel="noopener">Android 性能优化小册</a>相关内容的学习实践，感兴趣的同学可以点击查看</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本文所有源码可见：<a href="https://github.com/RicardoJiang/android-performance" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-performance</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;启动速度优化是 android 开发中的常见需求，除了一些常规的手段之外，也有一些黑科技手段，我们来看一下这些黑科技手段是否有效，以及如何实
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://RicardoJiang.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【稳定性优化】安全气囊如何实现？</title>
    <link href="http://RicardoJiang.github.io/blog/2023/03/android-stability-optimize.html"/>
    <id>http://RicardoJiang.github.io/blog/2023/03/android-stability-optimize.html</id>
    <published>2023-03-25T13:29:03.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们都知道，当 Andoird 程序发生未捕获的异常的时候，程序会直接 Crash 退出</p><p>而所谓安全气囊，是指在 Crash 发生时，可以捕获异常，触发兜底逻辑，在程序退出前做最后的抢救</p><p>接下来我们来看一下怎么实现一个安全气囊，以在 Crash 发生时做最后的抢救</p><h2 id="Java-层安全气囊"><a href="#Java-层安全气囊" class="headerlink" title="Java 层安全气囊"></a>Java 层安全气囊</h2><h3 id="Java-异常如何捕获"><a href="#Java-异常如何捕获" class="headerlink" title="Java 异常如何捕获"></a>Java 异常如何捕获</h3><p>在实现安全气囊之前，我们先思考一个问题，像 bugly, sentry 这种库，是如何捕获异常并上传堆栈的呢？</p><p>要了解这个问题，我们首先要了解一下当异常发生时是怎么传播的</p><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2023/march/p7.png" alt></p><p>其实也很简单，主要分为以下几步</p><ol><li>当抛出异常时，通过<code>Thread.dispatchUncaughtException</code>进行分发</li><li>依次由<code>Thread</code>，<code>ThreadGroup</code>，<code>Thread.getDefaultUncaughtExceptionHandler</code>处理</li><li>在默认情况下，<code>KillApplicationHandler</code>会被设置<code>defaultUncaughtExceptionHandler</code></li><li><code>KillApplicationHandler</code>中会调用<code>Process.killProcess</code>退出应用</li></ol><p>这就是异常发生时的传播路径，可以看出，如果我们通过<code>Thread.setDefaultUncaughtExceptionHandler</code>设置自定义处理器，就可以捕获异常做一些兜底操作了，其实 bugly 这些库也是这么做的</p><h3 id="自定义异常处理器的问题"><a href="#自定义异常处理器的问题" class="headerlink" title="自定义异常处理器的问题"></a>自定义异常处理器的问题</h3><p>那么问题来了，如果我们设置了自定义处理器，在里面只做一些打印日志的操作，而不是退出应用，是不是就可以让 app 永不崩溃了呢？</p><p>答案当然是否定的，主要有以下两个问题</p><h4 id="Looper-循环问题"><a href="#Looper-循环问题" class="headerlink" title="Looper 循环问题"></a>Looper 循环问题</h4><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2023/march/p8.png" alt></p><p>我们知道，App 的运行在很大程序上依赖于 Handler 消息机制，<code>Handler</code> 不断的往 <code>MessageQueue</code> 中发送 <code>Message</code>，而<code>Looper</code>则死循环的不断从<code>MessageQueue</code>中取出<code>Message</code>并消费，整个 app 才能运行起来</p><p>而当异常发生时，<code>Looper.loop</code> 循环被退出了，事件也就不会被消费了，因此虽然 app 不会直接退出，但也会因为无响应发生 ANR</p><p>因此，当崩溃发生在主线程时，我们需要恢复一下<code>Looper.loop</code></p><h4 id="主流程抛出异常问题"><a href="#主流程抛出异常问题" class="headerlink" title="主流程抛出异常问题"></a>主流程抛出异常问题</h4><p>当我们在主淤积抛出异常时，比如在<code>onCreate</code>方法中，虽然我们捕获住了异常，但程序的执行也被中断了，界面的绘制可能无法完成，点击事件的设置也没有生效</p><p>这就导致了 app 虽然没有退出，但用户却无法操作的问题，这种情况似乎还不如直接 Crash 了呢</p><p>因此我们的安全气囊应该支持配置，只处理那些非主流程的操作，比如点击按钮触发的崩溃，或者一些打点等对用户无感知操作造成的崩溃</p><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p>为了解决上面提到的两个问题，我们的方案如下</p><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2023/march/p9.jpg" alt></p><p>主要分为以下几步：  </p><ol><li>注册自定义<code>DefaultUncaughtExceptionHandler</code></li><li>当异常发生是捕获异常</li><li>匹配异常堆栈是否符合配置，如果符合则捕获，否则交给默认处理器处理</li><li>判断异常发生时是否是主线程，如果是则重启<code>Looper</code></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>代码实现如下： </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setUpJavaAirBag</span><span class="params">(configList: <span class="type">List</span>&lt;<span class="type">JavaAirBagConfig</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> preDefaultExceptionHandler = Thread.getDefaultUncaughtExceptionHandler()</span><br><span class="line">    <span class="comment">// 设置自定义处理器</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler &#123; thread, exception -&gt;</span><br><span class="line">        handleException(preDefaultExceptionHandler, configList, thread, exception)</span><br><span class="line">        <span class="keyword">if</span> (thread == Looper.getMainLooper().thread) &#123;</span><br><span class="line">        <span class="comment">// 重启 Looper</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Looper.loop()</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                    handleException(</span><br><span class="line">                        preDefaultExceptionHandler, configList, Thread.currentThread(), e</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleException</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    preDefaultExceptionHandler: <span class="type">Thread</span>.<span class="type">UncaughtExceptionHandler</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    configList: <span class="type">List</span>&lt;<span class="type">JavaAirBagConfig</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    thread: <span class="type">Thread</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    exception: <span class="type">Throwable</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line"><span class="comment">// 匹配配置</span></span><br><span class="line">    <span class="keyword">if</span> (configList.any &#123; isStackTraceMatching(exception, it) &#125;) &#123;</span><br><span class="line">        Log.w(<span class="string">"StabilityOptimize"</span>, <span class="string">"Java Crash 已捕获"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.w(<span class="string">"StabilityOptimize"</span>, <span class="string">"Java Crash 未捕获，交给原有 ExceptionHandler 处理"</span>)</span><br><span class="line">        preDefaultExceptionHandler.uncaughtException(thread, exception)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Native-层安全气囊"><a href="#Native-层安全气囊" class="headerlink" title="Native 层安全气囊"></a>Native 层安全气囊</h2><p>通过上面的步骤，我们实现了一个 Java 层安全气囊，但是如果发生 Native 层崩溃时，程序还是会崩溃</p><p>那么我们能不能按照 Java 层安全气囊的思路，实现一个 Native 层的安全气囊？</p><h3 id="Native-异常如何捕获"><a href="#Native-异常如何捕获" class="headerlink" title="Native 异常如何捕获"></a>Native 异常如何捕获</h3><p>Native 层异常是通过信号机制实现的</p><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2023/march/p10.png" alt></p><ol><li>crash产生后，会在用户态阶段调用中断进入内核态</li><li>在处理完内核操作，返回用户态时，会检查信号队列上是否有信号需要处理</li><li>如果有信号需要处理，则会调用<code>sigaction</code>函数进行相应处理</li></ol><p>那么如果我们通过注册信号处理函数<code>sigaction</code>设置自定义信号处理器，是不是可以实现跟 Java 安全气囊一样的效果？</p><p>需要注意的是，我们可以通过<code>sigaction</code>设置自定义信号处理器，但是<code>SIGKILL</code>与<code>SIGSTOP</code>信号我们是无法更改其默认行为的，如果我们设置了自定义信号处理器，没有退出 app，但错误实际还是产生了，当错误实在不可控时，系统还是会发送<code>SIGKILL/SIGSTOP</code>信号，这个时候还会导致我们 crash 时无法获取真正的堆栈，因此我们在自定义信号处理器时需要慎重</p><p>可以看出，要了解 Native 异常捕获，需要对 Linux 信号机制有一定了解，想了解更多的同学可以查看：<a href="https://juejin.cn/post/7196131493448613945" target="_blank" rel="noopener">写给android开发的Linux 信号 - 上篇</a></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>在了解了 Native 层异常处理的原理之后，我们通过自定义信号处理器来实现一个 Native 层的安全气囊，主要分为以下几步</p><ol><li>注册自定义信号处理器</li><li>获取 Native 堆栈并与配置堆栈进行比较</li><li>如果匹配上了则忽略相关崩溃，如果未匹配上则交给原信号处理器处理</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_zj_android_stability_optimize_StabilityNativeLib_openNativeAirBag(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>,</span><br><span class="line">        jint signal,</span><br><span class="line">        jstring soName,</span><br><span class="line">        jstring backtrace) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigc</span>;</span></span><br><span class="line">        <span class="comment">// 自定义处理器</span></span><br><span class="line">        sigc.sa_sigaction = sig_handler;</span><br><span class="line">        sigemptyset(&amp;sigc.sa_mask);</span><br><span class="line">        sigc.sa_flags = SA_SIGINFO | SA_ONSTACK | SA_RESTART;</span><br><span class="line">        <span class="comment">// 注册信号</span></span><br><span class="line">        <span class="keyword">int</span> flag = sigaction(signal, &amp;sigc, &amp;old);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取堆栈</span></span><br><span class="line">    <span class="keyword">auto</span> stackTrace = getStackTraceWhenCrash();</span><br><span class="line">    <span class="comment">// 与配置的堆栈进行匹配</span></span><br><span class="line">    <span class="keyword">if</span> (sig == airBagConfig.signal &amp;&amp;</span><br><span class="line">        stackTrace.<span class="built_in">find</span>(airBagConfig.soName) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos &amp;&amp;</span><br><span class="line">        stackTrace.<span class="built_in">find</span>(airBagConfig.backtrace) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        LOG(<span class="string">"异常信号已捕获"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没匹配上的交给原有处理器处理</span></span><br><span class="line">        LOG(<span class="string">"异常信号交给原有信号处理器处理"</span>);</span><br><span class="line">        sigaction(sig, &amp;old, <span class="literal">nullptr</span>);</span><br><span class="line">        raise(sig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>通过上面的步骤，其实 Native 层的安全气囊已经实现了，在 demo 中触发 Native Crash 可以被捕获到</p><p>但是信号处理函数必须是<code>async-signal-safe</code>和可重入的，理论上不应该在信号处理函数中做太多工作，比如<code>malloc</code>等函数都不是可重入的</p><p>而我们在信号处理函数中获取了堆栈，打印了日志，很可能会造成一些意料之外的问题</p><p>理论上我们可以在子线程获取堆栈，在信号处理函数中只需要发出信号就可以了，但我尝试在子线程中使用 unwind 获取堆栈，发现获取不到真正的堆栈，因此还存在一定的问题，有了解的大佬可以在评论区指点下</p><p>Native 层安全气囊的方案也可以看看@Pika 写的<a href="https://github.com/TestPlanB/mooner" target="_blank" rel="noopener">https://github.com/TestPlanB/mooner</a>，支持捕获 Android 基于“pthread_create” 产生的子线程中异常业务逻辑产生信号，导致的native crash</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了Java 层与 Native 层安全气囊的实现方案与异常捕获原理，在一些非主流程的 Crash 发生时，通过安全气囊可以做一些最后的挽救，在降低崩溃率方面应该还是有一些应用场景的，希望本文对你有所帮助~</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有源码可见：<a href="https://github.com/RicardoJiang/android-performance" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-performance</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;我们都知道，当 Andoird 程序发生未捕获的异常的时候，程序会直接 Crash 退出&lt;/p&gt;
&lt;p&gt;而所谓安全气囊，是指在 Crash 
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://RicardoJiang.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Native Hook 快速上手</title>
    <link href="http://RicardoJiang.github.io/blog/2023/03/native-hook-start.html"/>
    <id>http://RicardoJiang.github.io/blog/2023/03/native-hook-start.html</id>
    <published>2023-03-19T07:32:25.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hook 原意是指钩子，它表示的就是在某个函数的上下文做自定义的处理来实现我们想要的黑科技</p><p>大家可能比较熟悉 Java 层的一些 Hook 技术，比如反射，动态代理，或者 ASM 字节码插桩</p><p>在 Java 层之外，Android 系统还有很大一部分属于 Native 层，有时不可避免的需要用到 Native Hook 技术</p><p>本文主要介绍 Native Hook 是什么，以及如何通过一个例子快速上手</p><h2 id="Native-Hook-是什么？"><a href="#Native-Hook-是什么？" class="headerlink" title="Native Hook 是什么？"></a>Native Hook 是什么？</h2><p>Native Hook 技术通常有以下两种实现方式</p><ul><li>PLT Hook：通过修改 GOT 表，将目标函数的地址指向自定义的 Hook 函数的地址，从而拦截和修改目标函数的行为。</li><li>Inline Hook：直接将函数开始处的指令更替为跳转指令，使得原函数直接跳转到 Hook 的目标函数函数</li></ul><p>我们下面来分别介绍一下</p><h3 id="PLT-Hook"><a href="#PLT-Hook" class="headerlink" title="PLT Hook"></a>PLT Hook</h3><p>PLT Hook 用一句描述就是：通过修改 GOT 表，将目标函数的地址指向自定义的 Hook 函数的地址，从而拦截和修改目标函数的行为。那么 GOT 表是什么呢？这需要我们对 SO 库文件的 ELF 文件格式和动态链接过程有所了解。</p><p>ELF(Executable and Linkable Format) 文件格式是一种可执行文件和可链接文件格式，它是现代Unix和Linux系统上最常见的二进制文件格式之一，so 库其实就是一个 ELF 文件</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p1.png" alt></p><p>ELF 文件格式也比较复杂，我们这里主要关心<code>.plt</code>与<code>.got</code>两个表</p><ul><li>The Global Offset Table/全局偏移量表 (GOT)。简单来说就是在数据段的地址表，假定我们有一些代码段的指令引用一些地址变量，编译器会引用 GOT 表来替代直接引用绝对地址，因为绝对地址在编译期是无法知道的，只有重定位后才会得到 ，GOT 自己本身将会包含函数引用的绝对地址。</li><li>The Procedure Linkage Table/过程链接表 (PLT)。PLT 不同于 GOT，它位于代码段，动态库的每一个外部函数都会在 PLT 中有一条记录，每一条 PLT 记录都是一小段可执行代码。一般来说，外部代码都是在调用 PLT 表里的记录，然后 PLT 的相应记录会负责调用实际的函数。我们一般把这种设定叫作“蹦床”（Trampoline）。</li></ul><p>简单来说，对于其它 so 中的函数，在编译期无法确定其地址，只有在运行时才能获取，因此需要查询 GOT 表来查询外部函数的绝对地址。外部库函数的绝对地址在 got 表中的初始值都是 0 ，只有当实际调用这个函数时，Linker 程序才会写入实际的地址。</p><p>因此如果我们想要实现 native hook，只需要把 got 表中的目标函数的地址修改为我们自定义的地址即可。</p><p>那么在这个过程中，PLT 表的作用又是什么呢？</p><p>实际上，在函数调用的过程中，会先跳转到 PLT 表，它位于代码段，每一条 PLT 记录都是一小段可执行代码，这段代码会查询 GOT 表，获取真实地址然后跳转对应的函数</p><p>听起来有些多此一举，实际上 PLT 表可以起到延迟绑定的作用，只有当真正调用目标函数时，got 表中才会去绑定真实地址，如果没有调用则不绑定。因为很多函数可能在程序执行完时都不会被用到，那么一开始把所有函数都链接好实际是一种浪费。这就是 PLT 表起到的作用</p><p>因此在 So 中调用外部函数的实际过程如下所示:</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p2.jpg" alt></p><p>在了解了 PLT HOOK 的基本原理之后，其实我们可以自己解析 got 表然后替换为自定义的函数地址实现 hook，也可以使用一些已经比较成熟的库</p><ul><li><a href="https://github.com/bytedance/bhook" target="_blank" rel="noopener">https://github.com/bytedance/bhook</a>    </li><li><a href="https://github.com/iqiyi/xHook" target="_blank" rel="noopener">https://github.com/iqiyi/xHook</a></li></ul><p>本文后面的实战都是使用 bhook 实现 hook的</p><h3 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h3><p>从上面的介绍我们可以看出，PLT Hook 存在一定的局限性，它只能 hook 外部 so 的调用，但如果要 hook 当前的 so 呢？</p><p>Hook so 内部调用可以通过 Inline Hook 实现</p><p>Inline Hook 是通过在程序运行时动态修改内存中的汇编指令，来改变程序执行流程的一种 Hook 方式，它的基本原理是直接将函数开始处的指令更替为跳转指令，使得原函数直接跳转到 Hook 的目标函数函数，并保留被覆盖的原指令以完成后续再调用回来的目的。</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p3.png" alt></p><p>Inline Hook 的基本流程如上所示，主要分为以下几步</p><ol><li>拷贝原函数的头部两条汇编指令，并覆盖成跳转到自定义函数的指令</li><li>执行自定义函数，再执行前面被覆盖的两条指令</li><li>执行后续指令</li></ol><p>与 PLT Hook 方式相比，Inline Hook 更加强大，几乎可以 Hook 任何函数，但由于其实现十分复杂，需要直接修改汇编指令，因此会有很多兼容性问题，不太稳定，因此如果想要使用的话推荐直接使用相应的开源库，比如字节开源的：<a href="https://github.com/bytedance/android-inline-hook" target="_blank" rel="noopener">https://github.com/bytedance/android-inline-hook</a></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总得来说，两种 Native Hook 方式各有优劣，可根据实际情况使用</p><ul><li>PLT HooK的优点在于稳定，缺点则在于只能 Hook 外部函数的调用</li><li>Inline Hook的优点在于可以 hook so 内部调用，缺点则在于不够稳定，存在一定的兼容问题</li></ul><h2 id="Native-Hook-实战"><a href="#Native-Hook-实战" class="headerlink" title="Native Hook 实战"></a>Native Hook 实战</h2><p>接下来我们通过 Native Hook 技术来实现对 Native 内存申请的监控，主要支持以下功能</p><ol><li>添加对 malloc, free 函数的 hook，支持统计 so 的内存申请与释放情况</li><li>当申请超大内存时，支持获取 native 堆栈以定位问题</li><li>直接获取的 native 堆栈是个 16 进制数组，无法看出有效信息，因此还需要将解析堆栈还原出 so 名与函数信息</li></ol><h3 id="Hook-函数"><a href="#Hook-函数" class="headerlink" title="Hook 函数"></a>Hook 函数</h3><p>我们这里通过 bhook 库来实现对 malloc, free 函数的 hook，如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc_proxy</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    BYTEHOOK_STACK_SCOPE();</span><br><span class="line">    Dl_info callerInfo = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (dladdr(__builtin_return_address(<span class="number">0</span>), &amp;callerInfo)) &#123;</span><br><span class="line">    <span class="comment">// 统计分配的内存</span></span><br><span class="line">        onMalloc(callerInfo.dli_fname, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">void</span> *object = BYTEHOOK_CALL_PREV(malloc_proxy, len);</span><br><span class="line">    objMap[object] = len;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_proxy</span><span class="params">(<span class="keyword">void</span> *__ptr)</span> </span>&#123;</span><br><span class="line">    BYTEHOOK_STACK_SCOPE();</span><br><span class="line">    Dl_info callerInfo = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (dladdr(__builtin_return_address(<span class="number">0</span>), &amp;callerInfo)) &#123;</span><br><span class="line">        <span class="keyword">auto</span> len = objMap.<span class="built_in">find</span>(__ptr);</span><br><span class="line">        <span class="comment">// 统计 free的内存</span></span><br><span class="line">        onFree(callerInfo.dli_fname, len-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BYTEHOOK_CALL_PREV(free_proxy, __ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    bytehook_hook_all(<span class="literal">nullptr</span>, <span class="string">"malloc"</span>, (<span class="keyword">void</span> *) malloc_proxy,</span><br><span class="line">                      <span class="literal">nullptr</span>,</span><br><span class="line">                      <span class="literal">nullptr</span>);</span><br><span class="line">    bytehook_hook_all(<span class="literal">nullptr</span>, <span class="string">"free"</span>, (<span class="keyword">void</span> *) free_proxy,</span><br><span class="line">                      <span class="literal">nullptr</span>,</span><br><span class="line">                      <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hook 的逻辑非常简单，通过调用<code>bytehook_hook_all</code>，指定要<code>hook</code>的方法与代理方法，所有的<code>malloc</code>方法调用都会被代理到<code>malloc_proxy</code>方法，所有的<code>free</code>方法调用也会被代理到<code>free_proxy</code>方法中</p><p>然后我们在代理方法中加入 so 分配与回收内存的监控，就可以统计出一个 so 库一共申请了多少内存，释放了多少内存，打印出来的日志如下所示</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">So</span> /apex/com.<span class="keyword">android.art/lib64/libart-compiler.so </span>allocated <span class="number">581632</span> <span class="keyword">bytes, </span>freed <span class="number">2883686</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.art/lib64/libc++.so </span>allocated <span class="number">2779694</span> <span class="keyword">bytes, </span>freed <span class="number">2640</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.art/lib64/liblzma.so </span>allocated <span class="number">9071256</span> <span class="keyword">bytes, </span>freed <span class="number">9071256</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.i18n/lib64/libicuuc.so </span>allocated <span class="number">36428</span> <span class="keyword">bytes, </span>freed <span class="number">1164</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.runtime/lib64/bionic/libc.so </span>allocated <span class="number">33360</span> <span class="keyword">bytes, </span>freed <span class="number">0</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/apex/com.<span class="keyword">android.vndk.v30/lib64/libc++.so </span>allocated <span class="number">10944</span> <span class="keyword">bytes, </span>freed <span class="number">0</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/<span class="meta">data</span>/app/~~<span class="number">6</span>Mf4VQY4K16aFji1rZ4dkg==/com.zj.<span class="keyword">android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libandroid-performance.so </span>allocated <span class="number">184549424</span> <span class="keyword">bytes, </span>freed <span class="number">184549424</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/<span class="meta">data</span>/app/~~<span class="number">6</span>Mf4VQY4K16aFji1rZ4dkg==/com.zj.<span class="keyword">android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libmemory-hook.so </span>allocated <span class="number">3310960</span> <span class="keyword">bytes, </span>freed <span class="number">2776978</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libbinder.so allocated <span class="number">129408</span> <span class="keyword">bytes, </span>freed <span class="number">462200</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libc++.so allocated <span class="number">14428072</span> <span class="keyword">bytes, </span>freed <span class="number">864</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libhwui.so allocated <span class="number">725687</span> <span class="keyword">bytes, </span>freed <span class="number">11980415</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libutils.so allocated <span class="number">1896281</span> <span class="keyword">bytes, </span>freed <span class="number">2132345</span> <span class="keyword">bytes</span></span><br><span class="line"><span class="keyword">So </span>/system/lib64/libz.so allocated <span class="number">565024</span> <span class="keyword">bytes, </span>freed <span class="number">565024</span> <span class="keyword">bytes</span></span><br></pre></td></tr></table></figure><h3 id="获取-native-堆栈"><a href="#获取-native-堆栈" class="headerlink" title="获取 native 堆栈"></a>获取 native 堆栈</h3><p>除了统计 So 内存使用情况之外，在申请超大内存时，我们也可以获取 native 堆栈以方便定位问题</p><p>目前，在 Android 中获取 Native 堆栈的方法基本上都是通过 CFI 来实现的。CFI 代表 Call Frame Information，即帧调用信息。在程序运行时，当 Native 函数执行进入栈指令时，它会将对应指令的信息（即 CFI ）写入 so 文件中的 .eh_frame 和 .eh_frame_hdr 段中，这两个段是 so 文件中的段之一。因此，要获取 Native 堆栈，只需要读取这两个段中的数据即可。</p><p>在 Android 系统中，我们可以使用 libunwind 库来直接获取 Native 堆栈信息，其底层原理实际上也是通过读取 CFI 来实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unwind.h&gt; //引入 unwind 库</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backtrace_stack</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> **current;</span><br><span class="line">    <span class="keyword">void</span> **<span class="built_in">end</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> _Unwind_Reason_Code <span class="title">unwind_callback</span><span class="params">(struct _Unwind_Context *context, <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *state = (struct backtrace_stack *) (data);</span><br><span class="line">    <span class="keyword">uintptr_t</span> pc = _Unwind_GetIP(context);  <span class="comment">// 获取 pc 值，即绝对地址</span></span><br><span class="line">    <span class="keyword">if</span> (pc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;current == state-&gt;<span class="built_in">end</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *state-&gt;current++ = (<span class="keyword">void</span> *) (pc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">fill_backtraces_buffer</span><span class="params">(<span class="keyword">void</span> **<span class="built_in">buffer</span>, <span class="keyword">int</span> <span class="built_in">max</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backtrace_stack</span> <span class="title">stack</span> = &#123;</span><span class="built_in">buffer</span>, <span class="built_in">buffer</span> + <span class="built_in">max</span>&#125;;</span><br><span class="line">    _Unwind_Backtrace(unwind_callback, &amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>.current - <span class="built_in">buffer</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc_proxy</span><span class="params">(<span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">80</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="comment">// 当申请内存大小大于 80M 时获取堆栈</span></span><br><span class="line">        <span class="keyword">int</span> maxStackSize = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">void</span> *<span class="built_in">buffer</span>[maxStackSize];</span><br><span class="line">        <span class="keyword">int</span> count = fill_backtraces_buffer(<span class="built_in">buffer</span>, maxStackSize);</span><br><span class="line">        dumpBacktrace(<span class="built_in">buffer</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，当申请内存大小大于 80M 时，我们通过 unwind 来获取堆栈，将将获取的堆栈放入 buffer 数组中</p><p>但是我们获得的 buffer 数组只是 16 进制的地址，根本看不出有效信息，如下所示：</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p4.jpg" alt></p><p>因此我们还要进行下一步，还原堆栈信息</p><h3 id="还原堆栈信息"><a href="#还原堆栈信息" class="headerlink" title="还原堆栈信息"></a>还原堆栈信息</h3><p>要将16进制的地址堆栈还原成带有效信息的堆栈，通常需要完成以下三个步骤：</p><ol><li>首先要确认相关的 so 文件名称；</li><li>接下来需要计算相应的偏移地址；</li><li>最后，基于带符号表（ELF文件中的一张表，存放了函数、方法、变量等名称符号信息）的so文件，还原指针对应的函数名和行数。</li></ol><h4 id="确认-so-文件名称"><a href="#确认-so-文件名称" class="headerlink" title="确认 so 文件名称"></a>确认 so 文件名称</h4><p>我们可以通过<code>dladdr</code>函数来查询 so 文件名，函数定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">dladdr</span> <span class="params">( <span class="keyword">void</span> * addr , Dl_info * info )</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dli_fname;   <span class="comment">//地址对应的 so 名</span></span><br><span class="line">    <span class="keyword">void</span>       *dli_fbase;   <span class="comment">//对应so库的基地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dli_sname;   <span class="comment">//如果so库有符号表，这会显示离地址最近的函数名</span></span><br><span class="line">    <span class="keyword">void</span>       *dli_saddr;   <span class="comment">//符号表中，离地址最近的函数的地址</span></span><br><span class="line">&#125; Dl_info;</span><br></pre></td></tr></table></figure><p>我们将函数地址传入<code>dladdr</code>函数，就可以获取相应的 so 库名称与基地址，如下所示： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpBacktrace</span><span class="params">(<span class="keyword">void</span> **<span class="built_in">buffer</span>, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">void</span> *addr = <span class="built_in">buffer</span>[i];</span><br><span class="line">        Dl_info info = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (dladdr(addr, &amp;info)) &#123;</span><br><span class="line">            LOG(<span class="string">"# %d : %p : %s(%s)(%p)"</span>, i, addr, info.dli_fname,</span><br><span class="line">                info.dli_sname, info.dli_saddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>dladdr</code>函数获取的堆栈打印如下所示：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 0 : 0x767174309c : /data/app/~~6Mf4VQY4K16aFji1rZ4dkg==/com.zj.android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libmemory-hook.so(0x2609c)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 1 : 0x7671742ec8 : /data/app/~~6Mf4VQY4K16aFji1rZ4dkg==/com.zj.android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libmemory-hook.so(0x25ec8)(_Z12malloc_proxym)(0x7671742dbc)</span></span><br><span class="line"><span class="comment"># 2 : 0x76712f23d8 : /data/app/~~6Mf4VQY4K16aFji1rZ4dkg==/com.zj.android.performance-XHR75TrkIVbXU9GfDYgZGg==/lib/arm64/libandroid-performance.so(0x203d8)(Java_com_zj_android_performance_jni_NativeLibTest_testMalloc)(0x76712f23a8)</span></span><br><span class="line"><span class="comment"># 3 : 0x7691222248 : /apex/com.android.art/lib64/libart.so(0x222248)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 4 : 0x7691218968 : /apex/com.android.art/lib64/libart.so(0x218968)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 5 : 0x7691285ff4 : /apex/com.android.art/lib64/libart.so(0x285ff4)(_ZN3art9ArtMethod6InvokeEPNS_6ThreadEPjjPNS_6JValueEPKc)(0x7691285f30)</span></span><br><span class="line"><span class="comment"># 6 : 0x76913ea3ec : /apex/com.android.art/lib64/libart.so(0x3ea3ec)(_ZN3art11interpreter34ArtInterpreterToCompiledCodeBridgeEPNS_6ThreadEPNS_9ArtMethodEPNS_11ShadowFrameEtPNS_6JValueE)(0x76913ea254)</span></span><br><span class="line"><span class="comment"># 7 : 0x76913e4f88 : /apex/com.android.art/lib64/libart.so(0x3e4f88)(_ZN3art11interpreter6DoCallILb0ELb0EEEbPNS_9ArtMethodEPNS_6ThreadERNS_11ShadowFrameEPKNS_11InstructionEtPNS_6JValueE)(0x76913e4c48)</span></span><br><span class="line"><span class="comment"># 8 : 0x769175fd10 : /apex/com.android.art/lib64/libart.so(0x75fd10)(MterpInvokeVirtual)(0x769175f878)</span></span><br><span class="line"><span class="comment"># 9 : 0x7691203818 : /apex/com.android.art/lib64/libart.so(0x203818)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 10 : 0x769176b3f4 : /apex/com.android.art/lib64/libart.so(</span></span><br><span class="line"><span class="comment"># 11 : 0x7691203998 : /apex/com.android.art/lib64/libart.so(0x203998)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 12 : 0x769176b3f4 : /apex/com.android.art/lib64/libart.so(</span></span><br><span class="line"><span class="comment"># 13 : 0x7691203998 : /apex/com.android.art/lib64/libart.so(0x203998)((null))(0x0)</span></span><br><span class="line"><span class="comment"># 14 : 0x76913dcd30 : /apex/com.android.art/lib64/libart.so(0x3dcd30)((null))(0x0)</span></span><br><span class="line"></span><br><span class="line">malloc <span class="number">92274688</span> <span class="keyword">byte</span> success</span><br></pre></td></tr></table></figure><p>可以看出，在有符号表的情况下，so 名与函数名都正确的打印出来了，而对于 libart，由于已经移除了符号表，则显示为 null ，地址也为 0 </p><h3 id="计算函数偏移地址"><a href="#计算函数偏移地址" class="headerlink" title="计算函数偏移地址"></a>计算函数偏移地址</h3><p>通过<code>dladdr</code>函数，我们已经获取了堆栈的 so 名与函数名，那可不可以具体定位到到底是函数的哪一行出现了问题吗？</p><p>我们可以通过 NDK 的 addr2line 工具，根据函数偏移地址，获取地址对应的函数名、行号等信息</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">addr2line -C -f -e xxx.so 函数偏移地址</span><br><span class="line"></span><br><span class="line"><span class="deletion">-C:将低级别的符号名解码为用户级别的名字。</span></span><br><span class="line"><span class="deletion">-e:指定需要转换地址的可执行文件名</span></span><br><span class="line"><span class="deletion">-f:在显示文件名、行号信息的同时显示函数名。</span></span><br></pre></td></tr></table></figure><p>我们在堆栈中获取的地址是函数的绝对地址，要获取偏移地址减去 so 的基地址就可以了</p><p>偏移地址 = 函数的绝对地址 - 库文件的基地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dumpBacktrace</span><span class="params">(<span class="keyword">void</span> **<span class="built_in">buffer</span>, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dladdr(addr, &amp;info)) &#123;</span><br><span class="line">        <span class="comment">// 计算偏移地址</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uintptr_t</span> address_relative = (<span class="keyword">uintptr_t</span>) addr - (<span class="keyword">uintptr_t</span>) info.dli_fbase;</span><br><span class="line">            LOG(<span class="string">"# %d : %p : %s(%p)(%s)(%p)"</span>, i, addr, info.dli_fname, address_relative,</span><br><span class="line">                info.dli_sname, info.dli_saddr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的日志也可以看出，有问题的<code>Java_com_zj_android_performance_jni_NativeLibTest_testMalloc</code>函数的偏移地址是<code>0x203d8</code></p><h3 id="还原函数名及行号"><a href="#还原函数名及行号" class="headerlink" title="还原函数名及行号"></a>还原函数名及行号</h3><p>现在，我们已经得知了函数的偏移地址，接下来就可以使用 addr2line 工具来获取行号了。在 Android 的 NDK 中已经提供了这个工具，位于 /ndk/xxx/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin 目录中。如果您使用的是 M1 电脑，可以选择 aarch64 目录。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">arm</span>-linux-<span class="keyword">androideabi-addr2line </span>  -C -f -e libandroid_performance.so  <span class="number">0x203d8</span></span><br></pre></td></tr></table></figure><p>需要注意的是，这里的 so 必须是带符号表的，因此需要在编译产物中的 native_libs 目录去找(注意不是 stripped_native_libs 目录)</p><p>运行以上命令后，得到的结果如下</p><p><img src="https://raw.gitmirror.com/RicardoJiang/resource/main/2023/march/p5.jpg" alt></p><p>可以看出，已经定位到了具体的函数名与行号</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Native Hook 是什么以及常见实现方案，同时通过一个监控 native 内存的例子进行了实践</p><p>在 Android 应用性能优化中，Native Hook 技术广泛应用于内存优化、启动优化等方面，如 bitmap hook、pthread hook、GC 抑制等。因此，如果您希望在相关领域进行技术优化，掌握 Native Hook 技术将是非常有必要的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>本文主要是对<a href="https://juejin.cn/book/7153836660768292878" target="_blank" rel="noopener">Android 性能优化小册</a>相关内容的学习实践，感兴趣的同学可以点击查看</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>本文所有源码可见：<a href="https://github.com/RicardoJiang/android-performance" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-performance</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Hook 原意是指钩子，它表示的就是在某个函数的上下文做自定义的处理来实现我们想要的黑科技&lt;/p&gt;
&lt;p&gt;大家可能比较熟悉 Java 层的一
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://RicardoJiang.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>江同学的 2022 年终总结，请查收~</title>
    <link href="http://RicardoJiang.github.io/blog/2022/12/2022-sum-up.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/12/2022-sum-up.html</id>
    <published>2022-12-06T00:46:33.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>转眼间 2022 年也要过去了，今年也是坚持写年终总结的第 3 年，这个好习惯还是要保持下去。</p><p>古人说，述往事，思来者，岁末年终，正是总结盘点过去一年的收获并立下新的一年的<code>Flag</code>的时候~</p><h2 id="2021-年立下的-Flag"><a href="#2021-年立下的-Flag" class="headerlink" title="2021 年立下的 Flag"></a>2021 年立下的 Flag</h2><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/december/p1.jpg" alt></p><p>去年的 Flag 就立在这里，下面我们来看下今年的完成情况</p><ul><li>[x] <del>持续输出，掘金升级到<code>LV5</code></del></li><li>[x] <del>坚持开源，<code>Github</code>的<code>Star</code>数突破1000</del></li><li>[x] <del>维护一个技术公众号，并突破500粉丝</del></li><li>[ ] 计算机基础巩固，继续学习操作系统，计算机网络，数据结构等知识</li><li>[ ] 继续深入学习<code>Compose</code>原理并输出，继续开源<code>Compose</code>项目</li><li>[x] <del>掌握一种跨平台技术，<code>Flutter</code>或者前端技术</del></li><li>[x] <del>继续坚持<code>ARTS</code>打卡，坚持每周总结与下周规划</del></li></ul><p>可以看出，大概完成了<code>70%</code>吧，我感觉对于一年的长期计划来说，完成度算还行吧<br>其中<code>Compose</code>因为项目中没有引入，所以今年没有做进一步的研究，至于计算机基础巩固也一直没有抽出时间来做，总是被其他事情打断</p><h2 id="2022-年的收获"><a href="#2022-年的收获" class="headerlink" title="2022 年的收获"></a>2022 年的收获</h2><h3 id="社区活动"><a href="#社区活动" class="headerlink" title="社区活动"></a>社区活动</h3><h4 id="北京-DevFest"><a href="#北京-DevFest" class="headerlink" title="北京 DevFest"></a>北京 DevFest</h4><p>由于疫情原因，北京 DevFest 是这几年第一次参加线下社区活动，面基了不少网友，也终于见识了很多关注已久的大佬的庐山真面目。</p><p>同时客串了一下 Compose Camp 代码工作坊的助教，顺便白嫖了谷歌周边大礼包</p><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/december/p2.jpg" alt></p><h4 id="北京-Kotlin-用户组"><a href="#北京-Kotlin-用户组" class="headerlink" title="北京 Kotlin 用户组"></a>北京 Kotlin 用户组</h4><p>今年也开始接手北京 Kotlin 用户组的组织工作，首先简单介绍一下<a href="https://beijing-kug.github.io/" target="_blank" rel="noopener">北京 Kotlin 用户组</a></p><ul><li>北京 Kotlin 用户组是一个交流 Kotlin 相关技术的平台，欢迎所有对 Kotlin 感兴趣的开发者加入用户组</li><li>在这里可以和其它成员一起讨论 Kotlin 语言的各项技术与最新特性</li><li>我们还会不定期举行分享会，进行与 Kotlin 相关的主题分享与讨论</li></ul><p>如果你想要加入的话，可以关注微信公众号“程序员江同学”，点击技术讨论，加入技术交流群</p><h3 id="开源与分享"><a href="#开源与分享" class="headerlink" title="开源与分享"></a>开源与分享</h3><p>今年主要进行了两场线上分享，分别在年初与年末</p><h4 id="社区说分享"><a href="#社区说分享" class="headerlink" title="社区说分享"></a>社区说分享</h4><p>上半年参与了谷歌社区说的分享活动，分享的主题是： Android 架构演进之 MVI 详解</p><p>主要包括以下内容</p><ul><li>MVI架构到底是什么?</li><li>MVI 架构的使用介绍与示例</li><li>MVI架构在Compose中的应用</li><li>MVI架构在KMP中的应用</li></ul><p>感兴趣的同学可以查看视频回放：<a href="https://www.bilibili.com/video/BV1x5411D7sA/" target="_blank" rel="noopener">「社区说」《Android 架构演进之 MVI 详解》</a></p><p>也可以查看示例项目：<a href="https://github.com/RicardoJiang/android-architecture" target="_blank" rel="noopener">https://github.com/RicardoJiang/android-architecture</a></p><h4 id="Kace-插件分享"><a href="#Kace-插件分享" class="headerlink" title="Kace 插件分享"></a>Kace 插件分享</h4><p>Kace 即 kotlin-android-compatible-extensions，一个用于帮助从 kotlin-android-extensions 无缝迁移的框架</p><p>kotlin-android-extensions 框架已经过时了很久，并且将在 Kotlin 1.8 中被正式移除</p><p>对于新代码，我们可以使用 ViewBinding 等方式替换，但是大量存量代码的迁移，对于开发者来说不是一个轻松的工作</p><p>为此，我们团队开发了 Kace 框架, 帮助开发者实现 kotlin-android-extensions 插件的无缝迁移</p><p>目前 Kace 已经开源，开源地址：<a href="https://github.com/kanyun-inc/Kace" target="_blank" rel="noopener">https://github.com/kanyun-inc/Kace</a></p><p>关于 Kace 的使用与原理解析，也可以查看视频回放：<a href="https://www.bilibili.com/video/BV1r841187RV/" target="_blank" rel="noopener">KAE将被正式移除，如何无缝迁移？</a></p><h3 id="写作与输出"><a href="#写作与输出" class="headerlink" title="写作与输出"></a>写作与输出</h3><p>我一直认为输出是一种最好的学习方式，通过写作的方式，将你学习的东西总结输出，可以帮助你更好的理解与掌握知识点，这种方式其实就是“费曼学习法”</p><p>今年同样是坚持写博客的一年，主要的输出平台是在掘金与微信公众号</p><p>今年在掘金共输出 35 篇博客，创作者等级也升到了 LV5，完成了去年立的 Flag</p><p>同时今年也有幸成为了掘金签约作者，本次签约要求以专栏的形式输出，因此这也促使我去思考如何输出一些成体系的内容，这也是我本次签约最大的收获</p><p>我输出的内容主要是 Android 编译期相关的一些技术，详情可见专栏：<a href="https://juejin.cn/column/7140249609728688135" target="_blank" rel="noopener">Android编译期那些事~</a></p><p>这个专栏的目标是专注于 Android 编译期相关技术，具体包括以下内容：  </p><ul><li>AGP ，KGP 等常用插件的原理解析</li><li>Gradle 进阶内容及常用插件分享</li><li>字节码插桩技术如 ASM 等分享 </li><li>Kotlin 编译期相关技术如 KCP ，KSP等分享</li><li>编译速度优化相关分享</li></ul><p>目前专栏内容也只是包括了其中一部分内容，希望明年能继续完善补充相关内容</p><p>今年也开始运营微信公众号：“程序员江同学”，今年在微信公众号共输出 32 篇文章，涨粉数量也达到了年初的目标，不过还是少的可怜，哈哈~</p><h2 id="2023-年的展望"><a href="#2023-年的展望" class="headerlink" title="2023 年的展望"></a>2023 年的展望</h2><p>接下来再立下 2023 年的 Flag 吧，看看明年能实现多少~</p><ul><li>持续输出，掘金升级到 LV6</li><li>继续维护公众号，并突破2000粉丝</li><li>坚持开源，Github 的 Star 数突破 2000</li><li>北京 Kotlin 用户组多组织几场活动</li><li>继续完善”Android编译期那些事”专栏</li><li>继续完善 android-workflow 项目</li><li>继续学习 JNI 和性能优化相关知识</li><li>最后，希望以上都能实现</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一路总结下来，看起来今年过得还挺充实的，2022 年即将过去了，我将会怀念它</p><p>最后，提前祝大家新年快乐吧，祝大家在新的一年里，身体健康，工作顺利~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;转眼间 2022 年也要过去了，今年也是坚持写年终总结的第 3 年，这个好习惯还是要保持下去。&lt;/p&gt;
&lt;p&gt;古人说，述往事，思来者，岁末年
      
    
    </summary>
    
    
      <category term="总结" scheme="http://RicardoJiang.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>学习一下 nowinandroid 的构建脚本</title>
    <link href="http://RicardoJiang.github.io/blog/2022/11/now-in-android-learn.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/11/now-in-android-learn.html</id>
    <published>2022-11-27T06:42:09.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/android/nowinandroid" target="_blank" rel="noopener">nowinandroid</a> 项目是谷歌开源的示例项目，它遵循 Android 设计和开发的最佳实践，并旨在成为开发人员的有用参考</p><p>这个项目在架构演进，模块化方案，单元测试，Jetpack Compose，启动优化等多个方面都做了很好的示例，的确是一个值得学习的好项目</p><p>今天我们来学习一下 nowinandroid 项目的构建脚本，看一下都有哪些值得学习的地方</p><h2 id="gradle-properties-中的配置"><a href="#gradle-properties-中的配置" class="headerlink" title="gradle.properties 中的配置"></a>gradle.properties 中的配置</h2><p>要看一个项目的构建脚本，我们首先看一下 gradle.properties</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Enable configuration caching between builds.</span></span><br><span class="line"><span class="attr">org.gradle.unsafe.configuration-cache</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">android.useAndroidX</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Non-transitive R classes is recommended and is faster/smaller</span></span><br><span class="line"><span class="attr">android.nonTransitiveRClass</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable build features that are enabled by default,</span></span><br><span class="line"><span class="comment"># https://developer.android.com/studio/releases/gradle-plugin#buildFeatures</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.buildconfig</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.aidl</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.renderscript</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.resvalues</span>=<span class="literal">false</span></span><br><span class="line"><span class="attr">android.defaults.buildfeatures.shaders</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以看出，nowinandroid 项目主要做了以下几个配置</p><ol><li>开启配置阶段缓存</li><li>开启 <code>androidX</code>，并且移除了 <code>Jetifier</code></li><li>关闭 <code>R</code> 文件传递</li><li>关闭 <code>build features</code></li></ol><p>前面3个配置之前都介绍过，我们来看一下关闭 <code>build features</code></p><p> AGP 4.0.0 引入了一种新方法来控制您要启用和停用哪些构建功能，如<code>ViewBinding</code>，<code>BuildConfig</code>。</p><p>我们可以在 gradle.properties 中全局开启或关闭某些功能，也可以在模块级 build.gradle 文件中为每个模块设置相应的选项，如下所示：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// The default value for each feature is shown below. You can change the value to</span></span><br><span class="line">    <span class="comment">// override the default behavior.</span></span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        <span class="comment">// Determines whether to generate a BuildConfig class.</span></span><br><span class="line">        buildConfig = <span class="keyword">true</span></span><br><span class="line">        <span class="comment">// Determines whether to support View Binding.</span></span><br><span class="line">        <span class="comment">// Note that the viewBinding.enabled property is now deprecated.</span></span><br><span class="line">        viewBinding = <span class="keyword">false</span></span><br><span class="line">        <span class="comment">// Determines whether to support Data Binding.</span></span><br><span class="line">        <span class="comment">// Note that the dataBinding.enabled property is now deprecated.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过停用不需要的构建可能，可以提升我们的构建性能，比如我们最熟悉的<code>BuildConfig</code>，每个模块都会生成这样一个类，但其实我们在绝大多数情况下是用不到的，因此其实可以将其默认关闭（在 AGP 8.0 中 BuildConfig 生成已经变成默认关闭了）</p><h2 id="自动安装-git-hook"><a href="#自动安装-git-hook" class="headerlink" title="自动安装 git hook"></a>自动安装 git hook</h2><p>有时我们会添加一些 git hook，用于在代码提交或者 push 时做一些检查</p><p>但使用 git hook 的一个问题在于，每次拉取新项目之后，都需要手动安装一下 git hook，这一点常常容易被忘记</p><p>那么有没有什么办法可以自动安装 git hook 呢？nowinandroid 项目提供了一个示例</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// settings.gradle.kts</span></span><br><span class="line"></span><br><span class="line">val prePushHook = <span class="keyword">file</span>(<span class="string">".git/hooks/pre-push"</span>)</span><br><span class="line">val commitMsgHook = <span class="keyword">file</span>(<span class="string">".git/hooks/commit-msg"</span>)</span><br><span class="line">val hooksInstalled = commitMsgHook.<span class="keyword">exists</span>()</span><br><span class="line">    &amp;&amp; prePushHook.<span class="keyword">exists</span>()</span><br><span class="line">    &amp;&amp; prePushHook.readBytes().contentEquals(<span class="keyword">file</span>(<span class="string">"tools/pre-push"</span>).readBytes())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!hooksInstalled) &#123;</span><br><span class="line">    <span class="keyword">exec</span> &#123;</span><br><span class="line">        <span class="keyword">commandLine</span>(<span class="string">"tools/setup.sh"</span>)</span><br><span class="line">        workingDir = rootProject.projectDir</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实原理很简单，在<code>settings.gradle.kts</code>中添加以上代码，这样在 Gradle 同步时，就会自动判断 git hook 有没有被安装，如果没有被安装则自动安装</p><h2 id="使用-includeBuild-而不是-buildSrc"><a href="#使用-includeBuild-而不是-buildSrc" class="headerlink" title="使用 includeBuild 而不是 buildSrc"></a>使用 includeBuild 而不是 buildSrc</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pluginManagement</span> &#123;</span><br><span class="line">    <span class="selector-tag">includeBuild</span>(<span class="string">"build-logic"</span>)</span><br><span class="line">    <span class="selector-tag">repositories</span> &#123;</span><br><span class="line">        <span class="selector-tag">google</span>()</span><br><span class="line">        <span class="selector-tag">mavenCentral</span>()</span><br><span class="line">        <span class="selector-tag">gradlePluginPortal</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了支持在不同的模块间共享构建逻辑，此前我们常常会添加一个 buildSrc 模块</p><p>但是 buildSrc 模块的问题在于每次发生修改都会导致项目的绝大多数缓存失效，从而导致构建速度变得极慢</p><p>因此官方现在更推荐我们使用 includeBuild，比如 nowinandroid 的构建逻辑就通过 includeBuild 放在了 <code>build-logic</code> 目录</p><h2 id="如何复用-build-gradle-代码"><a href="#如何复用-build-gradle-代码" class="headerlink" title="如何复用 build.gradle 代码"></a>如何复用 build.gradle 代码</h2><p>其实我们项目中的各个模块的 build.gradle 中的代码，大部分是重复的，做的都是一些重复的配置，当要修改时就需要一个一个去修改了</p><p>nowinandroid 通过抽取重复配置的方式大幅度的减少了 build.gradle 中的代码，如下所示</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">   <span class="built_in"> id</span>(<span class="string">"nowinandroid.android.feature"</span>)</span><br><span class="line">   <span class="built_in"> id</span>(<span class="string">"nowinandroid.android.library.compose"</span>)</span><br><span class="line">   <span class="built_in"> id</span>(<span class="string">"nowinandroid.android.library.jacoco"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    <span class="type">namespace</span> = <span class="string">"com.google.samples.apps.nowinandroid.feature.author"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation(libs.kotlinx.datetime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 nowinandroid 的一个 feature 模块，可以看出除了每个模块不同的<code>namespace</code>与各个模块的依赖之外，其他的内容都抽取到<code>nowinandroid.android.feature</code>等插件中去了，而这些插件的代码都存放在<code>build-logic</code> 目录中，通过 includeBuild 引入，大家可自行查看</p><p>总得来说，通过这种方式可以大幅减少重复配置代码，当配置需要迁移时也更加方便</p><h2 id="使用-Version-Catalog"><a href="#使用-Version-Catalog" class="headerlink" title="使用 Version Catalog"></a>使用 Version Catalog</h2><p>在 build.gradle 中添加依赖有以下几个痛点</p><ol><li>项目依赖统一管理，在单独文件中配置</li><li>不同Module中的依赖版本号统一</li><li>添加依赖时支持代码提示</li></ol><p>针对这几种需求，Gradle7.0 推出了一个新的特性，使用 Version Catalog 统一依赖版本，它支持以下特性：</p><ul><li>对所有 module 可见，可统一管理所有module的依赖</li><li>支持声明依赖bundles,即总是一起使用的依赖可以组合在一起</li><li>支持版本号与依赖名分离，可以在多个依赖间共享版本号</li><li>支持在单独的libs.versions.toml文件中配置依赖</li><li>支持代码提示(仅 kts)</li></ul><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p9.jpg" alt></p><p>noinandroid 中目前已经全面启用了 Version Catalog，如上所示，统一依赖版本，支持代码提示，体验还是不错的</p><p>关于 Version Catalog 的具体使用可以查看：<a href="https://juejin.cn/post/6997396071055900680" target="_blank" rel="noopener">【Gradle7.0】依赖统一管理的全新方式，了解一下~</a></p><h2 id="代码格式检查"><a href="#代码格式检查" class="headerlink" title="代码格式检查"></a>代码格式检查</h2><p>nowinandroid 作为一个开源项目，不可避免地会有第三方贡献一些代码，因此也需要在代码合并前做一些格式检查，保证代码风格的统一</p><p>nowinandroid 通过 spotless 来检查代码格式，主要是通过两种方式触发    </p><ol><li>通过上面提到的 git hook，在代码 push 时触发检查</li><li>通过 github workflow，在代码 push 到 main 分支时触发检查</li></ol><p>上面两种方式都会调用以下命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./gradlew</span> spotlessCheck <span class="params">--init-script</span> gradle/init.gradle.kts <span class="params">--no-configuration-cache</span> <span class="params">--stacktrace</span></span><br></pre></td></tr></table></figure><p>可以看出，这里主要是执行 spotlessCheck 任务，并且指定了 init-script，我们来看一下 init.gradle.kts 里面做了什么</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init.gradle.kts</span></span><br><span class="line">rootProject &#123;</span><br><span class="line">    subprojects &#123;</span><br><span class="line">        apply&lt;com<span class="selector-class">.diffplug</span><span class="selector-class">.gradle</span><span class="selector-class">.spotless</span>.SpotlessPlugin&gt;()</span><br><span class="line">        extensions.configure&lt;com<span class="selector-class">.diffplug</span><span class="selector-class">.gradle</span><span class="selector-class">.spotless</span>.SpotlessExtension&gt; &#123;</span><br><span class="line">            kotlin &#123;</span><br><span class="line">                target(<span class="string">"**/*.kt"</span>)</span><br><span class="line">                targetExclude(<span class="string">"**/build/**/*.kt"</span>)</span><br><span class="line">                ktlint(ktlintVersion).userData(mapOf(<span class="string">"android"</span> to <span class="string">"true"</span>))</span><br><span class="line">                licenseHeaderFile(rootProject.file(<span class="string">"spotless/copyright.kt"</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            format(<span class="string">"kts"</span>) &#123;</span><br><span class="line">                target(<span class="string">"**/*.kts"</span>)</span><br><span class="line">                targetExclude(<span class="string">"**/build/**/*.kts"</span>)</span><br><span class="line">                <span class="comment">// Look for the first line that doesn't have a block comment (assumed to be the license)</span></span><br><span class="line">                licenseHeaderFile(rootProject.file(<span class="string">"spotless/copyright.kts"</span>), <span class="string">"(^(?![\\/ ]\\*).*$)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            format(<span class="string">"xml"</span>) &#123;</span><br><span class="line">                target(<span class="string">"**/*.xml"</span>)</span><br><span class="line">                targetExclude(<span class="string">"**/build/**/*.xml"</span>)</span><br><span class="line">                <span class="comment">// Look for the first XML tag that isn't a comment (&lt;!--) or the xml declaration (&lt;?xml)</span></span><br><span class="line">                licenseHeaderFile(rootProject.file(<span class="string">"spotless/copyright.xml"</span>), <span class="string">"(&lt;[^!?])"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，这里指定了对于 kotlin , kts , xml 等文件的格式要求，比如 kotlin 代码需要遵守 ktlint 规范，并且文件开头必须是 license 声明</p><h2 id="自定义-lint-检查"><a href="#自定义-lint-检查" class="headerlink" title="自定义 lint 检查"></a>自定义 lint 检查</h2><p>除了代码风格的统一，nowinandroid 项目还自定义了一些 lint 检查，跟 spoltess 一样，也是通过 git hook 与 github workflow 两种方式触发，两种方式都会触发以下代码</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./gradlew</span> lintDemoDebug <span class="params">--stacktrace</span></span><br></pre></td></tr></table></figure><p>nowinandroid 中有一个自定义的 lint 模块，自定义 lint 规则就定义在这里，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesignSystemDetector</span> : <span class="type">Detector</span></span>(), Detector.UastScanner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createUastHandler</span><span class="params">(context: <span class="type">JavaContext</span>)</span></span>: UElementHandler &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">object</span> : UElementHandler() &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitCallExpression</span><span class="params">(node: <span class="type">UCallExpression</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> name = node.methodName ?: <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">val</span> preferredName = METHOD_NAMES[name] ?: <span class="keyword">return</span></span><br><span class="line">                reportIssue(context, node, name, preferredName)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitQualifiedReferenceExpression</span><span class="params">(node: <span class="type">UQualifiedReferenceExpression</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">val</span> name = node.receiver.asRenderString()</span><br><span class="line">                <span class="keyword">val</span> preferredName = RECEIVER_NAMES[name] ?: <span class="keyword">return</span></span><br><span class="line">                reportIssue(context, node, name, preferredName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@JvmField</span></span><br><span class="line">        <span class="keyword">val</span> ISSUE: Issue = Issue.create(</span><br><span class="line">            id = <span class="string">"DesignSystem"</span>,</span><br><span class="line">            briefDescription = <span class="string">"Design system"</span>,</span><br><span class="line">            explanation = <span class="string">"This check highlights calls in code that use Compose Material "</span> +</span><br><span class="line">                <span class="string">"composables instead of equivalents from the Now in Android design system "</span> +</span><br><span class="line">                <span class="string">"module."</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unfortunately :lint is a Java module and thus can't depend on the :core-designsystem</span></span><br><span class="line">        <span class="comment">// Android module, so we can't use composable function references (eg. ::Button.name)</span></span><br><span class="line">        <span class="comment">// instead of hardcoded names.</span></span><br><span class="line">        <span class="keyword">val</span> METHOD_NAMES = mapOf(</span><br><span class="line">            <span class="string">"MaterialTheme"</span> to <span class="string">"NiaTheme"</span>,</span><br><span class="line">            <span class="string">"Button"</span> to <span class="string">"NiaFilledButton"</span>,</span><br><span class="line">            <span class="string">"OutlinedButton"</span> to <span class="string">"NiaOutlinedButton"</span>,</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> RECEIVER_NAMES = mapOf(</span><br><span class="line">            <span class="string">"Icons"</span> to <span class="string">"NiaIcons"</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">reportIssue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            context: <span class="type">JavaContext</span>, node: <span class="type">UElement</span>, name: <span class="type">String</span>, preferredName: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">        )</span></span> &#123;</span><br><span class="line">            context.report(</span><br><span class="line">                ISSUE, node, context.getLocation(node),</span><br><span class="line">                <span class="string">"Using <span class="variable">$name</span> instead of <span class="variable">$preferredName</span>"</span></span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总得来说，这个自定义规则是检查是否使用了 Compose 的默认 Material 组件而没有使用 nowinandroid 封装好的组件，如果检查不通过则会抛出异常，提醒开发者修改</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 nowinandroid 项目构建脚本中的一系列小技巧，具体包括以下内容</p><ol><li>gradle.properties 中的配置</li><li>自动安装 git hook</li><li>使用 includeBuild 而不是 buildSrc</li><li>如何复用 build.gradle 代码</li><li>使用 Version Catalog</li><li>代码格式检查</li><li>自定义 lint 检查</li></ol><p>希望对你有所帮助~</p><h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/android/nowinandroid" target="_blank" rel="noopener">https://github.com/android/nowinandroid</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/android/nowinandroid&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="android" scheme="http://RicardoJiang.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>KAE 将被正式移除，如何无缝迁移？</title>
    <link href="http://RicardoJiang.github.io/blog/2022/10/android-compile-speed.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/10/android-compile-speed.html</id>
    <published>2022-10-07T08:09:25.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>KAE 插件早在 2020 年就已经被宣布废弃了，并且将在 Kotlin 1.8 中被正式移除：<a href="https://android-developers.googleblog.com/2022/02/discontinuing-kotlin-synthetics-for-views.html" target="_blank" rel="noopener">Discontinuing Kotlin synthetics for views</a></p><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p1.png" alt></p><p>如上图示，移除 KAE 的代码已经被 Merge 了，因此如果我们需要升级到 Kotlin 1.8，则必须要移除 KAE</p><p>那么移除 KAE 后，我们该如何迁移呢？</p><h2 id="迁移方案"><a href="#迁移方案" class="headerlink" title="迁移方案"></a>迁移方案</h2><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p2.png" alt></p><p>官方的迁移方案如上所示，官方建议我们老项目迁移到 ViewBinding，老项目直接迁移到 Jetpack Compose</p><p>对于新代码我们当然可以这么做，但是对于大量存量代码，我们该如何迁移？由于 KAE 简单易用的特性，它在项目中经常被大量使用，要迁移如此多的存量代码，并不是一个简单的工作</p><h3 id="存量代码迁移方案"><a href="#存量代码迁移方案" class="headerlink" title="存量代码迁移方案"></a>存量代码迁移方案</h3><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p3.png" alt></p><p>KAE 存量代码主要有如图3种迁移方式</p><p>最简单也最直接的当然就是直接手动修改，这种方式的问题在于要迁移的代码数量庞大，迁移成本高。同时手动迁移容易出错，也不容易回测，测试不能覆盖到所有的页面，导致引入线上 bug</p><p>第二个方案，是把 KAE 直接从 Kotlin 源码中抽取出来单独维护，但是 KAE 中也大量依赖了 Kotlin 的源码，抽取成本较高。同时 KAE 中大量使用了 Kotlin 编译器插件的 API，而这部分 API 并没有稳定，当 K2 编译器正式发布的时候很可能还会有较大的改动，而这也带来较高的维护成本。</p><p>第三个方案就是本篇要重点介绍的 Kace</p><h2 id="Kace-是什么？"><a href="#Kace-是什么？" class="headerlink" title="Kace 是什么？"></a>Kace 是什么？</h2><p>Kace 即 kotlin-android-compatible-extensions，一个用于帮助从 kotlin-android-extensions 无缝迁移的框架</p><p>目前已经开源，开源地址可见：<a href="https://github.com/kanyun-inc/Kace" target="_blank" rel="noopener">https://github.com/kanyun-inc/Kace</a></p><p>相比其它方案，Kace 主要有以下优点</p><ol><li>接入方便，不需要手动修改旧代码，可以真正做到无缝迁移</li><li>与 KAE 表现一致(都支持 viewId 缓存，并在页面销毁时清除)，不会引入预期外的 bug</li><li>统一迁移，回测方便，如果存在问题时，应该是批量存在的，避免手动修改可能引入线上 bug 的问题</li><li>通过生成源码的方式兼容 KAE，维护成本低</li></ol><h2 id="快速迁移"><a href="#快速迁移" class="headerlink" title="快速迁移"></a>快速迁移</h2><p>使用 Kace 完成迁移主要分为以下几步</p><h3 id="1-添加插件到-classpath"><a href="#1-添加插件到-classpath" class="headerlink" title="1. 添加插件到 classpath"></a>1. 添加插件到 classpath</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式 1</span></span><br><span class="line"><span class="comment">// 传统方式，在根目录的 build.gradle.kts 中添加以下代码</span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(<span class="string">"com.kanyun.kace:kace-gradle-plugin:1.0.0"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式 2</span></span><br><span class="line"><span class="comment">// 引用插件新方式，在 settings.gradle.kts 中添加以下代码</span></span><br><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    plugins &#123;</span><br><span class="line">        id(<span class="string">"com.kanyun.kace"</span>) version <span class="string">"1.0.0"</span> apply <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-应用插件"><a href="#2-应用插件" class="headerlink" title="2. 应用插件"></a>2. 应用插件</h3><p>移除<code>kotlin-android-extensions</code>插件，并添加以下代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id(<span class="string">"com.kanyun.kace"</span>)</span><br><span class="line">    id(<span class="string">"kotlin-parcelize"</span>) <span class="comment">// 可选，当使用了`@Parcelize`注解时需要添加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-配置插件（可选）"><a href="#3-配置插件（可选）" class="headerlink" title="3. 配置插件（可选）"></a>3. 配置插件（可选）</h3><p>默认情况下 Kace 会解析模块内的每个 layout 并生成代码，用户也可以自定义需要解析的 layout</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kace &#123;</span><br><span class="line">    whiteList = listOf() <span class="comment">// 当 whiteList 不为空时，只有 whiteList 中的 layout 才会被解析</span></span><br><span class="line">    blackList = listOf(<span class="string">"activity_main.xml"</span>) <span class="comment">// 当 blackList 不为空时，blackList 中的 layout 不会被解析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上几步，迁移就完全啦~</p><h2 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h2><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p4.png" alt></p><p>如上所示，Kace 目前支持了以上四种最常用的类型，其他 kotlin-android-extensions 支持的类型如 android.app.Fragment, android.app.Dialog, kotlinx.android.extensions.LayoutContainer 等，由于被废弃或者使用较少，Kace 目前没有做支持</p><h2 id="版本兼容"><a href="#版本兼容" class="headerlink" title="版本兼容"></a>版本兼容</h2><table><thead><tr><th></th><th>Kotlin</th><th>AGP</th><th>Gradle</th></tr></thead><tbody><tr><td>最低支持版本</td><td>1.7.0</td><td>4.2.0</td><td>6.7.1</td></tr></tbody></table><p>由于 Kace 的目标是帮助开发者更方便地迁移到 Kotlin 1.8，因此 Kotlin 最低支持版本比较高</p><h2 id="原理解析：前置知识"><a href="#原理解析：前置知识" class="headerlink" title="原理解析：前置知识"></a>原理解析：前置知识</h2><h3 id="编译器插件是什么？"><a href="#编译器插件是什么？" class="headerlink" title="编译器插件是什么？"></a>编译器插件是什么？</h3><p>Kotlin 的编译过程，简单来说就是将 Kotlin 源代码编译成目标产物的过程，具体步骤如下图所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/909ba8e80597430996e4e2f2817b83a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt></p><p>Kotlin 编译器插件，通过利用编译过程中提供的各种Hook时机，让我们可以在编译过程中插入自己的逻辑，以达到修改编译产物的目的。比如我们可以通过 IrGenerationExtension 来修改 IR 的生成，可以通过 ClassBuilderInterceptorExtension 修改字节码生成逻辑</p><p>Kotlin 编译器插件可以分为 Gradle 插件，编译器插件，IDE 插件三部分，如下图所示</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f3334def17d484aab8c009cb4608935~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt></p><h3 id="kotlin-android-extensions-是怎么实现的"><a href="#kotlin-android-extensions-是怎么实现的" class="headerlink" title="kotlin-android-extensions 是怎么实现的"></a>kotlin-android-extensions 是怎么实现的</h3><p>我们知道，KAE 是一个 Kotlin 编译器插件，当然也可以分为 Gradle 插件，编译器插件，IDE 插件三部分。我们这里只分析 Gradle 插件与编译器插件的源码，它们的具体结构如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/987583643eb443e79b80c9d2e5680e2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><ol><li><code>AndroidExtensionsSubpluginIndicator</code>是<code>KAE</code>插件的入口</li><li><code>AndroidSubplugin</code>用于配置传递给编译器插件的参数</li><li><code>AndroidCommandLineProcessor</code>用于接收编译器插件的参数</li><li><code>AndroidComponentRegistrar</code>用于注册如图的各种<code>Extension</code></li></ol><p>关于更细节的分析可以参阅：<a href="https://juejin.cn/post/7155491115645435917" target="_blank" rel="noopener">kotlin-android-extensions 插件到底是怎么实现的？</a></p><p>总的来说，其实 KAE 主要做了两件事</p><ol><li>KAE 会将 viewId 转化为 findViewByIdCached 方法调用</li><li>KAE 会在页面关闭时清除 viewId cache</li></ol><p>那么我们要无缝迁移，就也要实现相同的效果</p><h2 id="Kace-原理解析"><a href="#Kace-原理解析" class="headerlink" title="Kace 原理解析"></a>Kace 原理解析</h2><h3 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h3><p>我们首先想到的是解析 layout 自动生成扩展属性，如下图所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的代码</span></span><br><span class="line"><span class="keyword">val</span> AndroidExtensions.button1</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached&lt;Button&gt;(R.id.button1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> AndroidExtensions.buttion2</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached(R.id.button1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 Activity 添加 AndroidExtensions 接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), AndroidExtensions &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> androidExtensionImpl <span class="keyword">by</span> lazy &#123; AndroidExtensionsImpl() &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        lifecycle.addObserver(androidExtensionImpl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View?&gt;</span> <span class="title">findViewByIdCached</span><span class="params">(owner: <span class="type">AndroidExtensionsBase</span>, id: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> androidExtensionImpl.findViewByIdCached(id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，主要做了这么几件事：</p><ol><li>通过 gradle 插件，自动解析 layout 生成<code>AndroidExtensions</code>接口的扩展属性</li><li>给 Activity 添加 <code>AndroidExtensions</code> 接口</li><li>由于需要支持缓存，因此也需要添加一个全局的变量：<code>androidExtensionImpl</code></li><li>由于需要在页面关闭时清除缓存，因此也需要添加<code>lifecycle Observer</code></li><li>重写<code>findViewByIdCached</code>方法，将具体工作委托给<code>AndroidExtensionsImpl</code></li></ol><p>通过以上步骤，其实 KAE 的功能已经实现了，我们可以在 Activity 中通过<code>button1</code>，<code>button2</code>等 viewId 获取对应的 View</p><p>但是这样还是太麻烦了，修改一个页面需要添加这么多代码，还能再优化吗？</p><h3 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="keyword">val</span> AndroidExtensions.button1</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached&lt;Button&gt;(<span class="keyword">this</span>, R.id.button1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> AndroidExtensions.buttion2</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached(<span class="keyword">this</span>, R.id.button1)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), AndroidExtensions <span class="keyword">by</span> AndroidExtensionsImpl() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>我们通过委托简化了代码调用，只需要添加一行<code>AndroidExtensions by AndroidExtensionsImpl()</code>就可以实现迁移</li><li>我们不需要在初始化的时候手动添加<code>lifecycle observer</code>，这是因为我们在调用<code>findViewByIdCached</code>方法时会将<code>this</code>传递过去，因此可以在第一次调用时初始化，自动添加<code>lifecycle observer</code></li></ol><p>可以看出，现在已经比较简洁了，只需要添加一行代码就可以实现迁移，但如果项目中有几百个页面使用了 KAE 的话，改起来还是有点痛苦的，目前还不能算是真正的无缝迁移</p><p>那么还能再优化吗?</p><h3 id="第三次尝试"><a href="#第三次尝试" class="headerlink" title="第三次尝试"></a>第三次尝试</h3><p>第3次尝试就是 Kace 的最终方案，结构如图所示  </p><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p5.png" alt></p><p>下面我们就来介绍一下</p><h3 id="kace-compiler-实现"><a href="#kace-compiler-实现" class="headerlink" title="kace-compiler 实现"></a>kace-compiler 实现</h3><p>kace-compiler 是一个 Kotlin 编译器插件，它的作用是给目标类型（Activity 或者 Fragment）自动添加接口与实现</p><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/november/p6.png" alt></p><p>如上所示，kace-compiler 的作用就是通过<code>KaceSyntheticResolveExtension</code>扩展添加接口，以及<code>KaceIrGenerationExtension</code>扩展添加实现</p><p>处理后的代码如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>(), AndroidExtensions &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> $$androidExtensionImpl <span class="keyword">by</span> lazy &#123; AndroidExtensionsImpl() &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : View?&gt;</span> <span class="title">findViewByIdCached</span><span class="params">(owner: <span class="type">AndroidExtensionsBase</span>, id: <span class="type">Int</span>)</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">return</span> $$androidExtensionImpl.findViewByIdCached(id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能还记得，前面说过由于编译器插件 API 还没有稳定，因此将 KAE 抽取出来独立维护成本较高，那么我们这里为什么还使用了编译器插件呢？</p><p>这是因为我们这里使用的编译器插件是比较少的，生成的代码也很简单，将来维护起来并不复杂，但是可以大幅的降低迁移成本，实现真正的无缝迁移</p><h3 id="kace-gradle-plugin-生成代码"><a href="#kace-gradle-plugin-生成代码" class="headerlink" title="kace-gradle-plugin 生成代码"></a>kace-gradle-plugin 生成代码</h3><p>kace-gradle-plugin 的主要作用就是解析 layout 然后生成代码，生成的代码如下所示</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlinx.android.synthetic.debug.activity_main</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">inline</span> <span class="keyword">val</span> AndroidExtensionsBase.button1</span><br><span class="line">    <span class="keyword">get</span>() = findViewByIdCached&lt;android.widget.Button&gt;(<span class="keyword">this</span>, R.id.button1)</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="keyword">val</span> Activity.button1</span><br><span class="line">    <span class="keyword">get</span>() = (<span class="keyword">this</span> <span class="keyword">as</span> AndroidExtensionsBase).button1</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="keyword">val</span> Fragment.button1</span><br><span class="line">    <span class="keyword">get</span>() = (<span class="keyword">this</span> <span class="keyword">as</span> AndroidExtensionsBase).button1</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> kotlinx.android.synthetic.main.activity_main.view</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">inline</span> <span class="keyword">val</span> View.button1</span><br><span class="line">    <span class="keyword">get</span>() = findViewById&lt;android.widget.Button&gt;(R.id.button1)</span><br></pre></td></tr></table></figure><ol><li>给 Activity, Fragment, View 等类型添加扩展属性</li><li>给 View 添加的扩展属性目前不支持缓存，而是直接通过<code>finidViewById</code>实现</li><li>支持根据不同的<code>variant</code>，生成不同的<code>package</code>的代码，比如<code>debug</code></li></ol><h2 id="Kace-性能优化"><a href="#Kace-性能优化" class="headerlink" title="Kace 性能优化"></a>Kace 性能优化</h2><h3 id="明确输入输出"><a href="#明确输入输出" class="headerlink" title="明确输入输出"></a>明确输入输出</h3><p>前面介绍了 kace-gradle-plugin 的主要作用就是解析 layout 然后生成代码，但是对于一个比较大的模块，layout 可能有几百个，如果每次编译时都要运行这个 Task，会带来一定的性能损耗</p><p>理想情况下，在输入输出没有发生变化的情况下，应该跳过这个 Task</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/873a47d931704ee1bdfce191d260b9a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><p>比如 Gradle 中内置的 JavaCompilerTask，在源码与 jdk 版本没有发生变化的时候，会自动跳过（标记为 up-to-date）</p><p>Gradle 需要我们明确 Task 的输入与输出是什么，这样它才能决定是否可以自动跳过这个Task，如下所示： </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KaceGenerateTask</span> : <span class="type">DefaultTask</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Internal</span></span><br><span class="line">    <span class="keyword">val</span> layoutDirs: ConfigurableFileCollection = project.files()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Incremental</span></span><br><span class="line">    <span class="meta">@get:InputFiles</span></span><br><span class="line">    <span class="meta">@get:PathSensitive</span>(PathSensitivity.RELATIVE)</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">val</span> androidLayoutResources: FileCollection = layoutDirs</span><br><span class="line">        .asFileTree</span><br><span class="line">        .matching &#123; patternFilterable -&gt;</span><br><span class="line">            patternFilterable.include(<span class="string">"**/*.xml"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Input</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> layoutVariantMap: MapProperty&lt;String, String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:Input</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> namespace: Property&lt;String&gt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@get:OutputDirectory</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> sourceOutputDir: DirectoryProperty    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，通过注解的方式明确了 Task 的输入输出，在输入与输出都没有发生改变的时候，该 Task 会被标记为 up-to-date ，通过编译避免的方式提高编译性能</p><h3 id="并行-Task"><a href="#并行-Task" class="headerlink" title="并行 Task"></a>并行 Task</h3><p><code>KaceGenerateTask</code>的主要作用其实就是解析 layout 然后生成代码，每个 layout 都是相互独立的，在这种情况下就特别适合使用并行 Task</p><p>要实现并行 Task，首先要将 Task 转化为 <code>Worker API</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KaceGenerateAction</span> : <span class="type">WorkAction</span>&lt;<span class="type">KaceGenerateAction.Parameters</span>&gt; </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Parameters</span> : <span class="type">WorkParameters &#123;</span></span></span><br><span class="line">        <span class="keyword">val</span> destDir: DirectoryProperty</span><br><span class="line">        <span class="keyword">val</span> layoutFile: RegularFileProperty</span><br><span class="line">        <span class="keyword">val</span> variantName: Property&lt;String&gt;</span><br><span class="line">        <span class="keyword">val</span> namespace: Property&lt;String&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">execute</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> item = LayoutItem(</span><br><span class="line">            parameters.destDir.<span class="keyword">get</span>().asFile,</span><br><span class="line">            parameters.layoutFile.<span class="keyword">get</span>().asFile,</span><br><span class="line">            parameters.variantName.<span class="keyword">get</span>()</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> namespace = parameters.namespace.<span class="keyword">get</span>()</span><br><span class="line">        <span class="keyword">val</span> file = item.layoutFile</span><br><span class="line">        <span class="keyword">val</span> layoutNodeItems = parseXml(saxParser, file, logger)</span><br><span class="line">        writeActivityFragmentExtension(layoutNodeItems, item, namespace)</span><br><span class="line">        writeViewExtension(layoutNodeItems, item, namespace)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一步：首先我们需要定义一个接口来表示每个<code>Action</code>需要的参数，即<code>KaceGenerateAction.Parameters</code></li><li>第二步：您需要将自定义<code>Task</code>中为每个单独文件执行工作的部分重构为单独的类，即<code>KaceGenerateAction</code></li><li>第三步：您应该重构自定义<code>Task</code>类以将工作提交给 <code>WorkerExecutor</code>，而不是自己完成工作</li></ol><p>接下来就是将<code>KaceGenerateAction</code>提交给<code>WorkerExector</code></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KaceGenerateTask</span> : <span class="type">DefaultTask</span></span>() &#123;</span><br><span class="line">    <span class="meta">@get:Inject</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> workerExecutor: WorkerExecutor</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">action</span><span class="params">(inputChanges: <span class="type">InputChanges</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> workQueue = workerExecutor.noIsolation()</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        changedLayoutItemList.forEach &#123; item -&gt;</span><br><span class="line">            workQueue.submit(KaceGenerateAction::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123; parameters -&gt;</span><br><span class="line">                parameters.destDir.<span class="keyword">set</span>(destDir)</span><br><span class="line">                parameters.layoutFile.<span class="keyword">set</span>(item.layoutFile)</span><br><span class="line">                parameters.variantName.<span class="keyword">set</span>(item.variantName)</span><br><span class="line">                parameters.namespace.<span class="keyword">set</span>(namespace)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        workQueue.await() <span class="comment">// 等待所有 Action 完成，计算耗时</span></span><br><span class="line">        <span class="keyword">val</span> duration = System.currentTimeMillis() - startTime</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 您需要拥有`WorkerExecutor`服务才能提交`Action`。这里我们添加了一个抽象的`workerExecutor`并添加注解，`Gradle` 将在运行时注入服务</span><br><span class="line"><span class="number">2</span>. 在提交`Action`之前，我们需要通过不同的隔离模式获取`WorkQueue`，这里使用的是线程隔离模式</span><br><span class="line"><span class="number">3</span>. 提交`Action`时，指定`Action`实现，在这种情况下调用`KaceGenerateAction`并配置其参数</span><br><span class="line"></span><br><span class="line">经过测试，在一个包括 <span class="number">500</span> 个 layout 的模块中，在开启并行 Task 前全量编译耗时约 <span class="number">4</span> 秒，而开启后全量编译耗时减少到 <span class="number">2</span> 秒左右，可以有 <span class="number">100</span>% 左右的提升</span><br><span class="line"></span><br><span class="line">### 支持增量编译</span><br><span class="line">还有一种常见的场景，当我们只修改了一个 layout 时，如果模块内的所有 layout 都需要重新解析并生成代码，也是非常浪费性能的</span><br><span class="line"></span><br><span class="line">理想情况下，应该只需要重新解析与处理我们修改的 layout 就行了，Gradle 同样提供了 API 供我们实现增量编译</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KaceGenerateTask</span> : <span class="type">DefaultTask</span></span>() &#123;</span><br><span class="line">    <span class="meta">@get:Incremental</span></span><br><span class="line">    <span class="meta">@get:InputFiles</span></span><br><span class="line">    <span class="meta">@get:PathSensitive</span>(PathSensitivity.RELATIVE)</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">open</span> <span class="keyword">val</span> androidLayoutResources: FileCollection = layoutDirs</span><br><span class="line">        .asFileTree</span><br><span class="line">        .matching &#123; patternFilterable -&gt;</span><br><span class="line">            patternFilterable.include(<span class="string">"**/*.xml"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TaskAction</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">action</span><span class="params">(inputChanges: <span class="type">InputChanges</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> changeFiles = getChangedFiles(inputChanges, androidLayoutResources)</span><br><span class="line">        <span class="comment">// ...        </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getChangedFiles</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inputChanges: <span class="type">InputChanges</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        layoutResources: <span class="type">FileCollection</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> = <span class="keyword">if</span> (!inputChanges.isIncremental) &#123;</span><br><span class="line">        ChangedFiles.Unknown()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        inputChanges.getFileChanges(layoutResources)</span><br><span class="line">            .fold(mutableListOf&lt;File&gt;() to mutableListOf&lt;File&gt;()) &#123; (modified, removed), item -&gt;</span><br><span class="line">                <span class="keyword">when</span> (item.changeType) &#123;</span><br><span class="line">                    ChangeType.ADDED, ChangeType.MODIFIED -&gt; modified.add(item.file)</span><br><span class="line">                    ChangeType.REMOVED -&gt; removed.add(item.file)</span><br><span class="line">                    <span class="keyword">else</span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">                &#125;</span><br><span class="line">                modified to removed</span><br><span class="line">            &#125;.run &#123;</span><br><span class="line">                ChangedFiles.Known(first, second)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下步骤，就可以实现增量编译</p><ol><li><code>androidLayoutResources</code>使用<code>@Incremental</code>注解标识，表示支持增量处理的输入</li><li>给<code>TaskAction</code>方法添加<code>inputChange</code>参数</li><li>通过<code>inputChanges</code>方法获取输入中发生了更改的文件，如果发生了更改则重新处理，如果被删除了则同样删除目标目录中的文件，没有发生更改的文件则不处理</li></ol><p>通过支持增量编译，当只修改或者添加一个 layout 时，增量编译耗时可以减少到 8ms 左右，大幅减少了编译耗时</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何使用 Kace ，以及 Kace 到底是如何实现的，如果有任何问题，欢迎提出 Issue，如果对你有所帮助，欢迎点赞收藏 Star ~</p><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><p><a href="https://github.com/kanyun-inc/Kace" target="_blank" rel="noopener">https://github.com/kanyun-inc/Kace</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;KAE 插件早在 2020 年就已经被宣布废弃了，并且将在 Kotlin 1.8 中被正式移除：&lt;a href=&quot;https://andro
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://RicardoJiang.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 增量编译是怎么实现的？</title>
    <link href="http://RicardoJiang.github.io/blog/2022/08/kotlin-compile-analysis.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/08/kotlin-compile-analysis.html</id>
    <published>2022-08-28T02:57:15.000Z</published>
    <updated>2023-10-02T05:09:49.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编译运行是一个<code>Android</code>开发者每天都要做的工作，增量编译对于开发者也极其重要，高命中率的增量编译可以极大的提高开发者的开发效率与体验</p><p>之前写了一些文章介绍<code>Kotlin</code>增量编译的原理，以及<code>Kotlin 1.7</code>支持了跨模块增量编译        </p><p>了解了这些基本原理之后，我们今天一起来看下<code>Kotlin</code>增量编译的源码，看看<code>Kotlin</code>增量编译到底是怎么实现的</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><a href="https://juejin.cn/post/7118908219841314823" target="_blank" rel="noopener">Kotlin 快速编译背后的黑科技，了解一下~</a><br><a href="https://juejin.cn/post/7126698891692474375" target="_blank" rel="noopener">Kotlin 1.7 新特性：支持跨模块增量编译</a><br><a href="https://juejin.cn/post/7131889789787176974" target="_blank" rel="noopener">Transform 被废弃，TransformAction 了解一下~</a>   </p><p>主要是<code>Kotlin</code>增量编译的原理介绍，以及因为在源码中使用了<code>TransformAction</code>，也需要了解一下<code>TransformAction</code>的基本使用</p><h2 id="增量编译流程"><a href="#增量编译流程" class="headerlink" title="增量编译流程"></a>增量编译流程</h2><h3 id="第一步：编译入口"><a href="#第一步：编译入口" class="headerlink" title="第一步：编译入口"></a>第一步：编译入口</h3><p>如果我们要在项目中使用<code>Kotlin</code>，都必须要添加<code>org.jetbrains.kotlin.android</code>插件，这个插件是我们编译<code>Kotlin</code>的入口，它的代码在<code>kotlin-gradle-plugin</code>插件中</p><p>这个插件的实现类就是<code>KotlinAndroidPluginWrapper</code>，可以看出<code>KotlinAndroidPluginWrapper</code>就是个包装，里面主要就是创建并配置<code>KotlinAndroidPlugin</code></p><h3 id="第二步：配置KotlinAndroidPlugin"><a href="#第二步：配置KotlinAndroidPlugin" class="headerlink" title="第二步：配置KotlinAndroidPlugin"></a>第二步：配置<code>KotlinAndroidPlugin</code></h3><p><code>KotlinAndroidPlugin</code>是插件真正的入口，在这里完成<code>compileKotlin Task</code>相关的配置工作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinAndroidPlugin</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> registry: ToolingModelBuilderRegistry</span><br><span class="line">) : Plugin&lt;Project&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        checkGradleCompatibility()</span><br><span class="line"></span><br><span class="line">        project.dynamicallyApplyWhenAndroidPluginIsApplied() </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">preprocessVariant</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        variantData: <span class="type">BaseVariant</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        compilation: <span class="type">KotlinJvmAndroidCompilation</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        project: <span class="type">Project</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        rootKotlinOptions: <span class="type">KotlinJvmOptionsImpl</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        tasksProvider: <span class="type">KotlinTasksProvider</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> configAction = KotlinCompileConfig(compilation)</span><br><span class="line">        configAction.configureTask &#123; task -&gt;</span><br><span class="line">            task.useModuleDetection.value(<span class="literal">true</span>).disallowChanges()</span><br><span class="line">            <span class="comment">// 将kotlin 编译结果存储在tmp/kotlin-classes/$variantDataName目录下，会作为java compiler的class-path输入</span></span><br><span class="line">            task.destinationDirectory.<span class="keyword">set</span>(project.layout.buildDirectory.dir(<span class="string">"tmp/kotlin-classes/<span class="variable">$variantDataName</span>"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        tasksProvider.registerKotlinJVMTask(project, compilation.compileKotlinTaskName, compilation.kotlinOptions, configAction)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略了一些代码，主要做了几件事：  </p><ol><li>检查<code>KGP</code>与<code>Gradle</code>的版本兼容，如果不兼容则抛出异常，中止构建</li><li>如果在<code>project</code>中已经添加了<code>android</code>插件，则开始配置<code>kotlin-android</code>插件</li><li>通过<code>KotlinCompileConfig</code>来配置<code>KotlinCompile Task</code>，设置<code>destinationDirectory</code>作为<code>Kotlin</code>编译结果存储目录，后续会作为<code>java compiler</code>的<code>classpath</code>输入</li></ol><h3 id="第三步：配置KotlinCompile的输入输出"><a href="#第三步：配置KotlinCompile的输入输出" class="headerlink" title="第三步：配置KotlinCompile的输入输出"></a>第三步：配置<code>KotlinCompile</code>的输入输出</h3><p>要实现增量编译，最重要的一点就是配置输入输出，当输入输出没有发生变化时，<code>Task</code>就可以被跳过，而<code>KotlinCompile</code>输入输出的配置，主要是在<code>KotlinCompileConfig</code>中完成的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">configureTaskProvider &#123; taskProvider -&gt;</span><br><span class="line"><span class="comment">// 是否开启classpathSnapthot</span></span><br><span class="line">    <span class="keyword">val</span> useClasspathSnapshot = propertiesProvider.useClasspathSnapshot</span><br><span class="line">    <span class="keyword">val</span> classpathConfiguration = <span class="keyword">if</span> (useClasspathSnapshot) &#123;</span><br><span class="line">    <span class="comment">// 注册 Transform</span></span><br><span class="line">        registerTransformsOnce(project)</span><br><span class="line">        project.configurations.detachedConfiguration(</span><br><span class="line">            project.dependencies.create(objectFactory.fileCollection().from(project.provider &#123; taskProvider.<span class="keyword">get</span>().libraries &#125;))</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    taskProvider.configure &#123; task -&gt;</span><br><span class="line">    <span class="comment">// 配置输入属性</span></span><br><span class="line">        task.classpathSnapshotProperties.useClasspathSnapshot.value(useClasspathSnapshot).disallowChanges()</span><br><span class="line">        <span class="keyword">if</span> (useClasspathSnapshot) &#123;</span><br><span class="line">        <span class="comment">// 通过TransformAction读取输入</span></span><br><span class="line">            <span class="keyword">val</span> classpathEntrySnapshotFiles = classpathConfiguration!!.incoming.artifactView &#123;</span><br><span class="line">                it.attributes.attribute(ARTIFACT_TYPE_ATTRIBUTE, CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE)</span><br><span class="line">            &#125;.files</span><br><span class="line">            task.classpathSnapshotProperties.classpathSnapshot.from(classpathEntrySnapshotFiles).disallowChanges()</span><br><span class="line">            task.classpathSnapshotProperties.classpathSnapshotDir.value(getClasspathSnapshotDir(task)).disallowChanges()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            task.classpathSnapshotProperties.classpath.from(task.project.provider &#123; task.libraries &#125;).disallowChanges()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，主要做了这么几件事       </p><ol><li>判断是否开启了<code>classpathSnapthot</code>，这也是支持跨模块增量编译的开关，如果开启了就注册<code>Transform</code></li><li>通过<code>TransformAction</code>获取输入，并配置给<code>Task</code>相应的属性</li></ol><p>下面我们着重来看下<code>TransformAction</code>在这里做了什么工作?</p><h3 id="第四步：跨模块增量编译支持"><a href="#第四步：跨模块增量编译支持" class="headerlink" title="第四步：跨模块增量编译支持"></a>第四步：跨模块增量编译支持</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">registerTransformsOnce</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> buildMetricsReporterService = BuildMetricsReporterService.registerIfAbsent(project)</span><br><span class="line">    project.dependencies.registerTransform(ClasspathEntrySnapshotTransform::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123;</span><br><span class="line">        it.from.attribute(ARTIFACT_TYPE_ATTRIBUTE, JAR_ARTIFACT_TYPE)</span><br><span class="line">        it.to.attribute(ARTIFACT_TYPE_ATTRIBUTE, CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE)</span><br><span class="line">    &#125;</span><br><span class="line">    project.dependencies.registerTransform(ClasspathEntrySnapshotTransform::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>) </span>&#123;</span><br><span class="line">        it.from.attribute(ARTIFACT_TYPE_ATTRIBUTE, DIRECTORY_ARTIFACT_TYPE)</span><br><span class="line">        it.to.attribute(ARTIFACT_TYPE_ATTRIBUTE, CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了前置知识中的<code>TransformAction</code>，可以看出这就是注册了只变换<code>ArtifactType</code>的变换，主要涉及<code>JAR_ARTIFACT_TYPE</code>和<code>DIRECTORY_ARTIFACT_TYPE</code>转换为<code>CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE</code></p><p>也就是说依赖的<code>jar</code>和类目录都会转换为<code>CLASSPATH_ENTRY_SNAPSHOT_ARTIFACT_TYPE</code>类型，也就可以获取我们依赖的所有<code>classpath</code>的<code>abi</code>了</p><p>接下来我们看下<code>ClasspathEntrySnapshotTransform</code>的实现</p><h4 id="ClasspathEntrySnapshotTransform实现"><a href="#ClasspathEntrySnapshotTransform实现" class="headerlink" title="ClasspathEntrySnapshotTransform实现"></a><code>ClasspathEntrySnapshotTransform</code>实现</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClasspathEntrySnapshotTransform</span> : <span class="type">TransformAction</span>&lt;<span class="type">ClasspathEntrySnapshotTransform.Parameters</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@get:Classpath</span></span><br><span class="line">    <span class="meta">@get:InputArtifact</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> inputArtifact: Provider&lt;FileSystemLocation&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">transform</span><span class="params">(outputs: <span class="type">TransformOutputs</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> classpathEntryInputDirOrJar = inputArtifact.<span class="keyword">get</span>().asFile</span><br><span class="line">        <span class="keyword">val</span> snapshotOutputFile = outputs.file(classpathEntryInputDirOrJar.name.replace(<span class="string">'.'</span>, <span class="string">'_'</span>) + <span class="string">"-snapshot.bin"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> granularity = getClassSnapshotGranularity(classpathEntryInputDirOrJar, parameters.gradleUserHomeDir.<span class="keyword">get</span>().asFile)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">val</span> snapshot = ClasspathEntrySnapshotter.snapshot(classpathEntryInputDirOrJar, granularity, metrics)</span><br><span class="line">         ClasspathEntrySnapshotExternalizer.saveToFile(snapshotOutputFile, snapshot)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果是anroid.jar或者aar依赖，粒度为class, 否则为class_member_level </span></span><br><span class="line"><span class="comment">    /</span></span><br><span class="line"><span class="comment">    private fun getClassSnapshotGranularity(classpathEntryDirOrJar: File, gradleUserHomeDir: File): ClassSnapshotGranularity &#123;</span></span><br><span class="line"><span class="comment">        return if (</span></span><br><span class="line"><span class="comment">            classpathEntryDirOrJar.startsWith(gradleUserHomeDir) ||</span></span><br><span class="line"><span class="comment">            classpathEntryDirOrJar.name == "android.jar"</span></span><br><span class="line"><span class="comment">        ) CLASS_LEVEL</span></span><br><span class="line"><span class="comment">        else CLASS_MEMBER_LEVEL</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>关于自定义<code>TransformAction</code>，其实跟<code>Task</code>一样，也主要看3个部分，输入，输出，执行方法体</p><ol><li><code>ClasspathEntrySnapshotTransform</code>的输入就是模块依赖的<code>jar</code>或者文件目录</li><li>输出则是以<code>-snapshot.bin</code>结尾的文件       </li><li>方法体只做了一件事，通过<code>ClasspathEntrySnapshotter</code>计算出<code>claspath</code>的快照并保存，如果是<code>aar</code>依赖，计算的粒度为<code>class</code>，如果是项目内的类，计算的粒度是<code>class_member_level</code></li></ol><p><code>ClasspathEntrySnapshotter</code>内部是如何计算<code>classpath</code>快照的我们这就不看了，我们简单看下下面这样一个类计算的快照是怎样的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startTest</span><span class="params">(text: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(text)</span><br><span class="line">        test1(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">test1</span><span class="params">(index: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"here test126<span class="variable">$index</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontents.com/RicardoJiang/resource/main/2022/argust/p2.jpg" alt></p><p><code>MyTest</code>类计算出来的快照如图所示，主要<code>classId</code>,<code>classAbiHash</code>,<code>classHeaderStrings</code>等内容</p><p>可以看出<code>private</code>函数的声明也是<code>abi</code>的一部分，当<code>public</code>或者<code>private</code>的函数声明发生变化时，<code>classAbiHash</code>都会发生变化，而只修改函数体时，<code>snapshot</code>不会发生任何变化。</p><h3 id="第五步：KotlinCompile-Task执行编译"><a href="#第五步：KotlinCompile-Task执行编译" class="headerlink" title="第五步：KotlinCompile Task执行编译"></a>第五步：<code>KotlinCompile Task</code>执行编译</h3><p>在配置完成之后，接下来我们就来看下<code>KotlinCompile</code>是怎么执行编译的</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KotlinCompile</span> <span class="meta">@Inject</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> kotlinOptions: KotlinJvmOptions,</span><br><span class="line">    workerExecutor: WorkerExecutor,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> objectFactory: ObjectFactory</span><br><span class="line">) : AbstractKotlinCompile&lt;K2JVMCompilerArguments&gt;(objectFactory &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// classpathSnapshot入参</span></span><br><span class="line">    <span class="meta">@get:Nested</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> classpathSnapshotProperties: ClasspathSnapshotProperties</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClasspathSnapshotProperties</span> </span>&#123;</span><br><span class="line">        <span class="meta">@get:Classpath</span></span><br><span class="line">        <span class="meta">@get:Incremental</span></span><br><span class="line">        <span class="meta">@get:Optional</span> <span class="comment">// Set if useClasspathSnapshot == true</span></span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">val</span> classpathSnapshot: ConfigurableFileCollection</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增量编译参数</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> incrementalProps: List&lt;FileCollection&gt;</span><br><span class="line">        <span class="keyword">get</span>() = listOf(</span><br><span class="line">            sources,</span><br><span class="line">            javaSources,</span><br><span class="line">            classpathSnapshotProperties.classpathSnapshot</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">callCompilerAsync</span><span class="params">(inputChanges: <span class="type">InputChanges</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取增量编译环境变量</span></span><br><span class="line">        <span class="keyword">val</span> icEnv = <span class="keyword">if</span> (isIncrementalCompilationEnabled()) &#123;</span><br><span class="line">            IncrementalCompilationEnvironment(</span><br><span class="line">                changedFiles = getChangedFiles(inputChanges, incrementalProps),</span><br><span class="line">                classpathChanges = getClasspathChanges(inputChanges),</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">val</span> environment = GradleCompilerEnvironment(incrementalCompilationEnvironment = icEnv)</span><br><span class="line">        compilerRunner.runJvmCompilerAsync(</span><br><span class="line">            (kotlinSources + scriptSources).toList(),</span><br><span class="line">            commonSourceSet.toList(),</span><br><span class="line">            javaSources.files,</span><br><span class="line">            environment,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找改动了的input</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">getChangedFiles</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inputChanges: <span class="type">InputChanges</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        incrementalProps: <span class="type">List</span>&lt;<span class="type">FileCollection</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> = <span class="keyword">if</span> (!inputChanges.isIncremental) &#123;</span><br><span class="line">        ChangedFiles.Unknown()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        incrementalProps</span><br><span class="line">            .fold(mutableListOf&lt;File&gt;() to mutableListOf&lt;File&gt;()) &#123; (modified, removed), prop -&gt;</span><br><span class="line">                inputChanges.getFileChanges(prop).forEach &#123;</span><br><span class="line">                    <span class="keyword">when</span> (it.changeType) &#123;</span><br><span class="line">                        ChangeType.ADDED, ChangeType.MODIFIED -&gt; modified.add(it.file)</span><br><span class="line">                        ChangeType.REMOVED -&gt; removed.add(it.file)</span><br><span class="line">                        <span class="keyword">else</span> -&gt; <span class="built_in">Unit</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                modified to removed</span><br><span class="line">            &#125;</span><br><span class="line">            .run &#123;</span><br><span class="line">                ChangedFiles.Known(first, second)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找改变了的classpath</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getClasspathChanges</span><span class="params">(inputChanges: <span class="type">InputChanges</span>)</span></span>: ClasspathChanges = <span class="keyword">when</span> &#123;</span><br><span class="line">        !classpathSnapshotProperties.useClasspathSnapshot.<span class="keyword">get</span>() -&gt; ClasspathSnapshotDisabled</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">when</span> &#123;</span><br><span class="line">                !inputChanges.isIncremental -&gt; NotAvailableForNonIncrementalRun(classpathSnapshotFiles)</span><br><span class="line">                inputChanges.getFileChanges(classpathSnapshotProperties.classpathSnapshot).none() -&gt; NoChanges(classpathSnapshotFiles)</span><br><span class="line">                !classpathSnapshotFiles.shrunkPreviousClasspathSnapshotFile.exists() -&gt; &#123;</span><br><span class="line">                    NotAvailableDueToMissingClasspathSnapshot(classpathSnapshotFiles)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> -&gt; ToBeComputedByIncrementalCompiler(classpathSnapshotFiles)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>KotlinCompile</code>，我们也可以从入参，出参，<code>TaskAction</code>的角度来分析</p><ol><li><code>classpathSnapshotProperties</code>是个包装类型的输入，内部包括<code>@Classpath</code>类型的输入，使用<code>@Classpath</code>输入时，如果输入文件名发生变化而内容没有发生变化时，不会触发<code>Task</code>重新运行，这对<code>classpath</code>来说非常重要</li><li><code>incrementalProps</code>是组件后的增量编译输入参数，包括<code>kotlin</code>输入，<code>java</code>输入，<code>classpath</code>输入等</li><li><code>CompileKotlin</code>的<code>TaskAction</code>，它最后会执行到<code>callCompilerAsync</code>方法，在其中通过<code>getChangedFiles</code>与<code>getClasspathChanges</code>获取改变了的输入与<code>classpath</code></li><li><code>getClasspathChanges</code>方法通过<code>inputChanges</code>获取一个已经改变与删除的文件的<code>Pair</code></li><li><code>getClasspathChanges</code>则根据增量编译是否开启，是否有文件发生更改，历史<code>snapshotFile</code>是否存在，返回不同的<code>ClassPathChanges</code>密封类</li></ol><p>在增量编译参数拼装完成后，接下来就是跟着逻辑走，最后会走到<code>GradleKotlinCompilerWork</code> 的 <code>compileWithDaemmonOrFailbackImpl</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a20c41dfc3f94bc5993d8a0e3d20d203~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">compileWithDaemonOrFallbackImpl</span><span class="params">(messageCollector: <span class="type">MessageCollector</span>)</span></span>: ExitCode &#123;</span><br><span class="line">  <span class="keyword">val</span> executionStrategy = kotlinCompilerExecutionStrategy()</span><br><span class="line">  <span class="keyword">if</span> (executionStrategy == DAEMON_EXECUTION_STRATEGY) &#123;</span><br><span class="line">    <span class="keyword">val</span> daemonExitCode = compileWithDaemon(messageCollector)</span><br><span class="line">    <span class="keyword">if</span> (daemonExitCode != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> daemonExitCode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> isGradleDaemonUsed = System.getProperty(<span class="string">"org.gradle.daemon"</span>)?.let(String::toBoolean)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">if</span> (executionStrategy == IN_PROCESS_EXECUTION_STRATEGY || isGradleDaemonUsed == <span class="literal">false</span>) &#123;</span><br><span class="line">    compileInProcess(messageCollector)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compileOutOfProcess()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>kotlin</code>编译有三种策略，分别是     </p><ol><li>守护进程编译：<code>Kotlin</code>编译的默认模式，只有这种模式才支持增量编译，可以在多个<code>Gradle daemon</code>进程间共享</li><li>进程内编译：<code>Gradle daemon</code>进程内编译</li><li>进程外编译：每次编译都是在不同的进程</li></ol><p><code>compileWithDaemon</code> 会调用到 <code>Kotlin Compile</code> 里执行真正的编译逻辑：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> exitCode = <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> res = <span class="keyword">if</span> (isIncremental) &#123;</span><br><span class="line">    incrementalCompilationWithDaemon(daemon, sessionId, targetPlatform, bufferingMessageCollector)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    nonIncrementalCompilationWithDaemon(daemon, sessionId, targetPlatform, bufferingMessageCollector)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里会执行 <code>org.jetbrains.kotlin.daemon.CompileServiceImpl</code> 的 <code>compile</code> 方法，这样就终于调到了<code>Kotlin</code>编译器内部</p><h3 id="第六步：Kotlin-编译器计算出需重编译的文件"><a href="#第六步：Kotlin-编译器计算出需重编译的文件" class="headerlink" title="第六步：Kotlin 编译器计算出需重编译的文件"></a>第六步：<code>Kotlin</code> 编译器计算出需重编译的文件</h3><p>经过这么多步骤，终于走到<code>Kotlin</code>编译器内部了，下面我们来看下<code>Kotlin</code>编译器的增量编译逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;ServicesFacadeT, JpsServicesFacadeT, CompilationResultsT&gt;</span> <span class="title">compileImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">CompilerMode.INCREMENTAL_COMPILER -&gt; &#123;</span><br><span class="line">    <span class="keyword">when</span> (targetPlatform) &#123;</span><br><span class="line">        CompileService.TargetPlatform.JVM -&gt; withIC(k2PlatformArgs) &#123;</span><br><span class="line">            doCompile(sessionId, daemonReporter, tracer = <span class="literal">null</span>) &#123; _, _ -&gt;</span><br><span class="line">                execIncrementalCompiler(</span><br><span class="line">                    k2PlatformArgs <span class="keyword">as</span> K2JVMCompilerArguments,</span><br><span class="line">                    gradleIncrementalArgs,</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，会判断输入的编译参数，如果是增量编译并且是<code>JVM</code>平台的话，就会执行<code>execIncrementalCompiler</code>方法，最后会调用到<code>sourcesToCompile</code>方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sourcesToCompile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    caches: <span class="type">CacheManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    changedFiles: <span class="type">ChangedFiles</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    args: <span class="type">Args</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    messageCollector: <span class="type">MessageCollector</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    dependenciesAbiSnapshots: <span class="type">Map</span>&lt;<span class="type">String</span>, AbiSnapshot&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: CompilationMode =</span><br><span class="line">    <span class="keyword">when</span> (changedFiles) &#123;</span><br><span class="line">        <span class="keyword">is</span> ChangedFiles.Known -&gt; calculateSourcesToCompile(caches, changedFiles, args, messageCollector, dependenciesAbiSnapshots)</span><br><span class="line">        <span class="keyword">is</span> ChangedFiles.Unknown -&gt; CompilationMode.Rebuild(BuildAttribute.UNKNOWN_CHANGES_IN_GRADLE_INPUTS)</span><br><span class="line">        <span class="keyword">is</span> ChangedFiles.Dependencies -&gt; error(<span class="string">"Unexpected ChangedFiles type (ChangedFiles.Dependencies)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateSourcesToCompileImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        caches: <span class="type">IncrementalJvmCachesManager</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        changedFiles: <span class="type">ChangedFiles</span>.<span class="type">Known</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        args: <span class="type">K2JVMCompilerArguments</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        abiSnapshots: <span class="type">Map</span>&lt;<span class="type">String</span>, AbiSnapshot&gt; = HashMap()</span></span>,</span><br><span class="line">        withAbiSnapshot: <span class="built_in">Boolean</span></span><br><span class="line">    ): CompilationMode &#123;</span><br><span class="line">      <span class="keyword">val</span> dirtyFiles = DirtyFilesContainer(caches, reporter, kotlinSourceFilesExtensions)</span><br><span class="line">      <span class="comment">// 初始化dirtyFiles</span></span><br><span class="line">        initDirtyFiles(dirtyFiles, changedFiles)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算变化的classpath</span></span><br><span class="line">        <span class="keyword">val</span> classpathChanges = <span class="keyword">when</span> (classpathChanges) &#123;</span><br><span class="line">            <span class="keyword">is</span> NoChanges -&gt; ChangesEither.Known(emptySet(), emptySet())</span><br><span class="line">            <span class="comment">//  classpathSnapshot可用时</span></span><br><span class="line">            <span class="keyword">is</span> ToBeComputedByIncrementalCompiler -&gt; reporter.measure(BuildTime.COMPUTE_CLASSPATH_CHANGES) &#123;</span><br><span class="line">                computeClasspathChanges(</span><br><span class="line">                    classpathChanges.classpathSnapshotFiles,</span><br><span class="line">                    caches.lookupCache,</span><br><span class="line">                    storeCurrentClasspathSnapshotForReuse,</span><br><span class="line">                    ClasspathSnapshotBuildReporter(reporter)</span><br><span class="line">                ).toChangesEither()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> NotAvailableDueToMissingClasspathSnapshot -&gt; ChangesEither.Unknown(BuildAttribute.CLASSPATH_SNAPSHOT_NOT_FOUND)</span><br><span class="line">            <span class="keyword">is</span> NotAvailableForNonIncrementalRun -&gt; ChangesEither.Unknown(BuildAttribute.UNKNOWN_CHANGES_IN_GRADLE_INPUTS)</span><br><span class="line">            <span class="comment">// classpathSnapshot不可用时</span></span><br><span class="line">            <span class="keyword">is</span> ClasspathSnapshotDisabled -&gt; reporter.measure(BuildTime.IC_ANALYZE_CHANGES_IN_DEPENDENCIES) &#123;</span><br><span class="line">                <span class="keyword">val</span> lastBuildInfo = BuildInfo.read(lastBuildInfoFile)   </span><br><span class="line">                getClasspathChanges(</span><br><span class="line">                    args.classpathAsList, changedFiles, lastBuildInfo, modulesApiHistory, reporter, abiSnapshots, withAbiSnapshot,</span><br><span class="line">                    caches.platformCache, scopes</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> NotAvailableForJSCompiler -&gt; error(<span class="string">"Unexpected type for this code path: <span class="subst">$&#123;classpathChanges.javaClass.name&#125;</span>."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将结果添加到dirtyFiles</span></span><br><span class="line">        <span class="keyword">val</span> unused = <span class="keyword">when</span> (classpathChanges) &#123;</span><br><span class="line">            <span class="keyword">is</span> ChangesEither.Unknown -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> CompilationMode.Rebuild(classpathChanges.reason)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">is</span> ChangesEither.Known -&gt; &#123;</span><br><span class="line">                dirtyFiles.addByDirtySymbols(classpathChanges.lookupSymbols)</span><br><span class="line">                dirtyClasspathChanges = classpathChanges.fqNames</span><br><span class="line">                dirtyFiles.addByDirtyClasses(classpathChanges.fqNames)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> CompilationMode.Incremental(dirtyFiles)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>calculateSourcesToCompileImpl</code>的目的就是计算<code>Kotlin</code>编译器应该重新编译哪些代码，主要分为以下几个步骤</p><ol><li>初始化<code>dirtyFiles</code>，并将<code>changedFiles</code>加入<code>dirtyFiles</code>，因为<code>changedFiles</code>需要重新编译</li><li><code>classpathSnapshot</code>可用时，通过传入的<code>snapshot.bin</code>文件，与<code>Project</code>目录下的<code>shrunk-classpath-snapshot.bin</code>进行比较得出变化的<code>classpath</code>，以及受影响的类。在比较结束时，也会更新当前目录的<code>shrunk-classpath-snapshot.bin</code>，供下次比较使用</li><li>当<code>classpathSnapshot</code>不可用时，通过<code>getClasspathChanges</code>方法来判断<code>classpath</code>变化，这里面实际上是通过<code>last-build.bin</code>与<code>build-history.bin</code>来判断的，同时每次编译完成也会更新<code>build-history.bin</code></li><li>将受<code>classpath</code>变化影响的类也加入<code>dirtyFiles</code></li><li>返回<code>dirtyFiles</code>供<code>Kotlin</code>编译器真正开始编译</li></ol><p>在这一步，<code>Kotlin</code>编译器利用输入的各种参数进行分析，将需要重新编译的文件加入<code>dirtyFiles</code>，供下一步使用</p><h3 id="第七步：Kotlin编译器真正开始编译"><a href="#第七步：Kotlin编译器真正开始编译" class="headerlink" title="第七步：Kotlin编译器真正开始编译"></a>第七步：<code>Kotlin</code>编译器真正开始编译</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">compileImpl</span><span class="params">()</span></span>: ExitCode &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">var</span> compilationMode = sourcesToCompile(caches, changedFiles, args, messageCollector, classpathAbiSnapshot)</span><br><span class="line">    <span class="keyword">when</span> (compilationMode) &#123;</span><br><span class="line">        <span class="keyword">is</span> CompilationMode.Incremental -&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">            compileIncrementally(args, caches, allSourceFiles, compilationMode, messageCollector, withAbiSnapshot)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">is</span> CompilationMode.Rebuild -&gt; rebuildReason = compilationMode.reason</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">compileIncrementally</span><span class="params">()</span></span>: ExitCode &#123;</span><br><span class="line">   <span class="keyword">while</span> (dirtySources.any() || runWithNoDirtyKotlinSources(caches)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">val</span> (sourcesToCompile, removedKotlinSources) = dirtySources.partition(File::exists)</span><br><span class="line">        <span class="comment">// 真正进行编译</span></span><br><span class="line">        <span class="keyword">val</span> compiledSources = runCompiler(</span><br><span class="line">            sourcesToCompile, args, caches, services, messageCollectorAdapter,</span><br><span class="line">            allKotlinSources, compilationMode <span class="keyword">is</span> CompilationMode.Incremental</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exitCode == ExitCode.OK) &#123;</span><br><span class="line">        <span class="comment">// 写入`last-build.bin`</span></span><br><span class="line">        BuildInfo.write(currentBuildInfo, lastBuildInfoFile)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dirtyData = DirtyData(buildDirtyLookupSymbols, buildDirtyFqNames)</span><br><span class="line">    <span class="comment">// 写入`build-history.bin`</span></span><br><span class="line">    processChangesAfterBuild(compilationMode, currentBuildInfo, dirtyData)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exitCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码主要做了这么几件事：    </p><ol><li>通过<code>sourcesToCompile</code>计算出发生改变的文件后，如果可以增量编译，则进入到<code>compileIncrementally</code>     </li><li>从<code>dirtySouces</code>中找出需要重新编译的文件，交给<code>runCompiler</code>方法进行真正的编译</li><li>在编译结束之后，写入<code>last-build.bin</code>与<code>build-history.bin</code>文件，供下次编译时对比使用</li></ol><p>到这里，增量编译的流程也就基本完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文较为详细地介绍了<code>Kotin</code>是怎么一步步从编译入口到真正开始增量编译的，了解<code>Kotlin</code>增量编译原理可以帮助你定位为什么<code>Kotlin</code>增量编译有时会失效，也可以了解如何写出更容易命中增量编译的代码，希望对你有所帮助。</p><p>关于<code>Kotlin</code>增量编译还有更多的细节，本文也只是介绍了主要的流程，感兴趣的同学可直接查看<code>KGP</code>和<code>Kotlin</code>编译器的源码</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/7087832824501239821" target="_blank" rel="noopener">深入研究Android编译流程-Kotlin是如何编译的</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;编译运行是一个&lt;code&gt;Android&lt;/code&gt;开发者每天都要做的工作，增量编译对于开发者也极其重要，高命中率的增量编译可以极大的提高
      
    
    </summary>
    
    
      <category term="kotlin" scheme="http://RicardoJiang.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 快速编译背后的黑科技，了解一下~</title>
    <link href="http://RicardoJiang.github.io/blog/2022/07/kotlin-fast-compilation.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/07/kotlin-fast-compilation.html</id>
    <published>2022-07-10T08:19:30.000Z</published>
    <updated>2023-10-02T05:09:49.248Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://blog.jetbrains.com/kotlin/2020/09/the-dark-secrets-of-fast-compilation-for-kotlin/" target="_blank" rel="noopener">The Dark Secrets of Fast Compilation for Kotlin</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速编译大量代码一向是一个难题，尤其是当编译器必须执行很多复杂操作时，例如重载方法解析和泛型类型推断。 本文主要介绍在日常开发中做一些小改动时，<code>Kotlin</code>编译器是如何加快编译速度的</p><h2 id="为什么编译那么耗时"><a href="#为什么编译那么耗时" class="headerlink" title="为什么编译那么耗时?"></a>为什么编译那么耗时?</h2><p>编译时间长通常有三大原因：</p><ol><li>代码库大小：通常代码码越大，编译耗时越长</li><li>你的工具链优化了多少，这包括编译器本身和你正在使用的任何构建工具。</li><li>你的编译器有多智能：无论是在不打扰用户的情况下计算出许多事情，还是需要不断提示和样板代码</li></ol><p>前两个因素很明显，让我们谈谈第三个因素：编译器的智能。 这通常是一个复杂的权衡，在 <code>Kotlin</code> 中，我们决定支持干净可读的类型安全代码。这意味着编译器必须非常智能，因为我们在编译期需要做很多工作。</p><p><code>Kotlin</code> 旨在用于项目寿命长、规模大且涉及大量人员的工业开发环境。 </p><p>因此，我们希望静态类型安全，能够及早发现错误，并获得精确的提示（支持自动补全、重构和在 <code>IDE</code> 中查找使用、精确的代码导航等）。 </p><p>然后，我们还想要干净可读的代码，没有不必要的噪音。这意味着我们不希望代码中到处都是类型。 这就是为什么我们有支持 <code>lambda</code> 和扩展函数类型的智能类型推断和重载解析算法等等。 <code>Kotlin</code> 编译器会自己计算出很多东西，以同时保持代码干净和类型安全。</p><h2 id="编译器可以同时智能与高效吗"><a href="#编译器可以同时智能与高效吗" class="headerlink" title="编译器可以同时智能与高效吗?"></a>编译器可以同时智能与高效吗?</h2><p>为了让智能编译器快速运行，您当然需要优化工具链的每一部分，这是我们一直在努力的事情。 除此之外，我们正在开发新一代 <code>Kotlin</code> 编译器，它的运行速度将比当前编译器快得多，但这篇文章不是关于这个的。</p><p>不管编译器有多快，在大型项目上都不会太快。 而且，在调试时所做的每一个小改动都重新编译整个代码库是一种巨大的浪费。 因此，我们试图尽可能多地复用之前的编译，并且只编译我们绝对需要的文件。</p><p>有两种通用方法可以减少重新编译的代码量：</p><ul><li><strong>编译避免</strong>：即只重新编译受影响的模块，</li><li><strong>增量编译</strong>：即只重新编译受影响的文件。</li></ul><p>人们可能会想到一种更细粒度的方法，它可以跟踪单个函数或类的变化，因此重新编译的次数甚至少于一个文件，但我不知道这种方法在工业语言中的实际实现，总的来说它似乎没有必要。</p><p>现在让我们更详细地了解一下编译避免和增量编译。</p><h2 id="编译避免"><a href="#编译避免" class="headerlink" title="编译避免"></a>编译避免</h2><p>编译避免的核心思想是：</p><ul><li>查找<code>dirty</code>（即发生更改）的文件</li><li>重新编译这些文件所属的<code>module</code></li><li>确定哪些其他模块可能会受到更改的影响，重新编译这些模块，并检查它们的<code>ABI</code></li><li>然后重复这个过程直到重新编译所有受影响的模块</li></ul><p>从以上步骤可以看出，没有人依赖的模块中的更改将比每个人都依赖的模块(比如<code>util</code>模块)中的更改编译得更快（如果它影响其 <code>ABI</code>），因为如果你修改了<code>util</code>模块，依赖了它的模块全都需要编译</p><h3 id="ABI是什么"><a href="#ABI是什么" class="headerlink" title="ABI是什么"></a><code>ABI</code>是什么</h3><p>上面介绍了在编译过程中会检查<code>ABI</code>，那么<code>ABI</code>是什么呢?</p><p><code>ABI</code> 代表应用程序二进制接口，它与 <code>API</code> 相同，但用于二进制文件。本质上，<code>ABI</code> 是依赖模块关心的二进制文件中唯一的部分。</p><p>粗略地说，<code>Kotlin</code> 二进制文件（无论是 <code>JVM</code> 类文件还是 <code>KLib</code>）包含<code>declaration</code>和<code>body</code>两部分。其他模块可以引用<code>declaration</code>，但不是所有<code>declaration</code>。因此，例如，私有类和成员不是 <code>ABI</code> 的一部分。</p><p><code>body</code>可以成为 <code>ABI</code> 的一部分吗？也是可以的，比如当我们使用<code>inline</code>时。 同时<code>Kotlin</code> 具有内联函数和编译时常量（<code>const val</code>）。因此如果内联函数的<code>body</code>或 <code>const val</code> 的值发生更改，则可能需要重新编译相关模块。</p><p>因此，粗略地说，<code>Kotlin</code> 模块的 <code>ABI</code> 由<code>declaration</code>、内联<code>body</code>和其他模块可见的<code>const val</code>值组成。</p><p>因此检测 <code>ABI</code> 变化的直接方法是</p><ul><li>以某种形式存储先前编译的 <code>ABI</code>（您可能希望存储哈希以提高效率)</li><li>编译模块后，将结果与存储的 <code>ABI</code> 进行比较：</li><li>如果相同，我们就完成了；</li><li>如果改变了，重新编译依赖模块。</li></ul><h3 id="编译避免的优缺点"><a href="#编译避免的优缺点" class="headerlink" title="编译避免的优缺点"></a>编译避免的优缺点</h3><p>避免编译的最大优点是相对简单。</p><p>当模块很小时，这种方法确实很有帮助，因为重新编译的单元是整个模块。 但如果你的模块很大，重新编译的耗时会很长。        因此为了尽可能地利用编译避免提升速度，决定了我们的工程应该由很多小模块组成。作为开发人员，我们可能想要也可能不想要这个。          小模块不一定听起来像一个糟糕的设计，但我宁愿为人而不是机器构建我的代码。为了利用编译避免，实际上限制了我们项目的架构。</p><p>另一个观察结果是，许多项目都有类似于<code>util</code>的基础模块，其中包含许多有用的小功能。 几乎所有其他模块都依赖于<code>util</code>模块，至少是可传递的。 现在，假设我想添加另一个在我的代码库中使用了 3 次的小实用函数。 它添加到<code>util</code>模块中会导致<code>ABI</code>发生变化，因此所有依赖模块都受到影响，进而导致整个项目都需要重新编译。</p><p>最重要的是，拥有许多小模块（每个都依赖于多个其他模块）意味着我的项目的<code>configuration</code>时间可能会变得巨大，因为对于每个模块，它都包含其独特的依赖项集（源代码和二进制文件）。 在 <code>Gradle</code> 中配置每个模块通常需要 50-100 毫秒。 大型项目拥有超过 1000 个模块的情况并不少见，因此总配置时间可能会超过一分钟。 它必须在每次构建以及每次将项目导入 <code>IDE</code> 时都运行（例如，添加新依赖项时）。</p><p><code>Gradle</code> 中有许多特性可以减轻编译避免的一些缺点：例如，可以使用缓存<code>configuration cache</code>。 尽管如此，这里仍有很大的改进空间，这就是为什么在 <code>Kotlin</code> 中我们使用增量编译。</p><h2 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h2><p>增量编译比编译避免更加细粒度：它适用于单个文件而不是模块。 因此，当通用模块的 <code>ABI</code> 发生微小变化时，它不关心模块大小，也不重新编译整个项目。这种方式不会限制用户项目的架构，并且可以加快编译速度</p><p><code>JPS</code>(<code>IntelliJ</code>的内置构建系统)一直支持增量编译。 而<code>Gradle</code>仅支持开箱即用的编译避免。 从 1.4 开始，<code>Kotlin Gradle</code> 插件为 <code>Gradle</code> 带来了一些有限的增量编译实现，但仍有很大的改进空间。</p><p>理想情况下，我们只需查看更改的文件，准确确定哪些文件依赖于它们，然后重新编译所有这些文件。        </p><p>听起来很简单，但实际上准确地确定这组依赖文件非常复杂。 </p><p>一方面，源文件之间可能存在循环依赖关系，这是大多数现代构建系统中的模块所不允许的。并且单个文件的依赖关系没有明确声明。请注意，如果引用了相同的包和链调用，<code>imports</code>不足以确定依赖关系：对于 <code>A.b.c()</code>，我们最多需要导入<code>A</code>，但 <code>B</code> 类型的更改也会影响我们。</p><p>由于所有这些复杂性，增量编译试图通过多轮来获取受影响的文件集，以下是它的完成方式的概要：</p><ul><li>查找<code>dirty</code>（更改）的文件</li><li>重新编译它们（使用之前编译的结果作为二进制依赖，而不是编译其他源文件）</li><li>检查这些文件对应的<code>ABI</code>是否发生了变化</li><li>如果没有，我们就完成了！</li><li>如果发生了变化，则查找受更改影响的文件，将它们添加到脏文件集中，重新编译</li><li>重复直到 <code>ABI</code> 稳定（这称为“固定点”）</li></ul><p>由于我们已经知道如何比较 ABI，所以这里基本上只有两个棘手的地方：</p><ul><li>使用先前编译的结果来编译源的任意子集</li><li>查找受一组给定的 <code>ABI</code> 更改影响的文件。</li></ul><p>这两者都是 <code>Kotlin</code> 增量编译器的功能。 让我们一个一个看一下。</p><h3 id="编译脏文件"><a href="#编译脏文件" class="headerlink" title="编译脏文件"></a>编译脏文件</h3><p>编译器知道如何使用先前编译结果的子集来跳过编译非脏文件，而只需加载其中定义的符号来为脏文件生成二进制文件。 如果不是为了增量，编译器不一定能够做到这一点：从模块生成一个大二进制文件而不是每个源文件生成一个小二进制文件，这在 <code>JVM</code> 世界之外并不常见。 而且它不是 <code>Kotlin</code> 语言的一个特性，它是增量编译器的一个实现细节。</p><p>当我们将脏文件的 <code>ABI</code> 与之前的结果进行比较时，我们可能会发现我们很幸运，不需要再进行几轮重新编译。 以下是一些只需要重新编译脏文件的更改示例（因为它们不会更改 <code>ABI</code>）：</p><ul><li>注释、字符串文字（<code>const val</code> 除外）等，例如：更改调试输出中的某些内容</li><li>更改仅限于非内联且不影响返回类型推断的函数体，例如：添加/删除调试输出，或更改函数的内部逻辑</li><li>仅限于私有声明的更改（它们可以是类或文件私有的），例如：引入或重命名私有函数</li><li>重新排序函数声明</li></ul><p>如您所见，这些情况在调试和迭代改进代码时非常常见。</p><h3 id="扩大脏文件集"><a href="#扩大脏文件集" class="headerlink" title="扩大脏文件集"></a>扩大脏文件集</h3><p>如果我们不那么幸运并且某些声明已更改，则意味着某些依赖于脏文件的文件在重新编译时可能会产生不同的结果，即使它们的代码中没有任何一行被更改。</p><p>一个简单的策略是此时放弃并重新编译整个模块。<br>这将把所有编译避免的问题都摆在桌面上：一旦你修改了一个声明，大模块就会成为一个问题，而且大量的小模块也有性能成本，如上所述。<br>所以，我们需要更细化：找到受影响的文件并重新编译它们。     </p><p>因此，我们希望找到依赖于实际更改的 <code>ABI</code> 部分的文件。<br>例如，如果用户将 <code>foo</code> 重命名为 <code>bar</code>，我们只想重新编译关心名称 <code>foo</code> 和 <code>bar</code> 的文件，而不管其他文件，即使它们引用了此 <code>ABI</code>的其他部分。<br>增量编译器会记住哪些文件依赖于先前编译中的哪个声明，我们可以使用这种数据，有点像模块依赖图。同样，这不是非增量编译器通常会做的事情。</p><p>理想情况下，对于每个文件，我们应该存储哪些文件依赖于它，以及它们关心 <code>ABI</code> 的哪些部分。实际上，如此精确地存储所有依赖项的成本太高了。而且在许多情况下，存储完整签名毫无意义。</p><p>我们看一下下面这个例子：    </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dirty.kt</span></span><br><span class="line"><span class="comment">// rename this to be 'fun foo(i: Int)'</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">changeMe</span><span class="params">(i: <span class="type">Int</span>)</span></span> = <span class="keyword">if</span> (i == <span class="number">1</span>) <span class="number">0</span> <span class="keyword">else</span> bar().length</span><br><span class="line"></span><br><span class="line"><span class="comment">// clean.kt</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(a: <span class="type">Any</span>)</span></span> = <span class="string">""</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bar</span><span class="params">()</span></span> =  foo(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>我们定义两个<code>kt</code>文件 ，<code>dirty.kt</code>与<code>clean.kt</code>       </p><p>假设用户将函数 <code>changeMe</code> 重命名为 <code>foo</code>。 请注意，虽然 <code>clean.kt</code> 没有改变，但 <code>bar()</code> 的主体将在重新编译时改变：它现在将从<code>dirty.kt</code> 调用 <code>foo(Int)</code>，而不是从 <code>clean.kt</code> 调用 <code>foo(Any)</code> ，并且它的返回类型 也会改变。 </p><p>这意味着我们必须重新编译<code>dirty.kt</code> 和<code>clean.kt</code>。 增量编译器如何发现这一点？</p><p>我们首先重新编译更改的文件：<code>dirty.kt</code>。 然后我们看到 <code>ABI</code> 中的某些内容发生了变化：</p><ul><li>没有功能 <code>changeMe</code> 了</li><li>有一个函数 <code>foo</code> 接受一个 <code>Int</code> 并返回一个 <code>Int</code>。</li></ul><p>现在我们看到 <code>clean.kt</code> 依赖于名称 <code>foo</code>。 这意味着我们必须再次重新编译 <code>clean.kt</code> 和 <code>dirty.kt</code>。 为什么？ 因为类型不能被信任。    </p><p>增量编译必须产生与所有代码的完全重新编译相同的结果。<br>考虑<code>dirty.kt</code> 中新出现的<code>foo</code> 的返回类型。它是推断出来的，实际上它取决于 <code>clean.kt</code> 中 <code>bar</code> 的类型，它是文件之间的循环依赖。<br>因此，当我们将 <code>clean.kt</code> 添加到组合中时，返回类型可能会发生变化。在这个例子中，我们会得到一个编译错误，但是在我们重新编译 <code>clean.kt</code> 和 <code>dirty.kt</code> 之前，我们不知道它。</p><p><code>Kotlin</code> 增量编译的第一原则：您可以信任的只是名称。</p><p>这就是为什么对于每个文件，我们存储它产生的 <code>ABI</code>，以及在编译期间查找的名称（不是完整的声明）。</p><p>我们存储所有这些的方式可以进行一些优化。</p><p>例如，某些名称永远不会在文件之外查找，例如局部变量的名称，在某些情况下还有局部函数的名称。<br>我们可以从索引中省略它们。为了使算法更精确，我们记录了在查找每个名称时查阅了哪些文件。为了压缩我们使用散列的索引。这里有更多改进的空间。</p><p>您可能已经注意到，我们必须多次重新编译初始的脏文件集。 唉，没有办法解决这个问题：可能存在循环依赖，只有一次编译所有受影响的文件才能产生正确的结果。 </p><p>在最坏的情况下，增量编译可能会比编译避免做更多的工作，因此应该有适当的启发式方法来防止它。</p><h3 id="跨模块的增量编译"><a href="#跨模块的增量编译" class="headerlink" title="跨模块的增量编译"></a>跨模块的增量编译</h3><p>迄今为止最大的挑战是可以跨越模块边界的增量编译。</p><p>比如说，我们在一个模块中有脏文件，我们做了几轮并在那里到达一个固定点。现在我们有了这个模块的新 <code>ABI</code>，需要对依赖的模块做一些事情。</p><p>当然，我们知道初始模块的 <code>ABI</code> 中哪些名称受到影响，并且我们知道依赖模块中的哪些文件查找了这些名称。</p><p>现在，我们可以应用基本相同的增量算法，但从 <code>ABI</code> 更改开始，而不是从一组脏文件开始。      </p><p>如果模块之间没有循环依赖，单独重新编译依赖文件就足够了。但是，如果他们的 <code>ABI</code> 发生了变化，我们需要将更多来自同一模块的文件添加到集合中，并再次重新编译相同的文件。</p><p>在 <code>Gradle</code> 中完全实现这一点是一个公开的挑战。这可能需要对 <code>Gradle</code> 架构进行一些更改，但我们从过去的经验中知道，这样的事情是可能的，并且受到 <code>Gradle</code> 团队的欢迎。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，您对现代编程语言中的快速编译所带来的挑战有了基本的了解。请注意，一些语言故意选择让他们的编译器不那么智能，以避免不得不做这一切。不管好坏，<code>Kotlin</code> 走的是另一条路，让 <code>Kotlin</code> 编译器如此智能似乎是用户最喜欢的特性，因为它们同时提供了强大的抽象、可读性和简洁的代码。</p><p>虽然我们正在开发新一代编译器前端，它将通过重新考虑核心类型检查和名称解析算法的实现来加快编译速度，但我们知道这篇博文中描述的所有内容都不会过时。        </p><p>原因之一是使用 <code>Java</code> 编程语言的体验，它享受 <code>IntelliJ IDEA</code> 的增量编译功能，甚至拥有比今天的 <code>kotlinc</code> 快得多的编译器。         </p><p>另一个原因是我们的目标是尽可能接近解释语言的开发体验，这些语言无需任何编译即可立即获取更改。 </p><p>所以，<code>Kotlin</code> 的快速编译策略是：优化的编译器 + 优化的工具链 + 复杂的增量。</p><h2 id="译者总结"><a href="#译者总结" class="headerlink" title="译者总结"></a>译者总结</h2><p>本文主要介绍了<code>Kotlin</code>编译器在加快编译速度方面做的一些工作，介绍了编译避免与增量编译的区别以及什么是<code>ABI</code>。     </p><p>了解<code>Kotlin</code>增量编译的原理可以帮助我们提高增量编译成功的概率，比如<code>inline</code>函数体也是<code>ABI</code>的一部分，因此当我们声明内联函数时，内联函数体应该写得尽量简单，内部通常只需要调用另一个非内联函数即可。      </p><p>这样当<code>inline</code>函数内部逻辑发生更改时，不需要重新编译依赖于它的那些文件，从而实现增量编译。     </p><p>同时从实际开发过程中体验，<code>Kotlin</code>增量编译还是经常会失效，尤其是发生跨模块更改时。<code>Kotlin</code>新一代编译器已经发布了<code>Alpha</code>版本，期待会有更好的表现~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://blog.jetbrains.com/kotlin/2020/09/the-dark-secrets-of-fast-compilation-for-kotlin/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
      <category term="编译技术" scheme="http://RicardoJiang.github.io/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>别了 KAPT , 使用 KSP 快速实现 ButterKnife</title>
    <link href="http://RicardoJiang.github.io/blog/2022/07/ksp-version-butterknife.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/07/ksp-version-butterknife.html</id>
    <published>2022-07-03T12:00:40.000Z</published>
    <updated>2023-10-02T05:09:49.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注解处理器是<code>Android</code>开发中一种常用的技术，很多常用的框架比如<code>ButterKnife</code>，<code>ARouter</code>，<code>Glide</code>中都使用到了注解处理器相关技术        </p><p>但是如果项目比较大的话，会很容易发现<code>KAPT</code>是拖慢编译速度的常见原因，这也是谷歌推出<code>KSP</code>取代<code>KAPT</code>的原因</p><p>目前<code>KSP</code>已经发布了正式版，越来越多的框架也已经支持了<code>KSP</code>，因此现在应该是时候把你的迁移到<code>KSP</code>了~</p><p>本文主要介绍了<code>KSP</code>的一些优势与原理，以及使用<code>KSP</code>快速实现一个简易的<code>ButterKnife</code>框架，以实现<code>KSP</code>的快速上手</p><h2 id="为什么使用KSP"><a href="#为什么使用KSP" class="headerlink" title="为什么使用KSP"></a>为什么使用<code>KSP</code></h2><h3 id="KAPT为什么慢"><a href="#KAPT为什么慢" class="headerlink" title="KAPT为什么慢?"></a><code>KAPT</code>为什么慢?</h3><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/july/p1.jpg" alt></p><p>从上面这张图其实就可以看出原因了，<code>KAPT</code>处理注解的原理是将代码首先生成<code>Java Stubs</code>，再将<code>Java Stubs</code>交给<code>APT</code>处理的，这样天然多了一步，自然就耗时了</p><p>同时在项目中可以发现，往往生成<code>Java Stubs</code>的时间比<code>APT</code>真正处理注解的时间要长，因此使用<code>KSP</code>有时可以得到100%以上的速度提升     </p><p>同时由于<code>KAPT</code>不能直接解析<code>Kotlin</code>的特有的一些符号，比如<code>data class</code>，当我们要处理这些符号的时候就比较麻烦，而<code>KSP</code>则可以直接识别<code>Kotlin</code>符号</p><h3 id="KSP是什么"><a href="#KSP是什么" class="headerlink" title="KSP是什么"></a><code>KSP</code>是什么</h3><blockquote><p>Kotlin Symbol Processing (KSP) is an API that you can use to develop lightweight compiler plugins. KSP provides a simplified compiler plugin API that leverages the power of Kotlin while keeping the learning curve at a minimum. Compared to kapt, annotation processors that use KSP can run up to 2 times faster.</p></blockquote><p>官网对<code>KSP</code>的描述如上，主要说了两点：   </p><ol><li><code>KSP</code>是对<code>KCP</code>(<code>Kotlin</code>编译器插件)的轻量化封装，可以在降低我们学习曲线的同时，可以使用到<code>Kotlin</code>编译器的一些能力   </li><li>相比于<code>KAPT</code>，<code>KSP</code>处理注解可以得到2倍的性能提升</li></ol><p>上面得到了<code>KCP</code>(<code>Kotlin</code>编译器插件)，<code>KCP</code>在<code>kotlinc</code>过程中提供 <code>hook</code> 时机，可以在此期间解析 <code>AST</code>、修改字节码产物等，<code>Kotlin</code> 的不少语法糖都是 <code>KCP</code> 实现的，例如 <code>data class</code>、 <code>@Parcelize</code>、<code>kotlin-android-extension</code> 等, 如今火爆的 <code>Compose</code> 其编译期工作也是借助 <code>KCP</code> 完成的。</p><p><code>KCP</code>虽然强大，但开发成本也很高，学习曲线比较陡峭，因此当我们只需要处理注解等问题时，使用<code>KCP</code>是多余的，于是<code>Google</code>推出了<code>KSP</code>，它基于<code>KCP</code>，但屏蔽了<code>KCP</code>的细节，让我们专注于注解处理的业务</p><h2 id="KSP实战"><a href="#KSP实战" class="headerlink" title="KSP实战"></a><code>KSP</code>实战</h2><p><code>ButterKnife</code>是上古时期比较常用的一个框架，现在有<code>KAE</code>和<code>ViewBinding</code>了，当然也就用不上了      </p><p><code>ButterKnife</code>的主要原理是为注解解析的字段自动生成<code>findViewById</code>的代码，其中主要也是用到了注解处理技术，接下来我们就一起实现一个简易的<code>ButterKnife</code>框架</p><h3 id="1-声明注解"><a href="#1-声明注解" class="headerlink" title="1. 声明注解"></a>1. 声明注解</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">BindView</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>首先要做的就是声明<code>BindView</code>注解</p><h3 id="2-添加ProcessorProvider"><a href="#2-添加ProcessorProvider" class="headerlink" title="2. 添加ProcessorProvider"></a>2. 添加<code>ProcessorProvider</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessorProvider</span> : <span class="type">SymbolProcessorProvider &#123;</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(environment: <span class="type">SymbolProcessorEnvironment</span>)</span></span>: SymbolProcessor &#123;</span><br><span class="line">        <span class="keyword">return</span> ButterKnifeProcessor(environment.codeGenerator, environment.logger)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ProcessorProvider</code>用于提供注解处理器，其中主要提供了<code>SymbolProcessorEnvironment</code>，主要提供了以下功能</p><ol><li><code>environment.options</code>可以获取<code>build.gradle</code>声明的<code>ksp option</code>              </li><li><code>environment.logger</code>提供了<code>logger</code>供我们打印日志      </li><li>最常用的是<code>environment.codeGenerator</code>，用于生成与管理文件，不使用此 <code>API</code> 创建的文件将不会参与增量处理或后续编译。</li></ol><h3 id="3-获取注解处理的符号"><a href="#3-获取注解处理的符号" class="headerlink" title="3. 获取注解处理的符号"></a>3. 获取注解处理的符号</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span></span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> codeGenerator: CodeGenerator,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> logger: KSPLogger</span><br><span class="line">) : SymbolProcessor &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(resolver: <span class="type">Resolver</span>)</span></span>: List&lt;KSAnnotated&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> symbols = resolver.getSymbolsWithAnnotation(BindView::<span class="class"><span class="keyword">class</span>.<span class="title">qualifiedName</span>!!)</span></span><br><span class="line">        <span class="keyword">val</span> ret = symbols.filter &#123; !it.validate() &#125;.toList()</span><br><span class="line">        <span class="keyword">val</span> butterKnifeList = symbols</span><br><span class="line">            .filter &#123; it <span class="keyword">is</span> KSPropertyDeclaration &amp;&amp; it.validate() &#125;</span><br><span class="line">            .map &#123; it <span class="keyword">as</span> KSPropertyDeclaration &#125;.toList()</span><br><span class="line">        ButterKnifeGenerator().generate(codeGenerator, logger, butterKnifeList)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码其实很简单，找出被<code>BindView</code>注解的符号，并过滤出<code>KSPropertyDeclaration</code>，也就是声明的属性</p><h3 id="4-使用kotlin-poet生成代码"><a href="#4-使用kotlin-poet生成代码" class="headerlink" title="4. 使用kotlin-poet生成代码"></a>4. 使用<code>kotlin-poet</code>生成代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OptIn(KotlinPoetKspPreview::class)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">generate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        codeGenerator: <span class="type">CodeGenerator</span>, logger: <span class="type">KSPLogger</span>,list: <span class="type">List</span>&lt;<span class="type">KSPropertyDeclaration</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将获取的符号按包名与类名分组</span></span><br><span class="line">        <span class="keyword">val</span> map = list.groupBy &#123;</span><br><span class="line">            <span class="keyword">val</span> parent = it.parent <span class="keyword">as</span> KSClassDeclaration</span><br><span class="line">            <span class="keyword">val</span> key = <span class="string">"<span class="subst">$&#123;parent.toClassName().simpleName&#125;</span>,<span class="subst">$&#123;parent.packageName.asString()&#125;</span>"</span></span><br><span class="line">            key</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.forEach &#123;</span><br><span class="line">            <span class="keyword">val</span> classItem = it.value[<span class="number">0</span>].parent <span class="keyword">as</span> KSClassDeclaration</span><br><span class="line">            <span class="comment">// 添加文件</span></span><br><span class="line">            <span class="keyword">val</span> fileSpecBuilder = FileSpec.builder(</span><br><span class="line">                classItem.packageName.asString(),</span><br><span class="line">                <span class="string">"<span class="subst">$&#123;classItem.toClassName().simpleName&#125;</span>ViewBind"</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加方法</span></span><br><span class="line">            <span class="keyword">val</span> functionBuilder = FunSpec.builder(<span class="string">"bindView"</span>)</span><br><span class="line">                .receiver(classItem.toClassName())</span><br><span class="line"></span><br><span class="line">            it.value.forEach &#123; item -&gt;</span><br><span class="line">            <span class="comment">// 获取属性名与注解的值</span></span><br><span class="line">                <span class="keyword">val</span> symbolName = item.simpleName.asString()</span><br><span class="line">                <span class="keyword">val</span> annotationValue =</span><br><span class="line">                    (item.annotations.firstOrNull()?.arguments?.firstOrNull()?.value <span class="keyword">as</span>? <span class="built_in">Int</span>) ?: <span class="number">0</span></span><br><span class="line">                functionBuilder.addStatement(<span class="string">"<span class="variable">$symbolName</span> = findViewById(<span class="subst">$&#123;annotationValue&#125;</span>)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写文件</span></span><br><span class="line">            fileSpecBuilder.addFunction(functionBuilder.build())</span><br><span class="line">                .build()</span><br><span class="line">                .writeTo(codeGenerator, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码也不长，主要分为以下几步：  </p><ol><li>因为我们获取的是所有被<code>BindView</code>注解的忏悔，因此需要将获取的符号根据包名与类名分组 </li><li>遍历<code>map</code>，生成文件，并在其中生成相应<code>Activity</code>的<code>bindView</code>扩展方法</li><li>在<code>bindView</code>方法中，利用相关<code>API</code>获取属性名与注解的值     </li><li>利用<code>kotlin-poet</code>与<code>codeGenerator</code>生成代码</li></ol><h3 id="5-生成的代码"><a href="#5-生成的代码" class="headerlink" title="5. 生成的代码"></a>5. 生成的代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zj.ksp_butterknife</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.<span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> MainActivity.<span class="title">bindView</span><span class="params">()</span></span>: <span class="built_in">Unit</span> &#123;</span><br><span class="line">  fabView = findViewById(<span class="number">2131230915</span>)</span><br><span class="line">  toolbar = findViewById(<span class="number">2131231195</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>build/generated/ksp/debug/kotlin</code>目录下可以看到生成的代码，如上所示，其实就是给<code>MainActivity</code>添加了个扩展方法，在其中会自动为被注解的属性赋值</p><h3 id="6-在项目中使用"><a href="#6-在项目中使用" class="headerlink" title="6. 在项目中使用"></a>6. 在项目中使用</h3><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">plugins</span> &#123;</span><br><span class="line">    <span class="built_in">id</span>(<span class="string">"com.google.devtools.ksp"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">android</span> &#123;</span><br><span class="line">    kotlin &#123;</span><br><span class="line">        sourceSets &#123;</span><br><span class="line">        // 让IDE识别KSP生成的代码</span><br><span class="line">            <span class="keyword">main</span>.kotlin.srcDirs += <span class="string">'build/generated/ksp'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="literal">project</span>(<span class="string">':butterknife-annotation'</span>)</span><br><span class="line">    ksp <span class="literal">project</span>(<span class="string">':butterknife-ksp-compiler'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>kapt</code>使用的步骤其实差不多，主要区别在于默认情况下<code>IDE</code>并不认识<code>KSP</code>生成的代码，为了在<code>IDE</code>中支持引用相关的类，需要扩展<code>main.kotlin.srcDirs</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了<code>KSP</code>的一些特性以及如何利用<code>KSP</code>快速实现一个简易的<code>ButterKnife</code>，<code>KSP</code>相比<code>KAPT</code>主要有以下优势       </p><ol><li><code>KSP</code>性能更好，有时可以达到2倍的速度提升；</li><li><code>KSP</code>开发起来更加方便，不需要自己处理增量编译逻辑；</li><li><code>KSP</code>支持多平台，而<code>KAPT</code>只支持<code>JVM</code>平台</li><li><code>KSP</code>拥有更符合<code>Kotin</code>习惯的<code>API</code>，同时可以识别<code>Kotin</code>特有的符号</li></ol><p>总得来说，<code>KSP</code>目前已经发布正式版了，越来越多的框架也已经支持了<code>KSP</code>，因此现在应该是时候把你的应用迁移到<code>KSP</code>了~</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有代码可见：<a href="https://github.com/shenzhen2017/ksp-butterknife" target="_blank" rel="noopener">https://github.com/shenzhen2017/ksp-butterknife</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bilibili.com/video/BV1Tf4y157ku" target="_blank" rel="noopener"> Kotlin 编译器插件：我们究竟在期待什么？</a><br><a href="https://blog.jetbrains.com/kotlin/2021/10/kotlin-symbol-processors/" target="_blank" rel="noopener">Kotlin Symbol Processors</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;注解处理器是&lt;code&gt;Android&lt;/code&gt;开发中一种常用的技术，很多常用的框架比如&lt;code&gt;ButterKnife&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="编译技术" scheme="http://RicardoJiang.github.io/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Android Apk 编译打包流程，了解一下~</title>
    <link href="http://RicardoJiang.github.io/blog/2022/06/how-apk-compile.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/06/how-apk-compile.html</id>
    <published>2022-06-26T08:06:15.000Z</published>
    <updated>2023-10-02T05:09:49.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个<code>Android</code>开发，每天都会有相当一部分的时间花在编译打包上，如果项目比较大的话编译一次可能就要十几分钟。        </p><p>那么在编译打包的过程中<code>AGP</code>到底做了什么？为什么编译那么耗时，又该怎么优化？要解决这些问题，首先就需要我们对编译打包的流程有个总体的了解</p><p>本文主要包括以下内容    </p><ol><li>编译打包总体流程</li><li>编译打包主要步骤</li><li>编译打包过程中的<code>Task</code></li></ol><h2 id="编译打包总体流程"><a href="#编译打包总体流程" class="headerlink" title="编译打包总体流程"></a>编译打包总体流程</h2><p>首先看下<code>Android</code>官网给出的编译打包总体流程</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/679fae0479294940bcb9f136ebc5e7af~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><p>典型 <code>Android</code> 应用的构建流程如图所示，主要分为以下几步：       </p><ol><li>编译器将您的源代码转换成 <code>DEX</code> 文件（<code>Dalvik</code> 可执行文件，其中包括在 <code>Android</code> 设备上运行的字节码），并将其他所有内容转换成编译后的资源。</li><li>打包器将 <code>DEX</code> 文件和编译后的资源组合成 <code>APK</code> 或 <code>AAB</code>（具体取决于所选的 <code>build</code> 目标）。 </li><li>打包器使用调试或发布密钥库为 <code>APK</code> 或 <code>AAB</code> 签名。</li><li>在生成最终 <code>APK</code> 之前，打包器会使用 <code>zipalign</code> 工具对应用进行优化，以减少其在设备上运行时所占用的内存</li></ol><h2 id="编译打包主要步骤"><a href="#编译打包主要步骤" class="headerlink" title="编译打包主要步骤"></a>编译打包主要步骤</h2><p>关于<code>Android</code>编译打包还有一张更加复杂的图</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c23a4a87024042bcaaa226eee7ebbf57~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><p>这个看起来是相当复杂的，但其实我们也可以把这些步骤做一个分类，跟总体流程的四个步骤做一个对应</p><h3 id="资源与代码编译"><a href="#资源与代码编译" class="headerlink" title="资源与代码编译"></a>资源与代码编译</h3><h4 id="资源文件编译"><a href="#资源文件编译" class="headerlink" title="资源文件编译"></a>资源文件编译</h4><p><code>apk</code>资源包含:     </p><ul><li>工程中<code>res</code>目录下的所有文件</li><li><code>assets</code>目录下的文件</li><li><code>AndroidManifest.xml</code></li></ul><p><code>apk</code>的资源编译是编译过程中的一项主要工作，<code>AGP3.0.0</code>之后默认通过<code>AAPT2</code>来编译资源。     </p><p><code>AAPT2</code>（<code>Android Asset Packaging Tool2</code>）是一种构建工具，<code>Android Studio</code> 和 <code>Android Gradle</code> 插件使用它来编译和打包应用的资源。<code>AAPT2</code> 会解析资源、为资源编制索引，并将资源编译为针对 <code>Android</code>平台进行过优化的二进制格式。</p><h5 id="AAPT2做了什么优化"><a href="#AAPT2做了什么优化" class="headerlink" title="AAPT2做了什么优化?"></a><code>AAPT2</code>做了什么优化?</h5><p>为什么<code>AGP3.0.0</code>之后默认通过<code>AAPT2</code>来编译资源呢？它又做了什么优化呢?     </p><p><code>AAPT2</code> 支持通过启用增量编译实现更快的资源编译。这是通过将资源处理拆分为两个步骤来实现的：     </p><ul><li><p>1、编译：将资源文件编译为二进制格式。<br>把所有的<code>Android</code>资源文件进行解析，生成扩展名为<code>.flat</code>的二进制文件。比如是<code>png</code>图片，那么就会被压缩处理，采用<code>.png.flat</code>的扩展名。可以在<code>build/intermediates/merged_res/</code>文件下查看生成的中间产物</p></li><li><p>2、链接：合并所有已编译的文件并将它们打包到一个软件包中。<br>首先，这一步会生成辅助文件，比如<code>R.java</code>与<code>resources.arsc</code>，<code>R</code>文件大家应该都比较熟悉，就是一个资源索引文件，我们平时引用也都是通过<code>R.</code>的方式引用资源<code>id</code>。而<code>resources.arsc</code>则是资源索引表，供在程序运行时根据id索引到具体的资源<br>最后，会将<code>R</code>文件，<code>ressources.arsc</code>文件和之前的二进制文件进行打包，打包到一个软件包中。       </p></li></ul><p><strong>这种拆分方式有助于提高增量编译的性能</strong>。例如，如果某个文件中有更改，您只需要重新编译该文件。</p><h4 id="AIDL文件编译"><a href="#AIDL文件编译" class="headerlink" title="AIDL文件编译"></a><code>AIDL</code>文件编译</h4><p>对于<code>AIDL</code>，大家应该都很熟悉，它是一种用于进程间通信的接口文件。</p><p>其实它是<code>Google</code>为了帮助我们进行进程间通信的简便写法，最后还是需要被解析编译为<code>java</code>文件，而做这个工作的就是<code>aidl</code>工具，存在于<code>sdk/build-tools</code>目录。</p><p><strong>这个阶段的主要的工作就是将项目中的<code>aidl</code>文件编译为<code>java</code>文件</strong>。</p><h4 id="Java与Kotlin文件编译"><a href="#Java与Kotlin文件编译" class="headerlink" title="Java与Kotlin文件编译"></a><code>Java</code>与<code>Kotlin</code>文件编译</h4><ul><li>通过<code>Java Compiler</code> 编译项目中所有的<code>Java</code>代码，包括<code>R.java</code>、<code>.aidl</code>文件生成的<code>.java</code>文件、<code>Java</code>源文件，生成<code>.class</code>文件。在对应的<code>build</code>目录下可以找到相关的代码</li><li>通过<code>Kotlin Compiler</code>编译项目中的所有<code>Kotlin</code>代码，生成<code>.class文件</code></li></ul><p>注解处理器(<code>APT</code>,<code>KAPT</code>)生成代码也是在这个阶段生成的。当注解的生命周期被设置为<code>CLASS</code>的时候，就代表该注解会在编译<code>class</code>文件的时候生效，并且生成<code>java</code>源文件和<code>Class</code>字节码文件。</p><h4 id="Class文件打包成DEX"><a href="#Class文件打包成DEX" class="headerlink" title="Class文件打包成DEX"></a><code>Class</code>文件打包成<code>DEX</code></h4><p>这一步就是将<code>.class</code>文件打包成<code>dex</code>文件。</p><p>有人可能会奇怪了，<code>.class</code>文件不就是<code>JVM</code>可以识别的二进制文件吗，为什么还要进行一次转化呢？</p><p>这就涉及到另一个问题：<code>JVM</code> 和 <code>Dalvik（ART</code> 的区别。</p><p>其中一个重要的区别就是<code>Dalvik（ART）</code>有自己的二进制文件，也就是<code>.dex</code>文件，所以需要将<code>class</code>文件进行再一次转换。</p><p>你可以把<code>dex</code>文件理解为一个<code>class</code>文件包，里面装着很多的<code>class</code>文件，让这些类能够共享数据，类似这种关系：</p><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/june/p5.png" alt></p><h5 id="D8编译器与R8工具"><a href="#D8编译器与R8工具" class="headerlink" title="D8编译器与R8工具"></a><code>D8</code>编译器与<code>R8</code>工具</h5><p>在 <code>AGP 3.X</code> 以后，<code>Google</code> 分别引入 <code>D8</code> 编译器和 <code>R8</code> 工具作为默认的 <code>DEX</code> 编译器和混淆压缩工具。            </p><ul><li>在<code>AGP3.0.1</code>之后,<code>D8</code>编译器取代了<code>Dx</code>，用于将<code>class</code>文件打包成<code>DEX</code>，<code>D8</code>编译器编译更快、时间更短；<code>DEX</code> 编译时占用内容更小；生成的<code>dex</code>文件大小更小；同时拥有相同或者是更好的运行时性能；</li><li>在<code>AGP3.4.0</code>之后，默认开启<code>R8</code>，<code>R8</code> 是 <code>ProGuard</code> 的替代工具，用于代码的压缩（<code>shrinking</code>）和混淆（<code>obfuscation</code>）</li></ul><p>在 <code>AGP3.4.0</code>版本中，<code>R8</code> 把 <code>desugaring</code>、<code>shrinking</code>、<code>obfuscating</code>、<code>optimizing</code> 和 <code>dexing</code> 都合并到一步进行执行。在 <code>AGP3.4.0</code> 以前的版本编译流程如下：        </p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35cae24dd2a74099bae30d62ba636eca~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><p>在<code>AGP3.4.0</code>之后的编译流程如下：   </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/926de7469e724d8c9d49bc87458451f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt></p><h3 id="生成APK包"><a href="#生成APK包" class="headerlink" title="生成APK包"></a>生成<code>APK</code>包</h3><p>在资源文件与代码文件都编译完成后，接下来就是生成<code>apk</code>包了，将<code>manifest</code>文件、<code>resources</code>文件、<code>dex</code>文件、<code>assets</code>文件等等打包成一个压缩包，也就是<code>apk</code>文件。</p><p>在老版本使用的工具是<code>apkbuilder</code>，但是在最新的版本我发现没有这个工具了，<code>sdk</code>目录下也找不到了。</p><p>在<code>AGP3.6.0</code>之后，使用<code>zipflinger</code>作为默认打包工具来构建<code>APK</code>，以提高构建速度</p><h3 id="zipalign（对齐处理）"><a href="#zipalign（对齐处理）" class="headerlink" title="zipalign（对齐处理）"></a><code>zipalign</code>（对齐处理）</h3><p><code>zipalign</code> 是一种归档对齐工具，可对 <code>Android</code> 应用 (<code>APK</code>) 文件提供重要的优化</p><p><code>zipalign</code>会对<code>apk</code>中未压缩的数据进行4字节对齐，对齐的主要过程是将<code>APK</code>包中所有的资源文件距离文件起始偏移为4字节整数倍，对齐后就可以使用<code>mmap</code>函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。</p><p>有的同学可能会有疑问，这个对齐处理不是应该放在签名之后吗？其实这里就涉及到了签名工具的不同带来的对齐处理的顺序不同：</p><ul><li>如果使用的是 <code>apksigner</code>，只能在为 <code>APK</code> 文件签名之前执行 <code>zipalign</code>。</li><li>如果使用的是 <code>jarsigner</code>，只能在为 <code>APK</code> 文件签名之后执行 <code>zipalign</code>。</li></ul><h3 id="对APK进行签名"><a href="#对APK进行签名" class="headerlink" title="对APK进行签名"></a>对<code>APK</code>进行签名</h3><p>在生成APK文件之后，必须对该<code>apk</code>文件进行签名，否则无法被安装。</p><p>之前大家比较熟知的签名工具是<code>JDK</code>提供的<code>jarsigner</code>，而<code>apksigner</code>是<code>Google</code>专门为<code>Android</code>提供的签名和签证工具。</p><p>其区别就在于<code>jarsigner</code>只能进行<code>v1</code>签名，而<code>apksigner</code>可以进行<code>v2</code>、<code>v3</code>、<code>v4</code>签名。下面我们简单介绍下<code>V1</code>签名和<code>V2</code>签名的区别，关于<code>V3</code>,<code>V4</code>签名的内容可参考：<a href="https://juejin.cn/post/7111116047960244254" target="_blank" rel="noopener">Android开发应该知道的签名知识！</a></p><h4 id="V1签名"><a href="#V1签名" class="headerlink" title="V1签名"></a><code>V1</code>签名</h4><p><code>v1</code>签名方式主要是利用<code>META-INFO</code>文件夹中以<code>MF</code>、<code>SF</code> 和 <code>RSA</code> 的三个文件，流程如下所示：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43f200e494dc4cec8fee65f9e0bbea76~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt>      </p><p>首先，将<code>apk</code>中除了<code>META-INFO</code>文件夹中的所有文件进行进行摘要写到 <code>META-INFO/MANIFEST.MF</code>；然后计算<code>MANIFEST.MF</code>文件的摘要写到<code>CERT.SF</code>；最后计算<code>CERT.SF</code>的摘要，使用私钥计算签名，将签名和开发者证书写到<code>CERT.RSA</code>。</p><p>所以<code>META-INFO</code>文件夹中这三个文件就能保证<code>apk</code>不会被修改。但是<code>V1</code>签名方案主要有两个问题    </p><ul><li>一是签名校验慢，在签名校验时要针对 <code>Apk</code> 中所有的文件进行校验，这会拖累老设备的安装时间。</li><li>二是<code>META-INFO</code>文件夹不会被签名，存在一定安全隐患</li></ul><h4 id="V2签名"><a href="#V2签名" class="headerlink" title="V2签名"></a><code>V2</code>签名</h4><p><code>Android7.0</code>之后，<code>Google</code>推出了<code>V2</code>签名，解决<code>V1</code>签名速度慢以及签名不完整的问题。</p><p>apk本质上是一个压缩包，而压缩包文件格式一般分为三块：</p><p>文件数据区，中央目录，中央目录结束节。</p><p>而<code>V2</code>要做的就是，在文件中插入一个<code>APK</code>签名分块，位于中央目录部分之前，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab68a4f6847a41ca983100b0c832af95~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt>   </p><p>这样处理之后，文件签名完成就无法修改了，这也是为什么<code>ZipAlign</code>对齐只能在<code>ApkSigner</code>签名之前执行的原因。</p><h2 id="编译打包过程中的Task"><a href="#编译打包过程中的Task" class="headerlink" title="编译打包过程中的Task"></a>编译打包过程中的<code>Task</code></h2><p>上面介绍了<code>Apk</code>编译打包过程的主要步骤，这些步骤也都是通过<code>AGP</code>插件实现的，那么这些主要步骤又对应<code>AGP</code>中的哪些<code>Task</code>呢</p><p>当我们在<code>Android Studio</code>中点击<code>Run</code>时，便可以在控制台看到一系列的<code>Task</code>执行</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Executing <span class="string">tasks:</span> [:<span class="string">app:</span>assembleDebug] <span class="keyword">in</span> project</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>preBuild UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>preDebugBuild UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugNativeDebugMetadata NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugAidl NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugRenderscript NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dataBindingMergeDependencyArtifactsDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dataBindingMergeGenClassesDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugResValues UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>packageDebugResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>parseDebugLocalResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dataBindingGenBaseClassesDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugBuildConfig UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>checkDebugAarMetadata UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mapDebugSourceSetPaths UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>createDebugCompatibleScreenManifests UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>extractDeepLinksDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugMainManifest UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugManifest UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugManifestForPackage UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugResources UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>javaPreCompileDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugShaders UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugShaders NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugAssets UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugAssets UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compressDebugAssets UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugJavaRes NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>checkDebugDuplicateClasses UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>desugarDebugFileDependencies UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeExtDexDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeLibDexDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugJniLibFolders UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugNativeLibs NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>stripDebugDebugSymbols NO-SOURCE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>validateSigningDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>writeDebugAppMetadata UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>writeDebugSigningConfigVersions UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugKotlin</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugJavaWithJavac</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugJavaResource UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dexBuilderDebug UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeProjectDexDebug</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>packageDebug</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>createDebugApkListingFileRedirect UP-TO-DATE</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>assembleDebug</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL <span class="keyword">in</span> <span class="number">2</span>s</span><br><span class="line"><span class="number">35</span> actionable <span class="string">tasks:</span> <span class="number">4</span> executed, <span class="number">31</span> up-to-date</span><br></pre></td></tr></table></figure><p>上面就是点击运行过程中运行的所有<code>Task</code>，我们精简一下，列出上面主要步骤中提到的<code>Task</code>       </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//aidl 转换aidl文件为java文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugAidl</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成BuildConfig文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugBuildConfig</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取gradle中配置的资源文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>generateDebugResValues</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge资源文件，AAPT2 编译阶段</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugResources</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge assets文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>mergeDebugAssets</span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compressDebugAssets</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge所有的manifest文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugManifest</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成R文件 AAPT2 链接阶段</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>processDebugResources</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译kotlin文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugKotlin</span><br><span class="line"></span><br><span class="line"><span class="comment">//javac 编译java文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>compileDebugJavaWithJavac</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换class文件为dex文件</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>dexBuilderDebug</span><br><span class="line"></span><br><span class="line"><span class="comment">//打包成apk并签名</span></span><br><span class="line">&gt; <span class="string">Task :</span><span class="string">app:</span>packageDebug</span><br></pre></td></tr></table></figure><p>上面这些<code>Task</code>就对应于上面说的编译过程中的主要步骤，比如<code>mergeDebugResources</code>就对应于<code>AAPT2</code>的编译阶段，在<code>Task</code>结束后，会在<code>build/intermediates/merged_res/</code>文件夹中生成<code>Flat</code>文件<br>而<code>processDebugResources</code>则对应于<code>AAPT2</code>的链接阶段，会生成<code>R.java</code>与<code>resources.arsc</code>，并合并所有已编译的文件并将它们打包到一个软件包中</p><p>关于其他<code>Task</code>内容也都比较多，感兴趣的同学可以自行查看相关源码，这里就不缀述了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要详细介绍了<code>Android APK</code>打包编译的总体流程，主要步骤，以及<code>AGP</code>中相关的<code>Task</code>。这些知识点在平常的开发中或许没有多大用处，但是如果你要做包体积优化，或者编译优化相关的一些工作的话，这些应该是需要了解的前置知识，希望对你有所帮助~</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6924918885259378702" target="_blank" rel="noopener">Android&amp;Kotlin编译速度原理剖析（上）</a><br><a href="https://mp.weixin.qq.com/s/6Cb6MqV9GQG60hBltss61A" target="_blank" rel="noopener">从构建工具看 Android APK 编译打包流程</a><br><a href="https://juejin.cn/post/6973089862278725640" target="_blank" rel="noopener">Android D8 编译器 和 R8 工具</a><br><a href="https://juejin.cn/post/7111116047960244254" target="_blank" rel="noopener">Android开发应该知道的签名知识！</a>          </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为一个&lt;code&gt;Android&lt;/code&gt;开发，每天都会有相当一部分的时间花在编译打包上，如果项目比较大的话编译一次可能就要十几分钟。
      
    
    </summary>
    
    
      <category term="编译技术" scheme="http://RicardoJiang.github.io/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>ASM 插桩采集方法入参，出参及耗时信息</title>
    <link href="http://RicardoJiang.github.io/blog/2022/06/asm-method-record.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/06/asm-method-record.html</id>
    <published>2022-06-12T01:20:00.000Z</published>
    <updated>2023-10-02T05:09:49.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ASM</code>字节码插桩技术在<code>Android</code>开发中有着广泛的应用，但相信很多人会不知道怎么上手，不知道该拿<code>ASM</code>来做点什么。       </p><p>学习一门技术最好的方法就是动手实践，本文主要通过<code>ASM</code>插桩采集方法的入参，出参及耗时信息并打印，通过一个不大不小的例子快速上手<code>ASM</code>插桩开发。       </p><h2 id="技术目标"><a href="#技术目标" class="headerlink" title="技术目标"></a>技术目标</h2><p>我们先看下最终的效果</p><h3 id="插桩前代码"><a href="#插桩前代码" class="headerlink" title="插桩前代码"></a>插桩前代码</h3><p>首先来看下插桩前代码，就是一个<code>sum</code>方法         </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(i: <span class="type">Int</span>, j: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i + j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插桩后代码"><a href="#插桩后代码" class="headerlink" title="插桩后代码"></a>插桩后代码</h3><p>接下来看下插桩后的代码       </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(Integer.valueOf(i));</span><br><span class="line">    arrayList.add(Integer.valueOf(j));</span><br><span class="line">    MethodRecorder.onMethodEnter(<span class="string">"com.zj.android_asm.MainActivity"</span>, <span class="string">"sum"</span>, arrayList);</span><br><span class="line">    <span class="keyword">int</span> i2 = i + j;</span><br><span class="line">    MethodRecorder.onMethodExit(Integer.valueOf(i2), <span class="string">"com.zj.android_asm.MainActivity"</span>, <span class="string">"sum"</span>, <span class="string">"I,I"</span>, <span class="string">"I"</span>);</span><br><span class="line">    <span class="keyword">return</span> i2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，方法所有参数都被添加到了一个<code>arrayList</code>中，并且调用了<code>MethodRecorder.onMethodEnter</code>方法<br>而在结果返回之前，则会调用<code>MethodRecorder.onMethodExit</code>方法，并将返回值，参数类型，返回值类型等作为参数传递过支。     </p><h3 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h3><p>在调用了<code>onMethodExit</code>之后，会计算出方法耗时并输出日志，如下所示<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类名：<span class="selector-tag">com</span><span class="selector-class">.zj</span><span class="selector-class">.android_asm</span><span class="selector-class">.MainActivity</span> </span><br><span class="line">方法名：<span class="selector-tag">sum</span> </span><br><span class="line">参数类型：<span class="selector-attr">[I,I]</span> </span><br><span class="line">入参：<span class="selector-attr">[1,2]</span> </span><br><span class="line">返回类型：<span class="selector-tag">I</span> </span><br><span class="line">返回值：3 </span><br><span class="line">耗时：0 <span class="selector-tag">ms</span></span><br></pre></td></tr></table></figure></p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><p>上面我们介绍了最后要实现的效果，下面就来看下怎么一步一步实现，主要分为以下3步：    </p><ol><li>在方法开始时采集方法参数</li><li>在方法结束时采集返回值</li><li>调用帮助类计算耗时及打印结果</li></ol><h3 id="ASM采集方法参数"><a href="#ASM采集方法参数" class="headerlink" title="ASM采集方法参数"></a><code>ASM</code>采集方法参数</h3><p>采集方法参数的方法也很简单，主要就是读取出所有参数的值并存储在一个<code>List</code>中，主要问题在于我们需要用字节码来实现这些逻辑.   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodEnter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 方法开始</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedVisiMethod() &amp;&amp; descriptor != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> parametersIdentifier = MethodRecordUtil.newParameterArrayList(mv, <span class="keyword">this</span>)   <span class="comment">//1. new一个List</span></span><br><span class="line">        MethodRecordUtil.fillParameterArray(methodDesc, mv, parametersIdentifier, access) <span class="comment">//2. 填充列表</span></span><br><span class="line">MethodRecordUtil.onMethodEnter(mv, className, name, parametersIdentifier) <span class="comment">//3. 调用帮助类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onMethodEnter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，采集方法参数也分为3步，接下来我来一步步看下代码    </p><h4 id="ASM创建列表"><a href="#ASM创建列表" class="headerlink" title="ASM创建列表"></a><code>ASM</code>创建列表</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">newParameterArrayList</span><span class="params">(mv: <span class="type">MethodVisitor</span>, localVariablesSorter: <span class="type">LocalVariablesSorter</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">// new一个ArrayList</span></span><br><span class="line">    mv.visitTypeInsn(AdviceAdapter.NEW, <span class="string">"java/util/ArrayList"</span>)</span><br><span class="line">    mv.visitInsn(AdviceAdapter.DUP)</span><br><span class="line">    mv.visitMethodInsn(</span><br><span class="line">        AdviceAdapter.INVOKESPECIAL,</span><br><span class="line">        <span class="string">"java/util/ArrayList"</span>,</span><br><span class="line">        <span class="string">"&lt;init&gt;"</span>,</span><br><span class="line">        <span class="string">"()V"</span>,</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 存储new出来的List</span></span><br><span class="line">    <span class="keyword">val</span> parametersIdentifier = localVariablesSorter.newLocal(Type.getType(List::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line">    mv.visitVarInsn(AdviceAdapter.ASTORE, parametersIdentifier)</span><br><span class="line">    <span class="comment">// 返回parametersIdentifier，方便后续访问这个列表</span></span><br><span class="line">    <span class="keyword">return</span> parametersIdentifier</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑其实很简单，主要问题在于需要用<code>ASM</code>代码写，需要掌握一些字节码指令相关知识。不过我们也可以用<a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline" target="_blank" rel="noopener">asm-bytecode-outline</a>来自动生成这段代码，这样难度可以降低不少。关于代码中各个指令的具体含义，可查阅<a href="https://blog.csdn.net/qq_33589510/article/details/105285250" target="_blank" rel="noopener">Java虚拟机(JVM)字节码指令表</a>       </p><h4 id="ASM填充列表"><a href="#ASM填充列表" class="headerlink" title="ASM填充列表"></a><code>ASM</code>填充列表</h4><p>接下来要做的就是读出所有的参数并填充到上面创建的列表中<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fillParameterArray</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    methodDesc: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    mv: <span class="type">MethodVisitor</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    parametersIdentifier: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    access: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断是不是静态函数</span></span><br><span class="line">    <span class="keyword">val</span> isStatic = (access and Opcodes.ACC_STATIC) != <span class="number">0</span></span><br><span class="line">    <span class="comment">// 静态函数与普通函数的cursor不同</span></span><br><span class="line">    <span class="keyword">var</span> cursor = <span class="keyword">if</span> (isStatic) <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">val</span> methodType = Type.getMethodType(methodDesc)</span><br><span class="line">    <span class="comment">// 获取参数列表</span></span><br><span class="line">    methodType.argumentTypes.forEach &#123;</span><br><span class="line">    <span class="comment">// 读取列表</span></span><br><span class="line">        mv.visitVarInsn(AdviceAdapter.ALOAD, parametersIdentifier)</span><br><span class="line">        <span class="comment">// 根据不同类型获取不同的指令，比如int是iload, long是lload</span></span><br><span class="line">        <span class="keyword">val</span> opcode = it.getOpcode(Opcodes.ILOAD)</span><br><span class="line">        <span class="comment">// 通过指令与cursor读取参数的值</span></span><br><span class="line">        mv.visitVarInsn(opcode, cursor)</span><br><span class="line">        <span class="keyword">if</span> (it.sort &gt;= Type.BOOLEAN &amp;&amp; it.sort &lt;= Type.DOUBLE) &#123;</span><br><span class="line">        <span class="comment">// 基本类型转换为包装类型</span></span><br><span class="line">            typeCastToObject(mv, it)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新cursor</span></span><br><span class="line">        cursor += it.size</span><br><span class="line">        <span class="comment">// 添加到列表中</span></span><br><span class="line">        mv.visitMethodInsn(</span><br><span class="line">            AdviceAdapter.INVOKEINTERFACE,</span><br><span class="line">            <span class="string">"java/util/List"</span>,</span><br><span class="line">            <span class="string">"add"</span>,</span><br><span class="line">            <span class="string">"(Ljava/lang/Object;)Z"</span>,</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        )</span><br><span class="line">        mv.visitInsn(AdviceAdapter.POP)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要代码如上所示，代码中都有注释，主要需要注意以下几点:    </p><ol><li>静态函数与普通函数的初始<code>cursor</code>不同，因此需要区分开来    </li><li>不同类型的参数加载的指令也不同，因此需要通过<code>Type.getOpcode</code>获取具体指令       </li><li>为了将参数放在一个列表中，需要将基本类型转换为包装类型，比如<code>int</code>转换为<code>Integer</code>        </li></ol><h4 id="ASM调用帮助类"><a href="#ASM调用帮助类" class="headerlink" title="ASM调用帮助类"></a><code>ASM</code>调用帮助类</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">onMethodEnter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    mv: <span class="type">MethodVisitor</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    className: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    name: <span class="type">String</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">    parametersIdentifier: <span class="type">Int</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    mv.visitLdcInsn(className)</span><br><span class="line">    mv.visitLdcInsn(name)</span><br><span class="line">    mv.visitVarInsn(AdviceAdapter.ALOAD, parametersIdentifier)</span><br><span class="line">    mv.visitMethodInsn(</span><br><span class="line">        AdviceAdapter.INVOKESTATIC, <span class="string">"com/zj/android_asm/MethodRecorder"</span>, <span class="string">"onMethodEnter"</span>,</span><br><span class="line">        <span class="string">"(Ljava/lang/String;Ljava/lang/String;Ljava/util/List;)V"</span>, <span class="literal">false</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较简单，主要就是通过<code>ASM</code>调用<code>MethodRecorder.onMethodEnter</code>方法</p><h3 id="ASM采集返回值"><a href="#ASM采集返回值" class="headerlink" title="ASM采集返回值"></a><code>ASM</code>采集返回值</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodExit</span><span class="params">(opcode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 方法结束</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedVisiMethod()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((opcode <span class="keyword">in</span> IRETURN..RETURN) || opcode == ATHROW) &#123;</span><br><span class="line">            <span class="keyword">when</span> (opcode) &#123;</span><br><span class="line">            <span class="comment">// 基本类型返回</span></span><br><span class="line">                <span class="keyword">in</span> IRETURN..DRETURN -&gt; &#123;</span><br><span class="line">                <span class="comment">// 读取返回值</span></span><br><span class="line">                    MethodRecordUtil.loadReturnData(mv, methodDesc)</span><br><span class="line">                    MethodRecordUtil.onMethodExit(mv, className, name, methodDesc)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对象返回</span></span><br><span class="line">                ARETURN -&gt; &#123;</span><br><span class="line">                <span class="comment">// 读取返回值</span></span><br><span class="line">                    mv.visitInsn(DUP)</span><br><span class="line">                    MethodRecordUtil.onMethodExit(mv, className, name, methodDesc)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 空返回</span></span><br><span class="line">                RETURN -&gt; &#123;</span><br><span class="line">                    mv.visitLdcInsn(<span class="string">"void"</span>)</span><br><span class="line">                    MethodRecordUtil.onMethodExit(mv, className, name, methodDesc)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.onMethodExit(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采集返回值的逻辑也很简单，主要分为以下几步    </p><ol><li>判断当前指令，并且根据不同类型的返回添加不同的逻辑       </li><li>通过<code>DUP</code>指令复制栈顶数值并将复制值压入栈顶，以读取返回值    </li><li>读取方法参数类型与返回值类型，并调用<code>MethodRecorder.onMexthodExit</code>方法</li></ol><h3 id="帮助类实现"><a href="#帮助类实现" class="headerlink" title="帮助类实现"></a>帮助类实现</h3><p>由于<code>ASM</code>需要直接操作字节码，写起来终究不太方便，因此我们尽可能把代码转移到帮助类中，然后通过在<code>ASM</code>中调用帮助类来简化开发，帮助类的代码如下所示：   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> MethodRecorder &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mMethodRecordMap = HashMap&lt;String, MethodRecordItem&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onMethodEnter</span><span class="params">(className: <span class="type">String</span>, methodName: <span class="type">String</span>, parameterList: <span class="type">List</span>&lt;<span class="type">Any</span>?&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> key = <span class="string">"<span class="subst">$&#123;className&#125;</span>,<span class="subst">$&#123;methodName&#125;</span>"</span></span><br><span class="line">        <span class="keyword">val</span> startTime = System.currentTimeMillis()</span><br><span class="line">        <span class="keyword">val</span> list = parameterList?.filterNotNull() ?: emptyList()</span><br><span class="line">        mMethodRecordMap[key] = MethodRecordItem(startTime, list)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JvmStatic</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">onMethodExit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        response: <span class="type">Any</span>? = <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        className: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        methodName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        parameterTypes: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        returnType: <span class="type">String</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> key = <span class="string">"<span class="subst">$&#123;className&#125;</span>,<span class="subst">$&#123;methodName&#125;</span>"</span></span><br><span class="line">        mMethodRecordMap[key]?.let &#123;</span><br><span class="line">            <span class="keyword">val</span> parameters = it.parameterList.joinToString(<span class="string">","</span>)</span><br><span class="line">            <span class="keyword">val</span> duration = System.currentTimeMillis() - it.startTime</span><br><span class="line">            <span class="keyword">val</span> result = <span class="string">"类名：<span class="variable">$className</span> \n方法名：<span class="variable">$methodName</span> \n参数类型：[<span class="variable">$parameterTypes</span>] \n入参：[<span class="variable">$parameters</span>] \n返回类型：<span class="variable">$returnType</span> \n返回值：<span class="variable">$response</span> \n耗时：<span class="variable">$duration</span> ms \n"</span></span><br><span class="line">            Log.i(<span class="string">"methodRecord"</span>, result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码其实也很简单，主要逻辑如下：   </p><ol><li>方法开始时调用<code>onMethodEnter</code>方法，传入参数列表，并记录下方法开始时间          </li><li>方法结束时调用<code>onMethodExit</code>方法，传入返回值，计算方法耗时并打印结果</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述步骤，我们就把<code>ASM</code>插桩实现记录方法入参，返回值以及方法耗时的功能完成了，通过插桩可以在方法执行的时候输出我们需要的信息。而这些信息的价值就是可以很好的让我们做一些程序的全链路监控以及工程质量验证。  </p><p>总得来说，逻辑上其实并不复杂，主要问题可能在于需要熟悉如何直接操作字节码，我们可以通过<a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline" target="_blank" rel="noopener">asm-bytecode-outline</a>等工具自动生成代码来简化开发，同时也可以通过尽量把逻辑迁移到帮助类中的方式来减少直接操作字节码的工作。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有源码可见：<a href="https://github.com/shenzhen2017/Android-ASM" target="_blank" rel="noopener">https://github.com/shenzhen2017/Android-ASM</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/qq_33589510/article/details/105285250" target="_blank" rel="noopener">Java虚拟机(JVM)字节码指令表</a><br><a href="https://bugstack.cn/md/bytecode/asm/2020-04-05-%5BASM%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E7%A8%8B%5DJavaAgent+ASM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8F%92%E6%A1%A9%E9%87%87%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%8D%E7%A7%B0%E4%BB%A5%E5%8F%8A%E5%85%A5%E5%8F%82%E5%92%8C%E5%87%BA%E5%8F%82%E7%BB%93%E6%9E%9C%E5%B9%B6%E8%AE%B0%E5%BD%95%E6%96%B9%E6%B3%95%E8%80%97%E6%97%B6.html#_4-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C" target="_blank" rel="noopener">ASM字节码编程 | JavaAgent+ASM字节码插桩采集方法名称以及入参和出参结果并记录方法耗时</a><br><a href="https://blog.51cto.com/lsieun/2955738" target="_blank" rel="noopener">Java ASM系列：（025）修改已有的方法（添加－进入和退出－打印方法参数和返回值）</a>            </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ASM&lt;/code&gt;字节码插桩技术在&lt;code&gt;Android&lt;/code&gt;开发中有着广泛的应用，但相信很多人会不知道怎么上手，
      
    
    </summary>
    
    
      <category term="编译技术" scheme="http://RicardoJiang.github.io/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Transform 被废弃，ASM 如何适配?</title>
    <link href="http://RicardoJiang.github.io/blog/2022/06/gradle7-transform-learn.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/06/gradle7-transform-learn.html</id>
    <published>2022-06-05T12:26:56.000Z</published>
    <updated>2023-10-02T05:09:49.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Transform API</code> 是 <code>AGP1.5</code> 就引入的特性，主要用于在 <code>Android</code> 构建过程中，在 <code>Class</code>转<code>Dex</code>的过程中修改 <code>Class</code> 字节码。利用 <code>Transform API</code>，我们可以拿到所有参与构建的 <code>Class</code> 文件，然后可以借助<code>ASM</code> 等字节码编辑工具进行修改，插入自定义逻辑。    </p><p>国内很多团队都或多或少的用 <code>AGP</code> 的 <code>Transform API</code> 来搞点儿黑科技，比如无痕埋点，耗时统计，方法替换等。但是在<code>AGP7.0</code>中<code>Transform</code>已经被标记为废弃了，并且将在<code>AGP8.0</code>中移除。而<code>AGP8.0</code>应该会在今年内发布，可以说是已经近在眼前了。所以现在应该是时候了解一下，在<code>Transform</code>被废弃之后，该怎么适配了。</p><h2 id="Transform-Action介绍"><a href="#Transform-Action介绍" class="headerlink" title="Transform Action介绍"></a><code>Transform Action</code>介绍</h2><p><code>Transform API</code>是由<code>AGP</code>提供的，而<code>Transform Action</code>则是由<code>Gradle</code>提供。不光是 <code>AGP</code> 需要 <code>Transform</code>，<code>Java</code> 也需要，所以由 <code>Gradle</code> 来提供统一的 <code>Transform API</code> 也合情合理。<br>这应该也是<code>Transform API</code>被废弃的原因，既然<code>Gradle</code>已经统一提供了<code>API</code>，<code>AGP</code>也就没必要自定义一套了。   </p><p>关于 <code>TransformAction</code> 如何使用，<code>Gradle</code> 官方已经提供了很详细的文档–<a href="https://docs.gradle.org/current/userguide/artifact_transforms.html" target="_blank" rel="noopener">Transforming dependency artifacts on resolution</a>，具体使用可以直接参考文档</p><h2 id="AsmClassVisitorFactory介绍"><a href="#AsmClassVisitorFactory介绍" class="headerlink" title="AsmClassVisitorFactory介绍"></a><code>AsmClassVisitorFactory</code>介绍</h2><p>直接使用<code>Transform Action</code>的话还是有些麻烦，跟<code>Transform API</code>一样，需要手动处理增量编译的逻辑。<code>AGP</code>很贴心的为我们又做了一层封装，提供了<code>AsmClassVisitorFactory</code>来方便我们使用<code>Transform Action</code>进行<code>ASM</code>操作。<br>根据官方的说法，<code>AsmClassVisitoFactory</code>会带来约18%的性能提升，同时可以减少约5倍代码       </p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44e2f3d80f7847c1803c90f66a8c2bb5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp?" alt>     </p><h2 id="代码实战"><a href="#代码实战" class="headerlink" title="代码实战"></a>代码实战</h2><p>接下来我们利用<code>AGP</code> 的<code>AsmClassVisitorFactory API</code>,来实现方法执行耗时的插桩。     </p><h3 id="实现AsmClassVisitorFactory"><a href="#实现AsmClassVisitorFactory" class="headerlink" title="实现AsmClassVisitorFactory"></a>实现<code>AsmClassVisitorFactory</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeCostTransform</span>: <span class="type">AsmClassVisitorFactory</span>&lt;<span class="type">InstrumentationParameters.None</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createClassVisitor</span><span class="params">(classContext: <span class="type">ClassContext</span>, nextClassVisitor: <span class="type">ClassVisitor</span>)</span></span>: ClassVisitor &#123;</span><br><span class="line">        <span class="keyword">return</span> TimeCostClassVisitor(nextClassVisitor)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isInstrumentable</span><span class="params">(classData: <span class="type">ClassData</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>AsmClassVisitorFactory</code>即创建<code>ClassVisitor</code>对象的工厂。此接口的实现必须是一个抽象类，</li><li><code>createClassVisitor</code>返回我们自定义的<code>ClassVisitor</code>，在自定义<code>Visitor</code>处理完成后，需要传内容传递给下一个<code>Visitor</code>，因此我们将其放在构造函数中传入      </li><li><code>isInstrumentable</code>用于控制我们的自定义<code>Visitor</code>是否需要处理这个类，通过这个方法可以过滤我们不需要的类，加快编译速度</li></ol><h3 id="自定义ClassVisitor"><a href="#自定义ClassVisitor" class="headerlink" title="自定义ClassVisitor"></a>自定义<code>ClassVisitor</code></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeCostClassVisitor</span></span>(nextVisitor: ClassVisitor) : ClassVisitor(Opcodes.ASM5, nextVisitor) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">visitMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        access: <span class="type">Int</span>, name: <span class="type">String</span>?, descriptor: <span class="type">String</span>?, signature: <span class="type">String</span>?, exceptions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: MethodVisitor &#123;</span><br><span class="line">        <span class="keyword">val</span> methodVisitor = <span class="keyword">super</span>.visitMethod(access, name, descriptor, signature, exceptions)</span><br><span class="line">        <span class="keyword">val</span> newMethodVisitor =</span><br><span class="line">            <span class="keyword">object</span> : AdviceAdapter(Opcodes.ASM5, methodVisitor, access, name, descriptor) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodEnter</span><span class="params">()</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 方法开始</span></span><br><span class="line">                    <span class="keyword">if</span> (isNeedVisiMethod(name)) &#123;</span><br><span class="line">                        mv.visitLdcInsn(name);</span><br><span class="line">                        mv.visitMethodInsn(</span><br><span class="line">                            INVOKESTATIC, <span class="string">"com/zj/android_asm/TimeCache"</span>, <span class="string">"putStartTime"</span>,<span class="string">"(Ljava/lang/String;)V"</span>, <span class="literal">false</span></span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">super</span>.onMethodEnter();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onMethodExit</span><span class="params">(opcode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                    <span class="comment">// 方法结束</span></span><br><span class="line">                    <span class="keyword">if</span> (isNeedVisiMethod(name)) &#123;</span><br><span class="line">                        mv.visitLdcInsn(name);</span><br><span class="line">                        mv.visitMethodInsn(</span><br><span class="line">                            INVOKESTATIC, <span class="string">"com/zj/android_asm/TimeCache"</span>, <span class="string">"putEndTime"</span>,<span class="string">"(Ljava/lang/String;)V"</span>, <span class="literal">false</span></span><br><span class="line">                        );</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">super</span>.onMethodExit(opcode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> newMethodVisitor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isNeedVisiMethod</span><span class="params">(name: <span class="type">String</span>?)</span></span>:<span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="string">"putStartTime"</span> &amp;&amp; name != <span class="string">"putEndTime"</span> &amp;&amp; name != <span class="string">"&lt;clinit&gt;"</span> &amp;&amp; name != <span class="string">"printlnTime"</span> &amp;&amp; name != <span class="string">"&lt;init&gt;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就跟普通的<code>ASM</code>操作没什么不同了，主要是通过<code>ASM</code>字节码插桩，在方法的前后插入如下代码，通过计算两者的时间差来得出方法的耗时</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">timeMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TimeCache.putStartTime(<span class="string">"timeMethod"</span>) <span class="comment">//方法开始插入的代码</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">    TimeCache.putEndTime(<span class="string">"timeMethod"</span>) <span class="comment">//方法结束插入的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册Transform"><a href="#注册Transform" class="headerlink" title="注册Transform"></a>注册<code>Transform</code></h3><p>老版本的<code>Transform</code>是注册在<code>AppExtension</code>中的，新版本则是注册在<code>AndroidComponentsExtension</code>中      </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeCostPlugin</span> : <span class="type">Plugin</span>&lt;<span class="type">Project</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">apply</span><span class="params">(project: <span class="type">Project</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> androidComponents = project.extensions.getByType(AndroidComponentsExtension::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">        androidComponents.onVariants &#123; variant -&gt;</span><br><span class="line">            variant.instrumentation.transformClassesWith(TimeCostTransform::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>,<span class="type"></span></span></span><br><span class="line">                    InstrumentationScope.PROJECT) &#123;&#125;</span><br><span class="line">            variant.instrumentation.setAsmFramesComputationMode(</span><br><span class="line">                    FramesComputationMode.COMPUTE_FRAMES_FOR_INSTRUMENTED_METHODS</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>基于<code>variant</code>可实现不同的变种不同的处理逻辑    </li><li><code>transformClassesWith</code>通过<code>InstrumentationScope</code>控制是否需要扫描依赖库代码   </li><li><code>setAsmFramesComputationMode</code>可设置不同的栈帧计算模式，具体可查看源码</li></ol><h3 id="AsmClassVisitorFactory的优势"><a href="#AsmClassVisitorFactory的优势" class="headerlink" title="AsmClassVisitorFactory的优势"></a><code>AsmClassVisitorFactory</code>的优势</h3><p>通过以上步骤，一个简单的通过插桩计算方法执行耗时的功能就完成了，这比起老版的<code>Transform API</code>其实简化了不少，老版本处理增量更新就需要处理一大堆的逻辑。<br>可以看到我们这里并没有手动处理增量逻辑，这是因为调用<code>AsmClassVisitorFactory</code>的<code>TransformClassesWithAsmTask</code>继承自<code>NewIncrementalTask</code>，已经处理了增量逻辑，不需要我们再手动处理了</p><p>同时老版本的<code>Transform</code>每个<code>Transfrom</code>各自独立，如果每个<code>Transform</code>编译构建耗时<code>+10s</code>，各个<code>Transform</code>叠在一起，编译耗时就会呈线性增长<br>而新版本可以看出我们也没有手动进行<code>IO</code>操作，这是因为<code>AsmInstrumentationManager</code>中已经做了统一处理，只需要进行一次<code>IO</code>操作，然后交给<code>ClassVisitor</code>链表处理，完成后统一交给<code>ClassWriter</code>写入<br>通过这种方式，可以有效地减少<code>IO</code>操作，这也是新版本<code>API</code>性能提升的原因</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总得来说，由于<code>Transform API</code>在<code>AGP7.0</code>已标记为废弃，并且将在<code>AGP8.0</code>中移除，是时候了解一下如何迁移<code>Transform API</code>了              </p><p>而<code>AsmClassVisitorFactory</code>相比<code>Transform API</code>，使用起来更加简单，不需要手动处理增量逻辑，可以专注于字节码插桩操作。同时<code>AsmClassVisitorFactory</code>通过减少<code>IO</code>的方式，可以得到约20%的性能提升，加快编译速度。 </p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>本文所有源码可见：<a href="https://github.com/shenzhen2017/Android-ASM" target="_blank" rel="noopener">https://github.com/shenzhen2017/Android-ASM</a></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/7098752199575994405" target="_blank" rel="noopener">其实 Gradle Transform 就是个纸老虎 —— Gradle 系列(4)</a><br><a href="https://juejin.cn/post/7016147287889936397" target="_blank" rel="noopener">现在准备好告别Transform了吗？ | 拥抱AGP7.0</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Transform API&lt;/code&gt; 是 &lt;code&gt;AGP1.5&lt;/code&gt; 就引入的特性，主要用于在 &lt;code&gt;An
      
    
    </summary>
    
    
      <category term="编译技术" scheme="http://RicardoJiang.github.io/tags/%E7%BC%96%E8%AF%91%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>【从入门到实用】Android卡顿优化深入解析</title>
    <link href="http://RicardoJiang.github.io/blog/2022/06/android-jank-optimize.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/06/android-jank-optimize.html</id>
    <published>2022-06-01T00:31:03.000Z</published>
    <updated>2023-10-02T05:09:49.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6973564044351373326" target="_blank" rel="noopener">卡顿、ANR、死锁，线上如何监控？</a>      </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;h3 id
      
    
    </summary>
    
    
      <category term="android" scheme="http://RicardoJiang.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>使用 Baseline Profiles 优化启动性能</title>
    <link href="http://RicardoJiang.github.io/blog/2022/05/use-base-profile.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/05/use-base-profile.html</id>
    <published>2022-05-15T08:34:45.000Z</published>
    <updated>2023-10-02T05:09:49.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>应用的启动优化是<code>Android</code>性能优化中的一个常见问题，除了常规的一些优化手段，在本次<code>Google/IO</code>大会还介绍了通过<code>Baseline Profiles</code>来优化启动速度。<br>本文主要包括以下内容：     </p><ol><li><code>Baseline Profiles</code>是什么?</li><li>如何使用<code>Baseline Profiles</code>?</li><li>使用<code>Baseline Profiles</code>的效果怎么样?</li></ol><h2 id="Baseline-Profiles是什么"><a href="#Baseline-Profiles是什么" class="headerlink" title="Baseline Profiles是什么?"></a><code>Baseline Profiles</code>是什么?</h2><p><code>Android 9</code>在 <code>Play Cloud</code> 中引入了 <code>ART</code> 优化<code>Profiles</code>文件，以缩短应用启动时间。 平均而言，我们发现，当云<code>Profiles</code>文件可用时，应用程序的冷启动速度至少快 15%。</p><h3 id="Profiles文件如何工作"><a href="#Profiles文件如何工作" class="headerlink" title="Profiles文件如何工作?"></a><code>Profiles</code>文件如何工作?</h3><p>当应用程序在安装或更新后首次启动时，其代码在解释模式下运行(也就是<code>JIT</code>)。 在 <code>APK</code> 中，<code>Java</code> 和 <code>Kotlin</code> 代码被编译为 <code>dex</code> 字节码，但由于存储和加载完全编译的<code>App</code>的成本，并未完全编译为机器码。       应用程序中经常使用的类和方法，以及用于应用程序启动的类和方法，都记录在<code>Profiles</code>中。 一旦设备进入空闲模式，<code>ART</code> 就会根据这些<code>Profiles</code>编译应用程序。 这加快了后续应用程序的启动。</p><p>从 <code>Android 9</code>开始，<code>Google Play</code> 还提供 <code>Cloud Profiles</code>。 当应用在设备上运行时，由 <code>ART</code> 生成的配置文件由 <code>Play</code> 商店应用上传并在云端聚合。 一旦为应用程序上传了足够的配置文件，<code>Play</code> 应用程序就会使用汇总的配置文件进行后续安装。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>虽然<code>Cloud Profiles</code>在可用时很棒，但在安装应用程序时并不总是可以使用。 收集和汇总配置文件通常需要几天时间，如果你的<code>App</code>是每周更新时，就可能在<code>Cloud Profile</code>可用之前就发生更新了。 因此，<code>Google Android</code> 团队开始寻找其他方法来改善<code>Profiles</code>的延迟。     </p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p><code>Baseline Profiles</code>是一种新的机制，可提供可在 <code>Android 7</code>及更高版本上使用的配置文件。 <code>Baseline Profiles</code>是由 <code>Android Gradle</code> 插件使用生成的 <code>ART</code> 配置文件，示例如下所示：   </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSPLandroidx/compose/runtime/ComposerImpl;-&gt;updateValue(Ljava/lang/Object;)V</span><br><span class="line">HSPLandroidx/compose/runtime/ComposerImpl;-&gt;updatedNodeCount(I)I</span><br><span class="line">HLandroidx/compose/runtime/ComposerImpl;-&gt;validateNodeExpected()V</span><br><span class="line">PLandroidx/compose/runtime/CompositionImpl;-&gt;applyChanges()V</span><br><span class="line">HLandroidx/compose/runtime/ComposerKt;-&gt;findLocation(Ljava/util/List;I)I</span><br></pre></td></tr></table></figure><p><code>Baseline Profiles</code>是在构建期间创建的，作为 <code>APK</code> 的一部分提供给 <code>Play Store</code>，然后在下载应用程序时从 <code>Play Store</code> 发送给用户。 当云配置文件尚不可用时，它们填补了 <code>ART</code> 云配置文件管道中的空白，并在它们可用时自动与云配置文件合并。</p><p><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/may/p7.png" alt></p><p><code>Baseline Profiles</code>的最大好处之一是它们可以在本地开发和测试，因此开发人员可以看到用户的实际体验。 同时从<code>Android 7</code>就已经支持了，而<code>Cloud Profiles</code>只支持<code>Android 9</code>以后的版本</p><h2 id="如何使用Baseline-Profiles"><a href="#如何使用Baseline-Profiles" class="headerlink" title="如何使用Baseline Profiles?"></a>如何使用<code>Baseline Profiles</code>?</h2><p>所有应用程序和库开发人员都可以从<code>Baseline Profiles</code>中受益。 理想情况下，开发人员为其最关键的用户路径创建配置文件，以确保这些关键路径具有始终如一的快速性能，无论云配置文件是否可用。<br>关于如何创建<code>Baseline Profiles</code>的详细步骤，可查看：<a href="https://developer.android.com/studio/profile/baselineprofiles#creating-profile-rules" target="_blank" rel="noopener">创建基准配置文件</a>   </p><p>在通过以上方式生成了配置文件之后，将生成的文件重命名为<code>baseline-prof.txt</code>，并将其复制到应用模块的 <code>src/main</code> 目录，就可以生效了</p><p>如果您现在还没有准备好为您的应用程序生成<code>Baseline Profiles</code>，您也可以通过更新依赖项来从中受益。 如果您使用<code>AGP 7.1.0-alpha05</code> 或更高版本进行构建，您将获得包含在您的 <code>APK</code> 中的<code>Baseline Profiles</code>，这些配置文件已经由库（例如 <code>Jetpack</code>）默认提供。 <code>Google Play</code> 在安装时使用这些配置文件编译您的应用程序。 </p><h2 id="使用Baseline-Profiles的效果怎么样"><a href="#使用Baseline-Profiles的效果怎么样" class="headerlink" title="使用Baseline Profiles的效果怎么样?"></a>使用<code>Baseline Profiles</code>的效果怎么样?</h2><p>第三方库的代码在默认情况下是没有完全编译的，如果它在启动的关键路径上做了大量工作，可能会带来一些性能问题。<br>比如<code>Jetpack Compose</code> 是一个 <code>UI</code> 库，它不是 <code>Android</code> 系统的一部分，因此在安装时并未完全编译，这与许多 <code>Android View</code> 工具包代码不同。这也是<code>Compose</code>在可能刚启动时比较慢的原因.<br>为了解决这个问题，<code>Compose</code> 默认提供了<code>Baseline Profiles</code>，可减少 <code>Compose</code> 应用程序的启动时间和卡顿。    </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2462df01870b4757a9fb1ba7f39f21d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt></p><p><code>Gogle</code>在<code>Google Map</code>与<code>Google Play</code>中都使用了<code>Baseline Profiles</code>，根据<code>Google I/O</code>上给出的数据，可以达到30%左右的启动性能提升</p><h3 id="测量性能提升"><a href="#测量性能提升" class="headerlink" title="测量性能提升"></a>测量性能提升</h3><p>由于<code>Jetpack</code>包和<code>Compose</code>都提供了默认的<code>Baseline Profiles</code>配置，因此你自定义的<code>Baseline Profiles</code>不一定会达到最佳效果，在自定义时必须也要编写相关性能测试用例   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStartupBenchmark</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> startupMode: StartupMode) &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startupNoCompilation</span><span class="params">()</span></span> = startup(CompilationMode.None())</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startupBaselineProfileDisabled</span><span class="params">()</span></span> = startup(</span><br><span class="line">        CompilationMode.Partial(baselineProfileMode = Disable, warmupIterations = <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startupBaselineProfile</span><span class="params">()</span></span> = startup(CompilationMode.Partial(baselineProfileMode = Require))</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startupFullCompilation</span><span class="params">()</span></span> = startup(CompilationMode.Full())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，分别测试<code>CompilationMode.None</code>,<code>CompilationMode.Full</code>,<code>CompilationMode.Partial</code>等情况下的启动性能，根据结果分析是否需要自定义<code>Baseline Profiles</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过<code>Baseline Profiles</code>，将应用启动时的关键路径相关代码提前进行编译，可以加快启动速度与首次加载速度。您可以更新到<code>AGP 7.1.0-alpha05</code> 或更高，来享受到<code>Jetpack</code>库提供的默认配置，也可以自定义<code>Baseline Profiles</code>，但是在自定义后需要通过<code>Macrobenchmark</code>库测量性能，以衡量自定义配置是否有效</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://io.google/2022/program/2cf473b7-113e-4332-a469-8dfd815eb45b/intl/zh/" target="_blank" rel="noopener">Google I/0 应用性能的新动态</a><br><a href="https://android-developers.googleblog.com/2022/01/improving-app-performance-with-baseline.html" target="_blank" rel="noopener">Improving App Performance with Baseline Profiles</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;应用的启动优化是&lt;code&gt;Android&lt;/code&gt;性能优化中的一个常见问题，除了常规的一些优化手段，在本次&lt;code&gt;Google/I
      
    
    </summary>
    
    
      <category term="android" scheme="http://RicardoJiang.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack Compose 中常见的性能问题</title>
    <link href="http://RicardoJiang.github.io/blog/2022/05/compose-general-performance.html"/>
    <id>http://RicardoJiang.github.io/blog/2022/05/compose-general-performance.html</id>
    <published>2022-05-13T00:47:29.000Z</published>
    <updated>2023-10-02T05:09:49.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Jetpack Compose</code>的应用也逐渐广泛起来，由于声明式<code>UI</code>的特点，<code>Compose</code>在开发的易用性方面有较大优势，但相信很多人对于<code>Compose</code>的性能问题有一些疑问。<br>这些问题有些是因为<code>Compose</code>还是个新生事物，不够成熟导致的，有些则是因为开发者的使用不当导致的。<br>本文主要介绍如何编写和配置应用程序以获得最佳性能，并指出了一些要避免的问题。        </p><h2 id="正确配置应用"><a href="#正确配置应用" class="headerlink" title="正确配置应用"></a>正确配置应用</h2><p>如果您的<code>Compose</code>应用性能不佳，则可能意味着存在配置问题。 首先应该检查以下配置项       </p><h3 id="使用Release模式构建并且使用R8"><a href="#使用Release模式构建并且使用R8" class="headerlink" title="使用Release模式构建并且使用R8"></a>使用<code>Release</code>模式构建并且使用<code>R8</code></h3><p>如果您发现性能问题，请确保尝试在<code>Release</code>模式下运行您的应用。<code>Debug</code>模式对于发现许多问题很有用，但它会带来显着的性能成本，并且很难发现可能影响性能的其他代码的问题。<br>同时您还应该使用 <code>R8</code> 编译器从您的应用程序中删除不必要的代码。 默认情况下，在<code>Release</code>模式下构建会自动使用 <code>R8</code> 编译器。</p><h3 id="使用baseline-profile"><a href="#使用baseline-profile" class="headerlink" title="使用baseline profile"></a>使用<code>baseline profile</code></h3><p><code>Compose</code> 作为一个单独的库分发，而不是作为 <code>Android</code> 平台的一部分。这种方法让我们可以经常更新 <code>Compose</code> 并支持较旧的 <code>Android</code> 版本。但是，将 <code>Compose</code> 作为库分发也会产生一定的成本。 <code>Android</code> 平台代码已编译并安装在设备上。另一方面，库需要在应用程序启动时加载，并在需要功能时及时解释(即<code>JIT</code>)。这可能会在启动时减慢应用程序的速度，并且每当它首次使用库功能时。</p><p>您可以通过定义<code>baseline profile</code>来提高性能。这些配置文件定义了用户主流程所需的类和方法，并与您应用的 <code>APK</code> 一起分发。在应用程序安装期间，<code>ART</code> 会提前编译该关键代码(即<code>AOT</code>)，以便在应用程序启动时准备好使用。</p><p>定义一个好的<code>baseline profile</code>并不总是那么容易，因此 <code>Compose</code> 默认附带一个。因此默认情况下你不需要做任何额外工作。<br>同时，如果您选择定义自己的配置文件，您可能会生成一个实际上不会提高应用程序性能的配置文件。您应该测试配置文件以验证它是否有帮助。一个很好的方法是为您的应用程序编写 <a href="https://developer.android.com/studio/profile/macrobenchmark-overview" target="_blank" rel="noopener">Macrobenchmark</a> 测试，并在您编写和修改<code>baseline profile</code>时检查测试结果。有关如何为 <code>Compose UI</code> 编写 <code>Macrobenchmark</code> 测试的示例，请参阅 <a href="https://github.com/android/performance-samples/tree/main/MacrobenchmarkSample" target="_blank" rel="noopener">Macrobenchmark Compose</a> 示例。</p><p>总得来说，使用<code>baseline profile</code>即通过<code>AOT</code>取代<code>JIT</code>，加快<code>Compose</code>首次运行的速度。<br>在默认情况下<code>Compose</code>已经自带了一个默认的<code>baseline profile</code>，你不需要做什么额外工作就可以支持。<br>但如果你要自定义<code>baseline profile</code>的话，需要做好测试用例，验证自定义的配置是否有效。       </p><p>自定义<code>baseline profile</code>比较麻烦，不过根据<code>Google I/O</code>上给出的数据，可以达到20%到30%的启动性能提升，大家可以根据情况决定是否使用<br><img src="https://raw.githubusercontents.com/shenzhen2017/resource/main/2022/may/p1.jpg" alt>      </p><h2 id="关于Compose的一些最佳实践"><a href="#关于Compose的一些最佳实践" class="headerlink" title="关于Compose的一些最佳实践"></a>关于<code>Compose</code>的一些最佳实践</h2><p>在编写<code>Compose</code>代码时你可能会碰到一些常见的错误。这些错误不影响运行，但会损害您的 <code>UI</code> 性能。本节列出了一些最佳实践来帮助您避免它们。      </p><h3 id="使用remember减少计算"><a href="#使用remember减少计算" class="headerlink" title="使用remember减少计算"></a>使用<code>remember</code>减少计算</h3><p><code>Compose</code>函数可以非常频繁地运行，就像动画的每一帧一样频繁。 出于这个原因，你应该尽可能少地在<code>Compose</code>中做计算。<br>最常见的就是使用<code>remember</code>， 这样，计算只运行一次，并且可以在需要时获取结果。<br>例如，这里有一些代码显示排序的名称列表，其中排序操作比较耗时   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ContactList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    contacts: <span class="type">List</span>&lt;<span class="type">Contact</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    comparator: <span class="type">Comparator</span>&lt;<span class="type">Contact</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    LazyColumn(modifier) &#123;</span><br><span class="line">        <span class="comment">// DON’T DO THIS</span></span><br><span class="line">        items(contacts.sortedWith(comparator)) &#123; contact -&gt;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于，每次重组 <code>ContactsList</code> 时，整个联系人列表都会重新排序，即使列表没有更改。 如果用户滚动列表，只要出现新行，<code>Composable</code> 就会重新组合。<br>为了解决这个问题，在<code>LazyColumn</code> 之外对列表进行排序，并使用 <code>remember</code> 存储排序后的列表：      </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">ContactList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    contacts: <span class="type">List</span>&lt;<span class="type">Contact</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    comparator: <span class="type">Comparator</span>&lt;<span class="type">Contact</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    modifier: <span class="type">Modifier</span> = Modifier</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> sortedContacts = remember(contacts, sortComparator) &#123;</span><br><span class="line">        contacts.sortedWith(sortComparator)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LazyColumn(modifier) &#123;</span><br><span class="line">        items(sortedContacts) &#123;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，当第一次组成 <code>ContactList</code> 时，列表被排序一次。 如果联系人或比较器更改，则重新生成排序列表。 否则，可组合项可以继续使用缓存的排序列表。<br>当然：如果可能，最好将计算完全移到<code>Compose</code>之外，比如<code>ViewModel</code>       </p><h3 id="Lazy-Layout使用Key"><a href="#Lazy-Layout使用Key" class="headerlink" title="Lazy Layout使用Key"></a><code>Lazy Layout</code>使用<code>Key</code></h3><p><code>Lazy Layout</code>使用智能重组，仅在必要时才会发生重组。 同时，我们可以帮助它做出最佳决策。<br>假设用户操作导致<code>item</code>在列表中移动。 例如，假设您显示按修改时间排序的笔记列表，最近修改的笔记在最上面。      </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">NotesList</span><span class="params">(notes: <span class="type">List</span>&lt;<span class="type">Note</span>&gt;)</span></span> &#123;</span><br><span class="line">    LazyColumn &#123;</span><br><span class="line">        items(</span><br><span class="line">            items = notes</span><br><span class="line">        ) &#123; note -&gt;</span><br><span class="line">            NoteRow(note)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，这段代码存在一定的问题。 假设底部的<code>note</code>发生了变化。 它现在是最近修改的<code>note</code>，所以它应该排在列表的顶部，而其他每个<code>note</code>都向下移动一个位置。</p><p>这里的问题是，没有您的帮助，<code>Compose</code> 不会意识到未更改的项目只是在列表中移动。 相反，<code>Compose</code> 认为旧的“第 2 项”被删除并创建了一个新的，依此类推，第 3 项、第 4 项一直如此。 结果是，<code>Compose</code> 会重新组合列表中的每一项，即使其中只有一项实际发生了变化。</p><p>解决方案是提供<code>item key</code>。 为每个<code>item</code>提供一个稳定的<code>key</code>可以让 <code>Compose</code> 避免不必要的重组。 在这种情况下，<code>Compose</code> 可以看到现在位于第 3 项和<code>item</code>过去位于第 2 的<code>item</code>相同。由于该项目的数据都没有更改，因此 <code>Compose</code> 不必重新组合它。       </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">NotesList</span><span class="params">(notes: <span class="type">List</span>&lt;<span class="type">Note</span>&gt;)</span></span> &#123;</span><br><span class="line">    LazyColumn &#123;</span><br><span class="line">        items(</span><br><span class="line">            items = notes,</span><br><span class="line">             key = &#123; note -&gt;</span><br><span class="line">                <span class="comment">// Return a stable, unique key for the note</span></span><br><span class="line">                note.id</span><br><span class="line">            &#125;</span><br><span class="line">        ) &#123; note -&gt;</span><br><span class="line">            NoteRow(note)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-derivedStateOf-限制重组"><a href="#使用-derivedStateOf-限制重组" class="headerlink" title="使用 derivedStateOf 限制重组"></a>使用 <code>derivedStateOf</code> 限制重组</h3><p>在重组中使用状态的一个风险是，如果状态快速变化，你的 <code>UI</code> 可能会比你预期的发生更多的重组。<br>例如，假设您正在显示一个可滚动的列表。 您检查列表的状态以查看哪个<code>item</code>是列表中的第一个可见<code>item</code>：                   </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listState = rememberLazyListState()</span><br><span class="line"></span><br><span class="line">LazyColumn(state = listState) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> showButton = listState.firstVisibleItemIndex &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">AnimatedVisibility(visible = showButton) &#123;</span><br><span class="line">    ScrollToTopButton()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的问题在于，如果用户滚动列表，<code>listState</code> 会随着用户拖动手指而不断变化。 这意味着该列表不断被重新组合，而<code>showButton</code>的结果也会被不断计算。<br>但是，您只有在<code>firstVisibleItemIndex</code>发生变化时才需要计算<code>showButton</code>。 所以，这里多了很多额外的计算，会影响您的<code>UI</code>性能     </p><p>解决方案是使用<code>derivedStateOf</code>。 <code>derivedStateOf</code>告诉<code>Compose</code>只有当我们关心的状态发生变化时，才需要重组。<br>在这种情况下，当<code>firstVisibleItemIndex</code>发生变化时才需要重组。但如果用户还没有滚动到足以将新<code>item</code>带到顶部的程度，则不需要重新组合。     </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listState = rememberLazyListState()</span><br><span class="line"></span><br><span class="line">LazyColumn(state = listState) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> showButton <span class="keyword">by</span> remember &#123;</span><br><span class="line">    derivedStateOf &#123;</span><br><span class="line">        listState.firstVisibleItemIndex &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AnimatedVisibility(visible = showButton) &#123;</span><br><span class="line">    ScrollToTopButton()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果把状态都放在<code>ViewModel</code>里，也就不用考虑这个了</p><h3 id="尽可能延迟读取State"><a href="#尽可能延迟读取State" class="headerlink" title="尽可能延迟读取State"></a>尽可能延迟读取<code>State</code></h3><p>您应该尽可能推迟读取<code>State</code>。 延迟读取<code>State</code>有助于确保 <code>Compose</code> 在重组时重新运行尽可能少的代码。 例如，如果您的 <code>UI</code> 具有在<code>composable</code>树中高高提升的状态，并且您在子<code>composable</code>中读取状态，则可以将读取的状态包装在 <code>lambda</code> 函数中。 这样做会使读取仅在实际需要时发生。 </p><p>我们来看一段<code>Jetsnack</code>在列表滚动时实现<code>Title</code>折叠展开的代码，为了达到这个效果，<code>Title composable</code>需要知道滚动偏移量，以便使用修饰符来偏移自己。 在进行优化之前，这是<code>Jetsnack</code>代码的简化版本：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SnackDetail</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    Box(Modifier.fillMaxSize()) &#123; <span class="comment">// Recomposition Scope Start</span></span><br><span class="line">        <span class="keyword">val</span> scroll = rememberScrollState(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Title(snack, scroll.value)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="comment">// Recomposition Scope End</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Title</span><span class="params">(snack: <span class="type">Snack</span>, scroll: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">val</span> offset = with(LocalDensity.current) &#123; scroll.toDp() &#125;</span><br><span class="line"></span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .offset(y = offset)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当滚动状态发生变化时，<code>Compose</code> 会寻找最近的父重组作用域并使其无效。 在这种情况下，最近的父级是可组合的是<code>Box</code>。 因此 <code>Compose</code> 重组了 <code>Box</code>，并且还重组了 <code>Box</code> 内的任何可组合项。     如果您将代码重构为仅读取您需要的<code>State</code>，那么您可以减少需要重组的元素数量。     </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">SnackDetail</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    Box(Modifier.fillMaxSize()) &#123; <span class="comment">// Recomposition Scope Start</span></span><br><span class="line">        <span class="keyword">val</span> scroll = rememberScrollState(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Title(snack) &#123; scroll.value &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="comment">// Recomposition Scope End</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Title</span><span class="params">(snack: <span class="type">Snack</span>, scrollProvider: () -&gt; <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">val</span> offset = with(LocalDensity.current) &#123; scrollProvider().toDp() &#125;</span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .offset(y = offset)</span><br><span class="line">    ) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>滚动参数现在是一个 <code>lambda</code>。 这意味着 <code>Title</code> 仍然可以引用被提升的状态，但该值只能在 <code>Title</code> 内部读取，也就是实际需要的地方。 这样一来，当滚动值发生变化时，最近的重组范围现在是 <code>Title composable</code>，因此<code>Compose</code> 不再需要重组整个 <code>Box</code>。</p><p>这是一个很好的改进，但我们还可以做得更好。 因为我们所做的只是更改可组合标题的偏移量，这可以在布局阶段完成，而不必经过组合阶段。</p><h4 id="Compose的阶段"><a href="#Compose的阶段" class="headerlink" title="Compose的阶段"></a><code>Compose</code>的阶段</h4><p>与大多数其他界面工具包一样，<code>Compose</code> 会通过几个不同的“阶段”来渲染帧。如果我们观察一下 <code>Android View</code> 系统，就会发现它有 3 个主要阶段：测量、布局和绘制。<code>Compose</code> 和它非常相似，但开头多了一个叫做“组合”的重要阶段。</p><p><code>Compose</code> 有 3 个主要阶段：</p><ul><li>组合：要显示什么样的界面。<code>Compose</code> 运行可组合函数并创建界面说明。</li><li>布局：要放置界面的位置。该阶段包含两个步骤：测量和放置。对于布局树中的每个节点，布局元素都会根据 <code>2D</code> 坐标来测量并放置自己及其所有子元素。</li><li>绘制：渲染的方式。界面元素会绘制到画布（通常是设备屏幕）中。</li></ul><p><img src="https://developer.android.com/images/jetpack/compose/phases-3-phases.svg" alt></p><h4 id="优化状态读取"><a href="#优化状态读取" class="headerlink" title="优化状态读取"></a>优化状态读取</h4><p>知道了<code>Compose</code>的3个阶段，<code>Compose</code> 会执行局部状态读取跟踪，因此我们可以在适当阶段读取每个状态，从而尽可能降低需要执行的工作量<br>如果我们在布局阶段读取状态，就可以跳过组合阶段，如果我们在绘制阶段读取状态，就可以跳过组合和布局<br><img src="https://developer.android.com/images/jetpack/compose/phases-state-read-draw.svg" alt></p><p>因此我们可以将<code>offset</code>的读取推迟到布局阶段，这样可以避免组合阶段重新执行<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">Title</span><span class="params">(snack: <span class="type">Snack</span>, scrollProvider: () -&gt; <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Column(</span><br><span class="line">        modifier = Modifier</span><br><span class="line">            .offset &#123; IntOffset(y = scrollProvider()) &#125;</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之前代码使用了<code>Modifier.offset(x: Dp, y: Dp)</code>，它以偏移量为参数。 通过切换到修饰符的 <code>lambda</code> 版本，您可以确保函数在布局阶段读取滚动状态。 因此，当滚动状态发生变化时，<code>Compose</code> 可以完全跳过组合阶段，直接进入布局阶段。 当您将频繁更改的状态变量传递给<code>modifier</code>时，应尽可能使用<code>modifier</code>的 <code>lambda</code> 版本。</p><h4 id="绘制阶段读取状态的一个例子"><a href="#绘制阶段读取状态的一个例子" class="headerlink" title="绘制阶段读取状态的一个例子"></a>绘制阶段读取状态的一个例子</h4><p>上面我们看了一个在布局阶段读取状态的例子，下面来看一下绘制阶段读取状态的一个例子<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here, assume animateColorBetween() is a function that swaps between</span></span><br><span class="line"><span class="comment">// two colors</span></span><br><span class="line"><span class="keyword">val</span> color <span class="keyword">by</span> animateColorBetween(Color.Cyan, Color.Magenta)</span><br><span class="line"></span><br><span class="line">Box(Modifier.fillMaxSize().background(color))</span><br></pre></td></tr></table></figure></p><p>这里盒子的背景颜色在两种颜色之间快速切换。 因此，这种状态变化非常频繁。 然后可组合项在背景<code>modifier</code>中读取此状态。 结果，盒子必须在每一帧上重新组合，因为每一帧的颜色都在变化。</p><p>为了改善这一点，我们可以使用基于 <code>lambda</code> 的<code>modifier</code>：在本例中为 <code>drawBehind</code>。这意味着仅在绘制阶段读取颜色状态。<br>因此，<code>Compose</code> 可以完全跳过组合和布局阶段，当颜色发生变化时，<code>Compose</code> 会直接进入绘制阶段。     </p><h3 id="避免反向写入"><a href="#避免反向写入" class="headerlink" title="避免反向写入"></a>避免反向写入</h3><p><code>Compose</code> 有一个核心假设，即您永远不会写入已读取的状态。 当你这样做时，它被称为反向写入，它会导致重组在每一帧上发生，无休止。<br>以下代码显示了此类错误的示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Composable</span><br><span class="line">fun BadComposable() &#123;</span><br><span class="line">    var count by remember &#123; mutableStateOf(0) &#125;</span><br><span class="line"></span><br><span class="line">    // Causes recomposition on click</span><br><span class="line">    Button(onClick = &#123; count++ &#125;, Modifier.wrapContentSize()) &#123;</span><br><span class="line">        Text(&quot;Recompose&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Text(&quot;$count&quot;)</span><br><span class="line">    count++ // Backwards write, writing to state after it has been read</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在读取了状态之后在可组合项末尾的更新了状态。 如果您运行此代码，您会看到在单击导致重组的按钮后，随着 <code>Compose</code> 重组此 <code>Composable</code>，计数器会在无限循环中迅速增加，看到读取的状态已过期，因此会安排另一个重组 .</p><p>您可以通过从不在 <code>Composition</code> 中写入状态来完全避免向后写入。 如果可能，请始终响应事件来更新状态，并使用 <code>lambda</code> 表达式，就像前面的 <code>onClick</code> 示例一样。     </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍如何编写和配置<code>Compose</code>以获得最佳性能，并指出了一些要避免的问题。<br>想要了解更多的同学可参考<code>Google I/O</code>上相关的分享：<a href="https://io.google/2022/program/213421b6-9873-464f-9b36-38eeb232a854/intl/zh/" target="_blank" rel="noopener">Jetpack Compose 中常见的性能问题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Jetpack Compose&lt;/code&gt;的应用也逐渐广泛起来，由于声明式&lt;code&gt;UI&lt;/code&gt;的特点，&lt;code&gt;C
      
    
    </summary>
    
    
      <category term="compose" scheme="http://RicardoJiang.github.io/tags/compose/"/>
    
  </entry>
  
</feed>
